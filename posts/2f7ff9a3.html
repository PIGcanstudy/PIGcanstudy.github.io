<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><div id="myscoll"></div><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>C++面试笔记 | PigCanStudy</title><meta name="keywords" content="C++,面试笔记"><meta name="author" content="PigCanStudy"><meta name="copyright" content="PigCanStudy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="本文介绍了C++面试笔记的相关知识">
<meta property="og:type" content="article">
<meta property="og:title" content="C++面试笔记">
<meta property="og:url" content="https://pigcanstudy.github.io/posts/2f7ff9a3.html">
<meta property="og:site_name" content="PigCanStudy">
<meta property="og:description" content="本文介绍了C++面试笔记的相关知识">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://source.fomal.cc/img/default_cover_14.webp">
<meta property="article:published_time" content="2024-07-18T02:49:00.000Z">
<meta property="article:modified_time" content="2024-07-18T02:50:00.000Z">
<meta property="article:author" content="PigCanStudy">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="面试笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://source.fomal.cc/img/default_cover_14.webp"><link rel="shortcut icon" href="/"><link rel="canonical" href="https://pigcanstudy.github.io/posts/2f7ff9a3"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/6.0.0/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.js',
      css: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++面试笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-07-18 10:50:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/element-ui@2.15.6/packages/theme-chalk/lib/index.css"><style id="themeColor"></style><style id="rightSide"></style><style id="transPercent"></style><style id="blurNum"></style><style id="settingStyle"></style><span id="fps"></span><style id="defineBg"></style><style id="menu_shadow"></style><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="PigCanStudy" type="application/atom+xml">
</head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://tuchuang.voooe.cn/images/2023/01/02/avatar.webp" onerror="onerror=null;src='/assets/r1.jpg'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-home"></use></svg><span class="menu_word" style="font-size:17px"> 首页</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--article"></use></svg><span class="menu_word" style="font-size:17px"> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-guidang1">                   </use></svg><span class="menu_word" style="font-size:17px"> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-sekuaibiaoqian">                   </use></svg><span class="menu_word" style="font-size:17px"> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-fenlei">                   </use></svg><span class="menu_word" style="font-size:17px"> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pinweishenghuo"></use></svg><span class="menu_word" style="font-size:17px"> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/life/music/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-yinle">                   </use></svg><span class="menu_word" style="font-size:17px"> 八音盒</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/movies/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-dianying1">                   </use></svg><span class="menu_word" style="font-size:17px"> 影院</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/games/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-youxishoubing">                   </use></svg><span class="menu_word" style="font-size:17px"> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xiangzi"></use></svg><span class="menu_word" style="font-size:17px"> 八宝箱</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/box/gallery/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-tubiaozhizuomoban">                   </use></svg><span class="menu_word" style="font-size:17px"> 画廊</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/animation/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-nvwumao">                   </use></svg><span class="menu_word" style="font-size:17px"> 动画</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/nav/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-zhifengche">                   </use></svg><span class="menu_word" style="font-size:17px"> 网址导航</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shejiaoxinxi"></use></svg><span class="menu_word" style="font-size:17px"> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/social/fcircle/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pengyouquan">                   </use></svg><span class="menu_word" style="font-size:17px"> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-liuyan">                   </use></svg><span class="menu_word" style="font-size:17px"> 留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/social/link/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-lianjie">                   </use></svg><span class="menu_word" style="font-size:17px"> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-wangye"></use></svg><span class="menu_word" style="font-size:17px"> 网站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/site/census/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--tongjibiao">                   </use></svg><span class="menu_word" style="font-size:17px"> 网站统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/echarts/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shujutongji1">                   </use></svg><span class="menu_word" style="font-size:17px"> 文章统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/time/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xianxingshalou">                   </use></svg><span class="menu_word" style="font-size:17px"> 旧时光</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-maoliang"></use></svg><span class="menu_word" style="font-size:17px"> 个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/personal/bb/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-qunliaotian">                   </use></svg><span class="menu_word" style="font-size:17px"> 唠叨</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/love/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-love-sign">                   </use></svg><span class="menu_word" style="font-size:17px"> 恋爱小屋</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/about/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-paperplane">                   </use></svg><span class="menu_word" style="font-size:17px"> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">PigCanStudy</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-home"></use></svg><span class="menu_word" style="font-size:17px"> 首页</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--article"></use></svg><span class="menu_word" style="font-size:17px"> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-guidang1">                   </use></svg><span class="menu_word" style="font-size:17px"> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-sekuaibiaoqian">                   </use></svg><span class="menu_word" style="font-size:17px"> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-fenlei">                   </use></svg><span class="menu_word" style="font-size:17px"> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pinweishenghuo"></use></svg><span class="menu_word" style="font-size:17px"> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/life/music/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-yinle">                   </use></svg><span class="menu_word" style="font-size:17px"> 八音盒</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/movies/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-dianying1">                   </use></svg><span class="menu_word" style="font-size:17px"> 影院</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/games/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-youxishoubing">                   </use></svg><span class="menu_word" style="font-size:17px"> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xiangzi"></use></svg><span class="menu_word" style="font-size:17px"> 八宝箱</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/box/gallery/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-tubiaozhizuomoban">                   </use></svg><span class="menu_word" style="font-size:17px"> 画廊</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/animation/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-nvwumao">                   </use></svg><span class="menu_word" style="font-size:17px"> 动画</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/nav/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-zhifengche">                   </use></svg><span class="menu_word" style="font-size:17px"> 网址导航</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shejiaoxinxi"></use></svg><span class="menu_word" style="font-size:17px"> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/social/fcircle/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pengyouquan">                   </use></svg><span class="menu_word" style="font-size:17px"> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-liuyan">                   </use></svg><span class="menu_word" style="font-size:17px"> 留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/social/link/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-lianjie">                   </use></svg><span class="menu_word" style="font-size:17px"> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-wangye"></use></svg><span class="menu_word" style="font-size:17px"> 网站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/site/census/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--tongjibiao">                   </use></svg><span class="menu_word" style="font-size:17px"> 网站统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/echarts/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shujutongji1">                   </use></svg><span class="menu_word" style="font-size:17px"> 文章统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/time/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xianxingshalou">                   </use></svg><span class="menu_word" style="font-size:17px"> 旧时光</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-maoliang"></use></svg><span class="menu_word" style="font-size:17px"> 个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/personal/bb/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-qunliaotian">                   </use></svg><span class="menu_word" style="font-size:17px"> 唠叨</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/love/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-love-sign">                   </use></svg><span class="menu_word" style="font-size:17px"> 恋爱小屋</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/about/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-paperplane">                   </use></svg><span class="menu_word" style="font-size:17px"> 关于</span></a></li></ul></div></div><center id="name-container"><a id="page-name" href="javascript:scrollToTop()">PAGE_NAME</a></center><div id="nav-right"><div id="search-button"><a class="search faa-parent animated-hover" title="检索站内任何你想要的信息"><svg class="faa-tada icon" style="height:24px;width:24px;fill:currentColor;position:relative;top:6px" aria-hidden="true"><use xlink:href="#icon-valentine_-search-love-find-heart"></use></svg><span> 搜索</span></a></div><a class="meihua faa-parent animated-hover" onclick="toggleWinbox()" title="美化设置-自定义你的风格" id="meihua-button"><svg class="faa-tada icon" style="height:26px;width:26px;fill:currentColor;position:relative;top:8px" aria-hidden="true"><use xlink:href="#icon-tupian1"></use></svg></a><a class="sun_moon faa-parent animated-hover" onclick="switchNightMode()" title="浅色和深色模式转换" id="nightmode-button"><svg class="faa-tada" style="height:25px;width:25px;fill:currentColor;position:relative;top:7px" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon">       </use></svg></a><div id="toggle-menu"><a><i class="fas fa-bars fa-fw"></i></a></div></div></div></nav><div id="post-info"><h1 class="post-title">C++面试笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><svg class="meta_icon post-meta-icon" style="width:30px;height:30px;position:relative;top:10px"><use xlink:href="#icon-rili"></use></svg><span class="post-meta-label">发表于 </span><time class="post-meta-date-created" datetime="2024-07-18T02:49:00.000Z" title="发表于 2024-07-18 10:49:00">2024-07-18</time><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:18px;height:18px;position:relative;top:5px"><use xlink:href="#icon-gengxin1"></use></svg><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-07-18T02:50:00.000Z" title="更新于 2024-07-18 10:50:00">2024-07-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:18px;height:18px;position:relative;top:5px"><use xlink:href="#icon-biaoqian"></use></svg><a class="post-meta-categories" href="/categories/C/">C++</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><svg class="meta_icon post-meta-icon" style="width:25px;height:25px;position:relative;top:8px"><use xlink:href="#icon-charuword"></use></svg><span class="post-meta-label">字数总计:</span><span class="word-count">2.2w</span><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:20px;height:20px;position:relative;top:5px"><use xlink:href="#icon-shizhong"></use></svg><span class="post-meta-label">阅读时长:</span><span>73分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="C++面试笔记"><svg class="meta_icon post-meta-icon" style="width:25px;height:25px;position:relative;top:5px"><use xlink:href="#icon-eye"></use></svg><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>目录</h1>
<ul>
<li><a href="#%E7%9B%AE%E5%BD%95">目录</a>
<ul>
<li><a href="#new-delete-free-malloc-%E7%9A%84%E5%8C%BA%E5%88%AB">new delete free malloc 的区别</a>
<ul>
<li><a href="#%E8%A1%8D%E7%94%9F%E9%97%AE%E9%A2%98">衍生问题</a>
<ul>
<li><a href="#malloc%E6%98%AF%E6%80%8E%E4%B9%88%E5%88%86%E9%85%8D%E7%A9%BA%E9%97%B4%E7%9A%84">malloc是怎么分配空间的</a></li>
<li><a href="#malloc%E5%88%86%E9%85%8D%E7%9A%84%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E8%BF%98%E6%98%AF%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98">malloc分配的虚拟内存还是物理内存</a></li>
<li><a href="#malloc%E5%88%86%E9%85%8D%E5%90%8E%E6%98%AF%E5%90%A6%E7%AB%8B%E5%8D%B3%E5%BE%97%E5%88%B0%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98">malloc分配后是否立即得到物理内存</a></li>
<li><a href="#freep%E6%98%AF%E6%80%8E%E4%B9%88%E5%BE%97%E5%88%B0p%E8%BF%99%E4%B8%AA%E7%A9%BA%E9%97%B4%E6%9C%89%E5%A4%9A%E5%A4%A7%E7%9A%84">free§是怎么得到p这个空间有多大的</a></li>
<li><a href="#free%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98%E5%90%8E%E5%86%85%E5%AD%98%E8%BF%98%E5%9C%A8%E5%90%97">free释放内存后，内存还在吗</a></li>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%9B%B4%E6%8E%A5%E5%85%A8%E7%94%A8mmp%E6%9D%A5%E5%88%86%E9%85%8D%E8%80%8C%E9%9C%80%E8%A6%81%E5%88%86%E6%83%85%E5%86%B5%E4%BD%BF%E7%94%A8brk%E5%91%A2">为什么不直接全用mmp()来分配，而需要分情况使用brk()呢</a></li>
<li><a href="#new%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B">new的执行过程</a></li>
<li><a href="#delete%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B">delete的执行过程</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E4%B8%8E%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E6%8C%87%E9%92%88%E7%9A%84%E5%88%9B%E5%BB%BA%E6%97%B6%E6%9C%BA">虚函数表与虚函数表指针的创建时机</a>
<ul>
<li><a href="#%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E6%8C%87%E9%92%88%E5%88%9B%E5%BB%BA%E7%9A%84%E6%97%B6%E6%9C%BA">虚函数表指针创建的时机</a></li>
<li><a href="#%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E5%92%8C%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E6%8C%87%E9%92%88%E7%9A%84%E5%85%B3%E7%B3%BB">虚函数表和虚函数表指针的关系</a></li>
<li><a href="#%E8%A1%8D%E7%94%9F%E9%97%AE%E9%A2%98-1">衍生问题</a>
<ul>
<li><a href="#%E5%A4%9A%E6%80%81%E7%9A%84%E5%86%85%E5%AE%B9">多态的内容</a></li>
<li><a href="#c%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B">c++内存模型</a></li>
<li><a href="#%E7%A8%8B%E5%BA%8F%E5%8F%98%E4%B8%BA%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E8%BF%87%E7%A8%8B">程序变为可执行文件的过程</a></li>
<li><a href="#%E9%9D%99%E6%80%81%E5%BA%93%E4%B8%8E%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8C%BA%E5%88%AB">静态库与动态库的区别</a></li>
<li><a href="#elf%E6%96%87%E4%BB%B6%E6%A8%A1%E5%9E%8B">ELF文件模型</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#c%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%9F%E6%88%90%E9%BB%98%E8%AE%A4%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">C++什么时候生成默认拷贝构造函数</a>
<ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%A7%A6%E5%8F%91%E9%BB%98%E8%AE%A4%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">什么时候触发默认拷贝构造函数</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%9F%E6%88%90%E9%BB%98%E8%AE%A4%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">什么时候生成默认拷贝构造函数</a></li>
<li><a href="#%E8%A1%8D%E7%94%9F%E9%97%AE%E9%A2%98-2">衍生问题</a>
<ul>
<li><a href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E7%BB%86%E8%8A%82">函数返回值的细节</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81%E4%BB%A5%E5%8F%8A%E7%89%B9%E6%80%A7">面向对象的三大特征以及特性</a>
<ul>
<li><a href="#%E8%A1%8D%E7%94%9F%E9%97%AE%E9%A2%98-3">衍生问题</a>
<ul>
<li><a href="#%E7%BB%A7%E6%89%BF%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86">继承相关知识</a>
<ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E4%BB%80%E4%B9%88%E6%98%AF%E6%8A%BD%E8%B1%A1%E7%B1%BB">什么是纯虚函数？什么是抽象类？</a></li>
<li><a href="#%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF">接口继承与实现继承</a></li>
<li><a href="#%E9%82%A3%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E7%9B%B8%E6%AF%94%E4%BA%8E%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84%E5%90%97">那接口继承相比于实现继承有什么好处吗</a></li>
<li><a href="#%E7%BA%AF%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%8E%A5%E5%8F%A3%E7%B1%BB">纯接口继承与接口类</a></li>
<li><a href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E6%97%B6%E5%80%99%E4%B8%8D%E8%A6%81%E8%A6%86%E7%9B%96%E9%9D%9E%E8%99%9A%E5%87%BD%E6%95%B0">继承的时候不要覆盖非虚函数</a></li>
<li><a href="#%E7%BB%84%E5%90%88">组合</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF">什么是菱形继承</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86">线程池相关知识</a>
<ul>
<li><a href="#%E4%BB%80%E4%B9%88%E7%BA%BF%E7%A8%8B%E6%B1%A0">什么线程池</a></li>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0">为什么要用线程池</a></li>
<li><a href="#%E6%80%8E%E4%B9%88%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0">怎么用线程池</a></li>
</ul>
</li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB">进程和线程的区别</a>
<ul>
<li><a href="#%E8%A1%8D%E7%94%9F%E9%97%AE%E9%A2%98-4">衍生问题</a>
<ul>
<li><a href="#%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2%E7%9A%84%E5%8C%BA%E5%88%AB">进程切换与线程切换的区别</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%8F%8F%E8%BF%B0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%95%B4%E4%B8%AA%E6%B5%81%E7%A8%8B">描述系统调用整个流程</a>
<ul>
<li><a href="#%E8%A1%8D%E7%94%9F%E9%97%AE%E9%A2%98-5">衍生问题</a>
<ul>
<li><a href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%98%AF%E5%90%A6%E4%BC%9A%E5%BC%95%E8%B5%B7%E7%BA%BF%E7%A8%8B%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2">系统调用是否会引起线程/进程切换</a></li>
<li><a href="#%E7%94%A8%E6%88%B7%E6%80%81%E5%88%87%E6%8D%A2%E5%86%85%E6%A0%B8%E6%80%81%E5%88%87%E6%8D%A2%E5%A0%86%E6%A0%88%E5%85%B7%E4%BD%93%E6%98%AF%E5%95%A5">用户态切换内核态(切换堆栈)具体是啥？</a></li>
<li><a href="#task_struct%E7%9A%84%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86">task_struct的组成部分</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B">页面置换算法有哪些</a></li>
<li><a href="#tcp%E5%92%8Cudp%E7%9A%84%E5%8C%BA%E5%88%AB">tcp和udp的区别</a>
<ul>
<li><a href="#%E8%A1%8D%E7%94%9F%E9%97%AE%E9%A2%98-6">衍生问题</a>
<ul>
<li><a href="#tcp%E7%9A%84mss%E5%92%8Cip%E7%9A%84mtu%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">TCP的MSS和IP的MTU分别是什么？</a></li>
<li><a href="#%E6%97%A2%E7%84%B6%E5%86%8Dip%E5%B1%82%E5%B0%B1%E4%BC%9A%E5%88%86%E7%89%87%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E5%86%8Dtcp%E9%82%A3%E8%BF%9B%E8%A1%8C%E5%88%86%E6%AE%B5mss">既然再IP层就会分片，为什么还要再TCP那进行分段，MSS</a></li>
<li><a href="#tcp%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%9A%84">TCP是如何保证可靠性的？</a></li>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B">为什么需要三次握手</a></li>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B">为什么需要四次挥手</a></li>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%9A%84%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E7%AD%89%E5%BE%852%E4%B8%AAmsl%E6%97%B6%E9%97%B4">为什么在四次挥手的时候需要等待2个MSL时间</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AFsyn%E6%94%BB%E5%87%BB">什么是SYN攻击？</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E5%94%AF%E4%B8%80%E7%A1%AE%E5%AE%9A%E4%B8%80%E4%B8%AAtcp%E8%BF%9E%E6%8E%A5%E5%91%A2">如何唯一确定一个TCP连接呢？</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%B0%B4%E5%B9%B3%E8%A7%A6%E5%8F%91%E4%B8%8E%E8%BE%B9%E7%BC%98%E8%A7%A6%E5%8F%91%E7%9A%84%E5%8C%BA%E5%88%AB">水平触发与边缘触发的区别</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%8A%E6%89%93%E5%BC%80%E5%8D%8A%E5%85%B3%E9%97%AD%E7%8A%B6%E6%80%81">什么是半打开半关闭状态</a>
<ul>
<li><a href="#%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%8D%8A%E6%89%93%E5%BC%80%E7%8A%B6%E6%80%81">如何处理半打开状态</a></li>
</ul>
</li>
<li><a href="#%E5%86%99%E6%96%87%E4%BB%B6%E6%97%B6%E8%BF%9B%E7%A8%8B%E5%AE%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E4%BC%9A%E4%B8%A2%E5%A4%B1%E5%90%97">写文件时进程宕机，数据会丢失吗？</a>
<ul>
<li><a href="#%E6%96%87%E4%BB%B6%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86">文件相关知识</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E7%9B%B4%E6%8E%A5%E6%96%87%E4%BB%B6io%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98%E6%96%87%E4%BB%B6io">什么使用直接文件IO，什么时候使用缓存文件IO</a></li>
</ul>
</li>
<li><a href="#%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E5%92%8C%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%8C%BA%E5%88%AB">左值引用和右值引用区别</a>
<ul>
<li><a href="#%E8%A1%8D%E7%94%9F%E9%97%AE%E9%A2%98-7">衍生问题</a>
<ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B7%A6%E5%80%BC%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%B3%E5%80%BC">什么是左值，什么是右值</a></li>
<li><a href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E7%9A%84%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D">右值引用的移动语义是什么意思？</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91">什么是完美转发</a>
<ul>
<li><a href="#%E9%82%A3%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%87%E8%83%BD%E5%BC%95%E7%94%A8%E5%91%A2">那什么是万能引用呢？</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%A7%8D%E7%B1%BB%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">智能指针种类以及使用场景</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AE%83%E8%A7%A3%E5%86%B3%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98">什么设计模式，它解决的是什么问题</a>
<ul>
<li><a href="#%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86">相关知识</a>
<ul>
<li><a href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%80%E5%85%B1%E6%9C%89%E5%93%AA%E5%87%A0%E5%A4%A7%E7%B1%BB%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E6%98%AF%E4%BB%80%E4%B9%88">设计模式一共有哪几大类，设计模式的六大原则是什么</a></li>
<li><a href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F">单例模式</a>
<ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%95%E4%BE%8B%E5%AE%83%E5%8F%AF%E4%BB%A5%E5%9C%A8%E5%93%AA%E4%BA%9B%E5%9C%B0%E6%96%B9%E7%94%A8%E5%88%B0%E4%BA%86">什么是单例，它可以在哪些地方用到了</a></li>
<li><a href="#%E5%8D%95%E4%BE%8B%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9">单例的优缺点</a></li>
<li><a href="#%E5%8D%95%E4%BE%8B%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F">单例创建方式</a>
<ul>
<li><a href="#%E9%A5%BF%E6%B1%89%E5%BC%8F">饿汉式</a></li>
<li><a href="#%E6%87%92%E6%B1%89%E5%BC%8F">懒汉式</a></li>
<li><a href="#%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E6%96%B9%E5%BC%8F">静态内部方式</a></li>
</ul>
</li>
<li><a href="#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F">如何选择单例模式的创建方式</a></li>
</ul>
</li>
<li><a href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F">工厂模式</a>
<ul>
<li><a href="#%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F">简单工厂模式</a>
<ul>
<li><a href="#%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9">简单工厂模式的优缺点</a></li>
</ul>
</li>
<li><a href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F">工厂方法模式</a>
<ul>
<li><a href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9">工厂方法模式的优缺点</a></li>
</ul>
</li>
<li><a href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F">抽象工厂模式</a>
<ul>
<li><a href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9">抽象工厂模式的优缺点</a></li>
</ul>
</li>
<li><a href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB">抽象工厂模式和工厂方法模式的区别</a></li>
</ul>
</li>
<li><a href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F">策略模式</a>
<ul>
<li><a href="#%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B">应用案例</a></li>
</ul>
</li>
<li><a href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F">观察者模式</a>
<ul>
<li><a href="#%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98">解决了什么问题</a></li>
<li><a href="#%E4%BE%8B%E5%AD%90">例子</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84">代码结构</a></li>
<li><a href="#%E5%A6%82%E6%9E%9C%E6%89%A9%E5%B1%95%E4%BB%A3%E7%A0%81">如果扩展代码</a></li>
<li><a href="#%E5%BA%94%E7%94%A8%E7%9A%84%E6%A1%88%E4%BE%8B">应用的案例</a></li>
<li><a href="#%E4%BC%98%E7%BC%BA%E7%82%B9">优缺点</a></li>
</ul>
</li>
<li><a href="#%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F">责任链模式</a>
<ul>
<li><a href="#%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98-1">解决了什么问题</a></li>
<li><a href="#%E4%BE%8B%E5%AD%90-1">例子</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84-1">代码结构</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81%E6%89%A9%E5%B1%95">代码扩展</a></li>
<li><a href="#%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B-1">应用案例</a></li>
</ul>
</li>
<li><a href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F">装饰器模式</a>
<ul>
<li><a href="#%E4%BC%98%E7%BC%BA%E7%82%B9-1">优缺点</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81%E6%89%A9%E5%B1%95-1">代码扩展</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#b%E6%A0%91%E4%B8%8Eb%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91">B树与B+树与二叉搜索树</a></li>
<li><a href="#%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80">语法基础</a>
<ul>
<li><a href="#%E9%87%8E%E6%8C%87%E9%92%88-%E6%82%AC%E7%A9%BA%E6%8C%87%E9%92%88-%E7%A9%BA%E6%8C%87%E9%92%88">野指针 悬空指针 空指针</a></li>
<li><a href="#union%E7%9A%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86">union的相关知识</a></li>
<li><a href="#%E6%8C%87%E9%92%88%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86">指针相关知识</a></li>
<li><a href="#c-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E6%9C%BA%E5%88%B6">C++ 内存对齐机制</a></li>
<li><a href="#stdstring">std::string</a></li>
<li><a href="#const-int--ptr-int--const-ptr%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">const int * ptr, int * const ptr的区别是什么？</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AFstdref">什么是std::ref？</a>
<ul>
<li><a href="#stdref-%E5%92%8C%E4%B8%8D%E5%90%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB">std::ref 和不同引用的区别</a></li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>
</li>
<li><a href="#decltype-stddeclval-stddecay_t-%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">decltype, std::declval, std::decay_t 分别是什么？</a>
<ul>
<li><a href="#decltype">decltype</a></li>
<li><a href="#stddeclval">std::declval</a></li>
<li><a href="#stddecay_t">std::decay_t</a></li>
</ul>
</li>
<li><a href="#const-%E4%B8%8E-constexpr">const 与 constexpr</a></li>
<li><a href="#noexcept">noexcept</a></li>
<li><a href="#%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E9%9D%A2%E9%87%8F">用户自定义字面量</a></li>
<li><a href="#mutable-volatile">mutable volatile</a></li>
<li><a href="#explicit">explicit</a></li>
<li><a href="#stdinvoke">std::invoke</a>
<ul>
<li><a href="#invoke-%E5%92%8Cfunction-%E7%9A%84%E5%8C%BA%E5%88%AB">invoke 和function 的区别</a></li>
</ul>
</li>
<li><a href="#stl%E5%AE%B9%E5%99%A8%E9%87%8Cemplace_back%E5%92%8Cpush_back%E7%9A%84%E5%8C%BA%E5%88%ABemplace_back%E6%98%AF%E4%B8%8D%E6%98%AF%E8%83%BD%E5%AE%8C%E7%BE%8E%E6%9B%BF%E4%BB%A3push_back">stl容器里emplace_back和push_back的区别，emplace_back是不是能完美替代push_back</a></li>
<li><a href="#%E5%A6%82%E6%9E%9C%E4%BD%BF%E7%94%A8stdmovet%E6%9D%A5%E6%9E%84%E9%80%A0%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E4%BD%86%E6%98%AF%E8%AF%A5%E7%B1%BB%E6%B2%A1%E6%9C%89%E6%98%BE%E5%BC%8F%E6%8F%90%E4%BE%9B%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E9%82%A3%E4%B9%88%E5%AE%83%E6%98%AF%E4%BD%BF%E7%94%A8%E7%9A%84%E5%BC%8F%E9%BB%98%E8%AE%A4%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%B7%B2%E7%BB%8F%E5%AE%9A%E4%B9%89%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0">如果使用std::move(t)来构造一个对象，但是该类没有显式提供移动构造函数，那么它是使用的式默认移动构造函数已经定义的拷贝构造</a></li>
<li><a href="#%E5%9C%A8%E6%A8%A1%E6%9D%BF%E4%B8%AD%E4%BD%BF%E7%94%A8-typedef%E7%9A%84%E6%97%B6%E5%80%99%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">在模板中使用 typedef的时候的注意事项</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="new-delete-free-malloc-的区别">new delete free malloc 的区别</h2>
<ul>
<li>背景：前两者是C++里的操作符，后两者是C语言的库函数</li>
<li><strong>new</strong>在分配内存的时候是自动计算分配内存的大小，而<strong>malloc</strong>需要程序员手动指定</li>
<li><strong>new</strong>是在free store(自由存储区)分配，<strong>malloc</strong>是在堆区分配，由于<strong>new</strong>的底层实现用到了<strong>malloc</strong>所以free store默认也是堆区</li>
<li><strong>new</strong>分配失败会抛出异常，<strong>malloc</strong>分配失败会返回NULL</li>
<li><strong>new</strong>返回的指向对象类型的指针，<strong>malloc</strong>返回的是<strong>void*/</strong>，需要强制类型转换成对应类型</li>
<li><strong>new</strong>分配完内存后会执行析构函数, <strong>malloc</strong>分配内存后则不会</li>
</ul>
<h3 id="衍生问题">衍生问题</h3>
<h4 id="malloc是怎么分配空间的">malloc是怎么分配空间的</h4>
<ul>
<li>malloc在分配内存的时候会有一个阈值，这个值为128k，当分配内存小于128K的时候进行brk()调用申请内存，此内存在堆区，大于的时候会通过mmp()点用进行分配内存（分配在文件映射段也就是再堆区与栈区直接那个段），此内存会在销毁的时候释放，而小于128K的时候，在被销毁的时候会被先放到内存池中</li>
</ul>
<h4 id="malloc分配的虚拟内存还是物理内存">malloc分配的虚拟内存还是物理内存</h4>
<ul>
<li>malloc分配的内存是虚拟内存。</li>
</ul>
<h4 id="malloc分配后是否立即得到物理内存">malloc分配后是否立即得到物理内存</h4>
<ul>
<li>不是的，他是在访问已分配的虚拟地址空间的时候，操作系统通过查找页表，发现虚拟内存对应的页没有在物理内存中，就会触发缺页中断，然后操作系统会建立虚拟内存和物理内存之间的映射关系，这样之后才会得到物理内存</li>
</ul>
<h4 id="free§是怎么得到p这个空间有多大的">free§是怎么得到p这个空间有多大的</h4>
<ul>
<li>在malloc分配内存的时候，会首先分配16个字节放在前面，这16个字节会存储有关内存的相关信息，其中就包括内存块大小，所以在执行free的时候只需要向前移16字节就能知道空间有多大了</li>
</ul>
<h4 id="free释放内存后，内存还在吗">free释放内存后，内存还在吗</h4>
<ul>
<li>分情况，如果内存是通过brk()调用得到存放在堆区，释放内存后会被存储在内存池中，而如果通过mmp()调用得到的内存，则会被操作系统释放</li>
</ul>
<h4 id="为什么不直接全用mmp-来分配，而需要分情况使用brk-呢">为什么不直接全用mmp()来分配，而需要分情况使用brk()呢</h4>
<ul>
<li>因为mmp()调用的时候每次都需要进行系统调用，而进行系统调用需要从用户态变为内核态再变回用户态需要大量时间。另外，因为 mmap 分配的内存每次释放的时候，都会归还给操作系统，于是每次 mmap 分配的虚拟地址都是缺页状态的，然后在第一次访问该虚拟地址的时候，就会触发缺页中断。也就是说，频繁通过 mmap 分配的内存话，不仅每次都会发生运行态的切换，还会发生缺页中断（在第一次访问虚拟地址后），这样会导致 CPU 消耗较大。</li>
<li>而使用brk()就能改进这两个问题，由于堆空间是连续的，所以直接预分配更大的内存来作为内存池，当内存释放的时候，就缓存在内存池中。这样就可以在内存池中，取出对应内存块，而且可能虚拟地址与物理地址映射关系还存在这样不仅减少了系统调用的次数，也减少了缺页中断的次数，这将大大降低CPU的消耗</li>
</ul>
<h4 id="new的执行过程">new的执行过程</h4>
<ol>
<li>先执行operator new</li>
<li>寻找合适的内存空间</li>
<li>执行构造函数</li>
</ol>
<h4 id="delete的执行过程">delete的执行过程</h4>
<ol>
<li>先调用析构函数</li>
<li>执行operator delete</li>
<li>销毁空间</li>
</ol>
<h2 id="虚函数表与虚函数表指针的创建时机">虚函数表与虚函数表指针的创建时机</h2>
<ul>
<li>背景：是用来实现多态的</li>
<li>什么时候生成的? 是在编译器编译的时候，遇到virtual关键词的时候生成的</li>
<li>存放在哪里？ 可执行文件（存在磁盘）， 运行的时候（在内存），在磁盘里是存储在.rodata中，在内存中是存储在代码区</li>
<li>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/面试笔记/image-1.png" alt="示例图片" style="zoom:100%;" />
</li>
</ul>
<h3 id="虚函数表指针创建的时机">虚函数表指针创建的时机</h3>
<ul>
<li>类对象构造的时候，会把类的虚函数表地址赋给 vptr</li>
<li>如果类没有构造函数，编译器会生成默认的构造函数（类的前八个字节就是虚函数表指针所在位置(vptr)）</li>
<li>继承的情况下，虚函数表指针赋值过程？
<ol>
<li>调用基类构造函数，把A的虚函数表的地址赋给 vptr</li>
<li>调用子类构造函数，把B子类的虚函数表的地址赋给 vptr</li>
</ol>
</li>
</ul>
<h3 id="虚函数表和虚函数表指针的关系">虚函数表和虚函数表指针的关系</h3>
<ul>
<li>
<p>一个类只对应一个虚函数表，这个类创造的每一个对象对应的是虚函数表指针（在堆里），<strong>通常来说虚函数表指针是不一样的</strong>（涉及<strong>浅拷贝与深拷贝</strong>），<em><strong>需要显示写出拷贝构造函数和重载赋值运算符</strong></em>，虚函数表指针是指向的是虚函数表位置，大概如图所示:(vptr 在32位机上4字节，64位机上8字节)<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/面试笔记/image-6.png" alt="示例图片" style="zoom:100%;" /><br>
解释这张图就是 虚函数表指针指向虚函数表（在.rodata中）的某个位置，这个位置是一个函数的地址，指向代码区里的函数</p>
</li>
<li>
<p>对于每个对象来说，其都有一个虚函数表指针指向这个类的虚函数表，而虚函数表是与类绑定的，因此对于每个对象的虚函数表指针来说其指向的位置是相同的，即每个指针中存的地址是一样的。那么析构后仅是将对应的vptr置为nullptr，应该不会影响其他对象的vptr.</p>
</li>
</ul>
<h3 id="衍生问题-2">衍生问题</h3>
<h4 id="多态的内容">多态的内容</h4>
<ul>
<li>首先多态分为静态多态(编译时多态)与动态多态（运行时多态）</li>
<li><strong>静态多态</strong>：在系统编译期间就可以确定程序将要执行哪个函数，比如 函数重载，通过类成员函数符指定的运算<br>
函数重载条件：1.同一个作用域，2.同一个函数名，3.函数参数类型不同或者个数不同或者顺序不同<br>
<strong>注意</strong>：如果只有函数的返回值不同，就不算函数重载<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="image.png" alt="alt text"></li>
<li><strong>动态多态</strong>：是利用虚函数实现运行时的多态，即在系统编译的时候并不知道程序将要调用哪一个函数，只有在运行到这里的时候才能确定接下来会跳转到哪一个函数，动态多态是在虚函数的基础上实现的，而实现的条件有：<br>
(1) 在类中声明为虚函数<br>
(2) 函数的函数名，返回值，函数参数个数，参数类型，全都与基类的所声明的虚函数相同（否则是函数重载的条件）<br>
(3) 将子类对象的指针（或以引用形式）赋值给父类对象的指针（或引用），再用该指向父类对象的指针（或引用）调用虚函数<br>
如此，便可以实现动态多态，程序会按照实际对象类型来选择要实行的函数具体时哪一个。</li>
</ul>
<h4 id="c-内存模型">c++内存模型</h4>
<ol>
<li><strong>栈区</strong>：用于实现函数调用。由编译器自动分配释放，存放函数的参数值和局部变量等（向下增长），每个线程都有自己的栈区，栈区的内存是线程私有的，不同线程之间的栈区不共享</li>
<li><strong>堆区</strong>：用于存放于存放动态分配的变量。由程序员动态分配和释放，使用new和delete操作符（向上增长）<br>
<strong>堆区碎片</strong>：随着时间的推移，动态内存的频繁分配和释放可能导致堆区出现碎片。堆区碎片是指堆中剩余的不连续、无法利用的小块内存。虽然这不会直接影响程序的正确性，但在某些情况下，可能会降低内存的利用率<br>
<strong>线程共享</strong>：堆区内存可以在线程之间共享，多个线程可以访问和使用堆区的相同内存。这使得堆区在多线程编程中非常有用，但也需要注意同步和避免竞争条件</li>
<li><strong>全局/静态代码区</strong>：存放全局变量，和静态变量，在程序结束是自动释放
<ul>
<li>分为Bss Semgent：存放未初始化的全局与静态变量(.bss)，不占用实际的磁盘空间,只在编译时预留内存空间</li>
<li>Data Semgent：存放初始化的全局与静态变量(.data)</li>
</ul>
</li>
<li><strong>代码区（Text Semgent）</strong>:通常也被称为文本区或只读区。存放程序的二进制代码（ELF）文件和常量，代码段是只读的，可以被多个进程共享
<ul>
<li>.text</li>
<li>.rodata，里面存放只读数据，其中虚函数表就在其中</li>
</ul>
</li>
</ol>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/面试笔记/image-2.png" alt="示例图片" style="zoom:100%;" />
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/面试笔记/image-3.png" alt="示例图片" style="zoom:100%;" />
<h4 id="程序变为可执行文件的过程">程序变为可执行文件的过程</h4>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/面试笔记/image-5.png" alt="示例图片" style="zoom:100%;" />
<ul>
<li><strong>预处理阶段</strong>：预处理器（cpp）根据以#开头的命令修改原始的C程序，得到的通常是以.i文件扩展名为结尾的文件，也就是说，在这个阶段主要进行的是<strong>文本替换，宏展开，删除注释</strong>这类简单工作<br>
<strong>对应的命令</strong>：Linux&gt; gcc -E hello.c hello.i</li>
<li><strong>编译阶段</strong>：编译器将文本文件hello.i翻译成hello.s（用汇编语言程序翻译）<br>
<strong>对应的命令</strong>：Linux&gt; gcc -S hello.c hello.s</li>
<li><strong>汇编阶段</strong>：将.s文件翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标程序的格式，并将结果保存在目标文件.o中(把汇编语言翻译成机器语言的过程)。也就是编译原理学的东西(<strong>词法分析，语法分析，语义检查和中间代码生成，代码优化，目标代码生成</strong>，用来发现语法错误)<br>
<strong>对应的命令</strong>：Linux&gt; gcc -c hello.c hello.o</li>
<li><strong>连接阶段</strong>：此时hello程序调用了printf函数。 printf函数存在于一个名为printf.o的单独的预编译目标文件中。 链接器（ld）就负责处理把这个文件并入到hello.o程序中，结果得到hello文件，一个可执行文件。最后可执行文件加载到储存器后由系统负责执行<br>
<strong>对应的命令</strong>：Linux&gt; gcc hello.cpp<br>
<em><strong>注意:</strong></em> gcc -o 这里的-o并不是对应连接阶段，而是用于指定要生成的结果文件，后面跟的就是结果文件名字。<strong>链接器的作用</strong>就是以一组可重定位目标文件作为输入，生成可加载和运行的可执行目标文件</li>
</ul>
<h4 id="静态库与动态库的区别">静态库与动态库的区别</h4>
<ul>
<li>函数库一般分为<strong>静态库</strong>和<strong>动态库</strong>两种。<strong>静态库</strong>是指编译链接时，<em><strong>把库文件的代码全部加入到可执行文件中，因此生成的文件比较大，但在运行时也就不再需要库文件了。其后缀名一般为.a</strong></em>。<strong>动态库</strong>与之相反，在编译链接时并没有把库文件的代码加入到可执行文件中，而是在程序执行时由<strong>运行时链接文件加载库</strong>，这样可以<strong>节省系统的开销</strong>。<strong><a target="_blank" rel="noopener" href="http://xn--4gq6ez9k3sbea072nglc253h07f.so">动态库一般后缀名为.so</a></strong>，<strong>gcc在编译时默认使用动态库</strong>。</li>
</ul>
<h4 id="ELF文件模型">ELF文件模型</h4>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/面试笔记/image-4.png" alt="示例图片" style="zoom:100%;" />
<h2 id="C-什么时候生成默认拷贝构造函数">C++什么时候生成默认拷贝构造函数</h2>
<ul>
<li>背景：如果不提供，就是浅拷贝(位拷贝)，危害(堆上的资源，文件句柄socket)</li>
</ul>
<h3 id="什么时候触发默认拷贝构造函数">什么时候触发默认拷贝构造函数</h3>
<ol>
<li>赋值的时候</li>
<li>函数传参，其中参数为类对象</li>
<li>函数返回值</li>
</ol>
<h3 id="什么时候生成默认拷贝构造函数">什么时候生成默认拷贝构造函数</h3>
<ul>
<li>类成员变量也是一个类，该成员类有默认拷贝构造函数</li>
<li>类继承自一个基类，该基类有默认拷贝构造函数</li>
<li>类成员中有一个或者多个虚函数，如果没有拷贝构造函数</li>
<li>基类有虚函数，子类没有</li>
</ul>
<h3 id="衍生问题-3">衍生问题</h3>
<h4 id="函数返回值的细节">函数返回值的细节</h4>
<ul>
<li>对于以下这种情况：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">A <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A a = <span class="built_in">func</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在以上情况不考虑编译器优化的时候，会有一次构造函数，一次析构函数（前两者由于作用域），一次拷贝构造函数（由于返回值）</li>
<li>而如果去掉优化，并且时C++11版本后，会有以下三种情况
<ol>
<li>看类有没有移动构造</li>
<li>看类有没有拷贝构造</li>
<li>报错</li>
</ol>
</li>
</ul>
<h2 id="面向对象的三大特征以及特性">面向对象的三大特征以及特性</h2>
<ul>
<li>封装:
<ol>
<li>目的：隐藏实现细节，实现模块化（public，protect，private）</li>
<li>特性：访问权限，属性，方法</li>
</ol>
</li>
<li>继承:
<ol>
<li>目的：无需修改原有类的情况下通过继承实现对功能的扩展（只能继承public以及protected，因为private 访问不到，虽然它也会在子类中）</li>
<li>特性：权限继承，基类在子类中最高权限</li>
<li>怎么破除继承：1.使用友元 2.使用using 这样可以让派生类能够使用基类的私有成员</li>
</ol>
</li>
<li>多态: 有静态多态与动态多态 在上面有阐述</li>
</ul>
<h3 id="衍生问题-4">衍生问题</h3>
<h4 id="继承相关知识">继承相关知识</h4>
<h5 id="什么是纯虚函数？什么是抽象类？">什么是纯虚函数？什么是抽象类？</h5>
<ul>
<li>
<p>一个函数如果虚函数并且有等于0就为虚函数，此处0填充在虚表中，这会导致纯虚函数的虚表为0项，即无法创建虚表，无法实例化<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/面试笔记/image-13.png" alt="示例图片" style="zoom:100%;" /></p>
</li>
<li>
<p>一个类只要存在至少一个纯虚函数就是抽象类</p>
</li>
</ul>
<h5 id="接口继承与实现继承">接口继承与实现继承</h5>
<ul>
<li>接口继承就是一个类继承一个抽象类，并且这个子类必须重写父类这个抽象类的纯虚函数，并且要确保接口继承是一个&quot;is-a&quot;关系，也就是public继承，并且这个接口对于子类来说是有意义的，例如企鹅是鸟类但不能飞，所以鸟这个类就不能有飞行这个纯虚函数（接口）</li>
<li>实现继承就是派生类以protected或private继承一个基类时，派生类没有继承到基类的接口，而是继承到了基类的实现。实现继承就意味着派生类与基类不是&quot;is-a&quot;关系,而只是复用其实现或功能。</li>
<li>对于虚函数而言是继承接口与默认实现，对于非虚函数而言是继承的接口与强制实现</li>
<li>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/面试笔记/image-14.png" alt="示例图片" style="zoom:100%;" />
</li>
</ul>
<h5 id="那接口继承相比于实现继承有什么好处吗">那接口继承相比于实现继承有什么好处吗</h5>
<ul>
<li>对于某些情况就可以避免危险，例如飞机的飞行模式实现，使用接口继承就比实现继承更安全</li>
<li>如图：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/面试笔记/image-15.png" alt="示例图片" style="zoom:100%;" /></li>
<li>使用纯虚函数加提供protected下的默认实现函数来代替虚函数继承</li>
</ul>
<h5 id="纯接口继承与接口类">纯接口继承与接口类</h5>
<ul>
<li>纯接口继承是指基类只提供接口，不提供定义，即严格代码规范下，基类的所有函数都是纯虚函数，不提供具体实现，派生类需要对所有方法进行自定义，这样的类型称为纯接口类。纯接口继承完全分离了接口与实现，依赖更少，如下例所示：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/面试笔记/image-16.png" alt="示例图片" style="zoom:100%;" /></li>
<li>这样的接口类有以下三个特点：一，<strong>没有非静态成员变量</strong>；二，<strong>所有成员都是public成员</strong>；三，<strong>所有成员都是纯虚函数，析构函数除外</strong>，因此在上例Interface类中存在一个有定义的虚的析构函数。纯接口继承的<strong>优点</strong>是最小化调用处的依赖，且接口与实现完全分离，这样在只有实现发生变化时，调用处不会受到任何影响。而它的<strong>缺点</strong>是不利于代码复用，如果多个派生类都要实现相差不多的方法F()，就需要重复编写多遍F()的代码。</li>
</ul>
<h5 id="继承的时候不要覆盖非虚函数">继承的时候不要覆盖非虚函数</h5>
<ul>
<li>因为这样就破坏了&quot;is-a&quot;关系,如果子类也编写了一个与基类同名的非虚函数，这种关系叫做覆盖而不是重写，是子类函数覆盖了基类函数，当我们直接通过派生类对象调用F()与通过基类指针调用F()，会产生不一样的行为！如图：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/面试笔记/image-17.png" alt="示例图片" style="zoom:100%;" /></li>
</ul>
<h5 id="组合">组合</h5>
<ul>
<li>将std::string变成Password的一个成员，而不是Password的基类，这样仍能使用std::string的各种功能，且不需要增加一种继承关系。这种方法被称为“组合”，它是比继承更灵活的复用方法。一般在可以用组合达到目的时，要尽量避免使用实现继承</li>
</ul>
<h5 id="什么是菱形继承">什么是菱形继承</h5>
<ul>
<li>InputFile和OutputFile同时继承于File类，而下一层IOFile类同时继承InputFile和OutputFile，即继承了两次File，这就是菱形继承<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/面试笔记/image-18.png" alt="示例图片" style="zoom:100%;" /></li>
<li>使用虚继承来解决菱形继承问题</li>
</ul>
<h2 id="线程池相关知识">线程池相关知识</h2>
<h3 id="什么线程池">什么线程池</h3>
<ul>
<li>线程池是一个高效管理线程的技术，它是预先创建好一组线程，并用这些预先创建好的线程来处理工作任务，这些线程可以在需要的时候被动态地分配和重用，而不是为每一个任务创建一个新线程，这可以大大减少创建和销毁线程的开销</li>
<li>线程池由三个部分组成：
<ol>
<li>任务队列：用于存放需要执行的任务</li>
<li>线程池管理器：负责管理线程池的创建，销毁和线程的分配回收等，会根据需要动态调整线程数量</li>
<li>工作线程：线程池中实际执行任务的线程，它们从任务队列中取出任务并执行</li>
</ol>
</li>
</ul>
<h3 id="为什么要用线程池">为什么要用线程池</h3>
<ol>
<li>可以降低资源消耗：可以减少创建和销毁线程的开销</li>
<li>提高性能：对于一个任务而言不需要等待线程的创建就能被执行</li>
<li>避免过度资源竞争：线程池可以限制同时执行的线程数量，避免过度竞争，提高稳定性</li>
<li>控制并发度：可以根据资源与负载情况动态调整线程数量</li>
<li>简化了线程管理的难度</li>
</ol>
<p>可能会出现任务队列溢出：执行完一个任务的速度远小于进入任务队列的速度</p>
<h3 id="怎么用线程池">怎么用线程池</h3>
<h2 id="进程和线程的区别">进程和线程的区别</h2>
<ul>
<li>本质区别：进程是资源分配的基本单位，线程是CPU调度的基本单位</li>
<li>并发性：进程切换效率低，线程切换效率高</li>
<li>内存：进程有独立的虚拟地址空间，线程没有独立虚拟地址空间，是共享同一个进程，但是线程会分配独立的栈区，PC，本地存储等</li>
<li>所属关系：一个线程只能属于一个进程，一个进程可以拥有多个线程</li>
<li>健壮性：进程的健壮性高，因为进程切换在多进程的时候不会因为一个进程的宕机而影响整体，但是线程宕机就会影响同一进程下的其它线程</li>
</ul>
<h3 id="衍生问题-5">衍生问题</h3>
<h4 id="进程切换与线程切换的区别">进程切换与线程切换的区别</h4>
<ul>
<li>进程在进行上下文切换的时候，要保留现场的运行环境（CPU的寄存器，程序计数器，用户空间的信息，内核空间pcb），进程切换在多进程的时候不会因为一个进程的宕机而影响整体</li>
<li>线程的切换，如果线程是在不同进程里的，和进程是一样的，如果是在同一个进程里就可以少保留一些信息（CPU寄存器，程序计数器），效率就高了，但是线程需要加锁。</li>
</ul>
<h2 id="描述系统调用整个流程">描述系统调用整个流程</h2>
<ul>
<li>宏观视角：应用程序想要访问内核里的资源，应用程序通过函数库调用函数库中的系统调用，将用户态转变为内核态，调用完后再切换回用户态</li>
<li>微观视角：想要实现系统调用，离不开中断，当程序想要获取内核数据的时候，会触发<strong>中断</strong>，操作系统会把<strong>系统调用号</strong>放在<strong>寄存器（eax)<strong>中，并且会有一个</strong>中断号（比如 int 0x80）</strong>，接下来操作系统会<strong>切换堆栈</strong>，也就是从<strong>用户态切换为内核态</strong>，在内核态中通过<strong>中断号</strong>在<strong>中断向量表</strong>中找到对应的<strong>中断处理程序（比如system_call）</strong>，然后通过寄存器eax中的<strong>系统调用号</strong>在<strong>系统调用表</strong>中，找到对应的<strong>处理程序(比如syscall_read)</strong>，执行相应操作，之后通过<strong>iret中断</strong>返回对应值，并切换回用户态</li>
</ul>
<h3 id="衍生问题-6">衍生问题</h3>
<h4 id="系统调用是否会引起线程-进程切换">系统调用是否会引起线程/进程切换</h4>
<ul>
<li>不一定，如果我们使用阻塞的IO且IO未就绪，就会将线程或进程切换；运行态 -&gt; 阻塞态，如果使用的是非阻塞IO就不会引起进/线程切换</li>
</ul>
<h4 id="用户态切换内核态-切换堆栈-具体是啥？">用户态切换内核态(切换堆栈)具体是啥？</h4>
<ul>
<li>首先会切换中断上下文，也就是先保存用户态的上下文，之后会将CPU上的用户态指令切换成内核态的指令</li>
</ul>
<h4 id="task-struct的组成部分">task_struct的组成部分</h4>
<ol>
<li>标识符：与进程相关的唯一标识符，用来区别正在执行的进程和其他进程。</li>
<li>状态：描述进程的状态，因为进程有挂起，阻塞，运行等好几个状态，所以都有个标识符来记录进程的执行状态。</li>
<li>优先级：如果有好几个进程正在执行，就涉及到进程被执行的先后顺序的问题，这和进程优先级这个标识符有关。</li>
<li>程序计数器：程序中即将被执行的下一条指令的地址。</li>
<li>内存指针：程序代码和进程相关数据的指针。</li>
<li>上下文数据：进程执行时处理器的寄存器中的数据。</li>
<li>I/O状态信息：包括显示的I/O请求，分配给进程的I/O设备和被进程使用的文件列表等。</li>
<li>记账信息：包括处理器的时间总和，记账号等等。</li>
</ol>
<h2 id="页面置换算法有哪些">页面置换算法有哪些</h2>
<ul>
<li>产生页面置换原因：缺页中断-&gt; 内存已满 -&gt; 将某些页面置换到磁盘中</li>
<li>加载一个页面，如果产生缺页中断的全过程：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/面试笔记/image-8.png" alt="示例图片" style="zoom:100%;" /></li>
</ul>
<ol>
<li>最佳页面置换算法（置换未来最长时间不访问的页面）</li>
<li>先进先出置换算法(FIFO) （选择在内存驻留时间最长的页面）</li>
<li>最近最久未使用置换算法 （选择最长时间没有被访问的页面）</li>
<li>时钟页面置换算法/最近未用算法  (环形列表实现)</li>
<li>改进版的时钟页面置换算法</li>
</ol>
<h2 id="tcp和udp的区别">tcp和udp的区别</h2>
  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/面试笔记/image-11.png" alt="示例图片" style="zoom:100%;" />
<ul>
<li>相同点：都是传输层的协议，目的都是为了给上层提供服务</li>
<li>是否面向链接：tcp是面向链接，udp是面向无链接， 面向链接可以告诉我们：他建立链接需要三次握手，释放链接需要四次挥手，它是一个端对端的链接，他是一个全双工链接（双方可以互相发送数据），面向无连接：无需三次握手与四次挥手，可以一对一，一对多，多对一，多对多</li>
<li>数据传输方式：tcp是基于字节流，UDP是基于报文，对于TCP来说，完整的用户消息可能会被分成多个tcp报文进行传输，对于接收端而言，需要处理粘包（对于一个完整数据与一个不属于这个数据的数据链接在一起的问题）问题，而对于UDP，每次收发都是完整数据</li>
<li>是否可靠：TCP是可靠的，UDP是不可靠的，不可靠的意思就是，不保证消息交付的完整性，也不保证交付顺序，不进行拥塞控制，不进行流量控制（没有接收缓冲区）</li>
<li>传输效率：tcp效率低，udp效率高，tcp由于需要实现可靠传输，以及发送相同数据时，tcp所允许的大小比UDP小，因为tcp头是20字节，UDP头只有8字节</li>
<li>应用场景：TCP 主要是对于要求数据完整，效率不需要很高的场景（文件传输），UDP则是数据允许丢失，同时实时性要求高的的场景（网络直播，）</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/面试笔记/image-12.png" alt="示例图片" style="zoom:100%;" />
<h3 id="衍生问题-7">衍生问题</h3>
<h4 id="TCP的MSS和IP的MTU分别是什么？">TCP的MSS和IP的MTU分别是什么？</h4>
<ul>
<li>首先MTU为时网络层的最大传输单元，以太网最大的数据帧是1518字节，这样刨去帧头14字节和帧尾CRC校验部分4字节，那么剩下承载上层IP报文的地方最大就只有1500字节，这个值就是以太网的默认MTU值。当传输的数据的字节数超过这个数据就得分片，<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/面试笔记/image-9.png" alt="示例图片" style="zoom:100%;" /></li>
<li>MSS通常是MTU - IP头 - TCP头得到的数据，也就是1500 - 20 - 20 = 1460；<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/面试笔记/image-10.png" alt="示例图片" style="zoom:100%;" />，MSS的值通常需要两端的协商，得到具体值，TCP是传输层，IP在网络层，数据从传输层到网络层就要进行封装，IP头,TCP头就是封装</li>
</ul>
<h4 id="既然再IP层就会分片，为什么还要再TCP那进行分段，MSS">既然再IP层就会分片，为什么还要再TCP那进行分段，MSS</h4>
<ul>
<li>当数据大于这个（MSS）最大报文段长度的时候，要进行分段，这个值是建立连接的时候双方协商的，当双方每次发数据的时候都会协商一次，如果在TCP不分段传给IP的时候，一旦ip中的一个MTU发生丢包，就得重新传一大片数据，而如果采用了MSS分段，丢包的时候只需要重传丢的那一小块MSS就行，这样是为了效率，为了避免IP进行分片（加入TCP头 与 IP头）</li>
</ul>
<h4 id="TCP是如何保证可靠性的？">TCP是如何保证可靠性的？</h4>
<ul>
<li>重传机制：解决的是数据丢失问题，是通过序列号和确认应答机制来实现的，
<ol>
<li>超时重传：也就是会有一个超时定时器，当设定来回的时间之内没有收到ACK，就会重传数据，就是超时后重传</li>
<li>快速重传：就是在超时之前收到三个相同的数据包确认，直接重传丢失的数据，<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/面试笔记/image-19.png" alt="示例图片" style="zoom:100%;" /></li>
</ol>
</li>
<li>滑动窗口：（是一种机制，为下面两个服务）
<ol>
<li>可以连续发送多个字节数据，而不需要返回每个字节数据的确认</li>
<li>窗口：在没有应答的情况下发送方可以发送多少数据</li>
<li>滑动：收到确认包之后在移动窗口，例如连续发了300字节数据其中第201到300数据丢失了，下次发送的时候窗口左边界会移动到201，并根据对方（接收方）发来的窗口大小来调整大小（即发送方的滑动窗口由接收方决定）</li>
</ol>
</li>
<li>流量控制：
<ol>
<li>通过接收方的处理能力来限制发送方的发送量，即解决接收方接收缓冲区满而丢失数据的问题</li>
<li>怎么控制？ 先收缩窗口，再缩小缓冲区，当窗口收缩为0的时候，发送方由于不能发送数据，会发送一个1字节的探测报文，来探测接收方滑动窗口大小是否改变</li>
</ol>
</li>
<li>拥塞控制：
<ol>
<li>解决的是网络不好的时候，接收方继续发送大量数据而导致数据时延或丢失的问题</li>
<li>怎么控制？首先接收方会有一个cwnd（拥塞窗口），接收方接收缓冲区会有一个接收窗口，发送方还一个ssthresh值（慢启动阀值），一开始发送方从1开始执行慢开始算法(拥塞窗口以指数增长)，当到达设定的慢启动阀值的时候就开始进行拥塞避免算法(cwnd慢慢 + 1)，如果此时遇到了超时重传，就会使得阀值减少一半，然后cwnd变为1从新开始慢启动，如果遇到的是快重传，就会执行快恢复（阀值减半，但cwnd不会下降为1而是会变为从阀值开始执行拥塞避免）如图<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/面试笔记/image-20.png" alt="示例图片" style="zoom:100%;" />，2<em>N=v</em>RTT，探测到拥塞说明管道的容量为当前窗口C，而C=2*N，因此N=(1/2)*C!</li>
</ol>
</li>
</ul>
<h4 id="为什么需要三次握手">为什么需要三次握手</h4>
<ul>
<li>为什么最后要发送ack呢，因为如果主动连接端有一次SYN连接请求超时了，也就是在网络上滞留了，主动连接方会超时重传，当这个重传的被接受了，并且建立了链接，并正确释放连接后，滞留的连接请求到达了服务端，服务端发送确认请求，并且进入established阶段，但是由于客户端时closed，不会给予响应，就会导致服务端一直处于连接状态</li>
</ul>
<h4 id="为什么需要四次挥手">为什么需要四次挥手</h4>
<ul>
<li>因为服务端可以继续发送未发完的数据，使用三次挥手可能导致数据不完整</li>
</ul>
<h4 id="为什么在四次挥手的时候需要等待2个MSL时间">为什么在四次挥手的时候需要等待2个MSL时间</h4>
<ul>
<li><strong>保证A发送的最后一个ACK报文段能够到达B</strong>。这个ACK报文段有可能丢失，B收不到这个确认报文，就会超时重传连接释放报文段，然后A可以在2MSL时间内收到这个重传的连接释放报文段，接着A重传一次确认，重新启动2MSL计时器，最后A和B都进入到CLOSED状态，若A在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到B重传的连接释放报文段，所以不会再发送一次确认报文段，B就无法正常进入到CLOSED状态。</li>
<li><strong>防止已失效的连接请求报文段出现在本连接中</strong>。A在发送完最后一个ACK报文段后，再经过2MSL，就可以使这个连接所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现旧的连接请求报文段。</li>
</ul>
<h4 id="什么是SYN攻击？">什么是SYN攻击？</h4>
<ul>
<li>我们都知道 TCP 连接建立是需要三次握手,假设攻击者短时间伪造不同 IP 地址的 SYN 报文,服务端每接收到 一个 SYN 报文,就进入 SYN_RCVD 状态,但服务端发送出去的 ACK + SYN 报文,无法得到未知 IP 主机的ACK 应答,久而久之就会占满服务端的 SYN 接收队列(未连接队列),使得服务器不能为正常用户服务。</li>
</ul>
<h4 id="如何唯一确定一个TCP连接呢？">如何唯一确定一个TCP连接呢？</h4>
<ul>
<li>TCP 四元组可以唯一的确定一个连接,四元组包括如下: 源地址 源端口 目的地址 目的端口。</li>
<li>源地址和目的地址的字段(32位)是在 IP 头部中,作用是通过 IP 协议发送报文给对方主机。</li>
<li>源端口和目的端口的字段(16位)是在 TCP 头部中,作用是告诉 TCP 协议应该把报文发给哪个进程。</li>
</ul>
<h2 id="水平触发与边缘触发的区别">水平触发与边缘触发的区别</h2>
<ul>
<li>
<p>水平触发：</p>
<ol>
<li>读事件：只要有数据可读（接受缓冲区还有数据），就继续触发读事件</li>
<li>写事件：当发送缓冲区没有满的时候，也就是还能继续写入数据的时候，会继续触发写事件</li>
</ol>
</li>
<li>
<p>边缘触发：</p>
<ol>
<li>读事件：只有新数据到达缓冲区的时候才会再次出发读事件</li>
<li>写事件：只有当发送缓冲区从满变为了不满时，才会触发写事件</li>
</ol>
</li>
<li>
<p>由于水平触发时会一直调用读或写事件，所以得关闭EPOLLOUT，如果发送的数据很多会频繁关闭，所以一般来说边缘触发的效率要比水平触发要高</p>
</li>
</ul>
<h2 id="什么是半打开半关闭状态">什么是半打开半关闭状态</h2>
<ul>
<li>当连接双方两端，一端断开了连接，而另一端没有发觉，继续发送数据，保留连接状态，服务端一方未能及时检测到对端已经关闭,会一直占用资源直至超时。</li>
<li>半打开套接字会占用文件句柄和内存,影响系统的性能。因此,半打开套接字需要特别注意,应尽快检测并关闭。</li>
</ul>
<h3 id="如何处理半打开状态">如何处理半打开状态</h3>
<ul>
<li>采用超时重连机制或心跳包机制，定期检查连接状态，检出异常就关闭套接字</li>
<li>添加空闲超时机制，在一段时间内未收到数据就关闭套接字</li>
<li>在应用层做好异常处理</li>
<li>使用TCP keep-alive选项，对端DOWN后,TCP层会自动关闭连接。</li>
</ul>
<h2 id="写文件时进程宕机，数据会丢失吗？">写文件时进程宕机，数据会丢失吗？</h2>
<ul>
<li>背景：
<ol>
<li>文件的写是在stdIO库中</li>
<li>stdIO有缓冲区：可以setbuf自定义，作用是减少系统调用</li>
<li>page cache：的<strong>作用</strong>是为了减少磁盘IO的词是，是为了提供速度，因为从内存到磁盘需要花费大量时间，在中间引入page cache后可以异步向磁盘载入数据，<strong>缺点</strong>：用户层无法优化page cache的策略，这也是为什么数据库要维护page管理</li>
<li>两种磁盘IO的方式：
<ul>
<li>缓存文件IO: 是用户态的缓冲区里的数据先经过page cache，再写入磁盘</li>
<li>直接文件IO：是直接从用户态的缓存区到磁盘<br>
<strong>分两种情况</strong></li>
</ul>
</li>
</ol>
</li>
<li>写文件如果没有调用fflush(write)宕机后会丢失数据</li>
<li>写文件如果调用过fflush,也就是把数据写入了page cache，进程宕机不会丢失，但是os崩了就会</li>
<li>假设进程宕机了，系统也关闭了，如果没调用write会丢失，调用了write但是用的是缓存文件IO也会丢失，用直接文件IO不会丢失</li>
</ul>
<h3 id="文件相关知识">文件相关知识</h3>
<ul>
<li>用户态会有一个缓冲区，在内核态会有一个高速缓存区（page cache），还有磁盘，一共有四个接口，fflush（本质调用的是write）是把用户态缓冲区内容写入page cache，fsync（指定一个fd），fdatasync，sync（把所有文件全部载入磁盘） 是把page cache写入磁盘中<br>
如图：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/面试笔记/image-21.png" alt="示例图片" style="zoom:100%;" /></li>
</ul>
<h3 id="什么使用直接文件IO，什么时候使用缓存文件IO">什么使用直接文件IO，什么时候使用缓存文件IO</h3>
<ul>
<li>大数据使用直接文件IO，因为大数据使用缓存文件IO，会把page cache全部占据了并从page cache中淘汰一些数据，如果将来这些数据被频繁读取，需要从磁盘重新读，会大大减低效率</li>
<li>小数据使用缓存文件IO</li>
</ul>
<h2 id="左值引用和右值引用区别">左值引用和右值引用区别</h2>
<ul>
<li>一个是针对左值，一个是引用右值，const左值引用，可以引用右值，但是不能修改（右值引用就是解决不能修改这个问题），右值引用也可通过std::move（将左值转换为右值）来引用左值，声明出来的左值引用和右值引用都是左值</li>
<li>功能差异：
<ol>
<li>左值引用是为了避免对象拷贝，常用在函数传参和函数返回值（A&amp; b = func()）中</li>
<li>右值引用是为了实现移动语义move 和 完美转发</li>
</ol>
</li>
<li>右值引用的移动语义是为了在对象赋值时避免资源的重新分配，移动构造以及移动赋值构造，stl应用，std::unique_ptr，function等</li>
</ul>
<h3 id="衍生问题-8">衍生问题</h3>
<h4 id="什么是左值，什么是右值">什么是左值，什么是右值</h4>
<ul>
<li>左值：可以放在等号左边，可以取地址，并且是具备名字的，比如（变量，返回左值引用的函数调用，<strong>前置</strong>自增自减，赋值运算符，解引用）</li>
<li>右值：只能在等号右边，不可以取地址，没有具备名字
<ol>
<li>纯右值：常量（字面值），返回非引用类型的函数调用，<strong>后置</strong>自增自减，逻辑表达式，算数表达式，比较表达式</li>
<li>将亡值：是C++11新引入的值类型，与移动语义息息相关，移动构造和移动赋值构造处理的就是将亡值，并进行资源转移，之后将调用析构函数</li>
</ol>
</li>
</ul>
<h4 id="右值引用的移动语义是什么意思？">右值引用的移动语义是什么意思？</h4>
<ul>
<li>就是用来处理将亡值这个右值，用于函数返回值时可以减少一次拷贝构造函数，因为它是将将亡值里的资源直接&quot;移动&quot;到被赋值的上面</li>
<li>移动构造函数：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">A</span>(A&amp;&amp; a)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;p = a.p;</span><br><span class="line">    a.p = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">b</span><span class="params">(std::move(a))</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="什么是完美转发">什么是完美转发</h4>
<ul>
<li>完美转发的意思就是函数模板可以将自己的参数完美的转发给内部调用的其他函数</li>
<li>完美是指不仅能准确的转发参数的值，还能准确的转发参数的左右值属性,因为右值它经过一系列处理后会变为左值</li>
<li>我的理解是想要实现完美转发就离不开<strong>万能引用</strong> + <strong>引用折叠</strong> + <strong>std::forward函数</strong></li>
<li><strong>forward函数</strong>：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="af62188138a1eff94ced25b66cfb9df8.png" alt="alt text">，它定义于move.h中</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">forward&lt;<span class="type">int</span>&gt;(a);<span class="comment">// 这个与foward&lt;int &amp;&amp;&gt;(a)结果一样，无论a是左值还是右值都转换为右值引用</span></span><br><span class="line">forward&lt;<span class="type">int</span> &amp;&gt;(a);<span class="comment">// 无论a是左值还是右值都转换为左值引用</span></span><br><span class="line">forward&lt;<span class="keyword">decltype</span>(t)&gt;(t);<span class="comment">//根据实际类型和实际左右值进行转发</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>右值转发：forward(param) —&gt; int&amp;&amp; 或 forward&lt;int&amp;&amp;&gt;(param) —&gt; int&amp;&amp;</p>
</li>
<li>
<p>左值转发：forward&lt;int&amp;&gt;(param) —&gt; int&amp;</p>
</li>
<li>
<p>如果要转发其自身的类型，使用： <strong>forward&lt;decltype(param)&gt;(param)</strong></p>
</li>
</ul>
<h5 id="那什么是万能引用呢？">那什么是万能引用呢？</h5>
<ul>
<li>它既能接收左值又能接收右值</li>
<li>基于参数模板的， T &amp;&amp;，他会有以下几种情况：
<ol>
<li>T &amp;&amp;碰到右值int &amp;&amp;， T匹配成int；</li>
<li>T &amp;&amp; 遇到左值 int ，也能匹配，T此时是int &amp;。</li>
<li>T &amp;&amp; 碰到左值const int，T匹配为 const int &amp;。</li>
<li>T &amp;&amp;碰到左值const int <em>（指针类型), T匹配为const int</em>&amp; (下略）</li>
<li>T &amp;&amp;碰到左值const int <em>const（指针类型), T匹配为const int</em>const &amp; （下略）</li>
</ol>
</li>
<li>其中就用到了<strong>引用折叠</strong> int &amp; &amp;&amp; 这种情况 会被折叠为 int &amp;</li>
</ul>
<h2 id="智能指针种类以及使用场景">智能指针种类以及使用场景</h2>
<ul>
<li>
<p>指针管理的困境：</p>
<ol>
<li>资源释放了，但是指针没置空，野指针，指针悬挂</li>
<li>没有释放资源导致内存泄漏</li>
<li>多个指针指向一个资源，导致重复释放一个资源</li>
</ol>
</li>
<li>
<p>使用RAII思想：它通过在对象的构造函数中获取资源，在对象的析构函数中释放资源，从而确保资源的正确获取和释放，利用生命周期来正确释放资源<br>
一共三种智能指针：</p>
</li>
<li>
<p>shared_ptr:</p>
<ol>
<li>解决的是多个指针指向一个资源的问题，共享所有权</li>
<li>原理：内部维护了一个引用计数，这个数字就是指向这个资源的指针数量，只有数为0才能通过析构函数释放资源，因为不同shared_ptr指针需要共享相同的内存对象，因此引用计数的存储是在堆上的</li>
<li>使用场景：通常用于一些资源创建昂贵比较耗时的场景， 比如涉及到文件读写、网络连接、数据库连接等。当需要共享资源的所有权时，例如，一个资源需要被多个对象共享，但是不知道哪个对象会最后释放它，这时候就可以使用std::shared_ptr<T></li>
</ol>
</li>
<li>
<p>weak_ptr:</p>
<ol>
<li>是一个弱引用，指向的是<strong>shared_ptr所指的对象</strong>，而不影响所指对象的生命周期（不会改变引用计数）</li>
<li>weak_ptr不能解引用，所以如果要访问所指对象，就得强制转换为shared_ptr，lock()函数就实现了该功能，成功返回共享对象的shared_ptr,失败返回空的shared_ptr</li>
<li>使用场景：
<ol>
<li>可用于<strong>实现缓存</strong>，因为当weak_ptr所知对象被销毁是，weak_ptr会自动释放，不会成为野指针<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/面试笔记/image-23.png" alt="示例图片" style="zoom:100%;" />，为什么不直接用shared_ptr，因为用这个之后引用计数永远不会为0</li>
<li><strong>避免循环引用问题</strong>，两个对象的shared_ptr互相指向对方，导致形成一个环，互相依赖，从而导致内存泄漏，解决办法就是将其中一个shared_ptr改为weak_ptr</li>
<li><strong>用于实现单例模式</strong>，<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/面试笔记/image-24.png" alt="示例图片" style="zoom:100%;" />，优点是避免循环应用：避免了内存泄漏。访问控制：可以访问对象，但是不会延长对象的生命周期。可以在单例对象不被使用时，自动释放对象。</li>
</ol>
</li>
</ol>
</li>
<li>
<p>unique_ptr:</p>
<ol>
<li>
<p>独享所有权，一个资源只能有一个指针指向它，使用移动语义实现</p>
</li>
<li>
<p>原理：</p>
<ol>
<li>禁用了拷贝构造和赋值构造</li>
</ol>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>(<span class="type">const</span> unique_ptr&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">unique_ptr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> unique_ptr&amp;) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>std::move() 可以将一个unique_ptr转移给另一个unique_ptr或者shared_ptr。转移后，原来的unique_ptr将不再拥有对内存的控制权，将变为空指针</li>
</ol>
   <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; p1 = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">0</span>);</span><br><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; p2 = std::<span class="built_in">move</span>(p1); </span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h2 id="什么设计模式，它解决的是什么问题">什么设计模式，它解决的是什么问题</h2>
<ul>
<li>设计模式是指在软件开发中，通过前人验证的，用于解决特定环境下，一种通用的，可重用的解决方案</li>
<li>解决的是如何做到修改少量代码，就可以适应需求的变化，前提是（既有稳定点，又有变化点），就好比一个整洁的房间，好动的猫，怎么保证房间的整洁</li>
</ul>
<h3 id="相关知识">相关知识</h3>
<h4 id="设计模式一共有哪几大类，设计模式的六大原则是什么">设计模式一共有哪几大类，设计模式的六大原则是什么</h4>
<ul>
<li>有三大类， 创建型模式（工厂模式，抽象工厂模式，单例模式，建造者模式，原型模式），结构型模式（适配器模式，代理模式，外观模式），行为型模式（策略模式，观察者模式，责任链模式）</li>
<li>六大原则：
<ol>
<li>开放封闭原则：
<ol>
<li>原则思想：尽量通过扩展软件实体来解决需求变化，而不是通过修改已有的代码</li>
<li>描述：一个软件产品在生命周期内，都会发生变化，既然变化是一个既定的事实，我们就应该在设计的时候尽量适应这些变化，以提高项目的稳定性和灵活性。</li>
</ol>
</li>
<li>里氏代换原则：
<ol>
<li>原则思想：使用的基类可以在任何地方使用继承的子类，完美替换基类</li>
<li>大概意思是：子类可以扩展父类的功能，但不能改变父类原有的功能。子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法，子类中可以增加自己特有的方法</li>
</ol>
</li>
<li>依赖倒转原则：
<ol>
<li>核心思想是面向接口编程，它要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，依赖抽象而不依赖具体</li>
</ol>
</li>
<li>接口隔离原则：
<ol>
<li>这个原则的大概意思是使用多个隔离的接口，也就是各个接口之间的联系要尽可能小，即要降低接口之间的耦合度</li>
<li>类间的依赖接力在最基础的接口，尽量不要使用用户选择不用的接口</li>
</ol>
</li>
<li>迪米特法则（最少知道原则）：
<ol>
<li>原则思想：一个软件实体应当尽可能少的与其他实体发生相互作用，简称类之间的解耦</li>
<li>大概意思就是一个模块修改而尽量少的影响其他模块，也就是要高内聚，低耦合</li>
</ol>
</li>
<li>单一职责原则：
<ol>
<li>一个方法只负责一件事件</li>
<li>优点：降低类和类的耦合，提高可读性，增加可维护性和可拓展性，降低可变性的风险</li>
</ol>
</li>
</ol>
</li>
</ul>
<h4 id="单例模式">单例模式</h4>
<h5 id="什么是单例，它可以在哪些地方用到了">什么是单例，它可以在哪些地方用到了</h5>
<ul>
<li>保证一个类只有一个实例，并且提供一个访问该全局的访问点</li>
<li>windows的任务管理器，windows的回收站，网站的计数器，多线程的线程池设计等等</li>
</ul>
<h5 id="单例的优缺点">单例的优缺点</h5>
<ul>
<li>优点：保证所有的对象都只会访问一个实例，避免对共享资源的多重占用，一个系统只存在一个对象，因此可以节约系统资源，所以如果需要频繁创建和销毁的对象时单例模式可以提高系统的性能</li>
<li>缺点：单例类不好扩展，不适用于变化的对象</li>
</ul>
<h5 id="单例创建方式">单例创建方式</h5>
<h6 id="饿汉式">饿汉式</h6>
<ul>
<li>类初始化的时候，会加载该对象，调用效率高，线程安全</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//饿汉式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有的构造函数，防止外部调用构造函数创建实例</span></span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将拷贝构造函数和赋值运算符重载声明为私有，防止拷贝创建实例</span></span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;);</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态成员变量，用于存储唯一的实例</span></span><br><span class="line">    <span class="type">static</span> Singleton* instance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取单例实例的静态方法</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他成员方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">someMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Some method of Singleton class&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化静态成员变量，当类有静态成员变量，其是在类的定义外部进行初始化</span></span><br><span class="line">Singleton* Singleton::instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取单例实例</span></span><br><span class="line">    Singleton* singleton = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用单例实例的方法</span></span><br><span class="line">    singleton-&gt;<span class="built_in">someMethod</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="懒汉式">懒汉式</h6>
<ul>
<li>类初始化时，不会初始化该对象，而是在真正需要使用的时候才会创建该对象</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有的静态成员变量，用于存储唯一的实例</span></span><br><span class="line">    <span class="type">static</span> Singleton* instance;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 私有的构造函数，防止外部调用构造函数创建实例</span></span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Singleton instance created.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将拷贝构造函数和赋值运算符重载声明为私有，防止拷贝创建实例</span></span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;);</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取单例实例的静态方法</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用局部静态变量确保线程安全地创建单例实例</span></span><br><span class="line">        <span class="type">static</span> std::mutex mtx;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他成员方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">someMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Some method of Singleton class&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化静态成员变量</span></span><br><span class="line">Singleton* Singleton::instance = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取单例实例</span></span><br><span class="line">    Singleton* singleton1 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">    Singleton* singleton2 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否是同一个实例</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Are singleton1 and singleton2 the same instance? &quot;</span> &lt;&lt; (singleton1 == singleton2 ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用单例实例的方法</span></span><br><span class="line">    singleton1-&gt;<span class="built_in">someMethod</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="静态内部方式">静态内部方式</h6>
<ul>
<li>结合了懒汉式和饿汉式各自的优点，真正需要对象的时候才会加载，加载类是线程安全的。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有的构造函数，防止外部调用构造函数创建实例</span></span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Singleton instance created.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将拷贝构造函数和赋值运算符重载声明为私有，防止拷贝创建实例</span></span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取单例实例的静态方法</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton&amp; <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 局部静态变量，确保在程序运行过程中只创建一次实例</span></span><br><span class="line">        <span class="type">static</span> Singleton instance;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他成员方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">someMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Some method of Singleton class&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取单例实例</span></span><br><span class="line">    Singleton&amp; singleton1 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">    Singleton&amp; singleton2 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否是同一个实例</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Are singleton1 and singleton2 the same instance? &quot;</span> &lt;&lt; (&amp;singleton1 == &amp;singleton2 ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用单例实例的方法</span></span><br><span class="line">    singleton<span class="number">1.</span><span class="built_in">someMethod</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><em><strong>注意</strong></em>：这种方式 在C++11之前是不安全的，得加互斥锁，但是在C++11之后是安全的</p>
<h5 id="如何选择单例模式的创建方式">如何选择单例模式的创建方式</h5>
<ul>
<li>如果不需要延迟加载单例，就用饿汉式</li>
<li>如果需要用延迟加载机制，可以用静态内部类或者懒汉式</li>
</ul>
<h4 id="工厂模式">工厂模式</h4>
<ul>
<li>定义一个创建对象的接口，让子类决定实例化哪个类，而对象的创建统一交由工厂去生产，有良好的封装性，既做到了解耦，也保证了最少知识原则。</li>
<li>工厂模式总共分为三类，简单工厂模式，工厂方法模式，抽象工厂模式</li>
</ul>
<h5 id="简单工厂模式">简单工厂模式</h5>
<ul>
<li>特点是需要在工厂类中做判断，从而创造相应产品，当需要增加产品种类的时候，不能够扩展，而只能修改源码，不满足开发封闭原则</li>
<li>举例：有一家生产处理器核的厂家，它只有一个工厂，能够生产两种型号的处理器核。客户需要什么样的处理器核，一定要显示地告诉生产工厂。下面给出一种实现方案：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//程序实例（简单工厂模式）</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">CTYPE</span> &#123;COREA, COREB&#125;;     </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleCore</span>    </span><br><span class="line">&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;  </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="comment">//单核A    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleCoreA</span>: <span class="keyword">public</span> SingleCore    </span><br><span class="line">&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;SingleCore A&quot;</span>&lt;&lt;endl; &#125;    </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="comment">//单核B    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleCoreB</span>: <span class="keyword">public</span> SingleCore    </span><br><span class="line">&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;SingleCore B&quot;</span>&lt;&lt;endl; &#125;    </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="comment">//唯一的工厂，可以生产两种型号的处理器核，在内部判断    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span>    </span><br><span class="line">&#123;    </span><br><span class="line"><span class="keyword">public</span>:     </span><br><span class="line">    <span class="function">SingleCore* <span class="title">CreateSingleCore</span><span class="params">(<span class="keyword">enum</span> CTYPE ctype)</span>    </span></span><br><span class="line"><span class="function">    </span>&#123;    </span><br><span class="line">        <span class="keyword">if</span>(ctype == COREA) <span class="comment">//工厂内部判断    </span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SingleCoreA</span>(); <span class="comment">//生产核A    </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ctype == COREB)    </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SingleCoreB</span>(); <span class="comment">//生产核B    </span></span><br><span class="line">        <span class="keyword">else</span>    </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;    </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>大概如图所示：</li>
<li>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/面试笔记/image-26.png" alt="示例图片" style="zoom:100%;" />
</li>
</ul>
<h6 id="简单工厂模式的优缺点">简单工厂模式的优缺点</h6>
<ul>
<li>优点：可以根据需求，动态生成使用者所需的类对象，而使用者不用去知道怎么创建对象，者使得模块各司其职，降低了系统耦合性</li>
<li>缺点:违反了开放封闭原则</li>
</ul>
<h5 id="工厂方法模式">工厂方法模式</h5>
<ul>
<li>
<p>所谓工厂方法模式（又称多态性工厂模式），是指核心的工厂类不再负责所有的产品的创建，而是将具体创建的工作交给子类去做。该核心类成为一个抽象工厂角色，仅负责给出具体工厂子类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节</p>
</li>
<li>
<p>举例：这家生产处理器核的产家赚了不少钱，于是决定再开设一个工厂专门用来生产B型号的单核，而原来的工厂专门用来生产A型号的单核。这时，客户要做的是找好工厂，比如要A型号的核，就找A工厂要；否则找B工厂要，不再需要告诉工厂具体要什么型号的处理器核了。下面给出一个实现方案：</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//程序实例（工厂方法模式）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleCore</span>    </span><br><span class="line">&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;  </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="comment">//单核A    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleCoreA</span>: <span class="keyword">public</span> SingleCore    </span><br><span class="line">&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;SingleCore A&quot;</span>&lt;&lt;endl; &#125;    </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="comment">//单核B    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleCoreB</span>: <span class="keyword">public</span> SingleCore    </span><br><span class="line">&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;SingleCore B&quot;</span>&lt;&lt;endl; &#125;    </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span>    </span><br><span class="line">&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> SingleCore* <span class="title">CreateSingleCore</span><span class="params">()</span> </span>= <span class="number">0</span>;  </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="comment">//生产A核的工厂    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FactoryA</span>: <span class="keyword">public</span> Factory    </span><br><span class="line">&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function">SingleCoreA* <span class="title">CreateSingleCore</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> SingleCoreA; &#125;    </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="comment">//生产B核的工厂    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FactoryB</span>: <span class="keyword">public</span> Factory    </span><br><span class="line">&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function">SingleCoreB* <span class="title">CreateSingleCore</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> SingleCoreB; &#125;    </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/面试笔记/image-27.png" alt="示例图片" style="zoom:100%;" />
<h6 id="工厂方法模式的优缺点">工厂方法模式的优缺点</h6>
<ul>
<li>优点：扩展性好，符合了开放封闭原则，新增的时候只需要扩展子类就行</li>
<li>缺点：如果需要很多工厂，就要继承出很多子类</li>
</ul>
<h5 id="抽象工厂模式">抽象工厂模式</h5>
<ul>
<li>举例：这家公司的技术不断进步，不仅可以生产单核处理器，也能生产多核处理器。现在简单工厂模式和工厂方法模式都鞭长莫及。抽象工厂模式登场了。它的定义为提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。具体这样应用，这家公司还是开设两个工厂，一个专门用来生产A型号的单核多核处理器，而另一个工厂专门用来生产B型号的单核多核处理器，下面给出实现的代码：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//程序实例（抽象工厂模式）</span></span><br><span class="line"><span class="comment">//单核    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleCore</span>     </span><br><span class="line">&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;  </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleCoreA</span>: <span class="keyword">public</span> SingleCore      </span><br><span class="line">&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;Single Core A&quot;</span>&lt;&lt;endl; &#125;    </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleCoreB</span> :<span class="keyword">public</span> SingleCore    </span><br><span class="line">&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;Single Core B&quot;</span>&lt;&lt;endl; &#125;    </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="comment">//多核    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MultiCore</span>      </span><br><span class="line">&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;  </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MultiCoreA</span> : <span class="keyword">public</span> MultiCore      </span><br><span class="line">&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;Multi Core A&quot;</span>&lt;&lt;endl; &#125;    </span><br><span class="line">    </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MultiCoreB</span> : <span class="keyword">public</span> MultiCore      </span><br><span class="line">&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;Multi Core B&quot;</span>&lt;&lt;endl; &#125;    </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="comment">//工厂    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CoreFactory</span>      </span><br><span class="line">&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> SingleCore* <span class="title">CreateSingleCore</span><span class="params">()</span> </span>= <span class="number">0</span>;  </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> MultiCore* <span class="title">CreateMultiCore</span><span class="params">()</span> </span>= <span class="number">0</span>;  </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="comment">//工厂A，专门用来生产A型号的处理器    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FactoryA</span> :<span class="keyword">public</span> CoreFactory    </span><br><span class="line">&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function">SingleCore* <span class="title">CreateSingleCore</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SingleCoreA</span>(); &#125;    </span><br><span class="line">    <span class="function">MultiCore* <span class="title">CreateMultiCore</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">MultiCoreA</span>(); &#125;    </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="comment">//工厂B，专门用来生产B型号的处理器    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FactoryB</span> : <span class="keyword">public</span> CoreFactory    </span><br><span class="line">&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function">SingleCore* <span class="title">CreateSingleCore</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SingleCoreB</span>(); &#125;    </span><br><span class="line">    <span class="function">MultiCore* <span class="title">CreateMultiCore</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">MultiCoreB</span>(); &#125;    </span><br><span class="line">&#125;;   </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/面试笔记/image-28.png" alt="示例图片" style="zoom:100%;" />
<h6 id="抽象工厂模式的优缺点">抽象工厂模式的优缺点</h6>
<ul>
<li>
<p>优点： 工厂抽象类创建了多个类型的产品，当有需求时，可以创建相关产品子类和子工厂类来获取。</p>
</li>
<li>
<p>缺点： 扩展新种类产品时困难。抽象工厂模式需要我们在工厂抽象类中提前确定了可能需要的产品种类，以满足不同型号的多种产品的需求。但是如果我们需要的产品种类并没有在工厂抽象类中提前确定，那我们就需要去修改工厂抽象类了，而一旦修改了工厂抽象类，那么所有的工厂子类也需要修改，这样显然扩展不方便。</p>
</li>
</ul>
<h5 id="抽象工厂模式和工厂方法模式的区别">抽象工厂模式和工厂方法模式的区别</h5>
<ul>
<li>传统的工厂方法模式，一般只能有一个纯虚函数，他的子类实现这个纯虚函数，一个只能创造一种产品，且每个产品都是同一种</li>
<li>抽象工厂模式，必须有多个纯虚函数，他的子类必须实现这些纯虚函数，并创建一系列相关的对象，即一个工厂可以创造多个有相同性质又有不同的产品</li>
</ul>
<h4 id="策略模式">策略模式</h4>
<ul>
<li>
<p>定义：策略模式是定义了一系列算法，把它们一个个封装起来，并且使它们可互相替换，该模式使得算法可以独立于使用它的客户端变化而变化</p>
</li>
<li>
<p>例如：一个商城有多种打折方式，有国庆打折方式，劳动节打折方式，春节打折方式，又例如一个会员，有初级会员，中级会员，高级会员</p>
</li>
<li>
<p>如果不采用策略模式，在一个商城类中，既要有国庆打折方式，劳动节打折方式，春节打折方式，当一个打折方式变化后，这个商城类整体就要变化</p>
</li>
<li>
<p>如果采用设计模式，国庆打折方式抽象出来成为一个类劳动节打折方式和春节打折方式付也抽象出来成为类，这样就会有一个商城类和 一个国庆打折方式类，一个劳动节打折方式类，一个春节打折方式类，在商城类只需要一个指针，指向对应的打折方式就行</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ProStategy</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">CalcPro</span> <span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">gqStategy</span>: <span class="keyword">public</span> ProStategy&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">CalcPro</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;国庆打折&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ldjStategy</span>: <span class="keyword">public</span> ProStategy&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">CalcPro</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;劳动节打折&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">cjqStategy</span>: <span class="keyword">public</span> ProStategy&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">CalcPro</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;春节打折&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Promotion</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Promotion</span>(ProStategy * sss = <span class="literal">nullptr</span>) : <span class="built_in">s</span>(sss)&#123;&#125;</span><br><span class="line">    ~<span class="built_in">Promotion</span>()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Chose</span><span class="params">(ProStategy *sss)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sss != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        s = sss;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ProStategy *s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/面试笔记/image-29.png" alt="示例图片" style="zoom:100%;" />
<p>其中左位使用前，右为使用后</p>
<h5 id="应用案例">应用案例</h5>
<ul>
<li>日志容错恢复机制：通常情况下，日志记录在数据库中，但是如果发生了异常，数据库暂时连接不上的情况，就会先将日志记录在文件中，之后在合适的时机再写回数据库，这就可以采用策略模式，把日志记录在数据库和记录在文件中当作两种记录日志的策略，在运行其动态选择（断网了选择记入在文件，连接的上就计入在数据库中）</li>
</ul>
<h4 id="观察者模式">观察者模式</h4>
<ul>
<li>定义：指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。这种模式有时又称作发布-订阅模式、模型-视图模式，它是对象行为型模式。</li>
</ul>
<h5 id="解决了什么问题">解决了什么问题</h5>
<ul>
<li>稳定点：一对多的依赖关系，一变化多跟着变化</li>
<li>变化点：多增加或者多减少，不能影响依赖关系，也不能影响一的</li>
</ul>
<h5 id="例子">例子</h5>
<ul>
<li>气象站发布气象资料给数据中心，数据中心经过处理，将气象信息更新到两个不同的显示终端(a和b)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 观察者接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">const</span> std::string&amp; weatherData)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 气象站，作为被观察者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WeatherStation</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;Observer*&gt; observers;</span><br><span class="line">    std::string weatherData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单例实现</span></span><br><span class="line">    <span class="built_in">WeatherStation</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取单例实例</span></span><br><span class="line">    <span class="function"><span class="type">static</span> WeatherStation&amp; <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> WeatherStation instance;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册观察者</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">registerObserver</span><span class="params">(Observer* observer)</span> </span>&#123;</span><br><span class="line">        observers.<span class="built_in">push_back</span>(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发布气象资料并通知观察者</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">publishWeatherData</span><span class="params">(<span class="type">const</span> std::string&amp; data)</span> </span>&#123;</span><br><span class="line">        weatherData = data;</span><br><span class="line">        <span class="built_in">notifyObservers</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知所有观察者</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">notifyObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer* observer : observers) &#123;</span><br><span class="line">            observer-&gt;<span class="built_in">update</span>(weatherData);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示终端A，观察者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DisplayTerminalA</span> : <span class="keyword">public</span> Observer &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">const</span> std::string&amp; weatherData)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Display Terminal A: Weather data updated - &quot;</span> &lt;&lt; weatherData &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示终端B，观察者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DisplayTerminalB</span> : <span class="keyword">public</span> Observer &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">const</span> std::string&amp; weatherData)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Display Terminal B: Weather data updated - &quot;</span> &lt;&lt; weatherData &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取气象站单例实例</span></span><br><span class="line">    WeatherStation&amp; weatherStation = WeatherStation::<span class="built_in">getInstance</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建显示终端A和B</span></span><br><span class="line">    DisplayTerminalA displayA;</span><br><span class="line">    DisplayTerminalB displayB;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册观察者</span></span><br><span class="line">    weatherStation.<span class="built_in">registerObserver</span>(&amp;displayA);</span><br><span class="line">    weatherStation.<span class="built_in">registerObserver</span>(&amp;displayB);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟气象站发布气象资料</span></span><br><span class="line">    weatherStation.<span class="built_in">publishWeatherData</span>(<span class="string">&quot;Temperature: 25°C, Humidity: 50%&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>博客订阅的例子，当博主发表新文章的时候，即博主状态发生了改变，那些订阅的读者就会收到通知，然后进行相应的动作，比如去看文章，或者收藏起来</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//观察者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span>  </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Observer</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Observer</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Update</span><span class="params">()</span> </span>&#123;&#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//博客</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Blog</span>  </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Blog</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Blog</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Attach</span><span class="params">(Observer *observer)</span> </span>&#123; m_observers.<span class="built_in">push_back</span>(observer); &#125;     <span class="comment">//添加观察者</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Remove</span><span class="params">(Observer *observer)</span> </span>&#123; m_observers.<span class="built_in">remove</span>(observer); &#125;        <span class="comment">//移除观察者</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Notify</span><span class="params">()</span> <span class="comment">//通知观察者</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        list&lt;Observer*&gt;::iterator iter = m_observers.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">for</span>(; iter != m_observers.<span class="built_in">end</span>(); iter++)</span><br><span class="line">            (*iter)-&gt;<span class="built_in">Update</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SetStatus</span><span class="params">(string s)</span> </span>&#123; m_status = s; &#125; <span class="comment">//设置状态</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> string <span class="title">GetStatus</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_status; &#125;    <span class="comment">//获得状态</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    list&lt;Observer* &gt; m_observers; <span class="comment">//观察者链表</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    string m_status; <span class="comment">//状态</span></span><br><span class="line">&#125;;</span><br><span class="line">    以上是观察者和博客的基类，定义了通用接口。博客类主要完成观察者的添加、移除、通知操作，设置和获得状态仅仅是一个默认实现。下面给出它们相应的子类实现。</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体博客类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BlogCSDN</span> : <span class="keyword">public</span> Blog</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_name; <span class="comment">//博主名称</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BlogCSDN</span>(string name): <span class="built_in">m_name</span>(name) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">BlogCSDN</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetStatus</span><span class="params">(string s)</span> </span>&#123; m_status = <span class="string">&quot;CSDN通知 : &quot;</span> + m_name + s; &#125; <span class="comment">//具体设置状态信息</span></span><br><span class="line">    <span class="function">string <span class="title">GetStatus</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_status; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//具体观察者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ObserverBlog</span> : <span class="keyword">public</span> Observer   </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_name;  <span class="comment">//观察者名称</span></span><br><span class="line">    Blog *m_blog;   <span class="comment">//观察的博客，当然以链表形式更好，就可以观察多个博客</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="built_in">ObserverBlog</span>(string name,Blog *blog): <span class="built_in">m_name</span>(name), <span class="built_in">m_blog</span>(blog) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">ObserverBlog</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Update</span><span class="params">()</span>  <span class="comment">//获得更新状态</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        string status = m_blog-&gt;<span class="built_in">GetStatus</span>();</span><br><span class="line">        cout&lt;&lt;m_name&lt;&lt;<span class="string">&quot;-------&quot;</span>&lt;&lt;status&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//测试案例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Blog *blog = <span class="keyword">new</span> <span class="built_in">BlogCSDN</span>(<span class="string">&quot;wuzhekai1985&quot;</span>);</span><br><span class="line">    Observer *observer1 = <span class="keyword">new</span> <span class="built_in">ObserverBlog</span>(<span class="string">&quot;tutupig&quot;</span>, blog);</span><br><span class="line">    blog-&gt;<span class="built_in">Attach</span>(observer1);</span><br><span class="line">    blog-&gt;<span class="built_in">SetStatus</span>(<span class="string">&quot;发表设计模式C++实现（15）——观察者模式&quot;</span>);</span><br><span class="line">    blog-&gt;<span class="built_in">Notify</span>();</span><br><span class="line">    <span class="keyword">delete</span> blog; <span class="keyword">delete</span> observer1;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="代码结构">代码结构</h5>
<ul>
<li>观察者接口（抽象类）</li>
<li>实现不同的观察者</li>
<li>目标对象接口（一个单例，用容器接收不同的观察者）</li>
<li>往容器添加与删除接口</li>
<li>推送变化</li>
</ul>
<h5 id="如果扩展代码">如果扩展代码</h5>
<ul>
<li>新增一个观察者，继承自观察者接口，实现观察者的变化逻辑，进容器</li>
<li>减少就是使用出容器</li>
</ul>
<h5 id="应用的案例">应用的案例</h5>
<ul>
<li>游戏业务开发场景：一个用户有许多的特性，比如装备系统，vip系统，人物面板系统，当一个系统改变，其他系统也跟着改变</li>
</ul>
<h5 id="优缺点">优缺点</h5>
<ul>
<li>优点
<ol>
<li>降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。符合依赖倒置原则。</li>
<li>目标与观察者之间建立了一套触发机制。</li>
</ol>
</li>
<li>缺点
<ol>
<li>目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。</li>
<li>当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。</li>
</ol>
</li>
</ul>
<h4 id="责任链模式">责任链模式</h4>
<ul>
<li>定义：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递请求，直到有一个对象处理它为止</li>
<li>人话：客户发出一个请求，会有很多对象可以处理这个请求，并且不同对象的处理逻辑是不一样的，对于客户而言，不关心是谁处理的，只是希望处理流程可以灵活多变，处理请求的对象需要方便修改处理请求的方式或者能被替换，以适应业务功能的变化</li>
</ul>
<h5 id="解决了什么问题-2">解决了什么问题</h5>
<ul>
<li>稳定点： 处理流程，请求按照链条传递，需要链表和请求处理的接口，要可打断（结束继续遍历）</li>
<li>变化点：处理节点的个数，处理顺序，处理逻辑，其中处理逻辑又分为处理方式和处理条件</li>
</ul>
<h5 id="例子-2">例子</h5>
<ul>
<li>背景：请假流程，3天内需要主程序批准，30天内需要项目经理批准，30天以上需要老板批准</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 工厂模式加责任链模式</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 请假请求类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LeaveRequest</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> days;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LeaveRequest</span>(<span class="type">int</span> days) : <span class="built_in">days</span>(days) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getDays</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> days; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理请假请求的抽象处理者类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LeaveHandler</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    LeaveHandler* nextHandler;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LeaveHandler</span>() : <span class="built_in">nextHandler</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setNextHandler</span><span class="params">(LeaveHandler* handler)</span> </span>&#123;</span><br><span class="line">        nextHandler = handler;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">handleRequest</span><span class="params">(<span class="type">const</span> LeaveRequest&amp; request)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主程序处理者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Supervisor</span> : <span class="keyword">public</span> LeaveHandler &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleRequest</span><span class="params">(<span class="type">const</span> LeaveRequest&amp; request)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request.<span class="built_in">getDays</span>() &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Main program approved the leave request.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nextHandler != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            nextHandler-&gt;<span class="built_in">handleRequest</span>(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 项目经理处理者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProjectManager</span> : <span class="keyword">public</span> LeaveHandler &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleRequest</span><span class="params">(<span class="type">const</span> LeaveRequest&amp; request)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request.<span class="built_in">getDays</span>() &gt; <span class="number">3</span> &amp;&amp; request.<span class="built_in">getDays</span>() &lt;= <span class="number">30</span>) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Project manager approved the leave request.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nextHandler != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            nextHandler-&gt;<span class="built_in">handleRequest</span>(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 老板处理者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Boss</span> : <span class="keyword">public</span> LeaveHandler &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleRequest</span><span class="params">(<span class="type">const</span> LeaveRequest&amp; request)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request.<span class="built_in">getDays</span>() &gt; <span class="number">30</span>) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Boss approved the leave request.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;No one can approve the leave request.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 责任链工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LeaveHandlerFactory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> LeaveHandler* <span class="title">createLeaveHandlerChain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Supervisor* supervisor = <span class="keyword">new</span> <span class="built_in">Supervisor</span>();</span><br><span class="line">        ProjectManager* projectManager = <span class="keyword">new</span> <span class="built_in">ProjectManager</span>();</span><br><span class="line">        Boss* boss = <span class="keyword">new</span> <span class="built_in">Boss</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置责任链关系</span></span><br><span class="line">        supervisor-&gt;<span class="built_in">setNextHandler</span>(projectManager);</span><br><span class="line">        projectManager-&gt;<span class="built_in">setNextHandler</span>(boss);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> supervisor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建责任链</span></span><br><span class="line">    LeaveHandler* handlerChain = LeaveHandlerFactory::<span class="built_in">createLeaveHandlerChain</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发起请假请求</span></span><br><span class="line">    <span class="function">LeaveRequest <span class="title">request1</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">LeaveRequest <span class="title">request2</span><span class="params">(<span class="number">15</span>)</span></span>;</span><br><span class="line">    <span class="function">LeaveRequest <span class="title">request3</span><span class="params">(<span class="number">40</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理请假请求</span></span><br><span class="line">    handlerChain-&gt;<span class="built_in">handleRequest</span>(request1);</span><br><span class="line">    handlerChain-&gt;<span class="built_in">handleRequest</span>(request2);</span><br><span class="line">    handlerChain-&gt;<span class="built_in">handleRequest</span>(request3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">delete</span> handlerChain;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="代码结构-2">代码结构</h5>
<ul>
<li>从单个节点出发：
<ol>
<li>抽象一个处理对象接口</li>
<li>处理对象继承自该接口
<ol>
<li>实现处理请求功能</li>
<li>实现链条关系</li>
<li>实现功能传递</li>
</ol>
</li>
</ol>
</li>
<li>实现一个构造链表关系的静态接口（工厂）</li>
</ul>
<h5 id="代码扩展">代码扩展</h5>
<ul>
<li>如果我要扩展出一个新的处理逻辑，只需新增一个类，继承自处理请假接口，并在工厂中加入链表</li>
<li>例如我要加一个董事长</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 董事长处理者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Chairman</span> : <span class="keyword">public</span> LeaveHandler &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleRequest</span><span class="params">(<span class="type">const</span> LeaveRequest&amp; request)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request.<span class="built_in">getDays</span>() &gt; <span class="number">180</span>) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Chairman approved the leave request.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nextHandler != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            nextHandler-&gt;<span class="built_in">handleRequest</span>(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 责任链工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LeaveHandlerFactory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> LeaveHandler* <span class="title">createLeaveHandlerChain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Supervisor* supervisor = <span class="keyword">new</span> <span class="built_in">Supervisor</span>();</span><br><span class="line">        ProjectManager* projectManager = <span class="keyword">new</span> <span class="built_in">ProjectManager</span>();</span><br><span class="line">        Boss* boss = <span class="keyword">new</span> <span class="built_in">Boss</span>();</span><br><span class="line">        Chairman* chairman = <span class="keyword">new</span> <span class="built_in">Chairman</span>(); <span class="comment">// 新增董事长处理者</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置责任链关系</span></span><br><span class="line">        supervisor-&gt;<span class="built_in">setNextHandler</span>(projectManager);</span><br><span class="line">        projectManager-&gt;<span class="built_in">setNextHandler</span>(boss);</span><br><span class="line">        boss-&gt;<span class="built_in">setNextHandler</span>(chairman); <span class="comment">// 将董事长处理者添加到责任链中</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> supervisor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="应用案例-2">应用案例</h5>
<ul>
<li>nginx 就是用了责任链模式，http请求就是要经过11个阶段一个一个处理</li>
</ul>
<h4 id="装饰器模式">装饰器模式</h4>
<ul>
<li>定义：指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式。</li>
<li>结构及实现：通常情况下，扩展一个类的功能会使用继承方式来实现。但继承具有静态特征，耦合度高，并且随着扩展功能的增多，子类会很膨胀。如果使用组合关系来创建一个包装对象（即装饰对象）来包裹真实对象，并在保持真实对象的类结构不变的前提下，为其提供额外的功能，这就是装饰模式的目标。下面来分析其基本结构和实现方法。</li>
</ul>
<h5 id="优缺点-2">优缺点</h5>
<ul>
<li>
<p>优点：</p>
<ol>
<li>装饰器是继承的有力补充，比继承灵活，在不改变原有对象的情况下，动态扩展功能，即插即用</li>
<li>通过使用不用装饰类及这些装饰类的排列组合，可以实现不同效果；</li>
<li>装饰器模式完全遵守开闭原则</li>
</ol>
</li>
<li>
<p>缺点：装饰模式会增加许多子类，过度使用会增加程序得复杂性。</p>
</li>
</ul>
<h5 id="代码">代码</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 咖啡接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">cost</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基础咖啡类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleCoffee</span> : <span class="keyword">public</span> Coffee &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">cost</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0</span>; <span class="comment">// 基础咖啡价格为1元</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 咖啡装饰器类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CoffeeDecorator</span> : <span class="keyword">public</span> Coffee &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Coffee* coffee;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CoffeeDecorator</span>(Coffee* coffee) : <span class="built_in">coffee</span>(coffee) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">cost</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> coffee-&gt;<span class="built_in">cost</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 牛奶装饰器类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Milk</span> : <span class="keyword">public</span> CoffeeDecorator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Milk</span>(Coffee* coffee) : <span class="built_in">CoffeeDecorator</span>(coffee) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">cost</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> coffee-&gt;<span class="built_in">cost</span>() + <span class="number">0.5</span>; <span class="comment">// 牛奶价格为0.5元</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 糖装饰器类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sugar</span> : <span class="keyword">public</span> CoffeeDecorator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Sugar</span>(Coffee* coffee) : <span class="built_in">CoffeeDecorator</span>(coffee) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">cost</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> coffee-&gt;<span class="built_in">cost</span>() + <span class="number">0.2</span>; <span class="comment">// 糖价格为0.2元</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个简单的咖啡</span></span><br><span class="line">    Coffee* coffee = <span class="keyword">new</span> <span class="built_in">SimpleCoffee</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加牛奶和糖</span></span><br><span class="line">    coffee = <span class="keyword">new</span> <span class="built_in">Milk</span>(coffee);</span><br><span class="line">    coffee = <span class="keyword">new</span> <span class="built_in">Sugar</span>(coffee);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算总价格</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Total cost: &quot;</span> &lt;&lt; coffee-&gt;<span class="built_in">cost</span>() &lt;&lt; <span class="string">&quot;元&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> coffee; <span class="comment">// 释放内存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>往咖啡里加配料 就可以使用装饰者模式，我们可以动态地为咖啡添加各种配料，而不需要修改咖啡类的代码，这使得代码更加可维护和可扩展。</li>
</ul>
<h5 id="代码扩展-2">代码扩展</h5>
<ul>
<li>新增一个类继承自coffee装饰器类，实现具体功能</li>
</ul>
<h2 id="B树与B-树与二叉搜索树">B树与B+树与二叉搜索树</h2>
<ul>
<li>什么是二叉搜索树？二叉搜索树是一种使用了二分的思想，将小于根节点的数值放在左子树，大于根节点的放在右子树，这样便于查找数据，但是也有局限性，当根节点为最小值或者最大值的时候会退化成O(N)的复杂度</li>
<li>什么是B树？是为了解决二叉搜索树效率不稳定的弊端，它已经不属于二叉树，而是一种多叉树，运用的也是二分思想，允许一个节点有多个索引，并且每个索引都有一个指针以及对应的数据，但由于没多一层高度，就会多一次操作，在数据库里要频繁IO，所以效率也不是特别高</li>
<li>什么是B+树？B+树是B树的改良版，它只允许叶子节点有数据，并且每个叶子节点通过链表连接。其中一个节点的子节点包含根节点所表示的索引，这个索引的是半闭半开的。B+树比B树的层级更少，查找效率更稳定和快。</li>
</ul>
<h2 id="语法基础">语法基础</h2>
<h3 id="野指针-悬空指针-空指针">野指针 悬空指针 空指针</h3>
<ul>
<li>野指针是<strong>没有被初始化过</strong>的指针，指向的位置是不可知的（随机的、不正确的、没有明确限制的）</li>
<li>悬空指针：指针最初指向的内存已经被释放了的一种指针。（例子：返回局部变量的地址）</li>
<li>空指针：指针的值为0，不指向任何有效数据</li>
</ul>
<h3 id="union的相关知识">union的相关知识</h3>
<ul>
<li>union 是一个共用体，union 里面的属性是共享同一个内存，所以当我们sizeof(union),输出的大小是union里面内存最高的</li>
</ul>
<h3 id="指针相关知识">指针相关知识</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> p[][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>&#125;, &#123;<span class="number">5</span>, <span class="number">6</span>&#125;&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *((<span class="type">int</span>*) p + <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">- 输出是<span class="number">4</span> 因为先把p转换为p[<span class="number">0</span>][<span class="number">0</span>],之后三个位置为p[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">- </span><br></pre></td></tr></table></figure>
<h3 id="C-内存对齐机制">C++ 内存对齐机制</h3>
<ul>
<li>C++内存对齐机制：内存对齐的时候 看的是结构体里面最大的字节，如果最大为8 则对齐的时候是8的倍数，如果最大为4，最对齐是4的倍数</li>
</ul>
<h3 id="std-string">std::string</h3>
<ul>
<li>std::string 在初始化时给多少就会有多少字节，在后续扩展的时候，是以原来的两倍扩展，std::string 内部是用char* 实现的，所以当sizeof它的时候是4</li>
</ul>
<h3 id="const-int-ptr-int-const-ptr的区别是什么？">const int * ptr, int * const ptr的区别是什么？</h3>
<ul>
<li>const int *ptr 表示的是 ptr所指向的内容是常量，是不可变的，int *const ptr； 则表示其ptr指针的指向是不能改变的</li>
</ul>
<h3 id="什么是std-ref？">什么是std::ref？</h3>
<ul>
<li>
<p>std::ref的作用是将一个值包装为reference_Wrapper，这个对象在bind 和 thread时会被识别为引用，这样就解决了bind与thread 无法传递引用的问题（因为原本会被拷贝为右值）</p>
</li>
<li>
<p>大致可以这么理解：在底层 ref函数会把 一个值的地址和类型封装成reference_wrapper，当我们调用的时候触发了仿函数()，取得了该地址下的值</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> _CONSTEXPR20 <span class="keyword">operator</span> _Ty&amp;() <span class="type">const</span> <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> *_Ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">_NODISCARD _CONSTEXPR20 _Ty&amp; <span class="title">get</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *_Ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="std-ref-和不同引用的区别">std::ref 和不同引用的区别</h4>
<ul>
<li>std::ref只是尝试模拟引用传递，并不能真正变成引用，在非模板情况下，std::ref根本没法实现引用传递，只有模板自动推导类型或类型隐式转换时，std::ref能用包装类型reference_wrapper来代替原本会被识别的值类型，而reference_wrapper能隐式转换为被引用的值的引用类型。</li>
</ul>
<h4 id="总结">总结</h4>
<ul>
<li>我来给总结下，首先我们讲解了std::ref的一些用法，然后我们讲解std::ref是通过std::reference_wrapper实现，然后我们借助了cppreference上的实现来给大家剖析了他本质就是存放了对象的地址(类似指针的用法😁)，还讲解了noexcept等语法，最后我们讲解了下std::bind为什么要使用到reference_wrapper。</li>
<li>std::bind使用的是参数的拷贝而不是引用，当可调用对象期待入参为引用时，必须显示利用std::ref来进行引用绑定。</li>
<li>多线程std::thread的可调用对象期望入参为引用时，也必须显式通过std::ref来绑定引用进行传参。</li>
</ul>
<h3 id="decltype-std-declval-std-decay-t-分别是什么？">decltype, std::declval, std::decay_t 分别是什么？</h3>
<h4 id="decltype">decltype</h4>
<ul>
<li><strong>decltype</strong>是一个关键字，用于从一个表达式中推导出其类型。它通常与表达式一起使用，以便在编译时确定表达式的类型</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">decltype</span>(x) y = <span class="number">10</span>; 推到为<span class="type">int</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="std-declval">std::declval</h4>
<ul>
<li><strong>std::declval</strong>是一个函数模板，它能返回类型 T 的右值引用，其实是一个伪实例，不会产生任何临时对象，也不会因为表达式很复杂而发生真实的计算。因为不会真正的进行构造，所以可以实现在元编程时伪构造一个没有定义默认构造函数类，还可以避开纯虚基类不能实例化的问题，<strong>说白了它就是假装创建个对象(实际没创造)用于推导类型。</strong></li>
</ul>
<h4 id="std-decay-t">std::decay_t</h4>
<ul>
<li>
<p><strong>std::decay_t</strong>用于获取一个类型的衰变类型（decay type）。衰变类型是指将一个类型转换为最基本形式的类型，通常是将引用和顶层 const 限定符去除，并将数组类型转换为指针类型。<strong>说白了就是一个类型转换为最基本形式的类型</strong></p>
</li>
<li>
<p>如果类型是数组类型，则将其转换为指向数组首元素的指针类型。</p>
</li>
<li>
<p>如果类型是函数类型，则将其转换为指向函数的指针类型。</p>
</li>
<li>
<p>如果类型是引用类型，则将其转换为对应的非引用类型。</p>
</li>
<li>
<p>如果类型是顶层 const 限定符类型，则将其转换为对应的非 const 类型</p>
</li>
</ul>
<h3 id="const-与-constexpr">const 与 constexpr</h3>
<ul>
<li>
<p>constexpr 关键字的功能是使指定的常量表达式获得在程序编译阶段计算出结果的能力，而不必等到程序运行阶段。C++ 11 标准中，constexpr 可用于修饰普通变量、函数（包括模板函数）以及类的构造函数。<br>
注意，获得在编译阶段计算出结果的能力，并不代表 constexpr 修饰的表达式一定会在程序编译阶段被执行，具体的计算时机还是编译器说了算。</p>
</li>
<li>
<p>const与constexpr，这两个都是编译期就能知道确切值，在C++11后const建议用来表示只读，constexpr来表示常量，constexpr修饰的是常量表达式，它可以修饰模板函数，可以修饰函数(除了typedef，using static_assert断言)，只有一个返回值且必须是常量表达式，函数必须先声明，可以修饰构造函数</p>
</li>
</ul>
<h3 id="noexcept">noexcept</h3>
<ul>
<li>noexcept 是一个说明符同时也是一个操作符</li>
<li>noexcept 作为说明符放在函数名后面，表明次函数不会抛出异常，等同于noexcept(true)</li>
<li>noexcept 作为操作符时，可以用来判断一个函数是否会抛出异常，用法为 noexcept(funcName)</li>
<li>当使用 noexcept 标记函数时，我们需要自己保证函数不会抛出异常，这样可以生成更高效的代码，他会减少编译器对于抛出异常后对象的默认虚构</li>
<li>如果标记了 noexcept函数还是抛出了异常，那么程序会直接调用 std::abort() 终止程序，try…catch都没用</li>
<li>C++17后noexcept成为了一种类型的一部分</li>
</ul>
<p>使用 noecept之前的汇编代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">entrance</span>():</span><br><span class="line">        push    rbp</span><br><span class="line">        mov     rbp, rsp</span><br><span class="line">        push    rbx</span><br><span class="line">        sub     rsp, <span class="number">24</span></span><br><span class="line">        <span class="function">call    <span class="title">inner</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        lea     rax, [rbp-17]</span></span><br><span class="line"><span class="function">        mov     rdi, rax</span></span><br><span class="line"><span class="function">        call    Obj::~<span class="title">Obj</span><span class="params">()</span> [complete object destructor]</span></span><br><span class="line"><span class="function">        jmp     .L4</span></span><br><span class="line"><span class="function">        mov     rbx, rax</span></span><br><span class="line"><span class="function">        lea     rax, [rbp-17]</span></span><br><span class="line"><span class="function">        mov     rdi, rax</span></span><br><span class="line"><span class="function">        call    Obj::~<span class="title">Obj</span><span class="params">()</span> [complete object destructor]</span></span><br><span class="line"><span class="function">        mov     rax, rbx</span></span><br><span class="line"><span class="function">        mov     rdi, rax</span></span><br><span class="line"><span class="function">        call    _Unwind_Resume</span></span><br><span class="line"><span class="function">.L4:</span></span><br><span class="line"><span class="function">        mov     rbx, QWORD PTR [rbp<span class="number">-8</span>]</span></span><br><span class="line"><span class="function">        leave</span></span><br><span class="line"><span class="function">        ret</span></span><br></pre></td></tr></table></figure>
<p>使用 noecept之后的汇编代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">entrance</span>():</span><br><span class="line">        push    rbp</span><br><span class="line">        mov     rbp, rsp</span><br><span class="line">        sub     rsp, <span class="number">16</span></span><br><span class="line">        <span class="function">call    <span class="title">inner</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        lea     rax, [rbp-1]</span></span><br><span class="line"><span class="function">        mov     rdi, rax</span></span><br><span class="line"><span class="function">        call    Obj::~<span class="title">Obj</span><span class="params">()</span> [complete object destructor]</span></span><br><span class="line"><span class="function">        leave</span></span><br><span class="line"><span class="function">        ret</span></span><br></pre></td></tr></table></figure>
<ul>
<li>总而言之就是优化了个析构函数</li>
</ul>
<h3 id="用户自定义字面量">用户自定义字面量</h3>
<ul>
<li>其中用户自定义后缀尽可能使用“_”下划线作为开头，否则很可能会与C++原生的表示方式冲突，如2L其实是long long 2</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="keyword">operator</span> <span class="string">&quot;&quot;</span> _S(<span class="type">double</span> num)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (num + <span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="keyword">auto</span> res = <span class="number">2.6</span>_S;    <span class="comment">//res = int(2.6 + 0.5) = 3</span></span><br></pre></td></tr></table></figure>
<ul>
<li>然而用户定义字面量也不是随意定义的，有如下规则限制：</li>
</ul>
<p>1、字面量只可以使用四种基本类型：整型、浮点型、字符、字符串<br>
2、若字面量为整型，参数只能为unsigned long long、const char*，且当unsigned long long无法容纳该字面量时，会将其转换为字符串，以’\0’结束，并调用const char *参数版本的字面量函数<br>
3、若字面量为浮点型，参数只能为unsigned double 和const char *，当unsigned double过长时，也会调用const char <em>版本<br>
4、若字面量为字符型，参数只能为一个char<br>
5、若字面量为字符串，参数只能为const char</em> (注意是与，传入两个参数)size_t，即长度已知的字符串作为参数<br>
6、operator “” [用户定义字面量后缀]，注意中间必须有空格</p>
<h3 id="mutable-volatile">mutable volatile</h3>
<ul>
<li>mutable 就是使得被mutable修饰的const成员可以被修改(const_cast也可以实现去const)</li>
<li>volatile 表示<strong>直接存取原始内存地址</strong>，就是编译器优化的时候为了提高效率，会把一个变量读取到一个寄存器中，如果在本线程里值没有发生改变，就会直接从寄存器里取出上一次的值，如果在别的线程里被改变，编译器是识别不出来的，所以就会使用一个与实际不一样的值，这是很致命的。</li>
</ul>
<h3 id="explicit">explicit</h3>
<ul>
<li><strong>explicit</strong> 是禁用隐式转换</li>
</ul>
<h3 id="std-invoke">std::invoke</h3>
<ul>
<li>std::invoke 是 C++17标准库中引入的一个函数模板，它的引入就是为了解决这个问题，它提供了一种统一的调用语法，无论是调用普通函数、函数指针、类成员函数指针、仿函数、std::function、类成员还是lambda表达式，都可以使用相同的方式进行调用。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">member_function</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Member function called with argument: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">free_function</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Free function called with argument: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Foo foo;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用成员函数</span></span><br><span class="line">    std::<span class="built_in">invoke</span>(&amp;Foo::member_function, foo, <span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用自由函数</span></span><br><span class="line">    std::<span class="built_in">invoke</span>(free_function, <span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>invoke 只是调用可调用函数 而不是封装</li>
</ul>
<h4 id="invoke-和function-的区别">invoke 和function 的区别</h4>
<p>std::invoke 与 std::function 是 C++ 标准库中不同的概念，它们有不同的作用和用途：</p>
<ul>
<li>
<p>std::invoke：</p>
<p>是一个模板函数，用于调用可调用对象（函数指针、成员函数指针、仿函数等）。<br>
它是一个通用的工具函数，用于在运行时动态调用不同类型的可调用对象。<br>
不会持有可调用对象，只是调用它并返回结果。<br>
在使用时需要指定要调用的可调用对象的类型，例如成员函数指针需要使用 &amp;ClassName::member_function 的形式。</p>
</li>
<li>
<p>std::function：</p>
<p>是一个模板类，用于封装可调用对象，使其表现得像一个函数。<br>
它可以持有任何可调用对象，包括函数指针、成员函数指针、函数对象、Lambda 表达式等。<br>
提供了一种统一的接口来处理不同类型的可调用对象。<br>
可以在运行时动态改变持有的可调用对象。<br>
总的来说，std::invoke 用于调用可调用对象，而 std::function 用于封装和管理可调用对象。它们的主要区别在于功能和使用方式。</p>
</li>
</ul>
<h3 id="stl容器里emplace-back和push-back的区别，emplace-back是不是能完美替代push-back">stl容器里emplace_back和push_back的区别，emplace_back是不是能完美替代push_back</h3>
<ul>
<li>当加入一个已经存在的值的时候两个是一样的</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddItem</span><span class="params">(<span class="type">const</span> Item&amp; item)</span></span>&#123;</span><br><span class="line">vector&lt;Item&gt; vec1;</span><br><span class="line">vec<span class="number">1.</span><span class="built_in">push_back</span>(item); <span class="comment">//Item(const Item &amp;)</span></span><br><span class="line"></span><br><span class="line">vector&lt;Item&gt; vec2;</span><br><span class="line">vec<span class="number">2.</span><span class="built_in">emplace_back</span>(item);<span class="comment">//Item(const Item &amp;)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>当移动一个已经存在的对象的时候也是一样的</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Item <span class="title">item1</span><span class="params">(<span class="number">1</span>, <span class="string">&quot;car1&quot;</span>)</span></span>;</span><br><span class="line">vector&lt;Item&gt; vec1, vec2;</span><br><span class="line">vec<span class="number">1.</span><span class="built_in">push_back</span>(std::<span class="built_in">move</span>(item1));<span class="comment">// Item(Item &amp;&amp;)</span></span><br><span class="line"></span><br><span class="line"><span class="function">Item <span class="title">item2</span><span class="params">(<span class="number">2</span>, <span class="string">&quot;car2&quot;</span>)</span></span>;</span><br><span class="line">vec<span class="number">2.</span><span class="built_in">emplace_back</span>(std::<span class="built_in">move</span>(item2));<span class="comment">// Item(Item &amp;&amp;)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>当创建并加入的时候也是一样的</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Item <span class="title">item1</span><span class="params">(<span class="number">1</span>, <span class="string">&quot;car1&quot;</span>)</span></span>;          <span class="comment">// Item(int , string)</span></span><br><span class="line">vector&lt;Item&gt; vec1, vec2;        <span class="comment">// Item(Item &amp;&amp;)</span></span><br><span class="line">vec<span class="number">1.</span><span class="built_in">push_back</span>(<span class="built_in">Item</span>(<span class="number">1</span>, <span class="string">&quot;car1&quot;</span>));<span class="comment">// ~Item()</span></span><br><span class="line"></span><br><span class="line">                                    <span class="comment">// Item(int , string)</span></span><br><span class="line"><span class="function">Item <span class="title">item2</span><span class="params">(<span class="number">2</span>, <span class="string">&quot;car2&quot;</span>)</span></span>;              <span class="comment">// Item(Item &amp;&amp;)</span></span><br><span class="line">vec<span class="number">2.</span><span class="built_in">emplace_back</span>(<span class="built_in">Item</span>(<span class="number">1</span>, <span class="string">&quot;car1&quot;</span>)); <span class="comment">// ~Item()</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>直接构造一个匿名对象的时候 emplace_back效率更高，因为它是直接在vector容器的尾部执行构造函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">                            <span class="comment">// Item(int , string)</span></span><br><span class="line">vector&lt;Item&gt; vec1, vec2;    <span class="comment">// Item(Item &amp;&amp;)</span></span><br><span class="line">vec<span class="number">1.</span><span class="built_in">push_back</span>(&#123;<span class="number">1</span>, <span class="string">&quot;car1&quot;</span>&#125;);<span class="comment">// ~Item()</span></span><br><span class="line"></span><br><span class="line">vec<span class="number">2.</span><span class="built_in">emplace_back</span>(<span class="number">1</span>, <span class="string">&quot;car1&quot;</span>);<span class="comment">// Item(int, string)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/面试笔记/image-30.png" alt="示例图片" style="zoom:100%;" />
<ul>
<li>这样笔误可能会让你找不出错误</li>
</ul>
<h3 id="如果使用std-move-t-来构造一个对象，但是该类没有显式提供移动构造函数，那么它是使用的式默认移动构造函数已经定义的拷贝构造">如果使用std::move(t)来构造一个对象，但是该类没有显式提供移动构造函数，那么它是使用的式默认移动构造函数已经定义的拷贝构造</h3>
<ul>
<li>他会调用已经定义的拷贝构造，而不是默认的移动构造</li>
</ul>
<h3 id="在模板中使用-typedef的时候的注意事项">在模板中使用 typedef的时候的注意事项</h3>
<ul>
<li>typedef typename：</li>
</ul>
<p>在模板中，typename 关键字用于指示其后的标识符是一个类型名字（type name）而不是变量名或者其他东西。这在模板的实例化过程中是非常重要的，因为编译器需要知道该标识符代表的是类型还是变量等。<br>
通常情况下，当模板中使用了<strong>依赖于模板参数</strong>的类型名字时，需要在前面加上 typename 关键字，以告诉编译器这是一个类型。</p>
<ul>
<li>typedef：</li>
</ul>
<p>typedef 关键字用于给一个类型定义一个别名，可以为已有的类型或者复杂的类型表达式定义一个简单的别名。<br>
在模板中，typedef 用于给类型起一个别名，可以方便后续使用，但没有 typename 关键字那样特别用于模板的语法。<br>
综上所述，typedef typename 用于模板中，指示其后的标识符是一个类型名字；而 typedef 则用于给类型定义别名，无论在模板中还是非模板中都可以使用。</p>
<ul>
<li>
<p>什么叫做<strong>依赖于模板参数呢？</strong></p>
</li>
<li>
<p><strong>就是你定义的时候用到了模板嵌套类或者是你上一次typedef的的别名，如下</strong></p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;Key, Value&gt; bucket_value;</span><br><span class="line"><span class="keyword">typedef</span> std::list&lt;bucket_value&gt; bucket_data;</span><br><span class="line"><span class="comment">// 在模板中指定类型的时候要加typename</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> bucket_data::iterator bucket_iterator;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>typedef typename bucket_data::iterator bucket_iterator;：在这里，bucket_iterator 是由 bucket_data 类型的迭代器类型决定的，而 bucket_data 是依赖于模板参数的，因此需要加上 typename。</p>
</li>
<li>
<p>又如下：</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value, <span class="keyword">typename</span> Hash = std::hash&lt;Key&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> threadsafe_lockup_table &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">class</span> bucket_type &#123;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">typename</span> bucket_type::bucket_iterator it = buckets[i]-&gt;data.<span class="built_in">begin</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>这用到了嵌套类 所以得用typename</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>C++面试笔记</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://pigcanstudy.github.io/posts/2f7ff9a3.html">https://pigcanstudy.github.io/posts/2f7ff9a3.html</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>PigCanStudy</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2024-07-18</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2024-07-18</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/"><div class="tags-punctuation"><svg class="faa-tada icon" style="height:1.1em;width:1.1em;fill:currentColor;position:relative;top:2px;margin-right:3px" aria-hidden="true"><use xlink:href="#icon-sekuaibiaoqian"></use></svg></div>C++</a><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/"><div class="tags-punctuation"><svg class="faa-tada icon" style="height:1.1em;width:1.1em;fill:currentColor;position:relative;top:2px;margin-right:3px" aria-hidden="true"><use xlink:href="#icon-sekuaibiaoqian"></use></svg></div>面试笔记</a></div></div><link rel="stylesheet" href="/css/coin.css" media="defer" onload="this.media='all'"/><div class="post-reward"><button class="tip-button reward-button"><span class="tip-button__text">投喂作者</span><div class="coin-wrapper"><div class="coin"><div class="coin__middle"></div><div class="coin__back"></div><div class="coin__front"></div></div></div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://tuchuang.voooe.cn/images/2023/01/04/2.webp" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://tuchuang.voooe.cn/images/2023/01/04/2.webp" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://tuchuang.voooe.cn/images/2023/01/04/20f8e49805975b8f8.webp" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://tuchuang.voooe.cn/images/2023/01/04/20f8e49805975b8f8.webp" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></button></div><audio id="coinAudio" src="https://npm.elemecdn.com/akilar-candyassets@1.0.36/audio/aowu.m4a"></audio><script defer="defer" src="/js/coin.js"></script><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/6e928d8a.html"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_14.webp" onerror="onerror=null;src='/assets/r2.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">C++Qt</div></div></a></div><div class="next-post pull-right"><a href="/posts/e8e79e61.html"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_14.webp" onerror="onerror=null;src='/assets/r2.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">C++并发编程</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/6e928d8a.html" title="C++Qt"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_14.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-07-18</div><div class="title">C++Qt</div></div></a></div><div><a href="/posts/e8e79e61.html" title="C++并发编程"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_14.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-07-18</div><div class="title">C++并发编程</div></div></a></div><div><a href="/posts/9724705.html" title="C++asio网络编程"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_14.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-07-18</div><div class="title">C++asio网络编程</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><svg class="meta_icon" style="width:22px;height:22px;position:relative;top:5px"><use xlink:href="#icon-mulu1"></use></svg><span style="font-weight:bold">目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">目录</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#new-delete-free-malloc-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">new delete free malloc 的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8D%E7%94%9F%E9%97%AE%E9%A2%98"><span class="toc-text">衍生问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#malloc%E6%98%AF%E6%80%8E%E4%B9%88%E5%88%86%E9%85%8D%E7%A9%BA%E9%97%B4%E7%9A%84"><span class="toc-text">malloc是怎么分配空间的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#malloc%E5%88%86%E9%85%8D%E7%9A%84%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E8%BF%98%E6%98%AF%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98"><span class="toc-text">malloc分配的虚拟内存还是物理内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#malloc%E5%88%86%E9%85%8D%E5%90%8E%E6%98%AF%E5%90%A6%E7%AB%8B%E5%8D%B3%E5%BE%97%E5%88%B0%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98"><span class="toc-text">malloc分配后是否立即得到物理内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#free%C2%A7%E6%98%AF%E6%80%8E%E4%B9%88%E5%BE%97%E5%88%B0p%E8%BF%99%E4%B8%AA%E7%A9%BA%E9%97%B4%E6%9C%89%E5%A4%9A%E5%A4%A7%E7%9A%84"><span class="toc-text">free§是怎么得到p这个空间有多大的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#free%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98%E5%90%8E%EF%BC%8C%E5%86%85%E5%AD%98%E8%BF%98%E5%9C%A8%E5%90%97"><span class="toc-text">free释放内存后，内存还在吗</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%9B%B4%E6%8E%A5%E5%85%A8%E7%94%A8mmp-%E6%9D%A5%E5%88%86%E9%85%8D%EF%BC%8C%E8%80%8C%E9%9C%80%E8%A6%81%E5%88%86%E6%83%85%E5%86%B5%E4%BD%BF%E7%94%A8brk-%E5%91%A2"><span class="toc-text">为什么不直接全用mmp()来分配，而需要分情况使用brk()呢</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#new%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-text">new的执行过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#delete%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-text">delete的执行过程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E4%B8%8E%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E6%8C%87%E9%92%88%E7%9A%84%E5%88%9B%E5%BB%BA%E6%97%B6%E6%9C%BA"><span class="toc-text">虚函数表与虚函数表指针的创建时机</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E6%8C%87%E9%92%88%E5%88%9B%E5%BB%BA%E7%9A%84%E6%97%B6%E6%9C%BA"><span class="toc-text">虚函数表指针创建的时机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E5%92%8C%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E6%8C%87%E9%92%88%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">虚函数表和虚函数表指针的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8D%E7%94%9F%E9%97%AE%E9%A2%98-2"><span class="toc-text">衍生问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-text">多态的内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-text">c++内存模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%8F%98%E4%B8%BA%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-text">程序变为可执行文件的过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%BA%93%E4%B8%8E%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">静态库与动态库的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ELF%E6%96%87%E4%BB%B6%E6%A8%A1%E5%9E%8B"><span class="toc-text">ELF文件模型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%9F%E6%88%90%E9%BB%98%E8%AE%A4%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">C++什么时候生成默认拷贝构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%A7%A6%E5%8F%91%E9%BB%98%E8%AE%A4%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">什么时候触发默认拷贝构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%9F%E6%88%90%E9%BB%98%E8%AE%A4%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">什么时候生成默认拷贝构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8D%E7%94%9F%E9%97%AE%E9%A2%98-3"><span class="toc-text">衍生问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E7%BB%86%E8%8A%82"><span class="toc-text">函数返回值的细节</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81%E4%BB%A5%E5%8F%8A%E7%89%B9%E6%80%A7"><span class="toc-text">面向对象的三大特征以及特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8D%E7%94%9F%E9%97%AE%E9%A2%98-4"><span class="toc-text">衍生问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86"><span class="toc-text">继承相关知识</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%9F"><span class="toc-text">什么是纯虚函数？什么是抽象类？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF"><span class="toc-text">接口继承与实现继承</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%82%A3%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E7%9B%B8%E6%AF%94%E4%BA%8E%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84%E5%90%97"><span class="toc-text">那接口继承相比于实现继承有什么好处吗</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%AF%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%8E%A5%E5%8F%A3%E7%B1%BB"><span class="toc-text">纯接口继承与接口类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E6%97%B6%E5%80%99%E4%B8%8D%E8%A6%81%E8%A6%86%E7%9B%96%E9%9D%9E%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-text">继承的时候不要覆盖非虚函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%84%E5%90%88"><span class="toc-text">组合</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF"><span class="toc-text">什么是菱形继承</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86"><span class="toc-text">线程池相关知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">什么线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">为什么要用线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">怎么用线程池</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">进程和线程的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8D%E7%94%9F%E9%97%AE%E9%A2%98-5"><span class="toc-text">衍生问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">进程切换与线程切换的区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%95%B4%E4%B8%AA%E6%B5%81%E7%A8%8B"><span class="toc-text">描述系统调用整个流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8D%E7%94%9F%E9%97%AE%E9%A2%98-6"><span class="toc-text">衍生问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%98%AF%E5%90%A6%E4%BC%9A%E5%BC%95%E8%B5%B7%E7%BA%BF%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2"><span class="toc-text">系统调用是否会引起线程&#x2F;进程切换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%80%81%E5%88%87%E6%8D%A2%E5%86%85%E6%A0%B8%E6%80%81-%E5%88%87%E6%8D%A2%E5%A0%86%E6%A0%88-%E5%85%B7%E4%BD%93%E6%98%AF%E5%95%A5%EF%BC%9F"><span class="toc-text">用户态切换内核态(切换堆栈)具体是啥？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#task-struct%E7%9A%84%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86"><span class="toc-text">task_struct的组成部分</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">页面置换算法有哪些</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tcp%E5%92%8Cudp%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">tcp和udp的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8D%E7%94%9F%E9%97%AE%E9%A2%98-7"><span class="toc-text">衍生问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E7%9A%84MSS%E5%92%8CIP%E7%9A%84MTU%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">TCP的MSS和IP的MTU分别是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A2%E7%84%B6%E5%86%8DIP%E5%B1%82%E5%B0%B1%E4%BC%9A%E5%88%86%E7%89%87%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E5%86%8DTCP%E9%82%A3%E8%BF%9B%E8%A1%8C%E5%88%86%E6%AE%B5%EF%BC%8CMSS"><span class="toc-text">既然再IP层就会分片，为什么还要再TCP那进行分段，MSS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%9A%84%EF%BC%9F"><span class="toc-text">TCP是如何保证可靠性的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-text">为什么需要三次握手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-text">为什么需要四次挥手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%9A%84%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E7%AD%89%E5%BE%852%E4%B8%AAMSL%E6%97%B6%E9%97%B4"><span class="toc-text">为什么在四次挥手的时候需要等待2个MSL时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFSYN%E6%94%BB%E5%87%BB%EF%BC%9F"><span class="toc-text">什么是SYN攻击？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%94%AF%E4%B8%80%E7%A1%AE%E5%AE%9A%E4%B8%80%E4%B8%AATCP%E8%BF%9E%E6%8E%A5%E5%91%A2%EF%BC%9F"><span class="toc-text">如何唯一确定一个TCP连接呢？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B0%B4%E5%B9%B3%E8%A7%A6%E5%8F%91%E4%B8%8E%E8%BE%B9%E7%BC%98%E8%A7%A6%E5%8F%91%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">水平触发与边缘触发的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%8A%E6%89%93%E5%BC%80%E5%8D%8A%E5%85%B3%E9%97%AD%E7%8A%B6%E6%80%81"><span class="toc-text">什么是半打开半关闭状态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%8D%8A%E6%89%93%E5%BC%80%E7%8A%B6%E6%80%81"><span class="toc-text">如何处理半打开状态</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E6%96%87%E4%BB%B6%E6%97%B6%E8%BF%9B%E7%A8%8B%E5%AE%95%E6%9C%BA%EF%BC%8C%E6%95%B0%E6%8D%AE%E4%BC%9A%E4%B8%A2%E5%A4%B1%E5%90%97%EF%BC%9F"><span class="toc-text">写文件时进程宕机，数据会丢失吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86"><span class="toc-text">文件相关知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E7%9B%B4%E6%8E%A5%E6%96%87%E4%BB%B6IO%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98%E6%96%87%E4%BB%B6IO"><span class="toc-text">什么使用直接文件IO，什么时候使用缓存文件IO</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E5%92%8C%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%8C%BA%E5%88%AB"><span class="toc-text">左值引用和右值引用区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8D%E7%94%9F%E9%97%AE%E9%A2%98-8"><span class="toc-text">衍生问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B7%A6%E5%80%BC%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%B3%E5%80%BC"><span class="toc-text">什么是左值，什么是右值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E7%9A%84%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F"><span class="toc-text">右值引用的移动语义是什么意思？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91"><span class="toc-text">什么是完美转发</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%82%A3%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%87%E8%83%BD%E5%BC%95%E7%94%A8%E5%91%A2%EF%BC%9F"><span class="toc-text">那什么是万能引用呢？</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%A7%8D%E7%B1%BB%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">智能指针种类以及使用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E5%AE%83%E8%A7%A3%E5%86%B3%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-text">什么设计模式，它解决的是什么问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86"><span class="toc-text">相关知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%80%E5%85%B1%E6%9C%89%E5%93%AA%E5%87%A0%E5%A4%A7%E7%B1%BB%EF%BC%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">设计模式一共有哪几大类，设计模式的六大原则是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-text">单例模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%95%E4%BE%8B%EF%BC%8C%E5%AE%83%E5%8F%AF%E4%BB%A5%E5%9C%A8%E5%93%AA%E4%BA%9B%E5%9C%B0%E6%96%B9%E7%94%A8%E5%88%B0%E4%BA%86"><span class="toc-text">什么是单例，它可以在哪些地方用到了</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">单例的优缺点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="toc-text">单例创建方式</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%A5%BF%E6%B1%89%E5%BC%8F"><span class="toc-text">饿汉式</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%87%92%E6%B1%89%E5%BC%8F"><span class="toc-text">懒汉式</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E6%96%B9%E5%BC%8F"><span class="toc-text">静态内部方式</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="toc-text">如何选择单例模式的创建方式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-text">工厂模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-text">简单工厂模式</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">简单工厂模式的优缺点</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="toc-text">工厂方法模式</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">工厂方法模式的优缺点</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-text">抽象工厂模式</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">抽象工厂模式的优缺点</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">抽象工厂模式和工厂方法模式的区别</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F"><span class="toc-text">策略模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="toc-text">应用案例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-text">观察者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-text">解决了什么问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90"><span class="toc-text">例子</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84"><span class="toc-text">代码结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E6%89%A9%E5%B1%95%E4%BB%A3%E7%A0%81"><span class="toc-text">如果扩展代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E7%9A%84%E6%A1%88%E4%BE%8B"><span class="toc-text">应用的案例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">优缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F"><span class="toc-text">责任链模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98-2"><span class="toc-text">解决了什么问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-2"><span class="toc-text">例子</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84-2"><span class="toc-text">代码结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%89%A9%E5%B1%95"><span class="toc-text">代码扩展</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B-2"><span class="toc-text">应用案例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-text">装饰器模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-2"><span class="toc-text">优缺点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%89%A9%E5%B1%95-2"><span class="toc-text">代码扩展</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#B%E6%A0%91%E4%B8%8EB-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">B树与B+树与二叉搜索树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80"><span class="toc-text">语法基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8E%E6%8C%87%E9%92%88-%E6%82%AC%E7%A9%BA%E6%8C%87%E9%92%88-%E7%A9%BA%E6%8C%87%E9%92%88"><span class="toc-text">野指针 悬空指针 空指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#union%E7%9A%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86"><span class="toc-text">union的相关知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86"><span class="toc-text">指针相关知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E6%9C%BA%E5%88%B6"><span class="toc-text">C++ 内存对齐机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#std-string"><span class="toc-text">std::string</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const-int-ptr-int-const-ptr%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">const int * ptr, int * const ptr的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFstd-ref%EF%BC%9F"><span class="toc-text">什么是std::ref？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#std-ref-%E5%92%8C%E4%B8%8D%E5%90%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">std::ref 和不同引用的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#decltype-std-declval-std-decay-t-%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">decltype, std::declval, std::decay_t 分别是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#decltype"><span class="toc-text">decltype</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#std-declval"><span class="toc-text">std::declval</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#std-decay-t"><span class="toc-text">std::decay_t</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const-%E4%B8%8E-constexpr"><span class="toc-text">const 与 constexpr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#noexcept"><span class="toc-text">noexcept</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-text">用户自定义字面量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mutable-volatile"><span class="toc-text">mutable volatile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#explicit"><span class="toc-text">explicit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#std-invoke"><span class="toc-text">std::invoke</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#invoke-%E5%92%8Cfunction-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">invoke 和function 的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stl%E5%AE%B9%E5%99%A8%E9%87%8Cemplace-back%E5%92%8Cpush-back%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8Cemplace-back%E6%98%AF%E4%B8%8D%E6%98%AF%E8%83%BD%E5%AE%8C%E7%BE%8E%E6%9B%BF%E4%BB%A3push-back"><span class="toc-text">stl容器里emplace_back和push_back的区别，emplace_back是不是能完美替代push_back</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E4%BD%BF%E7%94%A8std-move-t-%E6%9D%A5%E6%9E%84%E9%80%A0%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%EF%BC%8C%E4%BD%86%E6%98%AF%E8%AF%A5%E7%B1%BB%E6%B2%A1%E6%9C%89%E6%98%BE%E5%BC%8F%E6%8F%90%E4%BE%9B%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%8C%E9%82%A3%E4%B9%88%E5%AE%83%E6%98%AF%E4%BD%BF%E7%94%A8%E7%9A%84%E5%BC%8F%E9%BB%98%E8%AE%A4%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%B7%B2%E7%BB%8F%E5%AE%9A%E4%B9%89%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0"><span class="toc-text">如果使用std::move(t)来构造一个对象，但是该类没有显式提供移动构造函数，那么它是使用的式默认移动构造函数已经定义的拷贝构造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E6%A8%A1%E6%9D%BF%E4%B8%AD%E4%BD%BF%E7%94%A8-typedef%E7%9A%84%E6%97%B6%E5%80%99%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">在模板中使用 typedef的时候的注意事项</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-color: transparent;"><div id="footer-wrap"><div id="ft"><div class="ft-item-1"><div class="t-top"><div class="t-t-l"><p class="ft-t t-l-t">格言🧬</p><div class="bg-ad"><div>再看看那个光点，它就在这里，这是家园，这是我们 —— 你所爱的每一个人，你认识的一个人，你听说过的每一个人，曾经有过的每一个人，都在它上面度过他们的一生✨</div><div class="btn-xz-box"><a class="btn-xz" target="_blank" rel="noopener" href="https://stellarium.org/">点击开启星辰之旅</a></div></div></div><div class="t-t-r"><p class="ft-t t-l-t">猜你想看💡</p><ul class="ft-links"><li><a href="/posts/eec9786.html">魔改指南</a><a href="/box/nav/">网址导航</a></li><li><a href="/social/link/">我的朋友</a><a href="/comments/">留点什么</a></li><li><a href="/personal/about/">关于作者</a><a href="/archives/">文章归档</a></li><li><a href="/categories/">文章分类</a><a href="/tags/">文章标签</a></li><li><a href="/box/Gallery/">我的画廊</a><a href="/personal/bb/">我的唠叨</a></li><li><a href="/site/time/">建设进程</a><a href="/site/census/">网站统计</a></li></ul></div></div></div><div class="ft-item-2"><p class="ft-t">推荐友链⌛</p><div class="ft-img-group"><div class="img-group-item"><a target="_blank" rel="noopener" href="https://www.fomal.cc/" title="Fomalhaut🥝"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/60e5d4e39da7c077.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div></div></div></div><div class="copyright"><span><b>&copy;2022-2024</b></span><span><b>&nbsp;&nbsp;By PigCanStudy</b></span></div><div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" title="博客框架为Hexo_v6.3.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Frame-Hexo-blue.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" title="主题版本Butterfly_v4.3.1"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Theme-Butterfly-6513df.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" title="本站采用多线部署，主线路托管于Vercel"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Hosted-Vercel-brightgreen.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://user.51.la/" style="margin-inline:5px" title="本站数据分析得益于51la技术支持"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Analytics-51la-3db1eb.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://icp.gov.moe/?keyword=20226665" style="margin-inline:5px" title="本站已加入萌ICP豪华套餐，萌ICP备20226665号"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/萌ICP备-20226665-fe1384.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://bitiful.dogecast.com/buckets" style="margin-inline:5px" title="本网站经Service Worker分流至缤纷云对象存储"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src=" https://sourcebucket.s3.ladydaily.com/badge/Bucket-缤纷云-9c62da.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://www.netdun.net/" style="margin-inline:5px" title="本站使用网盾星球提供CDN加速与防护"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/CDN-网盾星球-fff2cc.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" title="本网站源码由Github提供存储仓库"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src=" https://sourcebucket.s3.ladydaily.com/badge/Source-Github-d021d6.svg" alt=""/></a></p></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button class="share" type="button" title="右键模式" onclick="changeMouseMode()"><i class="fas fa-mouse"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog right_side"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button class="share" type="button" title="分享链接" onclick="share()"><i class="fas fa-share-nodes"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i><span id="percent">0<span>%</span></span></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();"><i class="fa fa-copy"></i><span>复制</span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.baidu.com/s?wd=&quot;+window.getSelection().toString());window.location.reload();"><i class="fa fa-search"></i><span>百度搜索</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();"><i class="fa fa-link"></i><span>转到链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()"><i class="fa fa-copy"></i><span>粘贴</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-post"><a class="rightMenu-item" href="#post-comment"><i class="fas fa-comment"></i><span>空降评论</span></a><a class="rightMenu-item" href="javascript:rmf.copyWordsLink()"><i class="fa fa-link"></i><span>复制本文地址</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>新窗口打开</span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()"><i class="fa fa-link"></i><span>转到链接</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()"><i class="fa fa-download"></i><span>保存图片</span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>在新窗口打开</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制图片链接</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:randomPost()"><i class="fa fa-paper-plane"></i><span>随便逛逛</span></a><a class="rightMenu-item" href="javascript:switchNightMode();"><i class="fa fa-moon"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="/personal/about/"><i class="fa fa-info-circle"></i><span>关于博客</span></a><a class="rightMenu-item" href="javascript:toggleWinbox();"><i class="fas fa-cog"></i><span>美化设置</span></a><a class="rightMenu-item" href="javascript:rmf.fullScreen();"><i class="fas fa-expand"></i><span>切换全屏</span></a><a class="rightMenu-item" href="javascript:window.print();"><i class="fa-solid fa-print"></i><span>打印页面</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.umd.min.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/instant.page/5.1.0/instantpage.min.js" type="module"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/vanilla-lazyload/17.3.1/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><script async="async">var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())
setTimeout(function(){preloader.endLoading();}, 5000);
document.getElementById('loading-box').addEventListener('click',()=> {preloader.endLoading()})</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: '',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: '',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.staticfile.org/twikoo/1.6.8/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script src="https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js"></script><script async src="https://cdn1.tianli0.top/npm/vue@2.6.14/dist/vue.min.js"></script><script async src="https://cdn1.tianli0.top/npm/element-ui@2.15.6/lib/index.js"></script><script async src="https://cdn.bootcdn.net/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script><script defer type="text/javascript" src="https://cdn1.tianli0.top/npm/sweetalert2@8.19.0/dist/sweetalert2.all.js"></script><script async src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><script defer src="https://cdn1.tianli0.top/gh/nextapps-de/winbox/dist/winbox.bundle.min.js"></script><script async src="//at.alicdn.com/t/c/font_3586335_hsivh70x0fm.js"></script><script async src="//at.alicdn.com/t/c/font_3636804_gr02jmjr3y9.js"></script><script async src="//at.alicdn.com/t/c/font_3612150_kfv55xn3u2g.js"></script><script async src="https://cdn.wpon.cn/2022-sucai/Gold-ingot.js"></script><canvas id="universe"></canvas><canvas id="snow"></canvas><script defer src="/js/fomal.js"></script><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.js"></script><script src="https://cdn1.tianli0.top/npm/js-heo@1.0.12/metingjs/Meting.min.js"></script><script src="https://lib.baomitu.com/pjax/0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show","#web_bg",".js-pjax","#bibi","body > title","#app","#tag-echarts","#posts-echart","#categories-echarts"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><a class="magnet_link_more"  href="https://pigcanstudy.github.io/categories/" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(33.333333333333336% - 5px);background: #e9e9e9;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: var(--text-bg-hover)}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/9724705.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-07-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/9724705.html&quot;);" href="javascript:void(0);" alt="">C++asio网络编程</a><div class="blog-slider__text">本文介绍了C++运用asio进行网络编程的相关知识</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/9724705.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/e8e79e61.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-07-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/e8e79e61.html&quot;);" href="javascript:void(0);" alt="">C++并发编程</a><div class="blog-slider__text">本文介绍了C++并发编程的相关知识</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/e8e79e61.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/95787e92.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-07-16</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/95787e92.html&quot;);" href="javascript:void(0);" alt="">网络编程教程</a><div class="blog-slider__text">🥧本文介绍了linux基础的系统编程和基础的Linux网络编程</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/95787e92.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/2f7ff9a3.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-07-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/2f7ff9a3.html&quot;);" href="javascript:void(0);" alt="">C++面试笔记</a><div class="blog-slider__text">本文介绍了C++面试笔记的相关知识</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/2f7ff9a3.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/6e928d8a.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-07-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/6e928d8a.html&quot;);" href="javascript:void(0);" alt="">C++Qt</a><div class="blog-slider__text">本文介绍了C++Qt的相关知识</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/6e928d8a.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><script data-pjax src="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.js"></script><script data-pjax>
  function gitcalendar_injector_config(){
      var parent_div_git = document.getElementById('gitZone');
      var item_html = '<div class="recent-post-item" id="gitcalendarBar" style="width:100%;height:auto;padding:10px;"><style>#git_container{min-height: 320px}@media screen and (max-width:650px) {#git_container{min-height: 0px}}</style><div id="git_loading" style="width:10%;height:100%;margin:0 auto;display: block;"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animatetransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animatetransform></path></svg><style>#git_container{display: none;}</style></div><div id="git_container"></div></div>';
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      console.log('已挂载gitcalendar')
      }

    if( document.getElementById('gitZone') && (location.pathname ==='/site/census/'|| '/site/census/' ==='all')){
        gitcalendar_injector_config()
        GitCalendarInit("/api?null",['#d9e0df', '#c6e0dc', '#a8dcd4', '#9adcd2', '#89ded1', '#77e0d0', '#5fdecb', '#47dcc6', '#39dcc3', '#1fdabe', '#00dab9'],'null')
    }
  </script><!-- hexo injector body_end end --></body></html>