<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><div id="myscoll"></div><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Mit6.824学习笔记 | PigCanStudy</title><meta name="keywords" content="分布式,MIT6.824"><meta name="author" content="PigCanStudy"><meta name="copyright" content="PigCanStudy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="本文描述的是Mit6.824课程的笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="Mit6.824学习笔记">
<meta property="og:url" content="https://pigcanstudy.github.io/posts/abaf39bf.html">
<meta property="og:site_name" content="PigCanStudy">
<meta property="og:description" content="本文描述的是Mit6.824课程的笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://source.fomal.cc/img/default_cover_14.webp">
<meta property="article:published_time" content="2024-11-29T09:26:24.000Z">
<meta property="article:modified_time" content="2024-11-29T10:47:30.940Z">
<meta property="article:author" content="PigCanStudy">
<meta property="article:tag" content="分布式">
<meta property="article:tag" content="MIT6.824">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://source.fomal.cc/img/default_cover_14.webp"><link rel="shortcut icon" href="/"><link rel="canonical" href="https://pigcanstudy.github.io/posts/abaf39bf"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/6.0.0/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.js',
      css: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Mit6.824学习笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-11-29 18:47:30'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/element-ui@2.15.6/packages/theme-chalk/lib/index.css"><style id="themeColor"></style><style id="rightSide"></style><style id="transPercent"></style><style id="blurNum"></style><style id="settingStyle"></style><span id="fps"></span><style id="defineBg"></style><style id="menu_shadow"></style><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="PigCanStudy" type="application/atom+xml">
</head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://tuchuang.voooe.cn/images/2023/01/02/avatar.webp" onerror="onerror=null;src='/assets/r1.jpg'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-home"></use></svg><span class="menu_word" style="font-size:17px"> 首页</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--article"></use></svg><span class="menu_word" style="font-size:17px"> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-guidang1">                   </use></svg><span class="menu_word" style="font-size:17px"> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-sekuaibiaoqian">                   </use></svg><span class="menu_word" style="font-size:17px"> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-fenlei">                   </use></svg><span class="menu_word" style="font-size:17px"> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pinweishenghuo"></use></svg><span class="menu_word" style="font-size:17px"> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/life/music/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-yinle">                   </use></svg><span class="menu_word" style="font-size:17px"> 八音盒</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/movies/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-dianying1">                   </use></svg><span class="menu_word" style="font-size:17px"> 影院</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/games/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-youxishoubing">                   </use></svg><span class="menu_word" style="font-size:17px"> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xiangzi"></use></svg><span class="menu_word" style="font-size:17px"> 八宝箱</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/box/gallery/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-tubiaozhizuomoban">                   </use></svg><span class="menu_word" style="font-size:17px"> 画廊</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/animation/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-nvwumao">                   </use></svg><span class="menu_word" style="font-size:17px"> 动画</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/nav/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-zhifengche">                   </use></svg><span class="menu_word" style="font-size:17px"> 网址导航</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shejiaoxinxi"></use></svg><span class="menu_word" style="font-size:17px"> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/social/fcircle/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pengyouquan">                   </use></svg><span class="menu_word" style="font-size:17px"> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-liuyan">                   </use></svg><span class="menu_word" style="font-size:17px"> 留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/social/link/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-lianjie">                   </use></svg><span class="menu_word" style="font-size:17px"> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-wangye"></use></svg><span class="menu_word" style="font-size:17px"> 网站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/site/census/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--tongjibiao">                   </use></svg><span class="menu_word" style="font-size:17px"> 网站统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/echarts/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shujutongji1">                   </use></svg><span class="menu_word" style="font-size:17px"> 文章统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/time/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xianxingshalou">                   </use></svg><span class="menu_word" style="font-size:17px"> 旧时光</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-maoliang"></use></svg><span class="menu_word" style="font-size:17px"> 个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/personal/bb/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-qunliaotian">                   </use></svg><span class="menu_word" style="font-size:17px"> 唠叨</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/love/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-love-sign">                   </use></svg><span class="menu_word" style="font-size:17px"> 恋爱小屋</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/about/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-paperplane">                   </use></svg><span class="menu_word" style="font-size:17px"> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">PigCanStudy</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-home"></use></svg><span class="menu_word" style="font-size:17px"> 首页</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--article"></use></svg><span class="menu_word" style="font-size:17px"> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-guidang1">                   </use></svg><span class="menu_word" style="font-size:17px"> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-sekuaibiaoqian">                   </use></svg><span class="menu_word" style="font-size:17px"> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-fenlei">                   </use></svg><span class="menu_word" style="font-size:17px"> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pinweishenghuo"></use></svg><span class="menu_word" style="font-size:17px"> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/life/music/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-yinle">                   </use></svg><span class="menu_word" style="font-size:17px"> 八音盒</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/movies/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-dianying1">                   </use></svg><span class="menu_word" style="font-size:17px"> 影院</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/games/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-youxishoubing">                   </use></svg><span class="menu_word" style="font-size:17px"> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xiangzi"></use></svg><span class="menu_word" style="font-size:17px"> 八宝箱</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/box/gallery/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-tubiaozhizuomoban">                   </use></svg><span class="menu_word" style="font-size:17px"> 画廊</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/animation/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-nvwumao">                   </use></svg><span class="menu_word" style="font-size:17px"> 动画</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/nav/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-zhifengche">                   </use></svg><span class="menu_word" style="font-size:17px"> 网址导航</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shejiaoxinxi"></use></svg><span class="menu_word" style="font-size:17px"> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/social/fcircle/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pengyouquan">                   </use></svg><span class="menu_word" style="font-size:17px"> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-liuyan">                   </use></svg><span class="menu_word" style="font-size:17px"> 留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/social/link/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-lianjie">                   </use></svg><span class="menu_word" style="font-size:17px"> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-wangye"></use></svg><span class="menu_word" style="font-size:17px"> 网站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/site/census/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--tongjibiao">                   </use></svg><span class="menu_word" style="font-size:17px"> 网站统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/echarts/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shujutongji1">                   </use></svg><span class="menu_word" style="font-size:17px"> 文章统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/time/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xianxingshalou">                   </use></svg><span class="menu_word" style="font-size:17px"> 旧时光</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-maoliang"></use></svg><span class="menu_word" style="font-size:17px"> 个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/personal/bb/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-qunliaotian">                   </use></svg><span class="menu_word" style="font-size:17px"> 唠叨</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/love/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-love-sign">                   </use></svg><span class="menu_word" style="font-size:17px"> 恋爱小屋</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/about/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-paperplane">                   </use></svg><span class="menu_word" style="font-size:17px"> 关于</span></a></li></ul></div></div><center id="name-container"><a id="page-name" href="javascript:scrollToTop()">PAGE_NAME</a></center><div id="nav-right"><div id="search-button"><a class="search faa-parent animated-hover" title="检索站内任何你想要的信息"><svg class="faa-tada icon" style="height:24px;width:24px;fill:currentColor;position:relative;top:6px" aria-hidden="true"><use xlink:href="#icon-valentine_-search-love-find-heart"></use></svg><span> 搜索</span></a></div><a class="meihua faa-parent animated-hover" onclick="toggleWinbox()" title="美化设置-自定义你的风格" id="meihua-button"><svg class="faa-tada icon" style="height:26px;width:26px;fill:currentColor;position:relative;top:8px" aria-hidden="true"><use xlink:href="#icon-tupian1"></use></svg></a><a class="sun_moon faa-parent animated-hover" onclick="switchNightMode()" title="浅色和深色模式转换" id="nightmode-button"><svg class="faa-tada" style="height:25px;width:25px;fill:currentColor;position:relative;top:7px" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon">       </use></svg></a><div id="toggle-menu"><a><i class="fas fa-bars fa-fw"></i></a></div></div></div></nav><div id="post-info"><h1 class="post-title">Mit6.824学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><svg class="meta_icon post-meta-icon" style="width:30px;height:30px;position:relative;top:10px"><use xlink:href="#icon-rili"></use></svg><span class="post-meta-label">发表于 </span><time class="post-meta-date-created" datetime="2024-11-29T09:26:24.000Z" title="发表于 2024-11-29 17:26:24">2024-11-29</time><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:18px;height:18px;position:relative;top:5px"><use xlink:href="#icon-gengxin1"></use></svg><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-29T10:47:30.940Z" title="更新于 2024-11-29 18:47:30">2024-11-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:18px;height:18px;position:relative;top:5px"><use xlink:href="#icon-biaoqian"></use></svg><a class="post-meta-categories" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><svg class="meta_icon post-meta-icon" style="width:25px;height:25px;position:relative;top:8px"><use xlink:href="#icon-charuword"></use></svg><span class="post-meta-label">字数总计:</span><span class="word-count">2.3w</span><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:20px;height:20px;position:relative;top:5px"><use xlink:href="#icon-shizhong"></use></svg><span class="post-meta-label">阅读时长:</span><span>72分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Mit6.824学习笔记"><svg class="meta_icon post-meta-icon" style="width:25px;height:25px;position:relative;top:5px"><use xlink:href="#icon-eye"></use></svg><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>目录</h1>
<ul>
<li><a href="#%E7%9B%AE%E5%BD%95">目录</a>
<ul>
<li><a href="#mit6824%E8%AF%BE%E7%A8%8B">MIT6.824课程</a>
<ul>
<li><a href="#%E5%88%86%E5%B8%83%E7%B3%BB%E7%BB%9F%E7%AE%80%E8%BF%B0">分布系统简述</a>
<ul>
<li><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%9A%E4%B9%89">分布式系统的定义</a></li>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F">为什么使用分布式系统？</a></li>
<li><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8E%86%E5%8F%B2">分布式系统的历史</a></li>
<li><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%9A%BE%E7%82%B9chalenges">分布式系统的难点（Chalenges）</a></li>
<li><a href="#%E8%AF%BE%E7%A8%8B%E4%BB%8B%E7%BB%8D">课程介绍</a></li>
<li><a href="#%E6%94%AF%E6%8C%81%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84">支持分布式系统的底层基础架构</a></li>
<li><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%B9%E6%80%A7">分布式系统的特性</a></li>
<li><a href="#mapreduce%E6%A6%82%E8%BF%B0">mapreduce概述</a></li>
<li><a href="#mapreduce%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B">mapreduce的执行流程</a></li>
<li><a href="#mapreduce%E7%9A%84%E5%AE%B9%E9%94%99%E6%80%A7">mapreduce的容错性</a></li>
<li><a href="#mapreduce%E5%85%B6%E4%BB%96%E5%BC%82%E5%B8%B8%E5%9C%BA%E6%99%AF">mapreduce其他异常场景</a></li>
<li><a href="#%E7%BB%93%E8%AF%AD">结语</a></li>
</ul>
</li>
<li><a href="#threads%E5%92%8Crpc%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8">Threads和RPC(多线程和远程过程调用)</a>
<ul>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E7%94%A8go%E8%AF%AD%E8%A8%80">为什么选用go语言</a></li>
<li><a href="#go%E7%9A%84%E5%A4%9A%E5%8D%8F%E7%A8%8B%E6%8C%91%E6%88%98">go的多协程挑战</a></li>
<li><a href="#go%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%8C%91%E6%88%98">go如何应对多线程的挑战</a></li>
<li><a href="#go%E7%9A%84%E5%A0%86%E6%A0%88%E5%92%8C%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90">go的堆栈和逃逸分析</a>
<ul>
<li><a href="#%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90">逃逸分析</a></li>
<li><a href="#%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99">逃逸分析的基本原则</a></li>
<li><a href="#%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E4%B8%BE%E4%BE%8B">逃逸分析举例</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E8%B0%B7%E6%AD%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fgfs">谷歌文件系统GFS</a>
<ul>
<li><a href="#%E5%AD%98%E5%82%A8">存储</a>
<ul>
<li><a href="#%E5%AD%98%E5%82%A8%E8%AE%BE%E8%AE%A1%E7%9A%84%E9%9A%BE%E7%82%B9">存储设计的难点</a></li>
<li><a href="#%E4%B8%80%E8%87%B4%E6%80%A7">一致性</a></li>
</ul>
</li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AFgfs">什么是GFS？</a></li>
<li><a href="#gfs%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%8F%96%E6%B5%81%E7%A8%8B">GFS数据读取流程</a></li>
<li><a href="#gfs-master%E7%AE%80%E8%BF%B0">GFS-Master简述</a></li>
<li><a href="#gfs-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96">GFS-文件读取</a></li>
<li><a href="#gfs-%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5">GFS-文件写入</a></li>
</ul>
</li>
<li><a href="#%E4%B8%BB%E5%A4%87%E5%A4%8D%E5%88%B6">主备复制</a>
<ul>
<li><a href="#%E5%A4%B1%E8%B4%A5%E7%9A%84%E5%9C%BA%E6%99%AF">失败的场景</a></li>
<li><a href="#%E4%B8%BB%E5%A4%87%E5%A4%8D%E5%88%B6%E7%9A%84%E5%AE%9E%E7%8E%B0%E9%9A%BE%E7%82%B9">主备复制的实现难点</a></li>
<li><a href="#%E4%B8%BB%E5%A4%87%E5%A4%8D%E5%88%B6%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95">主备复制的两种方法</a></li>
<li><a href="#%E5%A4%8D%E5%88%B6%E7%8A%B6%E6%80%81%E6%9C%BArsm-%E5%A4%8D%E5%88%B6%E4%BB%80%E4%B9%88%E7%BA%A7%E5%88%AB%E7%9A%84%E6%93%8D%E4%BD%9C">复制状态机RSM-复制什么级别的操作</a></li>
<li><a href="#%E9%80%9A%E8%BF%87%E8%99%9A%E6%8B%9F%E5%8C%96%E5%AE%9E%E7%8E%B0%E5%A4%8D%E5%88%B6">通过虚拟化实现复制</a></li>
<li><a href="#%E5%B7%AE%E5%BC%82%E6%9D%A5%E6%BA%90">差异来源</a></li>
<li><a href="#vm-ft%E7%9A%84%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86">VM-FT的中断处理</a></li>
<li><a href="#vm-ft%E5%A4%B1%E8%B4%A5%E5%9C%BA%E6%99%AF%E7%9A%84%E5%A4%84%E7%90%86">VM-FT失败场景的处理</a></li>
<li><a href="#vm-ft%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98">VM-FT性能问题</a></li>
</ul>
</li>
<li><a href="#%E9%94%99%E8%AF%AF%E5%AE%B9%E5%BF%8D-raft%E7%AE%97%E6%B3%95">错误容忍-Raft算法</a>
<ul>
<li><a href="#%E5%8D%95%E7%82%B9%E6%95%85%E9%9A%9C">单点故障</a></li>
<li><a href="#%E8%84%91%E8%A3%82%E9%97%AE%E9%A2%98">脑裂问题</a></li>
<li><a href="#raft%E9%87%87%E5%8F%96%E7%9A%84%E7%9A%84%E5%8E%9F%E5%88%99%E5%A4%A7%E5%A4%9A%E6%95%B0%E5%8E%9F%E5%88%99">Raft采取的的原则:大多数原则</a>
<ul>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B8%AA%E5%8E%9F%E5%88%99%E4%BC%9A%E4%BD%9C%E4%B8%BA%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3">为什么这个原则会作为基本思想</a></li>
</ul>
</li>
<li><a href="#raft%E5%8E%86%E5%8F%B2%E5%8F%91%E5%B1%95">raft历史发展</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8raft%E6%9E%84%E9%80%A0%E5%A4%8D%E5%88%B6%E7%8A%B6%E6%80%81%E6%9C%BA">使用Raft构造复制状态机</a></li>
<li><a href="#raft%E6%A6%82%E8%BF%B0">Raft概述</a></li>
<li><a href="#raft-log%E7%9A%84%E7%94%A8%E9%80%94">Raft log的用途</a></li>
<li><a href="#raft%E7%9A%84log%E6%A0%BC%E5%BC%8F">Raft的log格式</a></li>
<li><a href="#raft%E7%9A%84%E9%80%89%E4%B8%BE">Raft的选举</a>
<ul>
<li><a href="#%E6%83%85%E5%86%B51-%E9%9B%86%E7%BE%A4%E4%B8%AD%E6%B2%A1%E6%9C%89leader">情况1 ：集群中没有leader</a></li>
<li><a href="#%E6%83%85%E5%86%B52-%E9%9B%86%E7%BE%A4%E4%B8%AD%E6%9C%89leader%E5%B9%B6%E4%B8%94leader%E5%AE%95%E6%9C%BA%E4%BA%86">情况2 ：集群中有leader，并且leader宕机了</a>
<ul>
<li><a href="#%E6%AD%A4%E6%97%B6%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%E5%8F%98%E5%91%B3%E4%BA%86%E5%80%99%E9%80%89%E8%8A%82%E7%82%B9">此时只有一个节点变味了候选节点</a></li>
<li><a href="#%E6%9C%89%E4%B8%A4%E4%B8%AA%E5%80%99%E9%80%89%E4%BA%BA%E5%90%8C%E6%97%B6%E7%AB%9E%E9%80%89%E9%80%89%E4%B8%BE%E6%9D%A1%E4%BB%B6">有两个候选人同时竞选（选举条件）</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#raft%E7%9A%84%E9%80%89%E4%B8%BE%E8%B6%85%E6%97%B6%E6%97%B6%E9%97%B4">Raft的选举超时时间</a></li>
<li><a href="#raft-vote%E9%9C%80%E8%AE%B0%E5%BD%95%E5%88%B0%E7%A8%B3%E5%AE%9A%E7%9A%84storage%E6%8C%81%E4%B9%85%E5%8C%96">Raft-vote需记录到稳定的storage（持久化）</a></li>
<li><a href="#raft-%E6%97%A5%E5%BF%97">Raft-日志</a>
<ul>
<li><a href="#raft%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%A5%E5%BF%97%E5%A4%8D%E5%88%B6%E8%BF%87%E7%A8%8B">Raft算法的日志复制过程</a></li>
<li><a href="#raft-%E6%97%A5%E5%BF%97%E5%88%86%E6%AD%A7">Raft-日志分歧</a></li>
<li><a href="#raft%E9%80%89%E4%B8%BE%E8%A7%84%E5%88%99">Raft选举规则</a></li>
<li><a href="#raft-%E6%97%A5%E5%BF%97%E8%A6%86%E5%86%99%E5%90%8C%E6%AD%A5%E6%9C%AA%E4%BC%98%E5%8C%96%E7%89%88%E6%9C%AC">Raft-日志覆写同步（未优化版本）</a></li>
<li><a href="#raft-%E6%97%A5%E5%BF%97%E6%93%A6%E9%99%A4">Raft-日志擦除</a></li>
<li><a href="#raft-%E6%97%A5%E5%BF%97%E5%BF%AB%E9%80%9F%E8%A6%86%E5%86%99%E5%90%8C%E6%AD%A5">Raft-日志快速覆写同步</a></li>
<li><a href="#raft-%E6%8C%81%E4%B9%85%E5%8C%96">Raft-持久化</a></li>
<li><a href="#raft-%E6%9C%8D%E5%8A%A1%E6%81%A2%E5%A4%8D">Raft-服务恢复</a></li>
<li><a href="#%E7%BA%BF%E6%80%A7%E4%B8%80%E8%87%B4%E6%80%A7">线性一致性</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="MIT6-824课程">MIT6.824课程</h2>
<h3 id="分布系统简述">分布系统简述</h3>
<h4 id="分布式系统的定义">分布式系统的定义</h4>
<ul>
<li>非正式的定义，这里认为<strong>多个</strong>只能通过<strong>网络发送/接收数据包进行交互</strong>的系统，(而不是使用多处理核，因为多处理核是可以通过共享内存实现数据的交互的)即构成分布式系统, 它们<strong>合作</strong>来提供一些服务</li>
</ul>
<h4 id="为什么使用分布式系统？">为什么使用分布式系统？</h4>
<ul>
<li><strong>可以实现数据之间的共享 (sharing)</strong></li>
<li><strong>通过并行提高性能(increase capacity though parallelism)</strong>(可以将数据分散到多个节点上并行处理。处理海量数据时，传统的单机处理方式无法满足需求，而分布式处理可以将任务划分成小部分，快速处理，从而大大提高性能。)</li>
<li><em><strong>提高服务容错性 (tolerate faults) （本课重点）</strong></em> (一部分服务宕机不会影响到另一个部分服务，具有高可用性)</li>
<li><strong>利用物理隔离的手段提高整体服务安全性 (achieve security via isolation)</strong>(许多银行会将敏感的客户数据存放在隔离的数据库中，而与外部系统通过API进行通信。通过物理隔离，这些核心数据不暴露在开放的网络上，从而提高系统的安全性，降低数据被攻击或泄露的风险。)</li>
</ul>
<h4 id="分布式系统的历史">分布式系统的历史</h4>
<ul>
<li>局域网分布式系统的服务 (1980s)（类似校园网这种）</li>
<li>互联网规模的分布式系统，比如DNS（域名服务系统）、email</li>
<li>数据中心 (Data center)，伴随大型网站而生 (1990s)
<ol>
<li>常见的有网页搜索（爬虫实现，然后需要建立大量倒排索引）</li>
<li>商城购物系统（海量商品、订单、用户信息等数据）</li>
</ol>
</li>
<li>云计算 (Cloud computing) (2000s)
<ol>
<li>本地运算/本地运行应用，转移到云服务上运算/运行应用</li>
</ol>
</li>
</ul>
<h4 id="分布式系统的难点（Chalenges）">分布式系统的难点（Chalenges）</h4>
<blockquote>
<p><strong>网络分区</strong>：那么对于一个n个节点组成的网络来说，如果n 个节点可以被分为k个不相交且覆盖的group, 每个group内所有节点全是两两正常连接，而任意两个group之间的任何节点无连接。当k=1 时，网络正常，当k &gt; 1 时，我们称之为network partition。</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Jscroop/p/14382790.html#_label0">《RabbitMQ实战指南》整理（七）网络分区</a></p>
<p>RabbitMQ集群内两两节点之间会有信息交互，如果某节点出现网络故障或是端口不同，则会使与此节点的交互出现中断，经过超时判定后，会判定网络分区。网络分区的判断与net_ticktime参数息息相关，其默认值为60。集群内部每个节点间会每隔四分之一net_ticktime记一次应答，如果任何数据被写入节点中，则此节点会被认为已经被应答了，如果连续4次没有应答，则会判定此节点已下线，其余节点可以将此节点剥离出当前分区。</p>
<p>对于未配置镜像的集群，网络分区发生之后，队列也会随着宿主节点而分散在各自的分区中。对于消息发送方而言，可以成功发送消息，但是会有路由失败的情况，需要配合mandatory等机制保障消息的可靠性，对于消息消费方而言，可能会出现不可预知的现象，比如已消费消息ack会失效。网络分区发生后，客户端与某分区重新建立通信链路，其分区中如果没有相应的队列进程，则会有异常报出。如果从网络分区中恢复，数据不会丢失，但是客户端会重复消费。</p>
<p>对于已镜像的集群，网络分区的发生会引起消息的丢失，解决办法为消息发送端需要具备Basic.Return的能力，其次在检测到网络分区之后，需要迅速地挂起所有生产者进程，之后连接分区中的每个节点消费分区中所有的队列数据，在消费完之后再处理网络分区，最后从网络分区中恢复之后再恢复生产者进程。整个过程可以最大程度上保证网络分区之后的消息的可靠性。需要注意的是整个过程中会有大量的消息重复，消费客户端需要做好相应的幂等性处理。也可以将所有旧集群资源迁移到新集群来解决这个问题。</p>
</blockquote>
<ul>
<li>
<p>许多并发场景 (many concurrent part)</p>
</li>
<li>
<p><strong>需要处理故障/宕机问题</strong> (must deal with partial failure)</p>
</li>
<li>
<p><strong>尤其是发生网络分区问题</strong> (network partition)</p>
</li>
<li>
<p>体现性能优势 (realize the performance benefits)</p>
</li>
</ul>
<p>通常任务并非真正所有步骤都并行执行，需要良好的实现才能达到增加机器数就提高吞吐量的效果</p>
<h4 id="课程介绍">课程介绍</h4>
<p>实验内容：</p>
<ul>
<li>
<p>Lab1：实现mapreduce</p>
</li>
<li>
<p>Lab2：在存在故障和网络分区的情况下，使用raft协议完成复制</p>
</li>
<li>
<p>Lab3：通过实验2，复制一个Key-Value存储的服务</p>
</li>
<li>
<p>Lab4：构造分片(sharded)的key-value存储服务</p>
</li>
</ul>
<h4 id="支持分布式系统的底层基础架构">支持分布式系统的底层基础架构</h4>
<ul>
<li>存储：键值服务器，文件系统等</li>
<li>计算：分布式计算框架，用来编排或构建分布式应用程序如MapReduce，Spark等</li>
<li>通信：分布式通信框架，使用RPC（远程过程调用）：RPC的消息传递语义有三个（它们描述了在分布式系统中，消息如何在客户端和服务器之间进行传递，以及对消息传递保障的不同要求）
<ol>
<li>utmost once：最多一次，最多一次的发送消息，不管对方是否收到消息都不会重发</li>
<li>exactly once：确保一次，确保消息只发送一次，不管对方是否收到消息都不会重发</li>
<li>at least once：至少一次，至少发送一次，不管对方是否收到消息都发送一次</li>
</ol>
</li>
</ul>
<p><strong>对于分布式系统的底层基础架构，我们通常抽象的目标是做到让使用者觉得和单机操作无异，这是非常难实现的。</strong>（也就是隐藏分布式中各类难题的具体实现，对外暴露时争取和普通本地串行函数别无二致。）</p>
<h4 id="分布式系统的特性">分布式系统的特性</h4>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.zhangbj.com/p/769.html">尾部延迟是什么？如何避免尾部延迟？ | 程序员技术之旅 (zhangbj.com)</a>&lt;= 简述概念和产生原因<br>
概念：有1%的请求耗时高于99%的请求耗时，影响用户体验，甚至拖垮服务。</p>
<p><a target="_blank" rel="noopener" href="https://www.jdon.com/56122.html">什么是尾部延迟</a><br>
我们并行调用N个服务，然后等待最慢的一个。应用我们的直觉表明，随着N的增加，我们等待约100ms缓慢呼叫的可能性越来越大。在N = 1的情况下，发生这种情况的时间约为1％。在N = 10的情况下，大约有10％的时间。在这个简单的模型中，这种基本直觉是正确的。然而，在实际中，我们遇到的情况可能比这个更复杂。</p>
</blockquote>
<ul>
<li>
<p><strong>容错性</strong>：系统在部分节点故障时仍然可以正常运行，通常通过复制和容错机制实现。</p>
<ol>
<li>可用性：一般用p999等指标衡量（p999就是指99.9%，即在所有的请求中，99.9%的请求响应时间都在这个值以下。这意味着只有0.1%的请求响应时间会超过这个值。）
<ul>
<li>主要依赖replication复制技术（例如通过将数据和服务复制到多个节点上，确保即使部分节点发生故障，系统依然能够继续运行。）</li>
</ul>
</li>
<li>可恢复性：当机器崩溃或故障时，在重启时恢复正常工作状态
<ul>
<li>主要依赖logging or transaction（日志或事务）一类的技术</li>
<li>durable storage，需要将数据写入持久化的存储器（磁盘），便于后续恢复工作</li>
</ul>
</li>
</ol>
</li>
<li>
<p><strong>一致性</strong>:多个服务器应该具有相同的状态，提供一致的服务，不能出现客户端用相同操作请求两个服务器却获得了不同结果的情况。一致性根据程度可以分为最终一致性和强一致性。</p>
<ol>
<li>最终一致性：系统保证在一段时间后，所有节点的数据最终都能达到一致。也就是说不保证在任意时刻数据都是一致的</li>
<li>强一致性：系统保证任意时刻，所有节点的数据都是一致的。具体来说，任何一次读操作都能读到某个数据的最近一次写操作的结果。这意味着系统中的所有进程看到的操作顺序都与全局时钟下的顺序一致。例如，在关系型数据库中，更新后的数据必须能被后续的访问立即看到，这就是强一致性</li>
</ol>
</li>
<li>
<p><strong>性能</strong>：分布式系统往往希望能比单机系统要具备更高的性能，但是提高性能本身和提供容错性、一致性是冲突的。<br>
性能指标一般涉及两个方面：吞吐量和延迟。</p>
<ul>
<li>吞吐量：系统处理请求的能力，通常用每秒处理请求数（TPS）来衡量。</li>
<li>延迟：系统响应请求的时间，通常用平均响应时间（RTT）来衡量。（<strong>尾部延迟</strong>（上述引文有讲）在分布式系统中尤为重要，因为它会严重影响系统的整体性能。）</li>
</ul>
</li>
</ul>
<p>为了达到强一致性，需要不同机器之间的通信，这可能降低性能</p>
<p>​为了实现容错，需要从不同机器上复制数据，还需要将数据写入持久化存储器这一昂贵操作</p>
<p>​通常要兼顾以上3个特性很难做到，常见的实现要么牺牲一点一致性换取更高的性能；要么牺牲一点容错性换取更好的性能，不同的实现方式有不同的权衡。</p>
<h4 id="mapreduce概述">mapreduce概述</h4>
<ul>
<li>论文的背景是google的两位数据工程师需要处理爬虫数据，建立倒排索引，用于网页搜索。需要几个小时处理TB级别的数据。传统的代码实现，并发执行任务，如果中间一个线程出错，可能整个任务都需要重新执行，所以还需要考虑容错性设计。</li>
</ul>
<p>​- 程序员通过编写函数式或无状态的map函数和reduce函数的实现，实现分布式数据的处理。mapreduce内部通过其他机制保证执行过程的容错性、分布式通信等问题，对程序员隐藏这些细节。</p>
<p>​- map-reduce经典举例即统计字母出现的次数，多个进程各自通过map函数统计获取到的数据片段的字母的出现次数；后续再通过reduce函数，汇总聚合map阶段下每个进程对各自负责的数据片段统计的字母出现次数。一旦执行了shuffle，多个reduce函数可以各自只聚合一种字母的出现总次数，彼此之间不干扰。</p>
<p>​- 开销昂贵的部分即shuffle，map的结果经过shuffle按照一定的顺序整理/排序，然后才分发给不同的reduce处理。这里shuffle的操作理论比map、reduce昂贵。</p>
<p>提问：排序操作是否可以通过map-reduce完成</p>
<p>回答：可以，排序在mapreduce中是讨论最多的应用之一，可以通过mapreduce实现。你可以将输入拆分成不同部分，mapper对这些部分进行排序，输出拆分成r个桶，每个reduce对这r个桶进行排序，最后输出完整的文件。</p>
<h4 id="mapreduce的执行流程">mapreduce的执行流程</h4>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzIwODA2NjIxOA==&amp;mid=2247484185&amp;idx=1&amp;sn=055263242bfb70e727b8fffb1d879301&amp;chksm=970980dca07e09ca97fef2fda5ad34d5f56df4edc9ce487bc69291fb621fbdd6db4af6a57560&amp;scene=21#wechat_redirect">MIT6.824学习笔记</a>&lt;&lt;== 一位大佬对mapreduce的详细介绍</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/2024-11-29-Mit6-824%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ef809e086995d393077cdc480a64ef2b.png" alt="alt text"></p>
<ul>
<li>首先会创建许多worker，以及Master进程。其中一般来说Worker进程有两种一种是负责map任务一种是负责reduce任务（一个Worker会专注执行一种任务要么是reduce要么是map）。</li>
<li>Master进程，又被称为协调器，负责任务(map,reduce任务)分配给不同的worker</li>
<li>当输入的数据到来的时候，会被分为M个小文件（每个文件大小大概是16M-64M），然后在集群中启动MapReduce实例，其中有一个Master和多个Worker</li>
<li>Master会将小文件发给可用的Worker，这是基于GFS实现的，所以不存在网络传输</li>
<li>Worker得到小文件后，会读取文件并对其进行map操作，输出key/value对（中间状态&lt;a,1&gt;,&lt;b,1&gt;,&lt;a,1&gt;），首先缓存在内存中，在内存上存储实际是一个循环数组，有两个指针，一个指向可读的位置，一个指向可写的位置，当这个数组到达一个阈值(80%)就会执行flush操作，将数据写入磁盘，在内存中已经写入的数据会被移除（移动可读指针）。再写入磁盘前内存中的 (key, value) 对通过 partitioning function() 例如 hash(key) mod R 分为 R 个 regions（这个Regions的个数与执行reduce函数的Worker有关）。写入磁盘后，把这些文件的地址回传给 Master，然后 Master 把这些位置传给 Reduce Worker;</li>
<li>Reduce Worker 收到 Master 的位置信息后，会使用RPC从MapWorker所在的磁盘读取这些数据，并根据key进行排序，然后将同一key的所有数据聚合在一起（<strong>由于许多不同的 key 值会映射到相同的 Reduce 任务上，因此必须进行排序。如果中间数据太大无法在内存中完成排序，那么就要在外部进行排序</strong>）；</li>
<li>Reduce Worker 将分组后的值传给用户自定义的 reduce 函数，输出追加到所属分区的输出文件中；</li>
<li>当所有的 Map 任务和 Reduce 任务都完成后，Master 向用户程序返回结果；</li>
</ul>
<p>​ 输入文件在全局文件系统中，被称为GFS。Google现在使用的是不同的global file system，但该论文中使用的是GFS。</p>
<p>​ 上面流程最后reduce输出结果会被保存到GFS，而map产生的中间文件不会被保存到GFS中（而是保存到worker运行的本地机器上）。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/2024-11-29-Mit6-824%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image.png" alt="alt text"></p>
<p>上图为流程的概要</p>
<p>问题1：在远程读取进程中，文件是否会传输到reducer？</p>
<p>回答1：是的。map函数产生的中间结果存放在执行map函数的worker机器的磁盘上，而之后解调器分配文件给reducer执行reduce函数时，中间结果数据需要通过网络传输到reducer机器上。这里其实很少有网络通信，因为一个worker在一台机器上，而每台机器同时运行着worker进程和GFS进程。worker运行map产生中间结果存储在本地，而之后协调器给worker分配文件以执行reduce函数时，才需要通过网络获取中间结果数据，最后reduce处理完在写入GFS，写入GFS的动作也往往需要通络传输。</p>
<p><strong>问题2：协调器是否负责对数据进行分区，并将数据分发到每个worker或机器上？</strong></p>
<p><strong>回答2：不是的。mapreduce运行用户程序，这些输入数据在GFS中。（也就是说协调器告知worker从GFS取哪些数据进行map，后续协调器又告知worker从哪些worker机器上获取中间结果数据进行reduce，最后又统一写入到GFS中）</strong></p>
<p>问题3：这里涉及的排序是如何工作的？比如谁负责排序，如何排序？</p>
<p>回答3：在中间结果数据传递到reduce函数之前，mapreduce库进行一些排序。比如所有的中间结果键a、b、c到一个worker。比如(a,1) (b,1) (c,1) (a,1) 数据，被排序成(a,1) (a,1) (b,1) (c,1) 后才传递给reduce函数。</p>
<p>问题4：很多函数式编程是否可以归结为mapreduce问题？</p>
<p>回答4：是的。因为map、reduce函数的概念，在函数式编程语言中非常常见，或者说函数式编程真是map、reduce的灵感来源。</p>
<h4 id="mapreduce的容错性">mapreduce的容错性</h4>
<ul>
<li>
<p>主要分为两种故障：</p>
<ul>
<li>Worker故障：Master 周期性的 ping 每个 Worker，如果指定时间内没回应就是挂了。将这个 Worker 标记为失效，分配给这个失效 Worker 的任务将被重新分配给其他 空闲的Worker；这就是fault tolerance容错的基本方案</li>
</ul>
<p>换句话说，如果coordinator没有收到worker反馈task任务完成，那么会coordinator重新分配worker要求执行task（可能分配到同一个worker，重点是task会被重新执行）。<strong>这里涉及一个问题，map是否会被执行两次？</strong></p>
<p>或许没反馈task执行done完成的worker是遇到网络分区等问题，并没有宕机，或者协调者不能与worker达成网络通信，但实际上worker仍然在运行map任务，它正在产生中间结果。<strong>这里的答案是，同一个map可以被运行两次。</strong></p>
<p>​ **被执行两次是能够接受的（幂等性问题），正是map和reduce属于函数式(functional)的原因之一。**如果map/reduce是一个funcitonal program，那么使用相同输入运行时，产生的输出会是相同的（也就是保证幂等）。</p>
<p>**类似的，reduce能够运行两次吗？**是的，和map出于相同的原因，从容错的角度上看，执行reduce函数和map函数并没有太大区别。**需要注意的是，这时候可能有两个reducer同时有相同的输出文件需要写入GFS，它们首先在全局文件系统GFS中产生一个中间文件，然后进行atomic rename原子重命名，将文件重命名为实际的最终名称。**因为在GFS中执行的重命名是原子操作，最后哪个reducer胜出并不重要，因为reduce是函数式的，它们最终输出的数据都是一样的。</p>
<ul>
<li>Master 故障：中止整个 MapReduce 运算，重新执行。一般很少出现 Master 故障。</li>
</ul>
</li>
</ul>
<p><strong>问题1：一台机器应该可以执行多个map任务，如果它分配10个map任务，而在执行第7个map任务时失败了，master得知后，会安排将这7个已完成的map任务分布式地重新执行，可能分散到不同的map机器上，对吗？</strong></p>
<p><strong>回答1：是的。虽然我认为通常一台机器只运行一个map函数或一个reduce函数，而不是多个。</strong></p>
<p><strong>问题2：在worker完成map任务后，它是否会直接将文件写入其他机器可见的位置，或者只是将文件保存到自己的文件系统中？</strong></p>
<p><strong>回答2：map函数总是在本地磁盘产生结果，所以中间结果文件只会在本地文件系统中。</strong></p>
<p>问题3：即使一次只做一个map任务，但是如果执行了多次map任务后，如果机器突然崩溃，那么会丢失之前负责的所有map任务所产生的中间结果文件，对吗？</p>
<p>回答3：不，中间结果文件放在本地文件系统中（磁盘中）。所以当机器恢复时，中间结果文件还在那里，因为文件数据是被持久化保存的，而不是只会存在于内存中（换句话说，这里依赖了操作系统的文件系统本身的容错性）。并且map或reduce会直接访问包含intermediate results中间结果的机器。</p>
<h4 id="mapreduce其他异常场景">mapreduce其他异常场景</h4>
<ul>
<li>执行缓慢的worker（Slow workers）？</li>
</ul>
<p>比如GFS也在同一台机器上运行占用大量的机器周期或带宽，或硬件本身问题，导致worker执行map/reduce很慢。<strong>慢的worker被称为straggler，当剩下几个map/reduce任务没有执行时，协调者会另外分配相同的map/reduce任务到其他闲置worker上运行，达到backup task的效果</strong>（因为函数式，map/reduce以相同输入执行最后会产生相同输出，所以执行多少次都不会有问题）。</p>
<p><strong>通过备用任务(backup task)</strong>，性能不会受限于最慢的几个worker，因为有更快的worker会领先它们完成task（map或reduce）。这是应对straggler的普遍做法，通过replicate tasks复制任务，获取更快完成task的输出结果，处理了tail latency尾部延迟问题。</p>
<h4 id="结语">结语</h4>
<p>尽管由于一些原因，Google 已经不在使用 MapReduce 了。但 MapReduce 从根本上改变了大规模数据处理架构，它通过一个简单的 API，抽象了处理并行、容错和负载均衡的复杂性，让没有相关经验的程序员也能够在计算机集群上分布式地处理大规模数据集。</p>
<h3 id="Threads和RPC-多线程和远程过程调用">Threads和RPC(多线程和远程过程调用)</h3>
<h4 id="为什么选用go语言">为什么选用go语言</h4>
<p>这里主要讲为什么这个课程选用Go语言进行编程。</p>
<ul>
<li>good support for threads/RPC：对线程和RPC的支持度高</li>
<li>gc：自带GC，无需考虑垃圾回收问题</li>
<li>type safe：类型安全</li>
<li>simple：简单易上手</li>
<li>compiled：编译型语言，运行时开销更低</li>
</ul>
<h4 id="go的多协程挑战">go的多协程挑战</h4>
<ul>
<li>
<p>race conditions：多线程会引入竞态条件的场景</p>
<ul>
<li>avoid sharing：避免共享内存以防止竞态条件场景的产生（Go有一个竞态检测器race detector，能够辅助识别代码中的一些竞态条件场景）</li>
<li>use locks：让一系列指令变成原子操作</li>
</ul>
</li>
<li>
<p>coordination：同步协调问题，比如一个线程的执行依赖另一个线程的执行结果等</p>
<ul>
<li>channels：通道允许同时通信和协调</li>
<li>condition variables：配合互斥锁使用</li>
</ul>
</li>
<li>
<p>deadlock：死锁问题，比如在go中简单的死锁场景，一个写线程往channel写数据，但是永远没有读线程从channel读数据，那么写线程被永久阻塞，即死锁，go会抓住这种场景，抛出运行时错误runtime error。</p>
</li>
</ul>
<h4 id="go如何应对多线程的挑战">go如何应对多线程的挑战</h4>
<ul>
<li>channels：通道
<ul>
<li>no-sharing场景：如果线程间不需要共享内存（变量等），一般偏向于使用channels完成线程间的通信</li>
</ul>
</li>
<li>locks + condition variables：锁和条件变量配套使用
<ul>
<li>shared-memory：如果线程间需要共享内存，则采用锁+条件变量的方案。比如键值对key-value服务，需要共享key-value table。</li>
</ul>
</li>
</ul>
<h4 id="go的堆栈和逃逸分析">go的堆栈和逃逸分析</h4>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/586249256">go的堆栈和逃逸分析详解</a></p>
<p>相比于把内存分配到堆中，分配到栈中优势更明显。Go语言也是这么做的：Go编译器会尽可能将变量分配到到栈上。但是，当编译器无法证明函数返回的变量有没有被引用时，编译器就必须在堆上分配该变量，以此避免悬挂指针（dangling pointer）的问题。另外，如果局部变量占用内存非常大，也会将其分配在堆上。</p>
</blockquote>
<p><strong>问题：go是如何确定内存是分配到栈上还是堆上？</strong></p>
<p><strong>答案：逃逸分析</strong></p>
<h5 id="逃逸分析">逃逸分析</h5>
<ul>
<li>什么是逃逸分析：<em><strong>编译器通过逃逸分析技术去选择堆或者栈，逃逸分析的基本思想如下：检查变量的生命周期是否是完全可知的，如果通过检查，则在栈上分配。否则，就是所谓的逃逸，必须在堆上进行分配。</strong></em></li>
</ul>
<h5 id="逃逸分析的基本原则">逃逸分析的基本原则</h5>
<ul>
<li>不同于JAVA JVM的运行时逃逸分析，Go的逃逸分析是在<strong>编译期</strong>完成的：编译期无法确定的参数类型<strong>必定</strong>放到堆中；</li>
<li>如果变量在函数<strong>外部存在引用</strong>，则<strong>必定</strong>放在堆中；</li>
<li>如果变量占用<strong>内存较大</strong>时，则<strong>优先</strong>放到堆中；</li>
<li>如果变量在函数外部<strong>没有引用</strong>，则优先放到<strong>栈</strong>中；</li>
</ul>
<h5 id="逃逸分析举例">逃逸分析举例</h5>
<p>我们使用这个命令来查看逃逸分析的结果： go build -gcflags ‘-m -m -l’</p>
<ol>
<li>参数类型是interface类型</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pacakge main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="number">666</span></span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>运行结果</strong></p>
<p>这段代码就输出了 a escapes to heap</p>
<p><strong>原因分析</strong><br>
因为Println的参数类型是interface，编译器无法确定它的具体类型，因此必须在堆上分配。</p>
<ol start="2">
<li>变量在外部存在引用</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> *<span class="type">int</span> &#123;</span><br><span class="line">    a := <span class="number">6</span></span><br><span class="line">    <span class="keyword">return</span> &amp;a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    _ := test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>运行结果</strong><br>
这段代码就输出了moved to head: a</p>
<p><strong>原因分析</strong><br>
变量a在函数外部存在引用。</p>
<p><strong>我们来分析一下执行过程：当函数执行完毕，对应的栈帧就被销毁，但是引用已经被返回到函数之外。如果这时外部通过引用地址取值，虽然地址还在，但是这块内存已经被释放回收了，这就是非法内存。</strong></p>
<p>为了避免上述非法内存的情况，在这种情况下变量的内存分配必须分配到堆上</p>
<ol start="3">
<li>变量占用内存较大</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10000</span>, <span class="number">10000</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i ++ &#123;</span><br><span class="line">        a[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>运行结果</strong><br>
这段代码就输出了make([]int, 10000, 10000) escapes to heap</p>
<p><strong>原因分析</strong><br>
我们定义了一个容量为10000的int类型切片，发生了逃逸，内存分配到了堆上（heap）。</p>
<ol start="4">
<li>变量大小不确定的时候也会分配在堆上</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">l := <span class="number">1</span></span><br><span class="line">a := <span class="built_in">make</span>([]<span class="type">int</span>, l, l)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; l; i++ &#123;</span><br><span class="line">a[i] = i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>运行结果</strong><br>
这段代码就输出了make([]int, l, l) escapes to heap</p>
<p><strong>原因分析</strong><br>
我们虽然在代码段中给变量 l 赋值了1，但是编译期间只能识别到初始化int类型切片时，传入的长度和容量是变量l，编译期并不能确定变量l的值，所以发生了逃逸，会把内存分配到堆中。</p>
<h3 id="谷歌文件系统GFS">谷歌文件系统GFS</h3>
<ul>
<li>首先我们从三个方面去讨论：
<ol>
<li>从存储</li>
<li>介绍GFS</li>
<li>一致性</li>
</ol>
</li>
</ul>
<h4 id="存储">存储</h4>
<ul>
<li>存储的重要性：通常来说应用程序是无状态的，一些用户数据需要永久保存，这就需要存储，最简单的可以存储在本地磁盘上，再者可以存储在数据库中，</li>
</ul>
<h5 id="存储设计的难点">存储设计的难点</h5>
<ul>
<li>要考虑高性能
<ol>
<li>单个机器的网卡和CPU性能有限，所以需要考虑跨多个服务机器存储数据</li>
<li>因为要支持MapReduce，所以需要考虑分片</li>
</ol>
</li>
<li>要考虑多机器下的容错
<ol>
<li>数几千台机器共同运行，总有几个会出现故障，所以需要考虑容错</li>
<li>通常通过复制数据保证容错性，即当前磁盘数据异常/缺失等情况，尝试从另一个磁盘获取数据</li>
</ol>
</li>
<li>通过复制数据保证容错的话又会出现新问题：
<ol>
<li>会出现潜在的数据不一致问题，即多个副本之间数据不一致</li>
</ol>
</li>
<li>那么就又引入了一致性问题
<ol>
<li>因此就需要一些一致性协议来保证数据一致性，一般需要通过一些消息机制保证一致性，这会稍微带来一些性能影响，但一般底层为了保证数据一致性而额外进行的网络通信等操作在整体性能的开销中占比并不会很高。其中可能涉及需要将通信的一些结果写入存储中，这是相对昂贵的操作。</li>
</ol>
</li>
</ul>
<h5 id="一致性">一致性</h5>
<p>**并发性(concurrency)<strong>和</strong>故障/失败(failures)**是两个实现一致性时需要考虑的难点。（WHY？）</p>
<ul>
<li>
<p>并发性问题举例：</p>
<ul>
<li>W1写1，W2写2；R1和R2准备读取数据。W1和W2并发写，在不关心谁先谁后的情况下，考虑一致性，则我们希望R1和R2都读取到1或者都读取到2，R1和R2读取的值应该一致。（可通过分布式锁等机制解决）</li>
</ul>
</li>
<li>
<p>故障/失败问题举例：</p>
<ul>
<li>一般为了容错性，会通过复制的方式解决。而不成熟的复制操作，会导致读者在不做修改的情况下读取到两次不同的数据。比如，我们要求所有写者写数据时，需要往S1和S2都写一份。此时W1和W2并发地分别写1和2到S1、S2，而R1和R2即使在W1和W2都完成写数操作后，再从S1或S2读数时结果可能是1也可能是2（因为没有明确的协议指出这里W1和W2的数据在S1、S2上以什么方式存储，可能1被2覆盖，反之亦然）。</li>
</ul>
</li>
</ul>
<h4 id="什么是GFS？">什么是GFS？</h4>
<ul>
<li>GFS是一个可扩展的分布式文件系统，由Google开发，用于大规模集群环境中的海量数据存储和处理。</li>
<li>GFS旨在保持高性能，且有复制、容错机制，但很难保持一致性</li>
</ul>
<p>GFS的几个主要特征：</p>
<ol>
<li>
<p>Big：large data set，巨大的数据集</p>
</li>
<li>
<p>Fast：automatic sharding，自动分片到多个磁盘</p>
</li>
<li>
<p>Gloal：all apps see same files，所有应用程序从GFS读取数据时看到相同的文件（一致性）</p>
</li>
<li>
<p>Fault tolerance：automic，尽可能自动地采取一些容错恢复操</p>
</li>
</ol>
<h4 id="GFS数据读取流程">GFS数据读取流程</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/2024-11-29-Mit6-824%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image.png" alt="alt text"></p>
<ul>
<li>
<p>GFS通过Master管理文件系统的元数据等信息，其他Client只能往GFS写入或读取数据。当应用通过GFS Client读取数据时，大致流程如下：</p>
<ol>
<li>Client向Master发起读数据请求</li>
<li>Master查询需要读取的数据对应的目录等信息，汇总文件块访问句柄、这些文件块所在的服务器节点信息给Client（大文件通常被拆分成多个块Chunk存放到不同服务器上，单个Chunk（块）很大， 这里是64MB）</li>
<li>Client得知需要读取的Chunk的信息后，直接和拥有这些Chunk的服务器网络通信传输Chunks</li>
</ol>
</li>
</ul>
<h4 id="GFS-Master简述">GFS-Master简述</h4>
<ul>
<li>
<p>Master主要负责的工作如下:</p>
<ol>
<li>维护<strong>文件名</strong>到<strong>块句柄</strong>数组的映射(file name =&gt; chunk handles)(这些信息大多数存放在内存中，所以Master可以快速响应客户端Client)</li>
<li>维护每个块句柄(chunk handle)的版本(version)</li>
<li>维护块存储服务器列表(list of chunk servers)
<ul>
<li>主服务器(primary)
<ul>
<li>Master还需维护每一个主服务器(primary)的租赁时间(lease time)</li>
</ul>
</li>
<li>次要服务器(secondaries)<br>
典型配置即将chunk存储到3台服务器上</li>
</ul>
</li>
<li>log+check point：通过日志和检查点机制维护文件系统。所有变更操作会先在log中记录，后续才响应Client。这样即使Master崩溃/故障，重启时也能通过log恢复状态。master会定期创建自己状态的检查点，落到持久性存储上，重启/恢复状态时只需重放log中最后一个check point检查点之后的所有操作，所以恢复也很快</li>
</ol>
</li>
<li>
<p>这里需要思考的是，哪些数据需要放到稳定的存储中(比如磁盘)？</p>
<ol>
<li>比如file name =&gt; chunk hanles的映射，平时已经在内存中存储了，还有必要存在稳定的存储中吗？<br>
答:需要，否则崩溃后恢复时，内存数据丢失，master无法索引某个具体的文件，相当于丢失了文件。</li>
<li>chunk handle 到 存放chunk的服务器列表，这一层映射关系，master需要稳定存储吗？<br>
答: 不需要，master重启时会要求其他存储chunk数据的服务器说明自己维护的chunk handles数据。这里master只需要内存中维护即可。同样的，主服务器(primary)、次要服务器(secondaries)、主服务器(primary)的租赁时间(lease time)也都只需要在内存中即可。</li>
<li>chunk handle的version版本号信息呢，master需要稳定存储吗？<br>
答:需要。否则master崩溃重启时，master无法区分哪些chunk server存储的chunk最新的。比如可能有服务器存储的chunk version是14，由于网络问题，该服务器还没有拿到最新version 15的数据，master必须能够区分哪些server有最新version的chunk。</li>
</ol>
</li>
</ul>
<p>问题：Master崩溃重启后，会连接所有的chunk server，找到最大的version？</p>
<p>回答：Master会尝试和所有chunk server通信，尽量获取最新version。当然有可能拥有最新version的chunk server由于网络等原因正好联系不上，此时能联系上的存活最久的chunk server的version会比master存储的version小。</p>
<h4 id="GFS-文件读取">GFS-文件读取</h4>
<ol>
<li>Client向Master发请求，要求读取X文件的Y偏移量的数据</li>
<li>Master回复Client，X文件Y偏移量相关的块句柄、块服务器列表、版本号(chunk handle, list of chunk servers, version</li>
<li>Client 缓存cache块服务器列表(list of chunk servers)</li>
<li>Client从最近的服务器请求chunk数据(reads from closest servers)</li>
<li>被Client访问的chunk server检查version，version正确则返回数据</li>
</ol>
<ul>
<li>
<p><strong>为什么这里Client要缓存list of chunk server信息呢？</strong><br>
答：<strong>因为在这里的设计中，Master只有一台服务器，我们希望尽量减少Client和Server之间的通信次数，客户端缓存可以大大减少Master机器的负载。</strong></p>
</li>
<li>
<p><strong>为什么Client尽量访问最近的服务器来获取数据(reads from closest servers)？</strong><br>
答: <strong>因为这样在宛如拓扑结构的网络中可以最大限度地减少网络流量(mininize network traffic)，提高整体系统的吞吐量。</strong></p>
</li>
<li>
<p><strong>为什么在Client访问chunk server时，chunk server需要检查verison？</strong><br>
答: <strong>为了尽量避免客户端读到过时数据的情况。</strong></p>
</li>
</ul>
<h4 id="GFS-文件写入">GFS-文件写入</h4>
<p>这里主要关注文件写入中的<strong>append操作</strong>，因为把记录追加到文件中这个在他们的业务中很常见。在mapreduce中，reducer将处理后的记录数据(计算结果)很快地追加(append)到file中。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/2024-11-29-Mit6-824%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-1.png" alt="alt text"></p>
<ol>
<li>Client向Master发出请求，查询应该往哪里写入filename对应的文件。</li>
<li>Master查询filename到chunk handle映射关系的表，找到需要修改的chunk handle后，再查询chunk handle到chunk server数组映射关系的表，以list of chunk servers(primary、secondaries、version信息)作为Client请求的响应结果<br>
接下去有两种情况，已有primary和没有primary(假设这是系统刚启动后不久，还没有primary)
<ul>
<li>有primary: 继续后续流程</li>
<li>没有Primary:<strong>master在chunk servers中选出一个作为primary，其余的chunk server作为secondaries。(暂时不考虑选出的细节和步骤)</strong><br>
(master会增加version（每次有新的primary时，都需要考虑时进入了一个new epoch，所以需要维护新的version），然后向primary和secondaries发送新的version，并且会发给primary有效期限的租约lease。这里primary和secondaries需要将version存储到磁盘，否则重启后内存数据丢失，无法让master信服自己拥有最新version的数据(同理Master也是将version存储在磁盘中)。)</li>
</ul>
</li>
<li>Client发送数据到想写入的chunk servers(primary和secondaries)，有趣的是，这里Client只需访问最近的secondary，而这个被访问的secondary会将数据也转发到列表中的下一个chunk server，此时数据还不会真正被chunk severs存储。（即上图中间黑色粗箭头，secondary收到数据后，马上将数据推送到其他本次需要写的chunk server）,<strong>这么做提高了Client的吞吐量，避免Client本身需要消耗大量网络接口资源往primary和多个secondaries都发送数据。</strong></li>
<li>数据传递完毕后，Client向primary发送一个message，表明本次为append操作<br>
primary此时需要做几件事：
<ol>
<li>primary此时会检查version，如果version不匹配，那么Client的操作会被拒绝</li>
<li>primary检查lease是否还有效，如果自己的lease无效了，则不再接受任何mutation operations（因为租约无效时，外部可能已经存在一个新的primary了）</li>
<li>如果version、lease都有效，那么primary会选择一个offset用于写入</li>
<li>primary将前面接收到的数据写入稳定存储中</li>
</ol>
</li>
<li>primary发送消息到secondaries，表示需要将之前接收的数据写入指定的offset</li>
<li>secondaries写入数据到primary指定的offset中，并回应primary已完成数据写入</li>
<li>primary回应Client，你想append追加的数据已完成写入</li>
</ol>
<p><em><strong>当然，存在一些情况导致数据append失败，此时primary本身写入成功，但是后续存在某些/某个secondaries写入失败，此时会向Client返回错误error。Client遇到这种错误后，通常会retry整个流程直到数据成功append，这也就是所谓的最少一次语义(do at-least-once)</strong></em></p>
<ul>
<li><strong>需要注意的是，假设append失败，Client再次重试，此时流程中primary指定写入的offset和上一次会是一样的吗？</strong><br>
不，primary会指定一个新的offset。假设primary+2台secondaries，可能上一次p和s1都写成功，仅s2失败。此时retry需要用新的offset，或许p、s1、s2就都写入成功了。这里可以看出来<strong>副本记录是可以重复的(replicates records can be duplicated)</strong>，这和我们常见的操作系统中标准的文件系统不一样。</li>
</ul>
<p>好在应用程序不需要直接和这种特殊的文件系统交互，而是通过库操作，库的内部实现隐藏了这些细节，用户不会看到曾经失败的副本记录数据。如果你append数据，库会给数据绑定一个id，如果库读取到相同id的数据，会跳过前面的一个。同时库内通过checksums检测数据的变化，同时保证数据不会被篡改。</p>
<h3 id="主备复制">主备复制</h3>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_40910614/article/details/117995014">（VM-FT论文解读）容错虚拟机分布式系统的设计</a></p>
</blockquote>
<ul>
<li>
<p>failures：复制失败场景和对策</p>
</li>
<li>
<p>challenge：实现难点</p>
</li>
<li>
<p>2 appliction：2个典型应用场景的探讨</p>
<ul>
<li>状态转移复制(state transfer replication)</li>
<li>复制状态机(replicated state machines)<br>
case study</li>
</ul>
</li>
<li>
<p>VM FT：VMware fault tolerance</p>
</li>
</ul>
<h4 id="失败的场景">失败的场景</h4>
<ul>
<li>常见的复制失败场景分类
<ol>
<li>fail-stop failure：基础设备或计算机组件问题，导致系统暂停工作(stop compute)，一般指计算机原本工作正常，由于一些突发的因素暂时工作失败了，比如网线被切断等。</li>
<li>logic bugs, configuration errors：本身复制的逻辑有问题，或者复制相关的主从配置有异常，这类failure导致的失败，不能靠系统自身自动修复。</li>
<li>malicious errors：这里我们的设计假设的内部系统中每一部分都是可信的，所以我们无法处理试图伪造协议的恶意攻击者。</li>
<li>handling stop failure：比如主集群突发地震无法正常服务，我们希望系统能自动切换到使用backup备份集群提供服务。当然如果主从集群都在一个数据中心，那么一旦出现机房被毁问题，大概率整个系统就无法提供服务了。</li>
</ol>
</li>
</ul>
<p>我们只关注<strong>处理停止失败(handling stop failures)</strong>。</p>
<h4 id="主备复制的实现难点">主备复制的实现难点</h4>
<ul>
<li>
<p><strong>为了防止出现脑裂的场景，我们该如何判断一个primary真正的失败了？</strong></p>
<ul>
<li>你无法直接区分发生了网络分区问题(network partition)还是实质的机器故障问题(machine failed)</li>
<li>或许只是部分机器访问不到primary，但是客户端还是正常和primary交互中。你必须有一些机制保证不会让系统同时出现两个primary(假设机制中只允许正常情况下有且只有一个primary工作)。</li>
<li><strong>(Split-brain system)脑裂场景</strong><br>
假设机制不完善，可能导致两个网络分区下各自有一个primary，客户端们和不同的primary交互，最后导致整个系统内部状态产生严重的分歧（比如存储的数据、数据的版本等差异巨大）。此时如果重启整个系统，我们就不得不手动处理这些复杂的分歧状态问题（就好似手动处理git merge冲突似的）。</li>
</ul>
</li>
<li>
<p><strong>如何让主备保持同步？</strong></p>
</li>
</ul>
<p>**我们的目标是primary失败时，backup能接手primary的工作，并且从primary停止的地方继续工作。这要求backup总是能拿到primary最新写入的数据，保持最新版本。**我们不希望直接向客户端返回错误或者无法响应请求，因为从客户端角度来看，primary和backup无区别，backup就是为容错而生，理应也能正常为自己提供服务。</p>
<ul>
<li>
<p>需要保证应用中的所有变更，按照正确顺序被处理(apply changes in order)</p>
</li>
<li>
<p>必须<strong>避免/解决非决定论(avoid non-determinism)</strong>。即相同的变更在primary和backup上应该有一致的表现。</p>
</li>
<li>
<p><strong>故障转移</strong></p>
</li>
</ul>
<p>primary出现问题时，我们希望切换到backup提供服务。但是切换之前，我们需要保证primary已经完成了所有正在执行的工作。即我们不希望在primary仍然在响应client时突然切换backup（如果遇到网络分区等问题，会使得故障转移难上加难）。</p>
<blockquote>
<p><strong>在计算机术语中，故障转移（英语：failover），即当活动的服务或应用意外终止时，快速启用冗余或备用的服务器、系统、硬件或者网络接替它们工作。 故障转移 (failover)与交换转移操作基本相同，只是故障转移通常是自动完成的，没有警告提醒手动完成，而交换转移需要手动进行。</strong></p>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB/14768924?fr=aladdin">故障转移</a></p>
</blockquote>
<h4 id="主备复制的两种方法">主备复制的两种方法</h4>
<ol>
<li>
<p><strong>状态转移(state transfer)</strong>：primary正常和client交互，每次响应client之前，先生成记录checkpoint检查点，将checkpoint同步到备份backup，待backup都同步完状态后，primary再响应client。（<strong>即将主的最新消息同步到备份后，再响应client</strong>）</p>
</li>
<li>
<p><strong>复制状态机(replicated state machine，RSM)</strong>：与状态转移类似，只是这里primary和backup之间同步的不是状态，而是操作。即primary正常和client交互，每次响应client之前，先生成操作记录operations，将operations同步到备份backup，待backup都执行完相同的操作后，primary再响应client。</p>
</li>
</ol>
<p>这两种方案都有被应用，共同的要点在于，<strong>primary响应client之前，首先确保和backup同步到相同的状态，然后再响应client。这样当primary故障时，任意backup接管都能有和原primary对齐的状态。</strong></p>
<p>这两者的主要区别是<strong>方法一是执行完操作后，得到了结果，把结果同步到备份机上，而方法二则是将要执行的操作同步到备份机上，让备份机自己运行操作，并得到结果。</strong><br>
从这就能看出方法一的<strong>缺点</strong>了，如果一个操作得到了非常大的结果，那么同步起来就非常昂贵了</p>
<p>问题1：为什么client不需要发送数据到backup备机？<br>
答1：因为这里client发送的请求是具有确定性的操作，只需向primary请求就够了。主备复制机制保证primary能够将具有确定性的操作正确同步到其他backup，即系统内部自动保证了primary和backup之间的一致性，不需要client额外干预。<strong>接下来的问题即，怎么确定一个操作是否具有确定性？在复制状态机(replicated state machine，RSM)方案中，即要求所有的操作都是具有确定性的，不允许存在非确定性的操作。</strong></p>
<p>问题2：是不是存在着混合的机制，即混用状态转移(state transfer)和复制状态机(replicated state machine，RSM)？<br>
答2: <strong>是的。比如有的混合机制在默认情况下以复制状态机(replicated state machine，RSM)方案工作，而当集群内primary或backup故障，为此创建一个新的replica时则采用状态转移(state transfer)转移/复制现有副本的状态。</strong></p>
<h4 id="复制状态机RSM-复制什么级别的操作">复制状态机RSM-复制什么级别的操作</h4>
<p>使用复制状态机时，我们需要考虑什么级别的操作需要被复制。有以下几种可能性：</p>
<ul>
<li><strong>应用程序级别的操作(application-level operations)</strong></li>
</ul>
<p>比如GFS的文件append或write。如果你在应用程序级别的操作上使用复制状态机，那也意味着你的复制状态机实现内部需要密切关注应用程序的操作细节，比如GFS的append、write操作发生时，复制状态机应该如何处理这些操作。一般而言你需要修改应用程序本身，以执行或作为复制状态机方法的一部分。</p>
<ul>
<li><strong>机器层面的操作(machine-level operaitons)，或者说processor level / coputer level</strong></li>
</ul>
<p>这里对应的状态state是寄存器的状态、内存的状态，操作operation则是传统的计算机指令。这种级别下，复制状态机无感知应用程序和操作系统，只感知最底层的机器指令。</p>
<p>有一种传统的进行机器级别复制的方式，比如你可以额外购买机器/处理器，这些硬件本身支持复制/备份，但是这么做很昂贵。</p>
<p>这里讨论的论文(VM-FM论文)通过虚拟机(virtual machine, VM)实现。</p>
<h4 id="通过虚拟化实现复制">通过虚拟化实现复制</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/2024-11-29-Mit6-824%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-2.png" alt="alt text"></p>
<ul>
<li>
<p>虚拟化复制对应用程序透明，且能够提供很强的一致性。早期的VMware就是以此实现的，尽管现在新版可能有所不同。缺陷就是这篇论文只支持单核，不支持多核(multi-core)。或许后来的FT支持了，但应该不是纯粹通过复制状态机实现的，或许是通过状体转移实现的，这些都只是猜测，毕竟VMware没有透露后续产品的技术细节。</p>
</li>
<li>
<p><strong>我们先简单概览一下这个系统实现。</strong></p>
</li>
<li>
<p>首先有一个虚拟机控制器(virtual machine monitor)，或者有时也被称为hypervisor，在这论文中，对应的hypervisor即VM-FT。</p>
</li>
<li>
<p>当发生中断（比如定时器中断）时，作为hypervisor的VM-FT会接收到中断信号，此时它会做两件事：</p>
<ul>
<li><strong>通过日志通道将中断信号发送给备份计算机</strong>（sends it over a logging channel to a backup computer）</li>
<li><strong>将中断信号传递到实际的虚拟机，比如运行在guest space的Linux。</strong></li>
</ul>
</li>
<li>
<p>同理，当client向primary发送网络数据包packet时，primary所在的硬件产生中断，而VM-FT将同样的中断通过logging channel发送给backup computer（也就是另一个VM-FT），然后将中断发送到当前VM-FT上的虚拟机(比如Linux)。另一台backup的VM-FT上运行着和priamry相同的Linux虚拟机，其也会同样收到来自backup的VM-FT的中断信号。primary虚拟机Linux之后往虚拟网卡写数据，产生中断，同样VM-FT也会将中断往backup的VM-FT发送一份。最后就是primary上的Linux虚拟机和backup上的Linux虚拟机都往各自的虚拟网卡发送了数据，但是backup的VM-FT知道自己是backup备机，所以从虚拟网卡接收数据后什么也不会做，只有primary的VM-FT会真正往物理网卡写数据，响应client的请求。</p>
</li>
<li>
<p>论文中提到，在primary和backup两个VM-FT以外，假设还通过网络和外部一个storage存储保持通讯。外部storage通过一个flag记录primary和backup状态，记录谁是primary等信息。这个存储有两个作用：</p>
<ul>
<li><strong>首先他能够进行数据的存储</strong></li>
<li><strong>第二它能够在一定程度上防止脑裂的发生，因为它有一个flag标志，并且使用了testandset原理来保证flag的修改。</strong></li>
</ul>
</li>
<li>
<p>当primary和backup之间发生网络分区问题，而primary、backup仍可以与这个外部storage通信时，primary和backup互相会认为对方宕机了，都想把自己当作新的primary为外界的client提供服务。<strong>此时，原primary和原backup都试图通过test-and-set原子操作在外部storage修改flag记录（比如由0改成1之类的），谁先完成修改修改，谁就被外部storage认定为新的primary；而后来者test-and-set操作会返回1(test-and-set会返回旧值，这里返回1而不是0，表示已经有人领先自己把0改成1了)，其得知自己是后来者，会主动放弃称为primary的机会，在论文中提到会选择终结自己(terminate itself)。</strong></p>
</li>
</ul>
<p>test-and-set的伪代码如下:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">test-<span class="keyword">and</span>-<span class="keyword">set</span>():</span><br><span class="line">  <span class="function">acquire <span class="title">lock</span>()</span></span><br><span class="line"><span class="function">  <span class="keyword">if</span> flag</span> == <span class="number">0</span>:</span><br><span class="line">    flag = <span class="number">1</span>;</span><br><span class="line">    <span class="function">release <span class="title">lock</span>()</span></span><br><span class="line"><span class="function">    <span class="keyword">return</span> 0</span></span><br><span class="line"><span class="function">  <span class="keyword">else</span>:</span></span><br><span class="line"><span class="function">    release <span class="title">lock</span>()</span></span><br><span class="line"><span class="function">    <span class="keyword">return</span> 1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>虚拟机primary和backup都可能会失效，所以为了架构的高可用性，VMWare提出了一个技术FT VMotion，用来负责backup的创建。它能够直接对一个VM进行克隆，并且在完成克隆后会建立好和primary的Logging channel，被克隆一方是primary，另一个就是backup。根据协议，当backup启动完成备份时，flag就被重置为0。</li>
</ul>
<h4 id="差异来源">差异来源</h4>
<ul>
<li>
<p>如果前面primary执行的指令都是确定性的，那么primary和backup无疑可以保证拥有相同的状态。但是不可避免的是可能出现一些非确定性的事件，我们需要考虑如何处理。我们的<strong>目标即，将每一条非确定性的指令(non-deterministic instruction)变成确定性指令(deterministic instruction)</strong>。</p>
</li>
<li>
<p><strong>非确定性的指令(non-deterministic instruction)</strong></p>
<ul>
<li>比如获取时间的指令，我们不可能保证primary和backup都在同一时间执行，返回值一般来说会不同。</li>
</ul>
</li>
<li>
<p><strong>网络包接收/时钟中断(input packets / timer interrupters)</strong></p>
<ul>
<li>比如网络包输入时导致中断，primary和backup在原本CPU执行流中插入中断处理的位置可能不同。比如primary在第1～2条指令执行的位置插入网络包的中断处理，而backup在第2～3条指令执行的位置插入中断处理，这也有可能导致后续primary和backup的状态不一致。所以我们希望这里数据包产生的中断（或者时钟中断），在primary和backup相同的CPU指令流位置插入执行中断处理，确保不会产生不一致的状态。</li>
</ul>
</li>
</ul>
<p>那么它是怎么将<strong>非确定事件变为确定性事件的呢？</strong></p>
<p>答：解决这个问题是利用了<strong>日志</strong>。primary的所有确定性操作和不确定事件的所有状态都会记录在log entry流中，<strong>通过Logging channel发送给backup并使其replay。</strong></p>
<p><strong>举个例子，一个操作让 primary 生成一个随机数，那么 primary 会在日志中记录当前生成这个操作的所有状态，比如它是根据当前时间或者是当前某个时钟周期当作 seed，这些随机性全部由 hypervisor 来处理，backup 进行日志 replay 时，碰到这种随机性事件，hypervisor 让它执行的时候跟 primary 得出的结果一模一样</strong>，让两者在状态上没有差别，很了不起。</p>
<h4 id="VM-FT的中断处理">VM-FT的中断处理</h4>
<p>根据前面的讨论，可以知道中断是一个非确定性的差异来源，我们需要有机制保证primary和backup处理中断后仍保持状态一致。</p>
<p>​这里VM-FT是这样处理的，当接受到中断时，VM-FT能知道CPU已经执行了多少指令（比如执行了100条指令），并且计算一个位置（比如100），告知backup之后在指令执行到第100条的时候，执行中断处理程序。大多数处理器（比如x86）支持在执行到第X条指令后停止，然后将控制权返还给操作系统（这里即虚拟机监视器）。</p>
<p>​通过上面的流程，VM-FT能保证primary和backup按照相同的指令流顺序执行。当然，这里backup会落后一条message（因为primary总是领先backup执行完需要在logging channel上传递的消息）。</p>
<h4 id="VM-FT失败场景的处理">VM-FT失败场景的处理</h4>
<p>这里举例primary故障的场景:<br>
比如primary本来维护一个计数器为10，client请求将其自增到11，但是primary内部自增了计数器到11，但是响应client前正好故障了。如果backup此时接手，其执行完logging channel里要求同步的指令，但是自增到11这个并没有反映到bakcup上。如果client再次请求自增计数器，其会获取到11而不是12。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/2024-11-29-Mit6-824%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-3.png" alt="alt text"></p>
<ul>
<li>上述场景实际上不会发生，因为VM-FT定义了一个<strong>Output Rule</strong>。</li>
<li>为了保证上述要求，设计输出规则（如上图）：
<ol>
<li>primary<strong>在所有关于本次Output的信息都发送给backup后（并且要确保backup收到，backup会发送一个ACK），才会把output发送给外界。</strong></li>
<li>primary只是推迟将output发送给外界，不会暂停执行后面的任务（异步执行）。</li>
</ol>
</li>
</ul>
<p>如图，<strong>简单来说，就是primary收到一条信息，并且这条信息是需要回复的（即，要output），那么primary先会写日志并且传给backup，backup收到以后发送一个确认收到的ACK给primary，然后primary才会执行output。</strong></p>
<ul>
<li>但是，这种方法不能保证Exactly once（只发送一次），因为若primary在收到backup的ACK之后，已经发出了output，但是此时挂掉了，然后backup顶上去之后不能判断是否是在发送了output之后宕机的，所以它会再发一次。这个问题容易解决：
<ol>
<li>output是通过网络进行发送的，例如TCP之类的网络协议能够检测重复的数据包；</li>
<li>对于一个写操作，它就是两次在同一个位置写，也不影响结果。</li>
</ol>
</li>
</ul>
<h4 id="VM-FT性能问题">VM-FT性能问题</h4>
<p>因为VM-FT的操作都基于机器指令或中断的级别上，所以需要牺牲一定的性能。</p>
<p>论文中统计在primary/backup模式下运行时，性能和平时单机差异不会太大，保持在0.94~0.98的水平。而当网络输入输出流量很高时，性能下降很明显，下降将近30%。这里导致性能下降的原因可能是，primary处理大量数据包时，需要等待backup也处理完毕。</p>
<p>问题：如果primary宕机了几分钟，backup重新创建一个replica并通过test-and-set将storage的flag从0设置为1，自己成为新的primary。然后原primary又恢复了，这时候会怎么样？</p>
<p>回答：原primary会被clean，terminate自己。</p>
<p>问题：处理大量网络数据包时，primary只会等待backup确认第一个数据包吗？</p>
<p>回答：不是，primary每处理一个数据包，都会通过logging channel同步到backup，并且等待backup返回ack。满足了输出规则(output rule)之后，primary才会发出响应。这里它们有一些方法让这个过程尽量快。</p>
<p>问题：关于logging channel，我看论文中提到用UDP（发送心跳会用这个）。那如果出现故障，某个packet没有被确认，primary是不是直接认为backup失败，然后不会有任何重播？</p>
<p>回答：不是。因为有定时器中断，定时器中断大概每10ms左右触发一次。如果有包接受失败，primary会在心跳中断处理时尝试重发几次给backup，如果等待了可能几秒了还是有问题，那么可能直接stop停止工作。</p>
<h3 id="错误容忍-Raft算法">错误容忍-Raft算法</h3>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/488916891">Raft 协议原理详解，10 分钟带你掌握！</a><br>
<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1so4y1r7eM?spm_id_from=333.788.videopod.sections&amp;vd_source=772b61fb408cdf9169f726ab21790987">Raft算法讲解视频</a></p>
</blockquote>
<h4 id="单点故障">单点故障</h4>
<p>前面介绍过的复制系统，都存在单点故障问题(single point of failure)。</p>
<ul>
<li>mapreduce中的cordinator</li>
<li>GFS的master</li>
<li>VM-FT的test-and-set存储服务器storage</li>
</ul>
<p>而上诉的方案中，采用单机管理而不是采用多实例/多机器的原因，是为了避免**脑裂(split-brain)**问题。</p>
<p>​不过大多数情况下，单点故障是可以接受的，因为单机故障率显著比多机出现一台故障的概率低，并且重启单机以恢复工作的成本也相对较低，只需要容忍一小段时间的重启恢复工作。</p>
<h4 id="脑裂问题">脑裂问题</h4>
<ul>
<li>定义：是指在分布式系统中，由于网络分区或其他故障导致集群中的节点无法相互通信，进而形成多个独立的子集（通常是两个），每个子集都认为自己是唯一的集群。 这种情况可能导致数据的不一致性、系统的不可用性和其他严重问题</li>
</ul>
<p>Raft是避免单点故障问题的一种方案，在介绍Raft之前，<strong>我们要知道单机管理的某些协议在多机下是如何产生脑裂问题的</strong>，体会下为什么必须需要比这些协议更加严谨的协议</p>
<p>以VM-FT的test-and-set存储服务器storage举例。假设我们复制storage服务器，使其有两个实例机器S1、S2。（即打破单机管理的场景，看看简单的多机管理下有什么问题）</p>
<p>假设此时C1想要争取称为Primary，于是向S1和S2都发起test-and-set请求。假设因为某种原因，S2没有响应，S1响应，成功将0改成1，此时C1可能直接认为自己成为Primary。</p>
<p>这里S2没有响应可以先简单分析两种可能：</p>
<ol>
<li>
<p><strong>S2失败/宕机了，对所有请求方都无法提供服务</strong><br>
如果是这种情况，那么C1成为Primary不会有任何问题，S2就如同从来不曾存在，任何其他C同样只能访问到S1，他们都会知道自己无法成为Primary，并且整个系统只会存在C1作为Primary。</p>
</li>
<li>
<p><strong>S2和C1之间产生了网络分区(network partition)，仅C1无法访问到S2</strong></p>
</li>
</ol>
<p>这时候如果存在C2也向S1和S2发出请求，此时S1虽然将0改成1会失败，但是S2会成功。<strong>如果我们的协议不够严谨，这里C2会认为自己成为了Primary，导致整个系统存在两个Primary。这也就是严重的脑裂问题。</strong></p>
<ul>
<li><strong>产生这种问题的原因在于，对于请求方，无法简单地判断上诉两种情况，因为对他们来说两种情况的表现都是一样的。</strong></li>
</ul>
<p>因此，为避免出现脑裂，我们需要先<strong>解决网络分区问题</strong>。</p>
<h4 id="Raft采取的的原则-大多数原则">Raft采取的的原则:大多数原则</h4>
<p>诸如Raft一类的协议用于解决单点故障问题，同时也用于解决网络分区问题。这类解决方案的基本思想即：大多数原则(majority rule)，<strong>简单理解就是少数服从多数（获取票数多于一半）</strong>。</p>
<h5 id="为什么这个原则会作为基本思想">为什么这个原则会作为基本思想</h5>
<ul>
<li>我们来看看这个原则可以解决一些什么问题</li>
</ul>
<p>就那我们上一个举例来扩展，我们假设storage服务一共有三个实例，S1、S2、S3。</p>
<p>此时C1同时向S1、S2、S3请求test-and-set，其中S1和S2成功将0改成1，S3因为其他问题没有响应，但是我们不关系为什么。这里按照majority rule，只要3个S中有2个给出成功响应，我们就认为C1能够成为Primary。此时就算同时有C2向S1、S2、S3发起请求，就算S3成功了，C2根据majorty rule，3台只成功1台，不能成为Primary。<br>
<strong>这样就解决了脑裂问题，因为只有C1能够成为Primary，而C2只能访问到S1，S2。</strong></p>
<p>在之后准备介绍的Raft，和这里描述的工作流程基本一致。</p>
<ul>
<li>在majority rule下，尽管发生网络分区，只会一个拥有多数的分区，不会有其他分区具有多数，只有拥有多数的分区能继续工作（比如这里3台被拆成1台、2台的分区，只有和后者成功通信的能继续工作）。</li>
<li>而如果极端情况下所有分区都不占多数（ 比如这里3台被拆成1台、1台、1台的分区），那么整个系统都不能运行。</li>
</ul>
<p>上诉3台的场景，只能容忍1台宕机，如果宕机2台，那么任何人都无法达到majorty的情况。<strong>这里通过2f+1拓展可容忍宕机的机器数，f表示可容忍宕机的机器数量。2f+1，即使宕机了f台，剩下的f+1&gt;f，仍然可以组成majority完成服务。</strong></p>
<p>例如，当f=2时，表示系统内最多可容忍2台机器处于宕机状态，那么至少需要部署5台服务器（2x2+1=5）。</p>
<h4 id="raft历史发展">raft历史发展</h4>
<ul>
<li>
<p>在1980s～1990s，基本不存在诸如majority的协议，所以一直存在单点故障的问题。</p>
</li>
<li>
<p>在1990s出现了两种被广泛讨论协议，但是由于当时的应用没有自动化容错的需求，所以基本没有被应用。但近15年来(2000s~2020s)大量商用产品使用到这些协议：</p>
<ol>
<li>Paxos</li>
<li>View-Stamped replication (也被称为VR)</li>
</ol>
</li>
</ul>
<blockquote>
<p>附上Paxos算法的相关讲解文章: <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/31780743">Paxos算法详解</a></p>
</blockquote>
<ul>
<li>我们将要讨论的是Raft，大概在2014左右有相关的论文，它应用广泛，你可以用它来实现一个完全复制状态机(complete replicated state machine)。</li>
</ul>
<h4 id="使用Raft构造复制状态机">使用Raft构造复制状态机</h4>
<p>系统正常工作时，大致流程如下：</p>
<ol>
<li>Client向3台机器中作为leader的机器发查询请求</li>
<li>leader机器将接收到的请求记录到底层raft的顺序log中</li>
<li>当前leader的raft将顺序log中尾部新增的log记录通过网络同步到其他2台机器</li>
<li>其他两台K/V机器的raft成功追加log记录到自己的顺序log中后，回应leader一个ACK</li>
<li>leader的raft得知其他机器成功将log存储到各自的storage后，将log操作反映给自己的K/V应用，执行这个操请求，并且设为了提交状态</li>
<li>K/V应用实际进行K/V查询，并且将结果响应给Client，之后就会通知其他群众提交状态，以保持同步</li>
</ol>
<p>系统出现异常时，发生如下事件：</p>
<ol>
<li>Client向leader请求</li>
<li>leader向其他2台机器同步log并且获得ACK</li>
<li>leader准备响应时突然宕机，无法响应Client</li>
<li>其他2台机器重新选举出其中1台作为新的leader</li>
<li>Client请求超时或失败，重新发起请求，系统内部failover故障转移，所以这次Client请求到的是新leader</li>
<li>新leader同样记录log并且同步log到另一台机器获取到ACK</li>
<li>新leader响应Client</li>
</ol>
<p>这里可以想到的是，剩下存活的两台机器的log中会有<strong>重复请求</strong>，而我们需要能够检测(detect)出这些重复请求。</p>
<p>问题：访问leader的client数量通常是多少？</p>
<p>回答：我想你的疑问是系统只有1个leader的话，那能承受多少请求量。实际上，具体的系统设计还会采用shard将数据分片到多个raft实例上，每个shard可以再有各自的leader，这样就可以平均请求的负载到其他机器上了。</p>
<p>问题：旧leader宕机后，client怎么知道要和新leader通信？</p>
<p>回答：client中有系统中所有服务器的访问列表，这里举例中有3个服务器。当其中一台请求失败时，client会重新随机请求3台中的1台，直到请求成功。</p>
<h4 id="Raft概述">Raft概述</h4>
<p>首先我们要知道Raft的几个重要角色：</p>
<ol>
<li>Leader：Raft协议中，每个副本(replica)都有可能成为Leader，Leader负责处理客户端的请求，并将其转发给其他副本。Leader在Raft中扮演着重要的角色，它负责将客户端请求转发给其他副本，并在必要时进行日志的复制。</li>
<li>Candidate：Raft协议中，当Leader出现故障时，会选举出一个新的Leader。在Raft中，Candidate扮演着重要的角色，它会向其他副本发送请求，询问是否可以成为新的Leader。</li>
<li>Follower：Raft协议中，Follower是Raft中最基本的角色，它只负责接收Leader的日志，并将其提交到自己的存储中。Follower在Raft中扮演着重要的角色，它负责接收Leader的日志，并将其提交到自己的存储中。</li>
</ol>
<p>然后在进行选举过程中，还有几个重要的概念：</p>
<ol>
<li>Leader Election（领导人选举）：简称选举，就是从候选人中选出领袖；</li>
<li>Term（任期）：它其实是个单独递增的连续数字，每一次任期就会重新发起一次领导人选举；</li>
<li>Election Timeout（选举超时）：就是一个超时时间，当群众超时未收到领袖的心跳时，会重新进行选举。</li>
</ol>
<p>接下来我们重新描述下Raft的工作流程（此时已经有一个leader,另外两台为follower）：</p>
<ol>
<li>客户端向Leader发送请求；</li>
<li>Leader将请求记录到log尾部，并将其转发给其他的fllower；</li>
<li>Follower接收到Leader的请求后，将其记录到自己的log中，然后会回复Leader一个ACK；</li>
<li>此时leader和follower1共2台机器成功追加log，达到majority（必须符合大多数原则），于是leader可以进行commit，将操作移交给上层的kv服务。（这里即使宕机了一台，之后重新选举，包含最后操作的服务器将当选成为新的leader，比如原leader或follower1将当选，所以服务能继续正常提供）</li>
<li>leader将log提交到自己的存储中commit后响应Client，完成一次请求，并且会发请求给所有的follower，让他们也进行commit。</li>
</ol>
<p>问题：如果log从leader同步到其他follower时，leader宕机了，会怎么样？</p>
<p>回答：会重新发生选举，而拥有<strong>最新操作</strong>log的机器成为新leader后会将追加的log条目传递给其他follower，这样就保证这些机器都拥有最新的log了</p>
<h4 id="Raft-log的用途">Raft log的用途</h4>
<ol>
<li>重传:leader向follower同步消息时，消息可能传递失败，所以需要log记录，方便重传</li>
<li><strong>顺序执行: 我们需要被同步的操作，以相同的顺序出现在所有的replica上</strong></li>
<li>持久化(persistence)：持久化log数据，才能支持失败重传，重启后日志恢复等机制</li>
<li><strong>试探性操作(space tentative)</strong>：比如follower接收到来自leader的log后，并不知道哪些操作被leader提交了，可能等待一会直到明确操作被commit了才进行后续操作。我们需要一些空间来做这些试探性操作(tentative operations)，而log很合适。</li>
</ol>
<p>​ <strong>尽管中间有些时间点，可能有些机器的log是落后的。但是当一段时间没有新log产生时，最终这些机器的log会同步到完全相同的状态(logs identical on all servers)</strong>。并且因为这些log是有顺序的，意味着上层的kv服务最终也会达到相同的状态。</p>
<h4 id="Raft的log格式">Raft的log格式</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/2024-11-29-Mit6-824%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-4.png" alt="alt text"></p>
<p>每一个日志条目一般包括三个属性：整数索引Log Index、任期号Term和指令Commond。每个条目所包含的“整数索引”即该条目在日志文件中的槽位，“任期号”对应到图中就是每个方块中的数字，用于检测在不同服务器上日志的不一致问题，指令即用于被状态机执行的外部命令，图中就是带箭头的数字。</p>
<h4 id="Raft的选举">Raft的选举</h4>
<h5 id="情况1-：集群中没有leader">情况1 ：集群中没有leader</h5>
<p>我们假设一共有五个节点，每个节点的初始状态都是follower，它们都有着不同的超时时间，terms技术为1<br>
Raft的选举过程如下：</p>
<ol>
<li>首先，等待一段时间，直至五个节点有一个节点超时了，然后超时的节点会变成candidate，并投自己一票，再向其他节点发送投票请求，并且会执行terms + 1；</li>
<li>由于此时只有一个候选人，所以其他节点都选了赞成票，票数大于集群个数的一半，于是候选节点变成了leader</li>
<li>成为leader后会不断向follower发送心跳</li>
</ol>
<h5 id="情况2-：集群中有leader，并且leader宕机了">情况2 ：集群中有leader，并且leader宕机了</h5>
<h6 id="此时只有一个节点变味了候选节点">此时只有一个节点变味了候选节点</h6>
<ol>
<li>其他follower由于没有收到leader的心跳，会一直等待，知道自己的超时时间超时，于是超时的节点就会成为候选人，发起新一轮竞选</li>
<li>后续操作和情况一类似就不赘述了</li>
</ol>
<h6 id="有两个候选人同时竞选（选举条件）">有两个候选人同时竞选（选举条件）</h6>
<p><em><strong>follower投给哪个候选人取决于Term（任期）更高的人，如果任期相同就会投给日志最新的人，如果日志都相同了，就先到先得</strong></em></p>
<ul>
<li><strong>未出现投票分裂</strong></li>
</ul>
<ol>
<li>两个候选人都会先给自己投一票，然后向其他节点发送投票请求（即使接受节点宕机），并且会执行terms + 1；</li>
<li>候选人之间会互投反对票，follower会根据一个上述规则投给一个候选人</li>
<li>其中一位候选人得到了超过半数的票，成为leader，并开始不断向follower发送心跳</li>
</ol>
<ul>
<li><strong>出现投票分裂</strong></li>
</ul>
<ol>
<li>两个候选人都会先给自己投一票，然后向其他节点发送投票请求（即使接受节点宕机），并且会执行terms + 1；</li>
<li>候选人之间会互投反对票，follower会根据一个上述规则投给一个候选人</li>
<li>此时假设票数相同都为两票，就出现了投票分裂</li>
<li>又可以分为两种情况：
<ul>
<li>假设此时另外一个follower先超时，将term + 1，由于这个新term大于其他两个候选人的term，所以其他候选人会给他投赞成票，于是他就成为leader</li>
<li>假设此时两个候选人同时超时，又会发送新一轮选举，然后继续循环等待，（为了避免这个情况，Raft在设计时会将选举超时时间设为一个随机值（150ms到300ms之间），避免所有节点同时超时，先到的也会先获得赞成票），直至打破循环</li>
</ul>
</li>
<li>新leader开始不断向follower发送心跳</li>
</ol>
<h4 id="Raft的选举超时时间">Raft的选举超时时间</h4>
<p>选举超时的时间，应该设置成大概多少才合适？</p>
<ul>
<li><strong>略大于心跳时间(&gt;= few heartbeats)</strong></li>
</ul>
<p>如果选举超时比心跳还短，那么系统将频繁发起选举，而选举期间系统对外呈现的是阻塞请求，不能正常响应client。因为election时很可能丢失同步的log，一直频繁地更新term，不接受旧leader的log（旧leader的term低于新term，同步log消息会被拒绝）</p>
<ul>
<li><strong>加入一些随机数(random value)</strong></li>
</ul>
<p>加入适当范围的随机数，能够避免无限循环下去的<strong>分裂选举(split vote)问题</strong>。random value越大，越能够减少进行split vote的次数，但random value越大，也意味着对于client来说，整个系统停止提供对外服务的时间越长（对外表现和宕机差不多，反正选举期间无法正常响应client的请求）</p>
<ul>
<li><strong>尽量短(short enough that down time is short)</strong></li>
</ul>
<p>因为选举期间，对外client表现上如同宕机一般，无法正常响应请求，所以我们希望eleciton timeout能够尽量短</p>
<p>​Raft论文进行了大量实验，以得到250ms～300ms这个在它们系统中的合理值作为eleciton timeout。</p>
<h4 id="Raft-vote需记录到稳定的storage（持久化）">Raft-vote需记录到稳定的storage（持久化）</h4>
<ul>
<li>这里提一个选举中的细节问题。假设还是leader宕机，follower1和follower2中的follower1发起选举。follower1会先vote自己，然后发起拉票请求希望follower2投票自己。</li>
</ul>
<p>​- 这里follower1应该用一个稳定的storage记录自己的vote历史记录，有人知道为什么吗？原因是避免重复vote。假设follower1在vote自己后宕机一小段时间后恢复，我们需要避免follower1又vote自己一次，不然follower1由于vote过自己两次，直接就可以无视其他follower的投票认为自己成为了leader。</p>
<p>​<em><strong>所以，为了保证每个term，每个机器只会进行一次vote行为，以保证最后只会产生一个leader，每个参选者都需要用稳定的storage记录自己的vote行为。</strong></em></p>
<p>问题：这里需要记录vote之前当前机器自身是follower、leader或者candidate吗？<br>
答：需要</p>
<h4 id="Raft-日志">Raft-日志</h4>
<p>首先说明下集中图形代表啥：</p>
<ol>
<li>虚线代表日志未提交<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/2024-11-29-Mit6-824%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-5.png" alt="alt text"></li>
<li>箭头代表下一索引，圆圈代表日志提交成功的索引下标<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/2024-11-29-Mit6-824%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-6.png" alt="alt text"></li>
<li></li>
</ol>
<h5 id="Raft算法的日志复制过程">Raft算法的日志复制过程</h5>
<p>假设起始情况如下图：<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/2024-11-29-Mit6-824%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-7.png" alt="alt text"></p>
<ol>
<li>leader会向其他follower发送日志更新请求</li>
<li>S2收到日志并写入本地，然后s1继续发送直至s2与s1一致<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/2024-11-29-Mit6-824%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-8.png" alt="alt text"></li>
<li>由于只收到一个follower的回复，所以现在还不能提交日志，此时S3恢复</li>
<li>leader节点会先进行日志探测，寻找S3日志第一个不符位置，然后向S3发送日志同步请求</li>
<li>S3收到第一条日志写入本地并发送确认，leader接收到确认后由于缓存日志的节点数超过了一半，所以提交了第一个日志<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/2024-11-29-Mit6-824%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-9.png" alt="alt text"></li>
<li>S3收到第二条复制日志后，会把第一条提交，并发送确认，leader收到确认后提交第二条日志<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/2024-11-29-Mit6-824%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-10.png" alt="alt text"></li>
<li>leader继续发送第三条复制日志请求，并且会向S2发送日志提交请求（心跳信息），S2会一次性提交2条日志<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/2024-11-29-Mit6-824%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-11.png" alt="alt text"></li>
<li>leader提交第三条日志，并通知其他两个节点提交第三条日志<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/2024-11-29-Mit6-824%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-12.png" alt="alt text"></li>
</ol>
<h5 id="Raft-日志分歧">Raft-日志分歧</h5>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://mit-public-courses-cn-translatio.gitbook.io/mit6-824/lecture-07-raft2/7.2-xuan-ju-yue-shu-election-restriction">选举约束</a><br>
如果你去看处理RequestVote的代码和Raft论文的图2，当某个节点为候选人投票时，节点应该将候选人的任期号记录在持久化存储中。（换言之，就算当前server的term记录落后于其他server，也可以通过通信知道下一次选举term值应该是多少，比如S1的term为5，但是S2的term为7，S1下次选举时也知道要从term8开始，而不是term6）</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/2024-11-29-Mit6-824%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-13.png" alt="alt text"></p>
<ul>
<li>根据上述图片我们可以分析出<br>
a 的 term以及index是 6, 9<br>
b 的 term以及index是 4, 4<br>
c 的 term以及index是 6, 11<br>
d 的 term以及index是 7，12<br>
e 的 term以及index是 4， 7<br>
f 的 term以及index是 3，11</li>
</ul>
<p>我们可以知道可能成为候选人的分别是a, c, d 因为他们可以得到超过半数的票<br>
因为他们发起候选人投票的</p>
<h5 id="Raft选举规则">Raft选举规则</h5>
<p><em><strong>首先一个候选人发起选举时，调用的RequestVote RPC携带的参数分别是最新的term，该节点最后一条条目的term和index（不管有没有提交），follower接收到这些信息的时候，是拿自己日志中最后一个term和index与收到的term和index进行比较的。不管此日志条目是否提交</strong></em></p>
<p>有两个规定：</p>
<ol>
<li><strong>候选人的term如果大于投票者的最后一个日志条目的任期就投赞成票</strong></li>
<li><strong>如果任期相同则看候选人最后一个日志条目的下标索引是不是更大，是的话就投赞成票</strong></li>
</ol>
<ul>
<li>majority：大多数原则，即至少获取整个系统内大于全部机器数量一半的选票（包括自己，且每人只能投一次票，**宕机的机器也算在系统机器总数内。**如果剩余机器数压根凑不到刚好大于一半的机器数，则没有人能够成功获选）</li>
<li><strong>at-least-up-to-date：能当选的机器一定是具有最新term的机器</strong>（因为 Raft 选举过程中要求的是日志“至少”一样新，而不是严格“必须”拥有最高任期的日志。）</li>
</ul>
<h5 id="Raft-日志覆写同步（未优化版本）">Raft-日志覆写同步（未优化版本）</h5>
<ul>
<li>一共有两个指针，分别是:
<ol>
<li><strong>nextIndex</strong>：所有raft节点都维护nextIndex<strong>乐观的</strong>变量用于记录<strong>下一个需要填充log entry的log index</strong>。这里说乐观，因为<strong>当leader当选时，leader会初始化nextIndex值为当前log index值+1</strong>，表示认为<strong>leader自身的log一定是最新的</strong></li>
<li><strong>matchIndex</strong>：leader为所有raft节点(包括leader自己)维护一个<strong>悲观的</strong>matchIndex用于记录<strong>leader和其他follower从0开始往后最长能匹配上的log index的位置+1</strong>，表示<strong>leader和某个follower在matchIndex之前的所有log entry都是对齐的</strong>。这里说悲观，<strong>因为leader当选时，leader会初始化matchIndex值为0</strong>，表示认为自身log中没有一条记录和其他follower能匹配上。随着leader和其他follower同步消息时，matchIndex会<strong>慢慢增加</strong>。leader为每个自己的follower维护matchIndex，因为平时根据majority规则，需要保证log已经同步到足够多的followers上。</li>
</ol>
</li>
</ul>
<p>假设这里有S1～S3三台服务器组成Raft集群，每个Server的log记录如下，(X, Y)表示在log index X有log entry term=Y的log记录：</p>
<ul>
<li>S1：(10, 3)</li>
<li>S2：(10, 3); (11, 3); (12, 5)</li>
<li>S3：(10, 3); (11, 3); (12, 4)</li>
</ul>
<p>这里可以看出来S2是term5的leader。</p>
<p>这里S2通过heartbeats流程顺带发起log catch up，即想要和其他followers同步log entry的整体记录情况，按照majority原则，只需要向除了自身外的一台服务器发送消息即可，这里假设向S3发请求。</p>
<ol>
<li>
<p>S2向S3，发送heartbeat，携带信息（当前nextIndex指向的term，nextIndex-1的term值，nextIndex-1值），即(空，5，12)</p>
</li>
<li>
<p>S3收到后，检查自己的log发现自己log index12为term4，回复S2一条否定消息no，表明自己还存活，但是不能同意S2要求的append操作，因为S3自己发现自己的log落后了。</p>
</li>
<li>
<p>S2看到S3的否定回应后，认为S3落后于自己，于是将自己的nextIndex从13改成12</p>
</li>
<li>
<p>S2重新发一条请求到S3，这次nextIndex是12，所以携带信息(5, 3, 11)</p>
</li>
<li>
<p>S3接收到后，检查自己log index11的位置为3，发现和S2说的一样，于是按照S2的log记录，在自己log index12的位置将term4改成term5，然后回复S2一条确定消息ok</p>
</li>
<li>
<p>S2收到来自S3的ok后，认为S3这次通信后log和自己对齐是最新的了</p>
</li>
<li>
<p>S2将自己维护的对应S3的matchIndex更新为13，表示log index13之前的log entry，作为leader的S2和作为follower的S3是对齐的</p>
</li>
</ol>
<p>到这里为止，S2能够知道log index12的log entry term5至少在2个server上得到复制(S2和S3)，已经满足了majority原则了，所以S2能将消息传递到上层应用了。不幸的是，这不完全是对的。下面会讨论为什么。</p>
<p>这里未优化的版本有个很大的问题，那就是如果Raft集群中出现log落后很多的server，leader需要进行很多次请求才能将其log与自己对齐。</p>
<h5 id="Raft-日志擦除">Raft-日志擦除</h5>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://vearne.cc/archives/1851">聊聊RAFT的一个实现(4)–NOPCommand</a><br>
<a target="_blank" rel="noopener" href="https://www.cnblogs.com/xybaby/p/10124083.html#_label_7">对下面这句话的解释</a></p>
</blockquote>
<p><strong>也就是说，某个leader选举成功之后，不会直接提交前任leader时期的日志，而是通过提交当前任期的日志的时候“顺手”把之前的日志也提交了，具体怎么实现了，在log matching部分有详细介绍。那么问题来了，如果leader被选举后没有收到客户端的请求呢，论文中有提到，在任期开始的时候发立即尝试复制、提交一条空的log</strong></p>
<h5 id="Raft-日志快速覆写同步">Raft-日志快速覆写同步</h5>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/2024-11-29-Mit6-824%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-14.png" alt="alt text"></p>
<p>如果通过前面&quot;7.2 Log catch up(unoptimized)&quot;流程，可知道假设S2要向S1同步历史log的记录，那么需要从log index5（nextIndex=6）开始请求，一直请求到log index1（nextIndex=2）的位置后，才能找到S2和S1对齐的第一个位置log index1，然后又以1log index为单位，一直同步到nextIndex=6为止。这显然很浪费网络资源。</p>
<p>这里Log catch up quickly在论文中没有很详细的描述，但是大致流程如下：</p>
<ul>
<li>S2假设在term7当选leader，于是nextIndex=6，如之前一样，向S1发送heartbeat时携带log同步信息，(空，6，5)，对应（当前nextIndex指向的term，nextIndex-1的term，nextIndex-1值）</li>
<li>S1收到后，对比自己logIndex5位置为term5。此时S1不再是简单返回no，还顺带回复自己的log信息（即请求中logIndex位置的term值，这个term值最早出现的logIndex位置），这里S1回复（5，2），表示S2heartbeat中说的logIndex5位置自己是term5不对齐，并且term5的值在自己log可追溯到logIndex2</li>
<li>S2收到回应后，可以直接将nextIndex改成2，并且下次heartbeat携带的信息变成（[6,6,6,6], 4, 1），表示nextIndex即往后的数据为[6,6,6,6]</li>
<li>S1收到heartnbeat后，发现logIndex1是term4是对齐的，于是按照S2说的，将logIndex2开始往后的共4个位置替换成[6,6,6,6]。</li>
</ul>
<p>当然也可以使用更高级的方法，比如二分来优化，上述流程只是一种方法，意思大概就是一次性<strong>否定匹配当前不匹配term第一个出现的位置</strong></p>
<h5 id="Raft-持久化">Raft-持久化</h5>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://mit-public-courses-cn-translatio.gitbook.io/mit6-824/lecture-07-raft2/7.4-chi-jiu-hua-persistent">持久化</a><br>
Log需要被持久化存储的原因是，这是唯一记录了应用程序状态的地方。Raft论文图2并没有要求我们持久化存储应用程序状态。假如我们运行了一个数据库或者为VMware FT运行了一个Test-and-Set服务，根据Raft论文图2，实际的数据库或者实际的test-set值，并不会被持久化存储，只有Raft的Log被存储了。所以当服务器重启时，唯一能用来重建应用程序状态的信息就是存储在Log中的一系列操作，所以Log必须要被持久化存储。</p>
<p>那currentTerm呢？为什么currentTerm需要被持久化存储？是的，currentTerm和votedFor都是用来确保每个任期只有最多一个Leader。在一个故障的场景中，如果一个服务器收到了一个RequestVote请求，并且为服务器1投票了，之后它故障。如果它没有存储它为哪个服务器投过票，当它故障重启之后，收到了来自服务器2的同一个任期的另一个RequestVote请求，那么它还是会投票给服务器2，因为它发现自己的votedFor是空的，因此它认为自己还没投过票。现在这个服务器，在同一个任期内同时为服务器1和服务器2投了票。因为服务器1和服务器2都会为自己投票，它们都会认为自己有过半选票（3票中的2票），那它们都会成为Leader。现在同一个任期里面有了两个Leader。这就是为什么votedFor必须被持久化存储。</p>
<p>currentTerm的情况要更微妙一些，但是实际上还是为了实现一个任期内最多只有一个Leader，我们之前实际上介绍过这里的内容。如果（重启之后）我们不知道任期号是什么，很难确保一个任期内只有一个Leader。</p>
</blockquote>
<p>我们这里主要考虑Reboot重启时发生/需要做的事情。</p>
<ul>
<li>
<p>策略1：一个Raft节点崩溃重启后，必须重新加入Raft集群。即对于整个Raft集群来说，重启和新加入Raft节点没有太大区别</p>
<ul>
<li>重新加入(re-join)，重新加入Raft集群</li>
<li>重放日志(replay the log)，需要重新执行本地存储的log（我理解上只有未commit的需要重放，当然如果不能区分哪些commit的话，那就是所有现存log需要重放）</li>
</ul>
</li>
</ul>
<p>策略2：快速重启(start from your persistence state)，从上一次存储的持久化状态(快照)的位置开始工作，后续可以通过log catch up的机制，赶上leader的log状态</p>
<p>人们更偏向于策略2，快速重启。这就需要搞清楚，需要持久化哪些状态。</p>
<p>Raft持久化以下状态state：</p>
<ul>
<li>vote for：投票情况，因为需要保证每轮term每个server只能投票一次</li>
<li>log：崩溃前的log记录，因为我们需要保证(promise)已发生的(commit)不会被回退。否则崩溃重启后，可能发生一些奇怪的事情，比如client先前的请求又重新生效一次，导致某个K/V被覆盖成旧值之类的。</li>
<li>current term：崩溃前的当前term值。因为选举(election)需要用到，用于投票和拉票流程，并且<strong>需要保证单调递增</strong>(monotonic increasing)</li>
</ul>
<p>问题：什么时候，server决定进行持久化的动作呢？</p>
<p>回答：<strong>每当上面提到的需要持久化的变量state发生变化时，都应该进行持久化</strong>，写入稳定存储(磁盘)，即使这可能是很昂贵的操作。你必须<strong>保证在回复client或者leader的请求之前，先将需要持久化的数据写入稳定存储</strong>，然后再回复。否则如果先回复，但是持久化之前崩溃了，你相当于丢失了一些无法找回的记录。</p>
<h5 id="Raft-服务恢复">Raft-服务恢复</h5>
<p>类似的，服务重启恢复时有两种策略：</p>
<ul>
<li>日志重放(replay log)：理论上将log中的记录全部重放一遍，能得到和之前一致的工作状态。这一般来说是很昂贵的策略，特别是工作数年的服务，从头开始执行一遍log，耗时难以估量。所以一般人们不会考虑策略1。</li>
<li><strong>周期性快照(periodic snapshots)</strong>：假设在i的位置创建了快照，那么可以裁剪log，只保留i往后的log。此时重启后可以通过snapshot快照先快速恢复到某个时刻的状态，然后后续可以再通过log catch up或其他手段，将log同步到最新状态。（一般来说周期性的快照不会落后最新版本太多，所以恢复工作要少得多）</li>
</ul>
<p>这里可以扩展考虑一些场景，比如Raft集群中加入新的follower时，可以让leader将自己的snapshot传递给follower，帮助follower快速同步到近期的状态，尽管可能还是有些落后最新版本，但是根据后续log catch up等机制可以帮助follower随后快速跟进到最新版本log。</p>
<p>使用快照时，需要注意几点：</p>
<ol>
<li>需要拒绝旧版本的快照：有可能收到的snapshot比当前服务状态还老</li>
<li>需要保持快照后的log数据：在加载快照时，如果有新log产生，需要保证加载快照后这些新产生的log能够能到保留</li>
</ol>
<h5 id="线性一致性">线性一致性</h5>
<p>在论文中对整个系统提供的服务的正确性称为<strong>线性一致性(Linearizability)</strong>，线性一致性需要保证满足一下三个条件：</p>
<ol>
<li>
<p><strong>整体操作顺序一致(total order of operations)</strong><br>
即使操作实际上并发进行，你仍然可以按照整体顺序对它们进行排序。（即后续可以根据读写操作的返回值，对所有读写操作整理出一个符合逻辑的整体执行顺序）</p>
</li>
<li>
<p><strong>实时匹配(match real-time)</strong><br>
顺序和真实时间匹配，如果第一个操作在第二个操作开始前就完成，那么在整体顺序中，第一个操作必须排在第二个操作之前(换言之如果这么排序后，整体的执行结果不符合逻辑，那么就不符合&quot;实时匹配&quot;)。</p>
</li>
<li>
<p><strong>读操作总是返回最后一次写操作的结果(read return results of last write)</strong></p>
</li>
</ol>
<p><strong>问题：这里说的线性一致性，是不是就是人们说的强一致性？</strong></p>
<p><strong>回答：是的。一般直觉就是表现上像单机，而技术文献中准确定义称为线性一致性。</strong></p>
<p>问题：人们为什么决定定义这个property？（指，线性一致性这个概念为啥会被定义出来）</p>
<p>回答：比如你希望多机系统对外表现如同单机一样，线性一致性就是非常直观的定义。数据库世界中有类似的术语，叫做<strong>可串行化(serializability)</strong>。基本上<strong>线性一致性和可串行化的唯一区别是，可串行化不需要实时匹配(match real-time)</strong>。当然，人们对强一致性有不同定义，而我们这里认为线性一致性就是一种强一致性。</p>
<p>问题：可以稍微详细一点介绍clerk吗？</p>
<p>回答：clerk是一个RPC库，它可以帮助记录请求的RPC服务器列表。比如它认为server1是leader，于是Client发请求时，通过clerk会发送到server1，如果server1宕机了，也许clerk根据维护的server列表，会尝试将Client的请求发送到server2，猜测server2是leader。并且clerk会标记每次请求(get、put等)，生成请求id，可以帮助server服务检测重复的请求。</p>
<p>问题：论文12页中提到follower擦除旧log，但是不能回滚状态机，是吗？</p>
<p>回答：正如前面日志擦除所说，<strong>Raft可以擦除未提交(uncommitted)的log。</strong></p>
<p><strong>问题：server加载snapshot的时候，怎么保证后续还可以接收新的log</strong></p>
<p><strong>回答：可以在加载snapshot之前，先通过COW写时复制的fork创建子进程，子进程加载snapshot，而父进程继续提供服务，例如获取新的log之类的。因为子进程和父进程共享同样的物理内存，所以后续总有办法使得加载完snapshot的子进程获取父进程这段时间内新增的log。</strong></p>
<p>问题：当生成snapshot且因此压缩/删除旧log后，sever维护的log index是从0开始，还是在原本的位置继续往后？</p>
<p>回答：从原本的位置继续往后，不会回退log index索引。</p>
</article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>Mit6.824学习笔记</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://pigcanstudy.github.io/posts/abaf39bf.html">https://pigcanstudy.github.io/posts/abaf39bf.html</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>PigCanStudy</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2024-11-29</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2024-11-29</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"><div class="tags-punctuation"><svg class="faa-tada icon" style="height:1.1em;width:1.1em;fill:currentColor;position:relative;top:2px;margin-right:3px" aria-hidden="true"><use xlink:href="#icon-sekuaibiaoqian"></use></svg></div>分布式</a><a class="post-meta__tags" href="/tags/MIT6-824/"><div class="tags-punctuation"><svg class="faa-tada icon" style="height:1.1em;width:1.1em;fill:currentColor;position:relative;top:2px;margin-right:3px" aria-hidden="true"><use xlink:href="#icon-sekuaibiaoqian"></use></svg></div>MIT6.824</a></div></div><link rel="stylesheet" href="/css/coin.css" media="defer" onload="this.media='all'"/><div class="post-reward"><button class="tip-button reward-button"><span class="tip-button__text">投喂作者</span><div class="coin-wrapper"><div class="coin"><div class="coin__middle"></div><div class="coin__back"></div><div class="coin__front"></div></div></div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://tuchuang.voooe.cn/images/2023/01/04/2.webp" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://tuchuang.voooe.cn/images/2023/01/04/2.webp" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://tuchuang.voooe.cn/images/2023/01/04/20f8e49805975b8f8.webp" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://tuchuang.voooe.cn/images/2023/01/04/20f8e49805975b8f8.webp" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></button></div><audio id="coinAudio" src="https://npm.elemecdn.com/akilar-candyassets@1.0.36/audio/aowu.m4a"></audio><script defer="defer" src="/js/coin.js"></script><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/posts/119a915f.html"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_14.webp" onerror="onerror=null;src='/assets/r2.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">go中Gorm的使用</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><svg class="meta_icon" style="width:22px;height:22px;position:relative;top:5px"><use xlink:href="#icon-mulu1"></use></svg><span style="font-weight:bold">目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">目录</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#MIT6-824%E8%AF%BE%E7%A8%8B"><span class="toc-text">MIT6.824课程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E7%B3%BB%E7%BB%9F%E7%AE%80%E8%BF%B0"><span class="toc-text">分布系统简述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">分布式系统的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%EF%BC%9F"><span class="toc-text">为什么使用分布式系统？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8E%86%E5%8F%B2"><span class="toc-text">分布式系统的历史</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%9A%BE%E7%82%B9%EF%BC%88Chalenges%EF%BC%89"><span class="toc-text">分布式系统的难点（Chalenges）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BE%E7%A8%8B%E4%BB%8B%E7%BB%8D"><span class="toc-text">课程介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%AF%E6%8C%81%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84"><span class="toc-text">支持分布式系统的底层基础架构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-text">分布式系统的特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mapreduce%E6%A6%82%E8%BF%B0"><span class="toc-text">mapreduce概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mapreduce%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-text">mapreduce的执行流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mapreduce%E7%9A%84%E5%AE%B9%E9%94%99%E6%80%A7"><span class="toc-text">mapreduce的容错性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mapreduce%E5%85%B6%E4%BB%96%E5%BC%82%E5%B8%B8%E5%9C%BA%E6%99%AF"><span class="toc-text">mapreduce其他异常场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E8%AF%AD"><span class="toc-text">结语</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Threads%E5%92%8CRPC-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8"><span class="toc-text">Threads和RPC(多线程和远程过程调用)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E7%94%A8go%E8%AF%AD%E8%A8%80"><span class="toc-text">为什么选用go语言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#go%E7%9A%84%E5%A4%9A%E5%8D%8F%E7%A8%8B%E6%8C%91%E6%88%98"><span class="toc-text">go的多协程挑战</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#go%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%8C%91%E6%88%98"><span class="toc-text">go如何应对多线程的挑战</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#go%E7%9A%84%E5%A0%86%E6%A0%88%E5%92%8C%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90"><span class="toc-text">go的堆栈和逃逸分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90"><span class="toc-text">逃逸分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99"><span class="toc-text">逃逸分析的基本原则</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E4%B8%BE%E4%BE%8B"><span class="toc-text">逃逸分析举例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%B7%E6%AD%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9FGFS"><span class="toc-text">谷歌文件系统GFS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8"><span class="toc-text">存储</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E8%AE%BE%E8%AE%A1%E7%9A%84%E9%9A%BE%E7%82%B9"><span class="toc-text">存储设计的难点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-text">一致性</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFGFS%EF%BC%9F"><span class="toc-text">什么是GFS？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GFS%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%8F%96%E6%B5%81%E7%A8%8B"><span class="toc-text">GFS数据读取流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GFS-Master%E7%AE%80%E8%BF%B0"><span class="toc-text">GFS-Master简述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GFS-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96"><span class="toc-text">GFS-文件读取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GFS-%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5"><span class="toc-text">GFS-文件写入</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E5%A4%87%E5%A4%8D%E5%88%B6"><span class="toc-text">主备复制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%B1%E8%B4%A5%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-text">失败的场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E5%A4%87%E5%A4%8D%E5%88%B6%E7%9A%84%E5%AE%9E%E7%8E%B0%E9%9A%BE%E7%82%B9"><span class="toc-text">主备复制的实现难点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E5%A4%87%E5%A4%8D%E5%88%B6%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-text">主备复制的两种方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E7%8A%B6%E6%80%81%E6%9C%BARSM-%E5%A4%8D%E5%88%B6%E4%BB%80%E4%B9%88%E7%BA%A7%E5%88%AB%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-text">复制状态机RSM-复制什么级别的操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E8%99%9A%E6%8B%9F%E5%8C%96%E5%AE%9E%E7%8E%B0%E5%A4%8D%E5%88%B6"><span class="toc-text">通过虚拟化实现复制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%AE%E5%BC%82%E6%9D%A5%E6%BA%90"><span class="toc-text">差异来源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#VM-FT%E7%9A%84%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86"><span class="toc-text">VM-FT的中断处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#VM-FT%E5%A4%B1%E8%B4%A5%E5%9C%BA%E6%99%AF%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-text">VM-FT失败场景的处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#VM-FT%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98"><span class="toc-text">VM-FT性能问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%AE%B9%E5%BF%8D-Raft%E7%AE%97%E6%B3%95"><span class="toc-text">错误容忍-Raft算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E7%82%B9%E6%95%85%E9%9A%9C"><span class="toc-text">单点故障</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%84%91%E8%A3%82%E9%97%AE%E9%A2%98"><span class="toc-text">脑裂问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Raft%E9%87%87%E5%8F%96%E7%9A%84%E7%9A%84%E5%8E%9F%E5%88%99-%E5%A4%A7%E5%A4%9A%E6%95%B0%E5%8E%9F%E5%88%99"><span class="toc-text">Raft采取的的原则:大多数原则</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B8%AA%E5%8E%9F%E5%88%99%E4%BC%9A%E4%BD%9C%E4%B8%BA%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="toc-text">为什么这个原则会作为基本思想</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#raft%E5%8E%86%E5%8F%B2%E5%8F%91%E5%B1%95"><span class="toc-text">raft历史发展</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Raft%E6%9E%84%E9%80%A0%E5%A4%8D%E5%88%B6%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="toc-text">使用Raft构造复制状态机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Raft%E6%A6%82%E8%BF%B0"><span class="toc-text">Raft概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Raft-log%E7%9A%84%E7%94%A8%E9%80%94"><span class="toc-text">Raft log的用途</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Raft%E7%9A%84log%E6%A0%BC%E5%BC%8F"><span class="toc-text">Raft的log格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Raft%E7%9A%84%E9%80%89%E4%B8%BE"><span class="toc-text">Raft的选举</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%83%85%E5%86%B51-%EF%BC%9A%E9%9B%86%E7%BE%A4%E4%B8%AD%E6%B2%A1%E6%9C%89leader"><span class="toc-text">情况1 ：集群中没有leader</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%83%85%E5%86%B52-%EF%BC%9A%E9%9B%86%E7%BE%A4%E4%B8%AD%E6%9C%89leader%EF%BC%8C%E5%B9%B6%E4%B8%94leader%E5%AE%95%E6%9C%BA%E4%BA%86"><span class="toc-text">情况2 ：集群中有leader，并且leader宕机了</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%AD%A4%E6%97%B6%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%E5%8F%98%E5%91%B3%E4%BA%86%E5%80%99%E9%80%89%E8%8A%82%E7%82%B9"><span class="toc-text">此时只有一个节点变味了候选节点</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9C%89%E4%B8%A4%E4%B8%AA%E5%80%99%E9%80%89%E4%BA%BA%E5%90%8C%E6%97%B6%E7%AB%9E%E9%80%89%EF%BC%88%E9%80%89%E4%B8%BE%E6%9D%A1%E4%BB%B6%EF%BC%89"><span class="toc-text">有两个候选人同时竞选（选举条件）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Raft%E7%9A%84%E9%80%89%E4%B8%BE%E8%B6%85%E6%97%B6%E6%97%B6%E9%97%B4"><span class="toc-text">Raft的选举超时时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Raft-vote%E9%9C%80%E8%AE%B0%E5%BD%95%E5%88%B0%E7%A8%B3%E5%AE%9A%E7%9A%84storage%EF%BC%88%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%89"><span class="toc-text">Raft-vote需记录到稳定的storage（持久化）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Raft-%E6%97%A5%E5%BF%97"><span class="toc-text">Raft-日志</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Raft%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%A5%E5%BF%97%E5%A4%8D%E5%88%B6%E8%BF%87%E7%A8%8B"><span class="toc-text">Raft算法的日志复制过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Raft-%E6%97%A5%E5%BF%97%E5%88%86%E6%AD%A7"><span class="toc-text">Raft-日志分歧</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Raft%E9%80%89%E4%B8%BE%E8%A7%84%E5%88%99"><span class="toc-text">Raft选举规则</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Raft-%E6%97%A5%E5%BF%97%E8%A6%86%E5%86%99%E5%90%8C%E6%AD%A5%EF%BC%88%E6%9C%AA%E4%BC%98%E5%8C%96%E7%89%88%E6%9C%AC%EF%BC%89"><span class="toc-text">Raft-日志覆写同步（未优化版本）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Raft-%E6%97%A5%E5%BF%97%E6%93%A6%E9%99%A4"><span class="toc-text">Raft-日志擦除</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Raft-%E6%97%A5%E5%BF%97%E5%BF%AB%E9%80%9F%E8%A6%86%E5%86%99%E5%90%8C%E6%AD%A5"><span class="toc-text">Raft-日志快速覆写同步</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Raft-%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-text">Raft-持久化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Raft-%E6%9C%8D%E5%8A%A1%E6%81%A2%E5%A4%8D"><span class="toc-text">Raft-服务恢复</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-text">线性一致性</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-color: transparent;"><div id="footer-wrap"><div id="ft"><div class="ft-item-1"><div class="t-top"><div class="t-t-l"><p class="ft-t t-l-t">格言🧬</p><div class="bg-ad"><div>再看看那个光点，它就在这里，这是家园，这是我们 —— 你所爱的每一个人，你认识的一个人，你听说过的每一个人，曾经有过的每一个人，都在它上面度过他们的一生✨</div><div class="btn-xz-box"><a class="btn-xz" target="_blank" rel="noopener" href="https://stellarium.org/">点击开启星辰之旅</a></div></div></div><div class="t-t-r"><p class="ft-t t-l-t">猜你想看💡</p><ul class="ft-links"><li><a href="/posts/eec9786.html">魔改指南</a><a href="/box/nav/">网址导航</a></li><li><a href="/social/link/">我的朋友</a><a href="/comments/">留点什么</a></li><li><a href="/personal/about/">关于作者</a><a href="/archives/">文章归档</a></li><li><a href="/categories/">文章分类</a><a href="/tags/">文章标签</a></li><li><a href="/box/Gallery/">我的画廊</a><a href="/personal/bb/">我的唠叨</a></li><li><a href="/site/time/">建设进程</a><a href="/site/census/">网站统计</a></li></ul></div></div></div><div class="ft-item-2"><p class="ft-t">推荐友链⌛</p><div class="ft-img-group"><div class="img-group-item"><a target="_blank" rel="noopener" href="https://www.fomal.cc/" title="Fomalhaut🥝"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/60e5d4e39da7c077.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div></div></div></div><div class="copyright"><span><b>&copy;2022-2024</b></span><span><b>&nbsp;&nbsp;By PigCanStudy</b></span></div><div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" title="博客框架为Hexo_v6.3.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Frame-Hexo-blue.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" title="主题版本Butterfly_v4.3.1"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Theme-Butterfly-6513df.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" title="本站采用多线部署，主线路托管于Vercel"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Hosted-Vercel-brightgreen.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://user.51.la/" style="margin-inline:5px" title="本站数据分析得益于51la技术支持"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Analytics-51la-3db1eb.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://icp.gov.moe/?keyword=20226665" style="margin-inline:5px" title="本站已加入萌ICP豪华套餐，萌ICP备20226665号"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/萌ICP备-20226665-fe1384.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://bitiful.dogecast.com/buckets" style="margin-inline:5px" title="本网站经Service Worker分流至缤纷云对象存储"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src=" https://sourcebucket.s3.ladydaily.com/badge/Bucket-缤纷云-9c62da.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://www.netdun.net/" style="margin-inline:5px" title="本站使用网盾星球提供CDN加速与防护"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/CDN-网盾星球-fff2cc.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" title="本网站源码由Github提供存储仓库"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src=" https://sourcebucket.s3.ladydaily.com/badge/Source-Github-d021d6.svg" alt=""/></a></p></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button class="share" type="button" title="右键模式" onclick="changeMouseMode()"><i class="fas fa-mouse"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog right_side"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button class="share" type="button" title="分享链接" onclick="share()"><i class="fas fa-share-nodes"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i><span id="percent">0<span>%</span></span></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();"><i class="fa fa-copy"></i><span>复制</span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.baidu.com/s?wd=&quot;+window.getSelection().toString());window.location.reload();"><i class="fa fa-search"></i><span>百度搜索</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();"><i class="fa fa-link"></i><span>转到链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()"><i class="fa fa-copy"></i><span>粘贴</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-post"><a class="rightMenu-item" href="#post-comment"><i class="fas fa-comment"></i><span>空降评论</span></a><a class="rightMenu-item" href="javascript:rmf.copyWordsLink()"><i class="fa fa-link"></i><span>复制本文地址</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>新窗口打开</span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()"><i class="fa fa-link"></i><span>转到链接</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()"><i class="fa fa-download"></i><span>保存图片</span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>在新窗口打开</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制图片链接</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:randomPost()"><i class="fa fa-paper-plane"></i><span>随便逛逛</span></a><a class="rightMenu-item" href="javascript:switchNightMode();"><i class="fa fa-moon"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="/personal/about/"><i class="fa fa-info-circle"></i><span>关于博客</span></a><a class="rightMenu-item" href="javascript:toggleWinbox();"><i class="fas fa-cog"></i><span>美化设置</span></a><a class="rightMenu-item" href="javascript:rmf.fullScreen();"><i class="fas fa-expand"></i><span>切换全屏</span></a><a class="rightMenu-item" href="javascript:window.print();"><i class="fa-solid fa-print"></i><span>打印页面</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.umd.min.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/instant.page/5.1.0/instantpage.min.js" type="module"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/vanilla-lazyload/17.3.1/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><script async="async">var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())
setTimeout(function(){preloader.endLoading();}, 5000);
document.getElementById('loading-box').addEventListener('click',()=> {preloader.endLoading()})</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: '',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: '',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.staticfile.org/twikoo/1.6.8/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script src="https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js"></script><script async src="https://cdn1.tianli0.top/npm/vue@2.6.14/dist/vue.min.js"></script><script async src="https://cdn1.tianli0.top/npm/element-ui@2.15.6/lib/index.js"></script><script async src="https://cdn.bootcdn.net/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script><script defer type="text/javascript" src="https://cdn1.tianli0.top/npm/sweetalert2@8.19.0/dist/sweetalert2.all.js"></script><script async src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><script defer src="https://cdn1.tianli0.top/gh/nextapps-de/winbox/dist/winbox.bundle.min.js"></script><script async src="//at.alicdn.com/t/c/font_3586335_hsivh70x0fm.js"></script><script async src="//at.alicdn.com/t/c/font_3636804_gr02jmjr3y9.js"></script><script async src="//at.alicdn.com/t/c/font_3612150_kfv55xn3u2g.js"></script><script async src="https://cdn.wpon.cn/2022-sucai/Gold-ingot.js"></script><canvas id="universe"></canvas><canvas id="snow"></canvas><script defer src="/js/fomal.js"></script><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.js"></script><script src="https://cdn1.tianli0.top/npm/js-heo@1.0.12/metingjs/Meting.min.js"></script><script src="https://lib.baomitu.com/pjax/0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show","#web_bg",".js-pjax","#bibi","body > title","#app","#tag-echarts","#posts-echart","#categories-echarts"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><a class="magnet_link_more"  href="https://pigcanstudy.github.io/categories/" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(33.333333333333336% - 5px);background: #e9e9e9;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: var(--text-bg-hover)}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/95787e92.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-07-16</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/95787e92.html&quot;);" href="javascript:void(0);" alt="">网络编程教程</a><div class="blog-slider__text">🥧本文介绍了linux基础的系统编程和基础的Linux网络编程</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/95787e92.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/2f7ff9a3.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-07-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/2f7ff9a3.html&quot;);" href="javascript:void(0);" alt="">C++面试笔记</a><div class="blog-slider__text">本文介绍了C++面试笔记的相关知识</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/2f7ff9a3.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/e8e79e61.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-07-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/e8e79e61.html&quot;);" href="javascript:void(0);" alt="">C++并发编程</a><div class="blog-slider__text">本文介绍了C++并发编程的相关知识</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/e8e79e61.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/6e928d8a.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-07-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/6e928d8a.html&quot;);" href="javascript:void(0);" alt="">C++Qt</a><div class="blog-slider__text">本文介绍了C++Qt的相关知识</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/6e928d8a.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/9724705.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-07-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/9724705.html&quot;);" href="javascript:void(0);" alt="">C++asio网络编程</a><div class="blog-slider__text">本文介绍了C++运用asio进行网络编程的相关知识</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/9724705.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><script data-pjax src="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.js"></script><script data-pjax>
  function gitcalendar_injector_config(){
      var parent_div_git = document.getElementById('gitZone');
      var item_html = '<div class="recent-post-item" id="gitcalendarBar" style="width:100%;height:auto;padding:10px;"><style>#git_container{min-height: 320px}@media screen and (max-width:650px) {#git_container{min-height: 0px}}</style><div id="git_loading" style="width:10%;height:100%;margin:0 auto;display: block;"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animatetransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animatetransform></path></svg><style>#git_container{display: none;}</style></div><div id="git_container"></div></div>';
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      console.log('已挂载gitcalendar')
      }

    if( document.getElementById('gitZone') && (location.pathname ==='/site/census/'|| '/site/census/' ==='all')){
        gitcalendar_injector_config()
        GitCalendarInit("/api?null",['#d9e0df', '#c6e0dc', '#a8dcd4', '#9adcd2', '#89ded1', '#77e0d0', '#5fdecb', '#47dcc6', '#39dcc3', '#1fdabe', '#00dab9'],'null')
    }
  </script><!-- hexo injector body_end end --></body></html>