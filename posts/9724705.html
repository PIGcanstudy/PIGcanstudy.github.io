<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><div id="myscoll"></div><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>C++asio网络编程 | PigCanStudy</title><meta name="keywords" content="asio网络编程,C++,boost"><meta name="author" content="PigCanStudy"><meta name="copyright" content="PigCanStudy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="本文介绍了C++运用asio进行网络编程的相关知识">
<meta property="og:type" content="article">
<meta property="og:title" content="C++asio网络编程">
<meta property="og:url" content="https://pigcanstudy.github.io/posts/9724705.html">
<meta property="og:site_name" content="PigCanStudy">
<meta property="og:description" content="本文介绍了C++运用asio进行网络编程的相关知识">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://source.fomal.cc/img/default_cover_14.webp">
<meta property="article:published_time" content="2024-07-18T02:49:00.000Z">
<meta property="article:modified_time" content="2024-07-18T02:50:00.000Z">
<meta property="article:author" content="PigCanStudy">
<meta property="article:tag" content="asio网络编程">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="boost">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://source.fomal.cc/img/default_cover_14.webp"><link rel="shortcut icon" href="/"><link rel="canonical" href="https://pigcanstudy.github.io/posts/9724705"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/6.0.0/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.js',
      css: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++asio网络编程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-07-18 10:50:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/element-ui@2.15.6/packages/theme-chalk/lib/index.css"><style id="themeColor"></style><style id="rightSide"></style><style id="transPercent"></style><style id="blurNum"></style><style id="settingStyle"></style><span id="fps"></span><style id="defineBg"></style><style id="menu_shadow"></style><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="PigCanStudy" type="application/atom+xml">
</head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://tuchuang.voooe.cn/images/2023/01/02/avatar.webp" onerror="onerror=null;src='/assets/r1.jpg'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-home"></use></svg><span class="menu_word" style="font-size:17px"> 首页</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--article"></use></svg><span class="menu_word" style="font-size:17px"> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-guidang1">                   </use></svg><span class="menu_word" style="font-size:17px"> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-sekuaibiaoqian">                   </use></svg><span class="menu_word" style="font-size:17px"> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-fenlei">                   </use></svg><span class="menu_word" style="font-size:17px"> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pinweishenghuo"></use></svg><span class="menu_word" style="font-size:17px"> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/life/music/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-yinle">                   </use></svg><span class="menu_word" style="font-size:17px"> 八音盒</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/movies/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-dianying1">                   </use></svg><span class="menu_word" style="font-size:17px"> 影院</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/games/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-youxishoubing">                   </use></svg><span class="menu_word" style="font-size:17px"> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xiangzi"></use></svg><span class="menu_word" style="font-size:17px"> 八宝箱</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/box/gallery/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-tubiaozhizuomoban">                   </use></svg><span class="menu_word" style="font-size:17px"> 画廊</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/animation/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-nvwumao">                   </use></svg><span class="menu_word" style="font-size:17px"> 动画</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/nav/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-zhifengche">                   </use></svg><span class="menu_word" style="font-size:17px"> 网址导航</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shejiaoxinxi"></use></svg><span class="menu_word" style="font-size:17px"> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/social/fcircle/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pengyouquan">                   </use></svg><span class="menu_word" style="font-size:17px"> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-liuyan">                   </use></svg><span class="menu_word" style="font-size:17px"> 留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/social/link/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-lianjie">                   </use></svg><span class="menu_word" style="font-size:17px"> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-wangye"></use></svg><span class="menu_word" style="font-size:17px"> 网站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/site/census/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--tongjibiao">                   </use></svg><span class="menu_word" style="font-size:17px"> 网站统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/echarts/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shujutongji1">                   </use></svg><span class="menu_word" style="font-size:17px"> 文章统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/time/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xianxingshalou">                   </use></svg><span class="menu_word" style="font-size:17px"> 旧时光</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-maoliang"></use></svg><span class="menu_word" style="font-size:17px"> 个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/personal/bb/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-qunliaotian">                   </use></svg><span class="menu_word" style="font-size:17px"> 唠叨</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/love/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-love-sign">                   </use></svg><span class="menu_word" style="font-size:17px"> 恋爱小屋</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/about/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-paperplane">                   </use></svg><span class="menu_word" style="font-size:17px"> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">PigCanStudy</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-home"></use></svg><span class="menu_word" style="font-size:17px"> 首页</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--article"></use></svg><span class="menu_word" style="font-size:17px"> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-guidang1">                   </use></svg><span class="menu_word" style="font-size:17px"> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-sekuaibiaoqian">                   </use></svg><span class="menu_word" style="font-size:17px"> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-fenlei">                   </use></svg><span class="menu_word" style="font-size:17px"> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pinweishenghuo"></use></svg><span class="menu_word" style="font-size:17px"> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/life/music/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-yinle">                   </use></svg><span class="menu_word" style="font-size:17px"> 八音盒</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/movies/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-dianying1">                   </use></svg><span class="menu_word" style="font-size:17px"> 影院</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/games/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-youxishoubing">                   </use></svg><span class="menu_word" style="font-size:17px"> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xiangzi"></use></svg><span class="menu_word" style="font-size:17px"> 八宝箱</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/box/gallery/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-tubiaozhizuomoban">                   </use></svg><span class="menu_word" style="font-size:17px"> 画廊</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/animation/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-nvwumao">                   </use></svg><span class="menu_word" style="font-size:17px"> 动画</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/nav/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-zhifengche">                   </use></svg><span class="menu_word" style="font-size:17px"> 网址导航</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shejiaoxinxi"></use></svg><span class="menu_word" style="font-size:17px"> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/social/fcircle/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pengyouquan">                   </use></svg><span class="menu_word" style="font-size:17px"> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-liuyan">                   </use></svg><span class="menu_word" style="font-size:17px"> 留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/social/link/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-lianjie">                   </use></svg><span class="menu_word" style="font-size:17px"> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-wangye"></use></svg><span class="menu_word" style="font-size:17px"> 网站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/site/census/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--tongjibiao">                   </use></svg><span class="menu_word" style="font-size:17px"> 网站统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/echarts/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shujutongji1">                   </use></svg><span class="menu_word" style="font-size:17px"> 文章统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/time/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xianxingshalou">                   </use></svg><span class="menu_word" style="font-size:17px"> 旧时光</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-maoliang"></use></svg><span class="menu_word" style="font-size:17px"> 个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/personal/bb/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-qunliaotian">                   </use></svg><span class="menu_word" style="font-size:17px"> 唠叨</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/love/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-love-sign">                   </use></svg><span class="menu_word" style="font-size:17px"> 恋爱小屋</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/about/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-paperplane">                   </use></svg><span class="menu_word" style="font-size:17px"> 关于</span></a></li></ul></div></div><center id="name-container"><a id="page-name" href="javascript:scrollToTop()">PAGE_NAME</a></center><div id="nav-right"><div id="search-button"><a class="search faa-parent animated-hover" title="检索站内任何你想要的信息"><svg class="faa-tada icon" style="height:24px;width:24px;fill:currentColor;position:relative;top:6px" aria-hidden="true"><use xlink:href="#icon-valentine_-search-love-find-heart"></use></svg><span> 搜索</span></a></div><a class="meihua faa-parent animated-hover" onclick="toggleWinbox()" title="美化设置-自定义你的风格" id="meihua-button"><svg class="faa-tada icon" style="height:26px;width:26px;fill:currentColor;position:relative;top:8px" aria-hidden="true"><use xlink:href="#icon-tupian1"></use></svg></a><a class="sun_moon faa-parent animated-hover" onclick="switchNightMode()" title="浅色和深色模式转换" id="nightmode-button"><svg class="faa-tada" style="height:25px;width:25px;fill:currentColor;position:relative;top:7px" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon">       </use></svg></a><div id="toggle-menu"><a><i class="fas fa-bars fa-fw"></i></a></div></div></div></nav><div id="post-info"><h1 class="post-title">C++asio网络编程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><svg class="meta_icon post-meta-icon" style="width:30px;height:30px;position:relative;top:10px"><use xlink:href="#icon-rili"></use></svg><span class="post-meta-label">发表于 </span><time class="post-meta-date-created" datetime="2024-07-18T02:49:00.000Z" title="发表于 2024-07-18 10:49:00">2024-07-18</time><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:18px;height:18px;position:relative;top:5px"><use xlink:href="#icon-gengxin1"></use></svg><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-07-18T02:50:00.000Z" title="更新于 2024-07-18 10:50:00">2024-07-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:18px;height:18px;position:relative;top:5px"><use xlink:href="#icon-biaoqian"></use></svg><a class="post-meta-categories" href="/categories/C/">C++</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><svg class="meta_icon post-meta-icon" style="width:25px;height:25px;position:relative;top:8px"><use xlink:href="#icon-charuword"></use></svg><span class="post-meta-label">字数总计:</span><span class="word-count">4.8w</span><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:20px;height:20px;position:relative;top:5px"><use xlink:href="#icon-shizhong"></use></svg><span class="post-meta-label">阅读时长:</span><span>211分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="C++asio网络编程"><svg class="meta_icon post-meta-icon" style="width:25px;height:25px;position:relative;top:5px"><use xlink:href="#icon-eye"></use></svg><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li><a href="#目录">目录</a><ul>
<li><a href="#网络编程的基本流程">网络编程的基本流程</a><ul>
<li><a href="#终端节点的创建">终端节点的创建</a><ul>
<li><a href="#客户端之终端节点的创建">客户端之终端节点的创建</a></li>
<li><a href="#服务端之终端节点的创建">服务端之终端节点的创建</a></li>
</ul>
</li>
<li><a href="#创建socket">创建socket</a><ul>
<li><a href="#服务端与客户端之创建socket">服务端与客户端之创建socket</a></li>
<li><a href="#服务端之接收链接请求的socket对应accept">服务端之接收链接请求的socket（对应accept）</a></li>
</ul>
</li>
<li><a href="#绑定acceptor">绑定acceptor</a></li>
<li><a href="#可以把端口绑定和acceptor的传建合起来写">可以把端口绑定和acceptor的传建合起来写</a></li>
<li><a href="#链接指定的端点">链接指定的端点</a></li>
<li><a href="#服务器接收来连接">服务器接收来连接</a><ul>
<li><a href="#创建acceptor的几种方法">创建acceptor的几种方法</a></li>
</ul>
</li>
<li><a href="#关于buffer">关于buffer</a><ul>
<li><a href="#字符串的buffer">字符串的buffer</a></li>
<li><a href="#数组的buffer">数组的buffer</a></li>
<li><a href="#流式的buffer">流式的buffer</a></li>
<li><a href="#容器的buffer">容器的buffer</a></li>
<li><a href="#指向缓冲区的指针的buffer">指向缓冲区的指针的buffer</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#同步读写">同步读写</a><ul>
<li><a href="#同步写-write_some">同步写 write_some</a></li>
<li><a href="#同步写-send">同步写 send</a></li>
<li><a href="#同步写-write">同步写 write</a></li>
<li><a href="#同步读-read_some">同步读 read_some</a></li>
<li><a href="#同步读-receive">同步读 receive</a></li>
<li><a href="#同步读-read">同步读 read</a></li>
<li><a href="#读取直到指定字符">读取直到指定字符</a></li>
</ul>
</li>
<li><a href="#同步读写的客户端与服务端">同步读写的客户端与服务端</a><ul>
<li><a href="#客户端的设计">客户端的设计</a></li>
<li><a href="#服务端设计">服务端设计</a><ul>
<li><a href="#session函数">session函数</a></li>
<li><a href="#server函数">server函数</a></li>
<li><a href="#完整服务端代码">完整服务端代码</a></li>
</ul>
</li>
<li><a href="#同步读写的优劣">同步读写的优劣</a></li>
</ul>
</li>
<li><a href="#asio异步读写操作及注意事项">asio异步读写操作及注意事项</a><ul>
<li><a href="#异步写操作">异步写操作</a></li>
<li><a href="#异步读操作">异步读操作</a></li>
<li><a href="#总结-完整代码">总结 完整代码</a><ul>
<li><a href="#sessionh头文件">Session.h头文件</a></li>
<li><a href="#sessioncpp">Session.cpp</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#asio官方案例存在的隐患">asio官方案例存在的隐患</a><ul>
<li><a href="#session类">Session类</a></li>
<li><a href="#server类">Server类</a><ul>
<li><a href="#server实现">Server实现</a></li>
</ul>
</li>
<li><a href="#隐患">隐患</a></li>
<li><a href="#总结">总结</a></li>
<li><a href="#完整代码">完整代码</a><ul>
<li><a href="#头文件">头文件</a></li>
<li><a href="#实现">实现</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#使用伪闭包实现连接的安全回收">使用伪闭包实现连接的安全回收</a><ul>
<li><a href="#智能指针管理session">智能指针管理Session</a></li>
<li><a href="#session的uuid">Session的uuid</a></li>
<li><a href="#隐患1">隐患1</a></li>
<li><a href="#如何实现伪闭包">如何实现伪闭包</a></li>
<li><a href="#完整的代码">完整的代码</a><ul>
<li><a href="#实现1">实现1</a></li>
<li><a href="#头文件1">头文件1</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#封装服务器发送队列">封装服务器发送队列</a><ul>
<li><a href="#数据节点设计">数据节点设计</a></li>
<li><a href="#封装发送接口">封装发送接口</a></li>
</ul>
</li>
<li><a href="#修改读回调">修改读回调</a><ul>
<li><a href="#该节总结">该节总结</a></li>
<li><a href="#封装后完整代码">封装后完整代码</a><ul>
<li><a href="#msgnode">msgNode</a></li>
<li><a href="#csession">CSession</a></li>
<li><a href="#cserver">CServer</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#处理网络粘包问题">处理网络粘包问题</a><ul>
<li><a href="#什么是粘包">什么是粘包</a></li>
<li><a href="#粘包原因">粘包原因</a></li>
<li><a href="#处理粘包">处理粘包</a></li>
<li><a href="#完善消息节点">完善消息节点</a></li>
<li><a href="#csession类完善">CSession类完善</a></li>
<li><a href="#完善接收逻辑">完善接收逻辑</a></li>
<li><a href="#服务端完整代码">服务端完整代码</a><ul>
<li><a href="#csession头文件">CSession头文件</a></li>
<li><a href="#csession-实现">CSession 实现</a></li>
<li><a href="#cserver头文件">CServer头文件</a></li>
<li><a href="#cserver实现">CServer实现</a></li>
<li><a href="#msgnode-1">MsgNode</a></li>
</ul>
</li>
<li><a href="#客户端修改">客户端修改</a></li>
<li><a href="#粘包测试">粘包测试</a></li>
<li><a href="#目前服务端通信流程图">目前服务端通信流程图</a></li>
<li><a href="#io_context">io_context</a></li>
</ul>
</li>
<li><a href="#字节序处理和发送队列控制">字节序处理和发送队列控制</a><ul>
<li><a href="#字节序问题">字节序问题</a></li>
<li><a href="#如何区分本机字节序">如何区分本机字节序</a></li>
<li><a href="#服务器使用网络字节序">服务器使用网络字节序</a></li>
<li><a href="#消息队列控制">消息队列控制</a></li>
</ul>
</li>
<li><a href="#protobuf配置和使用">protobuf配置和使用</a><ul>
<li><a href="#portobuf简介">portobuf简介</a></li>
<li><a href="#生成pb文件">生成pb文件</a></li>
<li><a href="#在网络编程中的应用">在网络编程中的应用</a></li>
</ul>
</li>
<li><a href="#jsoncpp的使用与配置">jsoncpp的使用与配置</a><ul>
<li><a href="#简介">简介</a></li>
<li><a href="#配置参考我的csdn收藏">配置参考我的csdn收藏</a></li>
<li><a href="#测试">测试</a></li>
<li><a href="#网络编程中的应用">网络编程中的应用</a></li>
<li><a href="#新版json库-nlohmannjson">新版JSON库 nlohmann/json</a></li>
</ul>
</li>
<li><a href="#asio粘包处理的简单方式">asio粘包处理的简单方式</a><ul>
<li><a href="#简单方式">简单方式</a></li>
<li><a href="#获取头部数据">获取头部数据</a></li>
<li><a href="#获取消息体">获取消息体</a></li>
</ul>
</li>
<li><a href="#服务器逻辑层设计和消息完善">服务器逻辑层设计和消息完善</a><ul>
<li><a href="#简介1">简介1</a></li>
<li><a href="#服务器架构设计">服务器架构设计</a></li>
<li><a href="#消息头完善">消息头完善</a><ul>
<li><a href="#我们将上述结构定义在msgnodeh中">我们将上述结构定义在MsgNode.h中</a></li>
<li><a href="#实现msgnode">实现MsgNode</a></li>
</ul>
</li>
<li><a href="#session类改写">Session类改写</a><ul>
<li><a href="#完整的代码2">完整的代码2</a><ul>
<li><a href="#sessionh">Session.h</a></li>
<li><a href="#sessioncpp-1">Session.cpp</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#单例模式实现逻辑层设计">单例模式实现逻辑层设计</a><ul>
<li><a href="#单例模板类">单例模板类</a></li>
<li><a href="#logicsystem单例类">LogicSystem单例类</a><ul>
<li><a href="#logicsystem-完整代码">LogicSystem 完整代码</a><ul>
<li><a href="#头文件-1">头文件</a></li>
<li><a href="#实现-1">实现</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#服务器优雅退出">服务器优雅退出</a><ul>
<li><a href="#退出方式1开辟线程让服务器运行在线程中并接受退出信号退出">退出方式1：开辟线程，让服务器运行在线程中并接受退出信号退出</a></li>
<li><a href="#退出方式2使用asio底层异步等待函数">退出方式2：使用asio底层异步等待函数</a></li>
<li><a href="#总结-1">总结</a></li>
</ul>
</li>
<li><a href="#asio多线程模型ioservicepool">asio多线程模型IOServicePool</a><ul>
<li><a href="#简介-1">简介</a></li>
<li><a href="#单线程和多线程对比">单线程和多线程对比</a></li>
<li><a href="#ioservicepool实现">IOServicePool实现</a><ul>
<li><a href="#ioservicepool的声明">IOServicePool的声明:</a></li>
<li><a href="#实现-2">实现</a></li>
</ul>
</li>
<li><a href="#优雅退出">优雅退出</a></li>
</ul>
</li>
<li><a href="#asio多线程模式iothreadpool">asio多线程模式IOThreadPool</a><ul>
<li><a href="#结构图">结构图</a></li>
<li><a href="#先实现iothreadpool">先实现IOThreadPool</a><ul>
<li><a href="#iothreadpool-头文件">IOThreadPool 头文件</a></li>
<li><a href="#iothreadpool-实现">IOThreadPool 实现</a><ul>
<li><a href="#iocp的流程是这样的">iocp的流程是这样的</a></li>
<li><a href="#epoll流程是这样的">epoll流程是这样的</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#隐患-1">隐患</a></li>
<li><a href="#利用strand改进">利用strand改进</a></li>
<li><a href="#csession代码">CSession代码</a></li>
<li><a href="#性能对比">性能对比</a></li>
<li><a href="#取舍">取舍</a></li>
</ul>
</li>
<li><a href="#boostasio协程实现并发服务器">boost::asio协程实现并发服务器</a><ul>
<li><a href="#简介-2">简介</a></li>
<li><a href="#协程案例">协程案例</a></li>
<li><a href="#完整并发服务器">完整并发服务器</a><ul>
<li><a href="#asiioservicepool">AsiIOServicePool</a><ul>
<li><a href="#asioioservicepool头文件">AsioIOServicePool头文件</a></li>
<li><a href="#asioioservicepool实现">AsioIOServicePool实现</a></li>
</ul>
</li>
<li><a href="#cosnth">cosnt.h</a></li>
<li><a href="#cserver-1">CServer</a><ul>
<li><a href="#cserver头文件-1">CServer头文件</a></li>
<li><a href="#cserver实现-1">CServer实现</a></li>
</ul>
</li>
<li><a href="#csession-1">CSession</a><ul>
<li><a href="#csessionh">CSession.h</a></li>
<li><a href="#csession实现">CSession实现</a></li>
</ul>
</li>
<li><a href="#logicsystem">LogicSystem</a><ul>
<li><a href="#logicsystem头文件">LogicSystem头文件</a></li>
<li><a href="#logicsystem实现">LogicSystem实现</a></li>
</ul>
</li>
<li><a href="#msgnode-2">MsgNode</a><ul>
<li><a href="#msgnode头文件">MsgNode头文件</a></li>
<li><a href="#msgnode-实现">MsgNode 实现</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#使用asio实现http服务器">使用asio实现http服务器</a><ul>
<li><a href="#简介-3">简介</a></li>
<li><a href="#http包头信息">Http包头信息</a><ul>
<li><a href="#http请求头">HTTP请求头</a></li>
<li><a href="#http响应头">HTTP响应头</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#使用beast网络库实现http服务器">使用beast网络库实现http服务器</a><ul>
<li><a href="#简介-4">简介</a></li>
<li><a href="#连接类">连接类</a></li>
<li><a href="#完整代码-1">完整代码</a></li>
</ul>
</li>
<li><a href="#beast网络库实现websocket服务器">beast网络库实现websocket服务器</a><ul>
<li><a href="#简介-5">简介</a></li>
<li><a href="#构造websocket">构造websocket</a></li>
<li><a href="#开发的websocket代码">开发的websocket代码</a><ul>
<li><a href="#connectionh">Connection.h</a></li>
<li><a href="#connectioncpp">Connection.cpp</a></li>
<li><a href="#connectionmgrh">ConnectionMgr.h</a></li>
<li><a href="#connectionmgrcpp">ConnectionMgr.cpp</a></li>
<li><a href="#websocketserverh">WebSocketServer.h</a></li>
<li><a href="#websocketservercpp">WebSocketServer.cpp</a></li>
<li><a href="#maincpp">main.cpp</a></li>
<li><a href="#总结-2">总结</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#grpc的使用">gRPC的使用</a><ul>
<li><a href="#grpc客户端">gRPC客户端</a></li>
<li><a href="#grpc服务端">gRPC服务端</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="网络编程的基本流程"><a href="#网络编程的基本流程" class="headerlink" title="网络编程的基本流程"></a>网络编程的基本流程</h2><ul>
<li>网络编程的基本流程对于服务端是这样的</li>
<li><p>服务端<br>1）socket——创建socket对象。<br>2）bind——绑定本机ip+port。<br>3）listen——监听来电，若在监听到来电，则建立起连接<br>4）accept——再创建一个socket对象给其收发消息。原因是现实中服务端都是面对多个客户端，那么为了区分各个客户端，则每个客户端都需再分配一个socket对象进行收发消息。<br>5）read、write——就是收发消息了。</p>
</li>
<li><p>对于客户端是这样的</p>
</li>
<li><p>客户端<br>1）socket——创建socket对象。<br>2）connect——根据服务端ip+port，发起连接请求。<br>3）write、read——建立连接后，就可发收消息了。</p>
</li>
<li><p>图示如下</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/C++asio网络编程/image.png" alt="示例图片" style="zoom:100%;" /></p>
<ul>
<li>了解了解 Reactor模式以及proactor模式</li>
</ul>
<h3 id="终端节点的创建"><a href="#终端节点的创建" class="headerlink" title="终端节点的创建"></a>终端节点的创建</h3><ul>
<li>所谓终端节点就是用来通信的端对端的节点，可以通过ip地址和端口构造，其它节点可以连接这个终端节点做通信。</li>
</ul>
<h4 id="客户端之终端节点的创建"><a href="#客户端之终端节点的创建" class="headerlink" title="客户端之终端节点的创建"></a>客户端之终端节点的创建</h4><ul>
<li>如果我们是客户端，我们可以通过对端的ip和端口构造一个endpoint，用这个endpoint和其通信。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;endpoint.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">client_end_point</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> std::string raw_ip_address = <span class="string">&quot;127.4.8.1&quot;</span>;</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">short</span> port_num = <span class="number">8888</span>;</span><br><span class="line">    <span class="comment">// 用来进行错误处理</span></span><br><span class="line"> boost::system::error_code ec;</span><br><span class="line">    <span class="comment">// from_string函数是用来字符串IP地址形式转换为网络地址的表示形式</span></span><br><span class="line"> boost::asio::ip::address ip_address = boost::asio::ip::address::<span class="built_in">from_string</span>(raw_ip_address, ec);</span><br><span class="line"> <span class="keyword">if</span> (ec.<span class="built_in">value</span>() != <span class="number">0</span>) &#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Failed to parse the IP address. Error code = &quot;</span> &lt;&lt; ec.<span class="built_in">value</span>() &lt;&lt; <span class="string">&quot;.Message is&quot;</span> &lt;&lt; ec.<span class="built_in">message</span>();</span><br><span class="line">  <span class="keyword">return</span> ec.<span class="built_in">value</span>();</span><br><span class="line"> &#125;</span><br><span class="line"> boost::asio::ip::<span class="function">tcp::endpoint <span class="title">ep</span><span class="params">(ip_address, port_num)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="服务端之终端节点的创建"><a href="#服务端之终端节点的创建" class="headerlink" title="服务端之终端节点的创建"></a>服务端之终端节点的创建</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">server_end_point</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">short</span> port_num = <span class="number">8888</span>;</span><br><span class="line"> <span class="comment">// 表示可以接收任意IPV4地址</span></span><br><span class="line"> boost::asio::ip::address ip_address = boost::asio::ip::address_v4::<span class="built_in">any</span>();</span><br><span class="line"> boost::asio::ip::<span class="function">tcp::endpoint <span class="title">ep</span><span class="params">(ip_address, port_num)</span></span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建socket"><a href="#创建socket" class="headerlink" title="创建socket"></a>创建socket</h3><ul>
<li>创建socket分为4步，创建上下文iocontext，选择协议，生成socket，打开socket。</li>
</ul>
<h4 id="服务端与客户端之创建socket"><a href="#服务端与客户端之创建socket" class="headerlink" title="服务端与客户端之创建socket"></a>服务端与客户端之创建socket</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">create_tcp_socket</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 创建上下文io_context（旧版本为io_service)</span></span><br><span class="line"> boost::asio::io_context ioc;</span><br><span class="line"> <span class="comment">// 选择协议</span></span><br><span class="line"> boost::asio::ip::tcp protocol = boost::asio::ip::tcp::<span class="built_in">v4</span>();</span><br><span class="line"> <span class="comment">// 创建socket,ioc来管理套接字的创建和销毁</span></span><br><span class="line"> boost::asio::ip::<span class="function">tcp::socket <span class="title">socket</span><span class="params">(ioc)</span></span>;</span><br><span class="line"> <span class="comment">// 用来处理错误信息</span></span><br><span class="line"> boost::system::error_code ec;</span><br><span class="line"> <span class="comment">// 打开socket</span></span><br><span class="line"> socket.<span class="built_in">open</span>(protocol, ec);</span><br><span class="line"> <span class="keyword">if</span> (ec.<span class="built_in">value</span>() != <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// 打开失败</span></span><br><span class="line">  std::cout</span><br><span class="line">   &lt;&lt; <span class="string">&quot;Failed to open the socket! Error code = &quot;</span></span><br><span class="line">   &lt;&lt; ec.<span class="built_in">value</span>() &lt;&lt; <span class="string">&quot;. Message: &quot;</span> &lt;&lt; ec.<span class="built_in">message</span>();</span><br><span class="line">  <span class="keyword">return</span> ec.<span class="built_in">value</span>();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="服务端之接收链接请求的socket（对应accept）"><a href="#服务端之接收链接请求的socket（对应accept）" class="headerlink" title="服务端之接收链接请求的socket（对应accept）"></a>服务端之接收链接请求的socket（对应accept）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">create_acceptor_socket</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="comment">//创建上下文io_context</span></span><br><span class="line"> boost::asio::io_context ioc;</span><br><span class="line"> <span class="comment">// 选择协议</span></span><br><span class="line"> boost::asio::ip::tcp protocol = boost::asio::ip::tcp::<span class="built_in">v4</span>();</span><br><span class="line"> <span class="comment">// 创建socket</span></span><br><span class="line"> boost::asio::ip::<span class="function">tcp::acceptor <span class="title">acceptor</span><span class="params">(ioc)</span></span>;</span><br><span class="line"> <span class="comment">// 用来处理错误信息</span></span><br><span class="line"> boost::system::error_code ec;</span><br><span class="line"> <span class="comment">// 打开socket(打开监听状态)</span></span><br><span class="line"> acceptor.<span class="built_in">open</span>(protocol, ec);</span><br><span class="line">    </span><br><span class="line"> <span class="keyword">if</span> (ec.<span class="built_in">value</span>() != <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// 打开失败</span></span><br><span class="line">  std::cout</span><br><span class="line">   &lt;&lt; <span class="string">&quot;Failed to open the socket! Error code = &quot;</span></span><br><span class="line">   &lt;&lt; ec.<span class="built_in">value</span>() &lt;&lt; <span class="string">&quot;. Message: &quot;</span> &lt;&lt; ec.<span class="built_in">message</span>();</span><br><span class="line">  <span class="keyword">return</span> ec.<span class="built_in">value</span>();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="绑定acceptor"><a href="#绑定acceptor" class="headerlink" title="绑定acceptor"></a>绑定acceptor</h3><ul>
<li>对于acceptor类型的socket，服务器要将其绑定到指定的断点,所有连接这个端点的连接都可以被接收到。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind_acceptor_socket</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">short</span> port_num = <span class="number">8888</span>;</span><br><span class="line"> boost::asio::ip::<span class="function">tcp::endpoint <span class="title">ep</span><span class="params">(boost::asio::ip::address_v4::any(),</span></span></span><br><span class="line"><span class="params"><span class="function">  port_num)</span></span>;</span><br><span class="line"> boost::asio::io_context ioc;</span><br><span class="line"> boost::asio::ip::<span class="function">tcp::acceptor <span class="title">acceptor</span><span class="params">(ioc, ep.protocol())</span></span>;</span><br><span class="line"> boost::system::error_code ec;</span><br><span class="line">    <span class="comment">//将端点绑定道acceptor这个socket上，与这个端点链接的端点都能被接受到</span></span><br><span class="line"> acceptor.<span class="built_in">bind</span>(ep, ec);</span><br><span class="line"> <span class="keyword">if</span> (ec.<span class="built_in">value</span>() != <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">//打开失败</span></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Failed to bind the acceptor socket.&quot;</span></span><br><span class="line">   &lt;&lt; <span class="string">&quot;Error code = &quot;</span> &lt;&lt; ec.<span class="built_in">value</span>() &lt;&lt; <span class="string">&quot;. Message: &quot;</span></span><br><span class="line">   &lt;&lt; ec.<span class="built_in">message</span>();</span><br><span class="line">  <span class="keyword">return</span> ec.<span class="built_in">value</span>();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="可以把端口绑定和acceptor的传建合起来写"><a href="#可以把端口绑定和acceptor的传建合起来写" class="headerlink" title="可以把端口绑定和acceptor的传建合起来写"></a>可以把端口绑定和acceptor的传建合起来写</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新版本的写法,默认绑定了8888的端口</span></span><br><span class="line">boost::asio::ip::<span class="function">tcp::acceptor <span class="title">acceptor</span><span class="params">(ioc,boost::asio::ip::tcp::v4(),<span class="number">8888</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="链接指定的端点"><a href="#链接指定的端点" class="headerlink" title="链接指定的端点"></a>链接指定的端点</h3><ul>
<li>作为客户端可以连接服务器指定的端点进行连接</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对应客户端发送链接请求</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">connect_to_end</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> std::string raw_ip_address = <span class="string">&quot;192.168.168.124&quot;</span>;</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">short</span> port_num = <span class="number">8888</span>;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  boost::asio::ip::<span class="function">tcp::endpoint <span class="title">ep</span><span class="params">(boost::asio::ip::address::from_string(raw_ip_address),</span></span></span><br><span class="line"><span class="params"><span class="function">   port_num)</span></span>;</span><br><span class="line">  boost::asio::io_context ioc;</span><br><span class="line">  boost::asio::ip::<span class="function">tcp::socket <span class="title">sock</span><span class="params">(ioc, ep.protocol())</span></span>;</span><br><span class="line">  sock.<span class="built_in">connect</span>(ep);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">catch</span> (boost::system::system_error&amp; e) &#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Error occured! Error code = &quot;</span> &lt;&lt; e.<span class="built_in">code</span>()</span><br><span class="line">   &lt;&lt; <span class="string">&quot;. Message: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>();</span><br><span class="line">  <span class="keyword">return</span> e.<span class="built_in">code</span>().<span class="built_in">value</span>();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="服务器接收来连接"><a href="#服务器接收来连接" class="headerlink" title="服务器接收来连接"></a>服务器接收来连接</h3><ul>
<li>当有客户端连接时，服务器需要接收连接</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">accept_new_connection</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="comment">//指定连接队列的大小(用来存取未被及时处理的链接)</span></span><br><span class="line"> <span class="type">const</span> <span class="type">int</span> BACKLOG_SIZE = <span class="number">30</span>;</span><br><span class="line"> <span class="comment">//端口</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">short</span> port_num = <span class="number">8888</span>;</span><br><span class="line"> <span class="comment">// 创建端点</span></span><br><span class="line"> boost::asio::ip::<span class="function">tcp::endpoint <span class="title">ep</span><span class="params">(boost::asio::ip::address_v4::any(),</span></span></span><br><span class="line"><span class="params"><span class="function">  port_num)</span></span>;</span><br><span class="line"> boost::asio::io_context ioc;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">/*新版连接方式</span></span><br><span class="line"><span class="comment">        //boost::asio::ip::tcp::acceptor acceptor(io_context, boost::asio::ip::tcp::endpoint(boost::asio::ip::tcp::v4(), port_num));</span></span><br><span class="line"><span class="comment">        //这个可写可不写</span></span><br><span class="line"><span class="comment">        acceptor.listen();</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">  <span class="comment">// 创建指定类型的连接器</span></span><br><span class="line">  boost::asio::ip::<span class="function">tcp::acceptor <span class="title">acceptor</span><span class="params">(ioc, ep.protocol())</span></span>;</span><br><span class="line">  <span class="comment">//绑定端点</span></span><br><span class="line">  acceptor.<span class="built_in">bind</span>(ep);</span><br><span class="line">  <span class="comment">//监听事件</span></span><br><span class="line">  acceptor.<span class="built_in">listen</span>(BACKLOG_SIZE);</span><br><span class="line">  <span class="comment">// 创建一个活跃的sock 用来连接</span></span><br><span class="line">  boost::asio::ip::<span class="function">tcp::socket <span class="title">sock</span><span class="params">(ioc)</span></span>;</span><br><span class="line">  <span class="comment">// 连接</span></span><br><span class="line">  acceptor.<span class="built_in">accept</span>(sock);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">catch</span> (boost::system::system_error&amp; e) &#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Error occured! Error code = &quot;</span> &lt;&lt; e.<span class="built_in">code</span>()</span><br><span class="line">   &lt;&lt; <span class="string">&quot;. Message: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>();</span><br><span class="line">  <span class="keyword">return</span> e.<span class="built_in">code</span>().<span class="built_in">value</span>();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>在早期版本的 Boost.Asio 中，在使用 ip::tcp::acceptor 对象之前，通常需要调用 bind 函数将 acceptor 绑定到特定的地址和端口上，并调用 listen 函数开始监听连接请求。</p>
</li>
<li><p>但在较新的版本中，Boost.Asio 已经做了一些改进，使得在创建 ip::tcp::acceptor 对象时可以通过构造函数直接指定绑定地址和端口，并且开始监听连接请求。这样可以简化代码，并且提供了更方便的接口。</p>
</li>
</ul>
<h4 id="创建acceptor的几种方法"><a href="#创建acceptor的几种方法" class="headerlink" title="创建acceptor的几种方法"></a>创建acceptor的几种方法</h4><p>当使用 Boost.Asio 创建 TCP 服务器时，通常有以下几种方法来创建 acceptor 对象：</p>
<p>使用端点对象创建 acceptor：</p>
<p>这是最常见的方法。你首先创建一个 TCP 端点对象（boost::asio::ip::tcp::endpoint），指定要监听的特定地址和端口。然后，使用这个端点对象来创建 acceptor 对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">boost::asio::ip::<span class="function">tcp::endpoint <span class="title">endpoint</span><span class="params">(boost::asio::ip::address_v4::any(), <span class="number">8888</span>)</span></span>;</span><br><span class="line">boost::asio::io_context io_context;</span><br><span class="line">boost::asio::ip::<span class="function">tcp::acceptor <span class="title">acceptor</span><span class="params">(io_context, endpoint)</span></span>;</span><br></pre></td></tr></table></figure>
<p>使用协议对象创建 acceptor：</p>
<ul>
<li>你也可以直接使用 TCP 协议对象（boost::asio::ip::tcp::v4() 或 boost::asio::ip::tcp::v6()）来创建 acceptor 对象。在这种情况下，acceptor 将监听服务器上的所有网络接口。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">boost::asio::io_context io_context;</span><br><span class="line">boost::asio::ip::<span class="function">tcp::acceptor <span class="title">acceptor</span><span class="params">(io_context, boost::asio::ip::tcp::v4(), <span class="number">8888</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>延迟绑定端口：</p>
<ul>
<li>有时你可能希望在创建 acceptor 对象后，稍后再将其绑定到指定的地址和端口上。这样的话，在创建 acceptor 时不需要传递端点对象或协议对象。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">boost::asio::io_context io_context;</span><br><span class="line">boost::asio::ip::<span class="function">tcp::acceptor <span class="title">acceptor</span><span class="params">(io_context)</span></span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">boost::asio::ip::<span class="function">tcp::endpoint <span class="title">endpoint</span><span class="params">(boost::asio::ip::address_v4::any(), <span class="number">8888</span>)</span></span>;</span><br><span class="line">acceptor.<span class="built_in">bind</span>(endpoint);</span><br></pre></td></tr></table></figure>
<ul>
<li>总的来说，创建 acceptor 对象的方法取决于你的需求。如果你想监听特定的地址和端口，则使用端点对象或协议对象；如果你希望在稍后再绑定端口，则延迟绑定端口。</li>
</ul>
<h3 id="关于buffer"><a href="#关于buffer" class="headerlink" title="关于buffer"></a>关于buffer</h3><ul>
<li>任何网络库都有提供buffer的数据结构，所谓buffer就是接收和发送数据时缓存数据的结构。</li>
<li>boost::asio提供了<strong>asio::mutable_buffer</strong> 和 <strong>asio::const_buffer</strong>这两个结构，他们是一段连续的空间，首字节存储了后续数据的长度。</li>
<li>asio::mutable_buffer用于写服务，asio::const_buffer用于读服务。但是这两个结构都没有被asio的api直接使用。</li>
<li>对于api的buffer参数，asio提出了MutableBufferSequence和ConstBufferSequence概念，他们是由多个asio::mutable_buffer和asio::const_buffer组成的。也就是说boost::asio为了节省空间，将一部分连续的空间组合起来，作为参数交给api使用。</li>
<li>我们可以理解为MutableBufferSequence的数据结构为<strong>std::vector<asio::mutable_buffer></strong><br>结构如下</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/C++asio网络编程/image-1.png" alt="示例图片" style="zoom:100%;" /></p>
<ul>
<li>每个vector存储的都是mutable_buffer的地址，每个mutable_buffer的第一个字节表示数据的长度，后面跟着数据内容。</li>
<li>这么复杂的结构交给用户使用并不合适，所以asio提出了buffer()函数，该函数接收多种形式的字节流，该函数返回asio::mutable_buffers_1 o或者asio::const_buffers_1结构的对象。</li>
<li>如果传递给buffer()的参数是一个只读类型，则函数返回asio::const_buffers_1 类型对象。</li>
<li>如果传递给buffer()的参数是一个可写类型，则返回asio::mutable_buffers_1 类型对象。</li>
<li><strong>asio::const_buffers_1</strong>和<strong>asio::mutable_buffers_1</strong>是asio::mutable_buffer和asio::const_buffer的适配器，提供了符合MutableBufferSequence和ConstBufferSequence概念的接口，所以他们可以作为boost::asio的api函数的参数使用。</li>
<li>简单概括一下，我们可以用buffer()函数生成我们要用的缓存存储数据。<br>比如boost的发送接口send要求的参数为ConstBufferSequence类型</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ConstBufferSequence&gt;</span></span><br><span class="line"><span class="function">std::<span class="type">size_t</span> <span class="title">send</span><span class="params">(<span class="type">const</span> ConstBufferSequence &amp; buffers)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>我们需要手动转换</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟构造const_buffer的结构,这样写非常的麻烦</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_const_buffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> std::string buf = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"> boost::<span class="function">asio::const_buffer <span class="title">asio_buf</span><span class="params">(buf.c_str(), buf.length())</span></span>;</span><br><span class="line"> std::vector&lt;boost::asio::const_buffer&gt; buffers_sequence;</span><br><span class="line"> buffers_sequence.<span class="built_in">push_back</span>(asio_buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="字符串的buffer"><a href="#字符串的buffer" class="headerlink" title="字符串的buffer"></a>字符串的buffer</h4><ul>
<li>最终buffers_sequence就是可以传递给发送接口send的类型。但是这太复杂了，可以直接用buffer函数转化为send需要的参数类型</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 他会自动模拟上述操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_buffer_str</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> boost::asio::const_buffers_1 output_buffer = boost::asio::<span class="built_in">buffer</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>output_buf可以直接传递给该send接口。我们也可以将数组转化为send接受的类型</li>
</ul>
<h4 id="数组的buffer"><a href="#数组的buffer" class="headerlink" title="数组的buffer"></a>数组的buffer</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_buffer_array</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="type">const</span> <span class="type">size_t</span> BUF_SIZE_BYTES = <span class="number">20</span>;</span><br><span class="line"> <span class="function">std::unique_ptr&lt;<span class="type">char</span>[]&gt; <span class="title">buf</span><span class="params">(<span class="keyword">new</span> <span class="type">char</span>[BUF_SIZE_BYTES])</span></span>;</span><br><span class="line"> <span class="keyword">auto</span> input_buf = boost::asio::<span class="built_in">buffer</span>(<span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(buf.<span class="built_in">get</span>()), BUF_SIZE_BYTES);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>其中可以不强制转换为void*</li>
</ul>
<h4 id="流式的buffer"><a href="#流式的buffer" class="headerlink" title="流式的buffer"></a>流式的buffer</h4><ul>
<li>对于流式操作，我们可以用streambuf，将输入输出流和streambuf绑定，可以实现流式输入和输出。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_stream_buffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    boost::asio::streambuf buf;</span><br><span class="line">    <span class="function">std::ostream <span class="title">output</span><span class="params">(&amp;buf)</span></span>;</span><br><span class="line">    <span class="comment">// Writing the message to the stream-based buffer.</span></span><br><span class="line">    output &lt;&lt; <span class="string">&quot;Message1\nMessage2&quot;</span>;</span><br><span class="line">    <span class="comment">// Now we want to read all data from a streambuf</span></span><br><span class="line">    <span class="comment">// until &#x27;\n&#x27; delimiter.</span></span><br><span class="line">    <span class="comment">// Instantiate an input stream which uses our </span></span><br><span class="line">    <span class="comment">// stream buffer.</span></span><br><span class="line">    <span class="function">std::istream <span class="title">input</span><span class="params">(&amp;buf)</span></span>;</span><br><span class="line">    <span class="comment">// We&#x27;ll read data into this string.</span></span><br><span class="line">    std::string message1;</span><br><span class="line">    std::<span class="built_in">getline</span>(input, message1);</span><br><span class="line">    <span class="comment">// Now message1 string contains &#x27;Message1&#x27;.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="容器的buffer"><a href="#容器的buffer" class="headerlink" title="容器的buffer"></a>容器的buffer</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">char</span>&gt; data = &#123; <span class="comment">/* 初始化数据 */</span> &#125;;</span><br><span class="line">boost::asio::const_buffer buffer = boost::asio::<span class="built_in">buffer</span>(data);</span><br></pre></td></tr></table></figure>
<h4 id="指向缓冲区的指针的buffer"><a href="#指向缓冲区的指针的buffer" class="headerlink" title="指向缓冲区的指针的buffer"></a>指向缓冲区的指针的buffer</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> data[<span class="number">1024</span>];</span><br><span class="line">boost::asio::mutable_buffer buffer = boost::asio::<span class="built_in">buffer</span>(data, <span class="built_in">sizeof</span>(data));</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="同步读写"><a href="#同步读写" class="headerlink" title="同步读写"></a>同步读写</h2><h3 id="同步写-write-some"><a href="#同步写-write-some" class="headerlink" title="同步写 write_some"></a>同步写 write_some</h3><ul>
<li>boost::asio提供了几种同步写的api，write_some可以每次向指定的空间写入固定的字节数，如果写缓冲区满了，就只写一部分，返回写入的字节数。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_to_socket</span><span class="params">(boost::asio::ip::tcp::socket&amp; sock)</span> </span>&#123;</span><br><span class="line"> std::string buf = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line"> std::<span class="type">size_t</span> total_bytes_written = <span class="number">0</span>;</span><br><span class="line"> <span class="comment">//循环发送</span></span><br><span class="line">    <span class="comment">//write_some返回每次写入的字节数</span></span><br><span class="line">    <span class="comment">//total_bytes_written是已经发送的字节数。</span></span><br><span class="line">    <span class="comment">//每次发送buf.length()- total_bytes_written)字节数据</span></span><br><span class="line"> <span class="keyword">while</span> (total_bytes_written != buf.<span class="built_in">length</span>()) &#123;</span><br><span class="line">  total_bytes_written += sock.<span class="built_in">write_some</span>(boost::asio::<span class="built_in">buffer</span>(</span><br><span class="line">   buf.<span class="built_in">c_str</span>() + total_bytes_written, buf.<span class="built_in">length</span>() - total_bytes_written));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">send_data_by_write_some</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  std::string raw_ip_address = <span class="string">&quot;192.168.168.123&quot;</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> port_nums = <span class="number">8888</span>;</span><br><span class="line">  boost::asio::ip::<span class="function">tcp::endpoint <span class="title">ep</span><span class="params">(boost::asio::ip::address::from_string(raw_ip_address), port_nums)</span></span>;</span><br><span class="line">  boost::asio::io_context ioc;</span><br><span class="line">  boost::asio::ip::<span class="function">tcp::socket <span class="title">sock</span><span class="params">(ioc, ep.protocol())</span></span>;</span><br><span class="line">  sock.<span class="built_in">connect</span>(ep);</span><br><span class="line">  <span class="built_in">write_to_socket</span>(sock);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">catch</span> (boost::system::system_error&amp; e) &#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Error occured! Error code = &quot;</span> &lt;&lt; e.<span class="built_in">code</span>()</span><br><span class="line">   &lt;&lt; <span class="string">&quot;. Message: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="同步写-send"><a href="#同步写-send" class="headerlink" title="同步写 send"></a>同步写 send</h3><ul>
<li>write_some使用起来比较麻烦，需要多次调用，asio提供了send函数。send函数会一次性将buffer中的内容发送给对端，如果有部分字节因为发送缓冲区满无法发送，则阻塞等待，直到发送缓冲区可用，则继续发送完成。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">send_data_by_send</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  std::string raw_ip_address = <span class="string">&quot;192.168.168.123&quot;</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> port_nums = <span class="number">8888</span>;</span><br><span class="line">  boost::asio::ip::<span class="function">tcp::endpoint <span class="title">ep</span><span class="params">(boost::asio::ip::address::from_string(raw_ip_address), port_nums)</span></span>;</span><br><span class="line">  boost::asio::io_context ioc;</span><br><span class="line">  boost::asio::ip::<span class="function">tcp::socket <span class="title">sock</span><span class="params">(ioc, ep.protocol())</span></span>;</span><br><span class="line">  sock.<span class="built_in">connect</span>(ep);</span><br><span class="line">  std::string buf = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">  <span class="comment">// send表示发完你要发的所有数据为止才返回</span></span><br><span class="line">  <span class="comment">//三种放回值 &lt;0 表示系统级错误 =0 对端关闭</span></span><br><span class="line">  <span class="comment">// &gt;0 必为发送的长度</span></span><br><span class="line">  <span class="type">int</span> send_length = sock.<span class="built_in">send</span>(boost::asio::<span class="built_in">buffer</span>(buf.<span class="built_in">c_str</span>(), buf.<span class="built_in">length</span>());</span><br><span class="line">  </span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">catch</span> (boost::system::system_error&amp; e) &#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Error occured! Error code = &quot;</span> &lt;&lt; e.<span class="built_in">code</span>()</span><br><span class="line">   &lt;&lt; <span class="string">&quot;. Message: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="同步写-write"><a href="#同步写-write" class="headerlink" title="同步写 write"></a>同步写 write</h3><ul>
<li>类似send方法，asio还提供了一个write函数，可以一次性将所有数据发送给对端，如果发送缓冲区满了则阻塞，直到发送缓冲区可用，将数据发送完成。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">send_data_by_write</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  std::string raw_ip_address = <span class="string">&quot;192.168.168.123&quot;</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> port_nums = <span class="number">8888</span>;</span><br><span class="line">  boost::asio::ip::<span class="function">tcp::endpoint <span class="title">ep</span><span class="params">(boost::asio::ip::address::from_string(raw_ip_address), port_nums)</span></span>;</span><br><span class="line">  boost::asio::io_context ioc;</span><br><span class="line">  boost::asio::ip::<span class="function">tcp::socket <span class="title">sock</span><span class="params">(ioc, ep.protocol())</span></span>;</span><br><span class="line">  sock.<span class="built_in">connect</span>(ep);</span><br><span class="line">  std::string buf = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">  <span class="comment">// send表示发完你要发的所有数据为止才返回</span></span><br><span class="line">  <span class="comment">//三种放回值 &lt;0 表示系统级错误 =0 对端关闭</span></span><br><span class="line">  <span class="comment">// &gt;0 必为发送的长度</span></span><br><span class="line">  <span class="type">int</span> send_length = boost::asio::<span class="built_in">write</span>(sock, boost::asio::<span class="built_in">buffer</span>(buf.<span class="built_in">c_str</span>(), buf.<span class="built_in">length</span>());</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">catch</span> (boost::system::system_error&amp; e) &#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Error occured! Error code = &quot;</span> &lt;&lt; e.<span class="built_in">code</span>()</span><br><span class="line">   &lt;&lt; <span class="string">&quot;. Message: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="同步读-read-some"><a href="#同步读-read-some" class="headerlink" title="同步读 read_some"></a>同步读 read_some</h3><ul>
<li>同步读和同步写类似，提供了读取指定字节数的接口read_some</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">read_from_socket</span><span class="params">(boost::asio::ip::tcp::socket&amp; sock)</span> </span>&#123;</span><br><span class="line"> <span class="type">const</span> <span class="type">unsigned</span> <span class="type">short</span> MESSAGE_SIZE = <span class="number">7</span>;</span><br><span class="line"> <span class="type">char</span> buf[MESSAGE_SIZE];</span><br><span class="line"> std::<span class="type">size_t</span> total_bytes_read = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">while</span> (total_bytes_read != MESSAGE_SIZE) &#123;</span><br><span class="line">  total_bytes_read += sock.<span class="built_in">read_some</span>(boost::asio::<span class="built_in">buffer</span>(buf + total_bytes_read, MESSAGE_SIZE - total_bytes_read));</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> std::<span class="built_in">string</span>(buf,total_bytes_read);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_data_by_read_some</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> std::string raw_ip_address = <span class="string">&quot;192.168.168.132&quot;</span>;</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">short</span> port_num = <span class="number">888</span>;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  boost::asio::ip::<span class="function">tcp::endpoint <span class="title">ep</span><span class="params">(boost::asio::ip::address::from_string(raw_ip_address), port_num)</span></span>;</span><br><span class="line">  boost::asio::io_context ioc;</span><br><span class="line">  boost::asio::ip::<span class="function">tcp::socket <span class="title">sock</span><span class="params">(ioc, ep.protocol())</span></span>;</span><br><span class="line">  sock.<span class="built_in">connect</span>(ep);</span><br><span class="line">  <span class="built_in">read_from_socket</span>(sock);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">catch</span> (boost::system::system_error&amp; e) &#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Error occured! Error code = &quot;</span> &lt;&lt; e.<span class="built_in">code</span>()</span><br><span class="line">   &lt;&lt; <span class="string">&quot;. Message: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>();</span><br><span class="line">  <span class="comment">//return e.code().value();</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="同步读-receive"><a href="#同步读-receive" class="headerlink" title="同步读 receive"></a>同步读 receive</h3><ul>
<li>可以一次性同步接收对方发送的数据</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">read_data_by_receive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string raw_ip_address = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> port_num = <span class="number">3333</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        boost::asio::ip::<span class="function">tcp::endpoint</span></span><br><span class="line"><span class="function">            <span class="title">ep</span><span class="params">(boost::asio::ip::address::from_string(raw_ip_address),</span></span></span><br><span class="line"><span class="params"><span class="function">                port_num)</span></span>;</span><br><span class="line">        boost::asio::io_service ios;</span><br><span class="line">        boost::asio::ip::<span class="function">tcp::socket <span class="title">sock</span><span class="params">(ios, ep.protocol())</span></span>;</span><br><span class="line">        sock.<span class="built_in">connect</span>(ep);</span><br><span class="line">        <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> BUFF_SIZE = <span class="number">7</span>;</span><br><span class="line">         <span class="type">char</span> buffer_receive[BUFF_SIZE];</span><br><span class="line">        <span class="type">int</span> receive_length =  sock.<span class="built_in">receive</span>(boost::asio::<span class="built_in">buffer</span>(buffer_receive, BUFF_SIZE));</span><br><span class="line">        <span class="keyword">if</span> (receive_length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;receive failed&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (boost::system::system_error&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Error occured! Error code = &quot;</span> &lt;&lt; e.<span class="built_in">code</span>()</span><br><span class="line">            &lt;&lt; <span class="string">&quot;. Message: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>();</span><br><span class="line">        <span class="keyword">return</span> e.<span class="built_in">code</span>().<span class="built_in">value</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="同步读-read"><a href="#同步读-read" class="headerlink" title="同步读 read"></a>同步读 read</h3><ul>
<li>可以一次性同步读取对方发送的数据</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">read_data_by_read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string raw_ip_address = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> port_num = <span class="number">3333</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        asio::ip::<span class="function">tcp::endpoint</span></span><br><span class="line"><span class="function">            <span class="title">ep</span><span class="params">(asio::ip::address::from_string(raw_ip_address),</span></span></span><br><span class="line"><span class="params"><span class="function">                port_num)</span></span>;</span><br><span class="line">        asio::io_service ios;</span><br><span class="line">        asio::ip::<span class="function">tcp::socket <span class="title">sock</span><span class="params">(ios, ep.protocol())</span></span>;</span><br><span class="line">        sock.<span class="built_in">connect</span>(ep);</span><br><span class="line">        <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> BUFF_SIZE = <span class="number">7</span>;</span><br><span class="line">        <span class="type">char</span> buffer_receive[BUFF_SIZE];</span><br><span class="line">        <span class="type">int</span> receive_length = asio::<span class="built_in">read</span>(sock, asio::<span class="built_in">buffer</span>(buffer_receive, BUFF_SIZE));</span><br><span class="line">        <span class="keyword">if</span> (receive_length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;receive failed&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (system::system_error&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Error occured! Error code = &quot;</span> &lt;&lt; e.<span class="built_in">code</span>()</span><br><span class="line">            &lt;&lt; <span class="string">&quot;. Message: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>();</span><br><span class="line">        <span class="keyword">return</span> e.<span class="built_in">code</span>().<span class="built_in">value</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="读取直到指定字符"><a href="#读取直到指定字符" class="headerlink" title="读取直到指定字符"></a>读取直到指定字符</h3><ul>
<li>我们可以一直读取，直到读取指定字符结束</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string  <span class="title">read_data_by_until</span><span class="params">(asio::ip::tcp::socket&amp; sock)</span> </span>&#123;</span><br><span class="line">    asio::streambuf buf;</span><br><span class="line">    <span class="comment">// Synchronously read data from the socket until</span></span><br><span class="line">    <span class="comment">// &#x27;\n&#x27; symbol is encountered.  </span></span><br><span class="line">    asio::<span class="built_in">read_until</span>(sock, buf, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    std::string message;</span><br><span class="line">    <span class="comment">// Because buffer &#x27;buf&#x27; may contain some other data</span></span><br><span class="line">    <span class="comment">// after &#x27;\n&#x27; symbol, we have to parse the buffer and</span></span><br><span class="line">    <span class="comment">// extract only symbols before the delimiter. </span></span><br><span class="line">    <span class="function">std::istream <span class="title">input_stream</span><span class="params">(&amp;buf)</span></span>;</span><br><span class="line">    std::<span class="built_in">getline</span>(input_stream, message);</span><br><span class="line">    <span class="keyword">return</span> message;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="同步读写的客户端与服务端"><a href="#同步读写的客户端与服务端" class="headerlink" title="同步读写的客户端与服务端"></a>同步读写的客户端与服务端</h2><ul>
<li>前面我们介绍了boost::asio同步读写的api函数，现在将前面的api串联起来，做一个能跑起来的客户端和服务器。</li>
<li>客户端和服务器采用阻塞的同步读写方式完成通信</li>
</ul>
<h3 id="客户端的设计"><a href="#客户端的设计" class="headerlink" title="客户端的设计"></a>客户端的设计</h3><ul>
<li>客户端设计基本思路是根据服务器对端的ip和端口创建一个endpoint，然后创建socket连接这个endpoint，之后就可以用同步读写的方式发送和接收数据了。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::asio::ip;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MAX_LENGTH = <span class="number">1024</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//创建上下文</span></span><br><span class="line">        boost::asio::io_context ioc;</span><br><span class="line">        <span class="comment">//构造终端端点</span></span><br><span class="line">        <span class="function">tcp::endpoint <span class="title">ep</span><span class="params">(address::from_string(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="number">8888</span>)</span></span>;</span><br><span class="line">        <span class="comment">//创建socket</span></span><br><span class="line">        <span class="function">tcp::socket <span class="title">sock</span><span class="params">(ioc, ep.protocol())</span></span>;</span><br><span class="line">        <span class="comment">//声明错误</span></span><br><span class="line">        boost::system::error_code error = boost::asio::error::host_not_found;</span><br><span class="line">        <span class="comment">//建立连接</span></span><br><span class="line">        sock.<span class="built_in">connect</span>(ep, error);</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;connect failed, code is&quot;</span></span><br><span class="line">                &lt;&lt; error.<span class="built_in">value</span>() &lt;&lt; <span class="string">&quot;message is &quot;</span> &lt;&lt; error.<span class="built_in">message</span>() &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Enter message: &quot;</span>;</span><br><span class="line">        <span class="type">char</span> request[MAX_LENGTH];</span><br><span class="line">        std::cin.<span class="built_in">getline</span>(request, MAX_LENGTH);</span><br><span class="line">        <span class="type">size_t</span> request_length = std::<span class="built_in">strlen</span>(request);</span><br><span class="line">        boost::asio::<span class="built_in">write</span>(sock, boost::asio::<span class="built_in">buffer</span>(request, request_length));</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> reply[MAX_LENGTH];</span><br><span class="line">        <span class="type">size_t</span> reply_length = boost::asio::<span class="built_in">read</span>(sock, boost::asio::<span class="built_in">buffer</span>(reply, request_length));</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;reply is &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout.<span class="built_in">write</span>(reply, reply_length);</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Exception&quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="服务端设计"><a href="#服务端设计" class="headerlink" title="服务端设计"></a>服务端设计</h3><h4 id="session函数"><a href="#session函数" class="headerlink" title="session函数"></a>session函数</h4><ul>
<li>创建session函数，该函数为服务器处理客户端请求，每当我们获取客户端连接后就调用该函数。在session函数里里进行echo方式的读写，所谓echo就是应答式的处理</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">session</span><span class="params">(socket_ptr sock)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">   <span class="type">char</span> data[max_length];</span><br><span class="line">   <span class="built_in">memset</span>(data, <span class="string">&#x27;\0&#x27;</span>, max_length);</span><br><span class="line">   boost::system::error_code error;</span><br><span class="line">   <span class="comment">//size_t length = boost::asio::read(sock, boost::asio::buffer(data, max_length), error);</span></span><br><span class="line">   <span class="type">size_t</span> length = sock-&gt;<span class="built_in">read_some</span>(boost::asio::<span class="built_in">buffer</span>(data, max_length), error);</span><br><span class="line">   <span class="keyword">if</span> (error == boost::asio::error::eof) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;connection closed by peer&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (error) &#123;</span><br><span class="line">    <span class="keyword">throw</span> boost::system::<span class="built_in">system_error</span>(error);</span><br><span class="line">   &#125;</span><br><span class="line">   std::cout &lt;&lt; <span class="string">&quot;receive from &quot;</span> &lt;&lt; sock-&gt;<span class="built_in">remote_endpoint</span>().<span class="built_in">address</span>().<span class="built_in">to_string</span>() &lt;&lt; std::endl;</span><br><span class="line">   std::cout &lt;&lt; <span class="string">&quot;receive message is &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">   <span class="comment">//回传给对方</span></span><br><span class="line">   boost::asio::<span class="built_in">write</span>(*sock, boost::asio::<span class="built_in">buffer</span>(data, length));</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">  std::cerr &lt;&lt; <span class="string">&quot;Exception in thread: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="server函数"><a href="#server函数" class="headerlink" title="server函数"></a>server函数</h4><ul>
<li>server函数根据服务器ip和端口创建服务器acceptor用来接收数据，用socket接收新的连接，然后为这个socket创建session。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">server</span><span class="params">(boost::asio::io_context&amp; io_context, <span class="type">unsigned</span> <span class="type">short</span> port)</span> </span>&#123;</span><br><span class="line"> <span class="comment">// boost::asio::ip::address_v4::any()第一个参数与这个效果一样</span></span><br><span class="line"> <span class="function">tcp::endpoint <span class="title">ep</span><span class="params">(tcp::v4(), port)</span></span>;</span><br><span class="line"> <span class="function">tcp::acceptor <span class="title">a</span><span class="params">(io_context, ep)</span></span>;</span><br><span class="line"> <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="function">socket_ptr <span class="title">sock</span><span class="params">(<span class="keyword">new</span> tcp::socket(io_context))</span></span>;</span><br><span class="line">  a.<span class="built_in">accept</span>(*sock);</span><br><span class="line">  <span class="keyword">auto</span> t = std::<span class="built_in">make_shared</span>&lt;std::thread&gt;(session, sock);</span><br><span class="line">  thread_set.<span class="built_in">insert</span>(t);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>创建线程调用session函数可以分配独立的线程用于socket的读写，保证acceptor不会因为socket的读写而阻塞。</li>
</ul>
<h4 id="完整服务端代码"><a href="#完整服务端代码" class="headerlink" title="完整服务端代码"></a>完整服务端代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::asio::ip;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> max_length = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::shared_ptr&lt;tcp::socket&gt; socket_ptr;</span><br><span class="line">std::set&lt;std::shared_ptr&lt;std::thread&gt;&gt; thread_set;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">session</span><span class="params">(socket_ptr sock)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">   <span class="type">char</span> data[max_length];</span><br><span class="line">   <span class="built_in">memset</span>(data, <span class="string">&#x27;\0&#x27;</span>, max_length);</span><br><span class="line">   boost::system::error_code error;</span><br><span class="line">   <span class="comment">//size_t length = boost::asio::read(sock, boost::asio::buffer(data, max_length), error);</span></span><br><span class="line">   <span class="type">size_t</span> length = sock-&gt;<span class="built_in">read_some</span>(boost::asio::<span class="built_in">buffer</span>(data, max_length), error);</span><br><span class="line">   <span class="keyword">if</span> (error == boost::asio::error::eof) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;connection closed by peer&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (error) &#123;</span><br><span class="line">    <span class="keyword">throw</span> boost::system::<span class="built_in">system_error</span>(error);</span><br><span class="line">   &#125;</span><br><span class="line">   std::cout &lt;&lt; <span class="string">&quot;receive from &quot;</span> &lt;&lt; sock-&gt;<span class="built_in">remote_endpoint</span>().<span class="built_in">address</span>().<span class="built_in">to_string</span>() &lt;&lt; std::endl;</span><br><span class="line">   std::cout &lt;&lt; <span class="string">&quot;receive message is &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">   <span class="comment">//回传给对方</span></span><br><span class="line">   boost::asio::<span class="built_in">write</span>(*sock, boost::asio::<span class="built_in">buffer</span>(data, length));</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">  std::cerr &lt;&lt; <span class="string">&quot;Exception in thread: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">server</span><span class="params">(boost::asio::io_context&amp; io_context, <span class="type">unsigned</span> <span class="type">short</span> port)</span> </span>&#123;</span><br><span class="line"> <span class="comment">// boost::asio::ip::address_v4::any()第一个参数与这个效果一样</span></span><br><span class="line"> <span class="function">tcp::endpoint <span class="title">ep</span><span class="params">(tcp::v4(), port)</span></span>;</span><br><span class="line"> <span class="function">tcp::acceptor <span class="title">a</span><span class="params">(io_context, ep)</span></span>;</span><br><span class="line"> <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="function">socket_ptr <span class="title">sock</span><span class="params">(<span class="keyword">new</span> tcp::socket(io_context))</span></span>;</span><br><span class="line">  a.<span class="built_in">accept</span>(*sock);</span><br><span class="line">  <span class="keyword">auto</span> t = std::<span class="built_in">make_shared</span>&lt;std::thread&gt;(session, sock);</span><br><span class="line">  thread_set.<span class="built_in">insert</span>(t);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  boost::asio::io_context ioc;</span><br><span class="line">  <span class="built_in">server</span>(ioc, <span class="number">8888</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; td : thread_set) &#123;</span><br><span class="line">   <span class="keyword">if</span> (td-&gt;<span class="built_in">joinable</span>()) &#123;</span><br><span class="line">    td-&gt;<span class="built_in">join</span>();</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="同步读写的优劣"><a href="#同步读写的优劣" class="headerlink" title="同步读写的优劣"></a>同步读写的优劣</h3><ol>
<li>同步读写的缺陷在于读写是阻塞的，如果客户端对端不发送数据服务器的read操作是阻塞的，这将导致服务器处于阻塞等待状态。</li>
<li>可以通过开辟新的线程为新生成的连接处理读写，但是一个进程开辟的线程是有限的，约为2048个线程，在Linux环境可以通过unlimit增加一个进程开辟的线程数，但是线程过多也会导致切换消耗的时间片较多。</li>
<li>该服务器和客户端为应答式，实际场景为全双工通信模式，发送和接收要独立分开。</li>
<li>该服务器和客户端未考虑粘包处理。</li>
</ol>
<ul>
<li>综上所述，是我们这个服务器和客户端存在的问题，为解决上述问题，我们在接下里的文章里做不断完善和改进，主要以异步读写改进上述方案。<br>当然同步读写的方式也有其优点，比如客户端连接数不多，而且服务器并发性不高的场景，可以使用同步读写的方式。使用同步读写能简化编码难度。</li>
</ul>
<h2 id="asio异步读写操作及注意事项"><a href="#asio异步读写操作及注意事项" class="headerlink" title="asio异步读写操作及注意事项"></a>asio异步读写操作及注意事项</h2><ul>
<li>我们定义一个session类，这个session类表示服务器处理客户端连接的管理类</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Session</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">Session</span>(std::shared_ptr&lt;boost::asio::ip::tcp::socket&gt; socket);</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">Connect</span><span class="params">(<span class="type">const</span> boost::asio::ip::tcp::endpoint&amp; ep)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> std::shared_ptr&lt;boost::asio::ip::tcp::socket&gt; sock;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Session.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Session::<span class="built_in">Session</span>(std::shared_ptr&lt;boost::asio::ip::tcp::socket&gt; socket): <span class="built_in">sock</span>(socket)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::Connect</span><span class="params">(<span class="type">const</span> boost::asio::ip::tcp::endpoint&amp; ep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> sock-&gt;<span class="built_in">connect</span>(ep);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="异步写操作"><a href="#异步写操作" class="headerlink" title="异步写操作"></a>异步写操作</h3><ul>
<li>在写操作前，我们先封装一个Node结构，用来管理要发送和接收的数据，该结构包含数据域首地址，数据的总长度，以及已经处理的长度(已读的长度或者已写的长度)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MsgNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//用来构造写节点</span></span><br><span class="line"> <span class="built_in">MsgNode</span>(<span class="type">const</span> <span class="type">char</span>* msg, <span class="type">int</span> total_len) : _total_len(total_len), _cur_len(<span class="number">0</span>) &#123;</span><br><span class="line">  _msg = <span class="keyword">new</span> <span class="type">char</span>[total_len];</span><br><span class="line">  <span class="built_in">memcpy</span>(_msg, msg, total_len);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用来构造读节点</span></span><br><span class="line"> <span class="built_in">MsgNode</span>(<span class="type">int</span> total_len) :_total_len(total_len), _cur_len(<span class="number">0</span>) &#123;</span><br><span class="line">  _msg = <span class="keyword">new</span> <span class="type">char</span>[total_len];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> ~<span class="built_in">MsgNode</span>() &#123;</span><br><span class="line">  <span class="keyword">delete</span>[] _msg;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要发送的总长度</span></span><br><span class="line"><span class="type">int</span> _total_len;</span><br><span class="line"><span class="comment">// 当前已经发送了多少长度</span></span><br><span class="line"><span class="type">int</span> _cur_len;</span><br><span class="line"><span class="comment">// 指向数据的指针</span></span><br><span class="line"><span class="type">char</span>* _msg;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>写了两个构造函数，两个参数的负责构造写节点，一个参数的负责构造读节点。</p>
</li>
<li><p>接下来为Session添加异步写操作和负责发送写数据的节点</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Session</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">Session</span>(std::shared_ptr&lt;boost::asio::ip::tcp::socket&gt; socket);</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">Connect</span><span class="params">(<span class="type">const</span> boost::asio::ip::tcp::endpoint&amp; ep)</span></span>;</span><br><span class="line"><span class="comment">//第一个参数错误码，第二个参数当前准备发送的长度，第三个参数为占位符用来增加引用</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">WriteCallBackErr</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec, std::<span class="type">size_t</span> bytes_transferred, </span></span></span><br><span class="line"><span class="params"><span class="function">  std::shared_ptr&lt;MsgNode&gt;)</span></span>;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">WriteToSocketErr</span><span class="params">(<span class="type">const</span> std::string buf)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> std::shared_ptr&lt;boost::asio::ip::tcp::socket&gt; sock;</span><br><span class="line"> std::shared_ptr&lt;MsgNode&gt; _send_node;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>WriteToSocketErr函数为我们封装的写操作，WriteCallBackErr为异步写操作回调的函数，为什么会有三个参数呢，</li>
<li>我们可以看一下asio源码</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BOOST_ASIO_COMPLETION_TOKEN_FOR</span>(<span class="built_in">void</span> (boost::system::error_code,</span><br><span class="line">        std::<span class="type">size_t</span>)) <span class="function">WriteToken</span></span><br><span class="line"><span class="function">          <span class="title">BOOST_ASIO_DEFAULT_COMPLETION_TOKEN_TYPE</span><span class="params">(executor_type)</span>&gt;</span></span><br><span class="line"><span class="function">  <span class="title">BOOST_ASIO_INITFN_AUTO_RESULT_TYPE_PREFIX</span><span class="params">(WriteToken,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">void</span> (boost::system::error_code, std::<span class="type">size_t</span>))</span></span></span><br><span class="line"><span class="function">  <span class="title">async_write_some</span><span class="params">(<span class="type">const</span> ConstBufferSequence&amp; buffers,</span></span></span><br><span class="line"><span class="params"><span class="function">      BOOST_ASIO_MOVE_ARG(WriteToken)token</span></span></span><br><span class="line"><span class="params"><span class="function">        BOOST_ASIO_DEFAULT_COMPLETION_TOKEN(executor_type))</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>
<ul>
<li>sync_write_some是异步写的函数，这个异步写函数有两个参数，第一个参数为ConstBufferSequence常引用类型的buffers，</li>
<li>第二个参数为WriteToken类型，而WriteToken在上面定义了，是一个函数对象类型，返回值为void，参数为error_code和size_t，</li>
<li>所以我们为了调用async_write_some函数也要传入一个符合WriteToken定义的函数，就是我们声明的WriteCallBackErr函数，</li>
<li><p>前两个参数为WriteToken规定的参数，第三个参数为MsgNode的智能指针，这样通过智能指针保证我们发送的Node生命周期延长。</p>
</li>
<li><p>我们看一下WriteToSocketErr函数的具体实现</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::WriteToSocketErr</span><span class="params">(<span class="type">const</span> std::string buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">//定义你要写的数据节点</span></span><br><span class="line"> _send_node = std::<span class="built_in">make_shared</span>&lt;MsgNode&gt;(buf.<span class="built_in">c_str</span>(), buf.<span class="built_in">length</span>());</span><br><span class="line"> <span class="comment">//通过socket官方异步写发送数据</span></span><br><span class="line"> <span class="keyword">this</span>-&gt;sock-&gt;<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_send_node-&gt;_msg, _send_node-&gt;_total_len),</span><br><span class="line">  std::<span class="built_in">bind</span>(&amp;Session::WriteCallBackErr, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2,</span><br><span class="line">   _send_node));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>因为WriteCallBackErr函数为三个参数且为成员函数，而async_write_some需要的回调函数为两个参数，所以我们通过bind将三个参数转换为两个参数的普通函数。</p>
</li>
<li><p>我们看看回调函数的实现</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::WriteCallBackErr</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec, std::<span class="type">size_t</span> bytes_transferred, std::shared_ptr&lt;MsgNode&gt; msg_node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">//当前要转发的数据加上已经转发的数据 与 发送总数据做比较</span></span><br><span class="line"> <span class="keyword">if</span> (bytes_transferred + msg_node-&gt;_cur_len &lt; msg_node-&gt;_total_len) &#123;</span><br><span class="line">  <span class="comment">//更新当前已发送的数据</span></span><br><span class="line">  _send_node-&gt;_cur_len += bytes_transferred;</span><br><span class="line">  <span class="comment">// 递归调用继续发送未发送玩的数据</span></span><br><span class="line">  <span class="keyword">this</span>-&gt;sock-&gt;<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_send_node-&gt;_msg</span><br><span class="line">   + _send_node-&gt;_cur_len, _send_node-&gt;_total_len - _send_node-&gt;_cur_len),</span><br><span class="line">   std::<span class="built_in">bind</span>(&amp;Session::WriteCallBackErr, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2,</span><br><span class="line">    _send_node));</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在WriteCallBackErr函数里判断如果已经发送的字节数没有达到要发送的总字节数，那么就更新节点已经发送的长度，然后计算剩余要发送的长度，如果有数据未发送完，再次调用async_write_some函数异步发送。</li>
<li><strong>但是这个函数并不能投入实际应用，因为async_write_some回调函数返回已发送的字节数可能并不是全部长度。比如TCP发送缓存区总大小为8字节，但是有3字节未发送(上一次未发送完)，这样剩余空间为5字节</strong></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/C++asio网络编程/image-2.png" alt="示例图片" style="zoom:100%;" /></p>
<ul>
<li>此时我们调用async_write_some发送hello world!实际发送的长度就是为5，也就是只发送了hello，剩余world!通过我们的回调继续发送。</li>
<li><p>而实际开发的场景用户是不清楚底层tcp的多路复用调用情况的，用户想发送数据的时候就调用WriteToSocketErr,或者循环调用WriteToSocketErr，<strong>很可能在一次没发送完数据还未调用回调函数时再次调用WriteToSocketErr</strong>，因为boost::asio封装的是epoll和iocp等多路复用模型，当写事件就绪后就发数据，发送的数据按照async_write_some调用的顺序发送，所以回调函数内调用的async_write_some可能并没有被及时调用。</p>
</li>
<li><p>比如如下代码：</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用户发送数据</span></span><br><span class="line"><span class="built_in">WriteToSocketErr</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line"><span class="comment">//用户无感知下层调用情况又一次发送了数据</span></span><br><span class="line"><span class="built_in">WriteToSocketErr</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>那么很可能第一次只发送了Hello，后面的数据没发完，第二次发送了Hello World!之后又发送了World!</li>
<li><p>所以对端收到的数据很可能是”HelloHello World! World!”</p>
</li>
<li><p>那怎么解决这个问题呢，<strong>我们可以通过队列保证应用层的发送顺序</strong>。我们在Session中定义一个发送队列，然后重新定义正确的异步发送函数和回调处理</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Session</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">Session</span>(std::shared_ptr&lt;boost::asio::ip::tcp::socket&gt; socket);</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">Connect</span><span class="params">(<span class="type">const</span> boost::asio::ip::tcp::endpoint&amp; ep)</span></span>;</span><br><span class="line"> <span class="comment">//第一个参数错误码，第二个参数当前准备发送的长度，第三个参数为占位符用来增加引用</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">WriteCallBackErr</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec, std::<span class="type">size_t</span> bytes_transferred, </span></span></span><br><span class="line"><span class="params"><span class="function">  std::shared_ptr&lt;MsgNode&gt; msg_node)</span></span>;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">WriteToSocketErr</span><span class="params">(<span class="type">const</span> std::string buf)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//正确的处理方式</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">WriteCallBack</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec, std::<span class="type">size_t</span> bytes_transferred)</span></span>;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">WriteToSocket</span><span class="params">(<span class="type">const</span> std::string buf)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="comment">//用来装要发送的数据</span></span><br><span class="line"> std::queue&lt;std::shared_ptr&lt;MsgNode&gt;&gt; _send_queue;</span><br><span class="line"> std::shared_ptr&lt;boost::asio::ip::tcp::socket&gt; sock;</span><br><span class="line"> std::shared_ptr&lt;MsgNode&gt; _send_node;</span><br><span class="line"> <span class="comment">//标记是否有数据未发送完</span></span><br><span class="line"> <span class="type">bool</span> _send_pending;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>定义了bool变量_send_pending，该变量为true表示一个节点还未发送完。</li>
<li><p>_send_queue用来缓存要发送的消息节点，是一个队列。</p>
</li>
<li><p>我们实现异步发送功能</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::WriteCallBack</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec, std::<span class="type">size_t</span> bytes_transferred)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (ec.<span class="built_in">value</span>() != <span class="number">0</span>) &#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Error , code is &quot;</span> &lt;&lt; ec.<span class="built_in">value</span>() &lt;&lt; <span class="string">&quot; . Message is &quot;</span> &lt;&lt; ec.<span class="built_in">message</span>();</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//取出队首元素即当前未发送完数据</span></span><br><span class="line"> <span class="keyword">auto</span>&amp; send_data = _send_queue.<span class="built_in">front</span>();</span><br><span class="line"> send_data-&gt;_cur_len += bytes_transferred;</span><br><span class="line"> <span class="comment">//数据未发送完， 则继续发送</span></span><br><span class="line"> <span class="keyword">if</span> (send_data-&gt;_cur_len &lt; send_data-&gt;_total_len) &#123;</span><br><span class="line">  <span class="keyword">this</span>-&gt;sock-&gt;<span class="built_in">async_write_some</span>(boost::asio::<span class="built_in">buffer</span>(send_data-&gt;_msg + send_data-&gt;_cur_len, send_data-&gt;_total_len - send_data-&gt;_cur_len),</span><br><span class="line">   std::<span class="built_in">bind</span>(&amp;Session::WriteCallBack,</span><br><span class="line">    <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2));</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//如果发送完，则pop出队首元素</span></span><br><span class="line"> _send_queue.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line"> <span class="comment">//如果队列为空，则说明所有数据都发送完,将pending设置为false</span></span><br><span class="line"> <span class="keyword">if</span> (_send_queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">  _send_pending = <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//如果队列不是空，则继续将队首元素发送</span></span><br><span class="line"> <span class="keyword">if</span> (!_send_queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">  <span class="keyword">auto</span>&amp; send_data = _send_queue.<span class="built_in">front</span>();</span><br><span class="line">  <span class="keyword">this</span>-&gt;sock-&gt;<span class="built_in">async_write_some</span>(boost::asio::<span class="built_in">buffer</span>(send_data-&gt;_msg + send_data-&gt;_cur_len, send_data-&gt;_total_len - send_data-&gt;_cur_len),</span><br><span class="line">   std::<span class="built_in">bind</span>(&amp;Session::WriteCallBack,</span><br><span class="line">    <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2));</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::WriteToSocket</span><span class="params">(<span class="type">const</span> std::string buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">//将数据放入队列中</span></span><br><span class="line"> _send_queue.<span class="built_in">emplace</span>(<span class="keyword">new</span> <span class="built_in">MsgNode</span>(buf.<span class="built_in">c_str</span>(), buf.<span class="built_in">length</span>()));</span><br><span class="line"> <span class="comment">//如果还有数据未发送完，直接返回</span></span><br><span class="line"> <span class="keyword">if</span> (_send_pending) &#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//异步发送数据，因为异步所以不会一下发送完</span></span><br><span class="line"> <span class="keyword">this</span>-&gt;sock-&gt;<span class="built_in">async_write_some</span>(boost::asio::<span class="built_in">buffer</span>(buf), std::<span class="built_in">bind</span>(&amp;Session::WriteCallBack, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2));</span><br><span class="line"> _send_pending = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>async_write_some函数不能保证每次回调函数触发时发送的长度为要总长度，这样我们每次都要在回调函数判断发送数据是否完成，asio提供了一个更简单的发送函数<strong>async_send</strong>，这个函数在发送的长度<strong>未达到我们要求的长度时就不会触发回调</strong>，所以触发回调函数时要么时<strong>发送出错了</strong>要么是<strong>发送完成</strong>了,其<strong>内部的实现原理</strong>就是帮我们<strong>不断的调用async_write_some直到完成发送</strong>，所以<strong>async_send不能和async_write_some混合使用</strong>，我们基于async_send封装另外一个发送函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个回调函数被调用并且没有异常肯定是发完了一个数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::WriteAllCallBack</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec, std::<span class="type">size_t</span> bytes_transferred)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (ec.<span class="built_in">value</span>() != <span class="number">0</span>) &#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Error occured! Error code = &quot;</span></span><br><span class="line">   &lt;&lt; ec.<span class="built_in">value</span>()</span><br><span class="line">   &lt;&lt; <span class="string">&quot;. Message: &quot;</span> &lt;&lt; ec.<span class="built_in">message</span>();</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//如果发送完，则pop出队首元素</span></span><br><span class="line"> _send_queue.<span class="built_in">pop</span>();</span><br><span class="line"> <span class="comment">//如果队列为空，则说明所有数据都发送完,将pending设置为false</span></span><br><span class="line"> <span class="keyword">if</span> (_send_queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">  _send_pending = <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//如果队列不是空，则继续将队首元素发送</span></span><br><span class="line"> <span class="keyword">if</span> (!_send_queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">  <span class="keyword">auto</span>&amp; send_data = _send_queue.<span class="built_in">front</span>();</span><br><span class="line">        <span class="comment">//send的时候由于使用的是async_send所以这可以不使用数据偏移，而直接发送buf，boost::asio::buffer(buf)</span></span><br><span class="line">  <span class="keyword">this</span>-&gt;sock-&gt;<span class="built_in">async_send</span>(boost::asio::<span class="built_in">buffer</span>(send_data-&gt;_msg + send_data-&gt;_cur_len, send_data-&gt;_total_len - send_data-&gt;_cur_len),</span><br><span class="line">   std::<span class="built_in">bind</span>(&amp;Session::WriteAllCallBack,</span><br><span class="line">    <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2));</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不能与async_write_some混合使用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::WriteAllToSocket</span><span class="params">(<span class="type">const</span> std::string buf)</span> </span>&#123;</span><br><span class="line"> <span class="comment">//插入发送队列</span></span><br><span class="line"> _send_queue.<span class="built_in">emplace</span>(<span class="keyword">new</span> <span class="built_in">MsgNode</span>(buf.<span class="built_in">c_str</span>(), buf.<span class="built_in">length</span>()));</span><br><span class="line"> <span class="comment">//pending状态说明上一次有未发送完的数据</span></span><br><span class="line"> <span class="keyword">if</span> (_send_pending) &#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//异步发送数据，因为异步所以不会一下发送完</span></span><br><span class="line"> <span class="keyword">this</span>-&gt;sock-&gt;<span class="built_in">async_send</span>(boost::asio::<span class="built_in">buffer</span>(buf),</span><br><span class="line">  std::<span class="built_in">bind</span>(&amp;Session::WriteAllCallBack, <span class="keyword">this</span>,</span><br><span class="line">   std::placeholders::_1, std::placeholders::_2));</span><br><span class="line"> _send_pending = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="异步读操作"><a href="#异步读操作" class="headerlink" title="异步读操作"></a>异步读操作</h3><ul>
<li><p>接下来介绍异步读操作，异步读操作和异步的写操作类似同样又async_read_some和async_receive函数，前者触发的回调函数获取的读数据的长度可能会小于要求读取的总长度，后者触发的回调函数读取的数据长度等于读取的总长度。</p>
</li>
<li><p>先基于async_read_some封装一个读取的函数ReadFromSocket，同样在Session类的声明中添加一些变量</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::ReadFromSocket</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (_recv_pending) &#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//可以调用构造函数直接构造，但不可用已经构造好的智能指针赋值</span></span><br><span class="line"> <span class="comment">/*auto _recv_nodez = std::make_unique&lt;MsgNode&gt;(RECVSIZE);</span></span><br><span class="line"><span class="comment"> _recv_node = _recv_nodez;*/</span></span><br><span class="line"> _recv_node = std::<span class="built_in">make_shared</span>&lt;MsgNode&gt;(RECVSIZE);</span><br><span class="line">    <span class="comment">//发送要读的数据</span></span><br><span class="line"> sock-&gt;<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_recv_node-&gt;_msg, _recv_node-&gt;_total_len), std::<span class="built_in">bind</span>(&amp;Session::ReadCallBack, <span class="keyword">this</span>,</span><br><span class="line">  std::placeholders::_1, std::placeholders::_2));</span><br><span class="line"> _recv_pending = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::ReadCallBack</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec, std::<span class="type">size_t</span> bytes_transferred)</span> </span>&#123;</span><br><span class="line"> _recv_node-&gt;_cur_len += bytes_transferred;</span><br><span class="line"> <span class="comment">//没读完继续读</span></span><br><span class="line"> <span class="keyword">if</span> (_recv_node-&gt;_cur_len &lt; _recv_node-&gt;_total_len) &#123;</span><br><span class="line">        <span class="comment">//要加上数据的偏移</span></span><br><span class="line">  sock-&gt;<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_recv_node-&gt;_msg + _recv_node-&gt;_cur_len,</span><br><span class="line">   _recv_node-&gt;_total_len - _recv_node-&gt;_cur_len), std::<span class="built_in">bind</span>(&amp;Session::ReadCallBack, <span class="keyword">this</span>,</span><br><span class="line">    std::placeholders::_1, std::placeholders::_2));</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//将数据投递到队列里交给逻辑线程处理，此处略去</span></span><br><span class="line"> <span class="comment">//如果读完了则将标记置为false</span></span><br><span class="line"> _recv_pending = <span class="literal">false</span>;</span><br><span class="line"> <span class="comment">//指针置空</span></span><br><span class="line"> _recv_node = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>我们基于async_receive再封装一个接收数据的函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::ReadAllFromSocket</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (_recv_pending) &#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//可以调用构造函数直接构造，但不可用已经构造好的智能指针赋值</span></span><br><span class="line"> <span class="comment">/*auto _recv_nodez = std::make_unique&lt;MsgNode&gt;(RECVSIZE);</span></span><br><span class="line"><span class="comment"> _recv_node = _recv_nodez;*/</span></span><br><span class="line"> _recv_node = std::<span class="built_in">make_shared</span>&lt;MsgNode&gt;(RECVSIZE);</span><br><span class="line"> sock-&gt;<span class="built_in">async_receive</span>(boost::asio::<span class="built_in">buffer</span>(_recv_node-&gt;_msg, _recv_node-&gt;_total_len), std::<span class="built_in">bind</span>(&amp;Session::ReadAllCallBack, <span class="keyword">this</span>,</span><br><span class="line">  std::placeholders::_1, std::placeholders::_2));</span><br><span class="line"> _recv_pending = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::ReadAllCallBack</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec, std::<span class="type">size_t</span> bytes_transferred)</span> </span>&#123;</span><br><span class="line"> _recv_node-&gt;_cur_len += bytes_transferred;</span><br><span class="line"> <span class="comment">//将数据投递到队列里交给逻辑线程处理，此处略去</span></span><br><span class="line"> <span class="comment">//如果读完了则将标记置为false</span></span><br><span class="line"> _recv_pending = <span class="literal">false</span>;</span><br><span class="line"> <span class="comment">//指针置空</span></span><br><span class="line"> _recv_node = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结-完整代码"><a href="#总结-完整代码" class="headerlink" title="总结 完整代码"></a>总结 完整代码</h3><h4 id="Session-h头文件"><a href="#Session-h头文件" class="headerlink" title="Session.h头文件"></a>Session.h头文件</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="comment">//最大报文接收大小</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> RECVSIZE = <span class="number">1024</span>; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MsgNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">MsgNode</span>(<span class="type">const</span> <span class="type">char</span>* msg, <span class="type">int</span> total_len) : _total_len(total_len), _cur_len(<span class="number">0</span>) &#123;</span><br><span class="line">  _msg = <span class="keyword">new</span> <span class="type">char</span>[total_len];</span><br><span class="line">  <span class="built_in">memcpy</span>(_msg, msg, total_len);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">MsgNode</span>(<span class="type">int</span> total_len) :_total_len(total_len), _cur_len(<span class="number">0</span>) &#123;</span><br><span class="line">  _msg = <span class="keyword">new</span> <span class="type">char</span>[total_len];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> ~<span class="built_in">MsgNode</span>() &#123;</span><br><span class="line">  <span class="keyword">delete</span>[] _msg;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 要发送的总长度</span></span><br><span class="line"> <span class="type">int</span> _total_len;</span><br><span class="line"> <span class="comment">// 当前发送了多少长度</span></span><br><span class="line"> <span class="type">int</span> _cur_len;</span><br><span class="line"> <span class="comment">// 指向数据的指针</span></span><br><span class="line"> <span class="type">char</span>* _msg;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Session</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">Session</span>(std::shared_ptr&lt;boost::asio::ip::tcp::socket&gt; socket);</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">Connect</span><span class="params">(<span class="type">const</span> boost::asio::ip::tcp::endpoint&amp; ep)</span></span>;</span><br><span class="line"> <span class="comment">//第一个参数错误码，第二个参数当前准备发送的长度，第三个参数为占位符用来增加引用</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">WriteCallBackErr</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec, std::<span class="type">size_t</span> bytes_transferred, </span></span></span><br><span class="line"><span class="params"><span class="function">  std::shared_ptr&lt;MsgNode&gt; msg_node)</span></span>;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">WriteToSocketErr</span><span class="params">(<span class="type">const</span> std::string buf)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//正确的处理方式</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">WriteCallBack</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec, std::<span class="type">size_t</span> bytes_transferred)</span></span>;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">WriteToSocket</span><span class="params">(<span class="type">const</span> std::string buf)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">WriteAllCallBack</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec, std::<span class="type">size_t</span> bytes_transferred)</span></span>;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">WriteAllToSocket</span><span class="params">(<span class="type">const</span> std::string buf)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">ReadFromSocket</span><span class="params">()</span></span>;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">ReadCallBack</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec, std::<span class="type">size_t</span> bytes_transferred)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">ReadAllFromSocket</span><span class="params">()</span></span>;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">ReadAllCallBack</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec, std::<span class="type">size_t</span> bytes_transferred)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="comment">//用来装要发送的数据</span></span><br><span class="line"> std::queue&lt;std::shared_ptr&lt;MsgNode&gt;&gt; _send_queue;</span><br><span class="line"> std::shared_ptr&lt;boost::asio::ip::tcp::socket&gt; sock;</span><br><span class="line"> std::shared_ptr&lt;MsgNode&gt; _send_node;</span><br><span class="line"> <span class="comment">//标记是否有数据未发送完</span></span><br><span class="line"> <span class="type">bool</span> _send_pending;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//读取节点</span></span><br><span class="line"> std::shared_ptr&lt;MsgNode&gt; _recv_node;</span><br><span class="line"> <span class="comment">//标记数据是否接收完全</span></span><br><span class="line"> <span class="type">bool</span> _recv_pending;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="Session-cpp"><a href="#Session-cpp" class="headerlink" title="Session.cpp"></a>Session.cpp</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Session.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Session::<span class="built_in">Session</span>(std::shared_ptr&lt;boost::asio::ip::tcp::socket&gt; socket): <span class="built_in">sock</span>(socket), _send_pending(<span class="literal">false</span>),_recv_pending(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::Connect</span><span class="params">(<span class="type">const</span> boost::asio::ip::tcp::endpoint&amp; ep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> sock-&gt;<span class="built_in">connect</span>(ep);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::WriteCallBackErr</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec, std::<span class="type">size_t</span> bytes_transferred, std::shared_ptr&lt;MsgNode&gt; msg_node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">//当前要转发的数据加上已经转发的数据 与 发送总数据做比较</span></span><br><span class="line"> <span class="keyword">if</span> (bytes_transferred + msg_node-&gt;_cur_len &lt; msg_node-&gt;_total_len) &#123;</span><br><span class="line">  <span class="comment">//更新当前已发送的数据</span></span><br><span class="line">  _send_node-&gt;_cur_len += bytes_transferred;</span><br><span class="line">  <span class="comment">// 递归调用继续发送未发送玩的数据</span></span><br><span class="line">  <span class="keyword">this</span>-&gt;sock-&gt;<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_send_node-&gt;_msg</span><br><span class="line">   + _send_node-&gt;_cur_len, _send_node-&gt;_total_len - _send_node-&gt;_cur_len),</span><br><span class="line">   std::<span class="built_in">bind</span>(&amp;Session::WriteCallBackErr, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2,</span><br><span class="line">    _send_node));</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::WriteToSocketErr</span><span class="params">(<span class="type">const</span> std::string buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">//定义你要写的数据节点</span></span><br><span class="line"> _send_node = std::<span class="built_in">make_shared</span>&lt;MsgNode&gt;(buf.<span class="built_in">c_str</span>(), buf.<span class="built_in">length</span>());</span><br><span class="line"> <span class="comment">//通过socket官方异步写发送数据</span></span><br><span class="line"> <span class="keyword">this</span>-&gt;sock-&gt;<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_send_node-&gt;_msg, _send_node-&gt;_total_len),</span><br><span class="line">  std::<span class="built_in">bind</span>(&amp;Session::WriteCallBackErr, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2,</span><br><span class="line">   _send_node));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::WriteCallBack</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec, std::<span class="type">size_t</span> bytes_transferred)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (ec.<span class="built_in">value</span>() != <span class="number">0</span>) &#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Error , code is &quot;</span> &lt;&lt; ec.<span class="built_in">value</span>() &lt;&lt; <span class="string">&quot; . Message is &quot;</span> &lt;&lt; ec.<span class="built_in">message</span>();</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//取出队首元素即当前未发送完数据</span></span><br><span class="line"> <span class="keyword">auto</span>&amp; send_data = _send_queue.<span class="built_in">front</span>();</span><br><span class="line"> send_data-&gt;_cur_len += bytes_transferred;</span><br><span class="line"> <span class="comment">//数据未发送完， 则继续发送</span></span><br><span class="line"> <span class="keyword">if</span> (send_data-&gt;_cur_len &lt; send_data-&gt;_total_len) &#123;</span><br><span class="line">  <span class="keyword">this</span>-&gt;sock-&gt;<span class="built_in">async_write_some</span>(boost::asio::<span class="built_in">buffer</span>(send_data-&gt;_msg + send_data-&gt;_cur_len, send_data-&gt;_total_len - send_data-&gt;_cur_len),</span><br><span class="line">   std::<span class="built_in">bind</span>(&amp;Session::WriteCallBack,</span><br><span class="line">    <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2));</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//如果发送完，则pop出队首元素</span></span><br><span class="line"> _send_queue.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line"> <span class="comment">//如果队列为空，则说明所有数据都发送完,将pending设置为false</span></span><br><span class="line"> <span class="keyword">if</span> (_send_queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">  _send_pending = <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//如果队列不是空，则继续将队首元素发送</span></span><br><span class="line"> <span class="keyword">if</span> (!_send_queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">  <span class="keyword">auto</span>&amp; send_data = _send_queue.<span class="built_in">front</span>();</span><br><span class="line">  <span class="keyword">this</span>-&gt;sock-&gt;<span class="built_in">async_write_some</span>(boost::asio::<span class="built_in">buffer</span>(send_data-&gt;_msg + send_data-&gt;_cur_len, send_data-&gt;_total_len - send_data-&gt;_cur_len),</span><br><span class="line">   std::<span class="built_in">bind</span>(&amp;Session::WriteCallBack,</span><br><span class="line">    <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2));</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::WriteToSocket</span><span class="params">(<span class="type">const</span> std::string buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">//将数据放入队列中</span></span><br><span class="line"> _send_queue.<span class="built_in">emplace</span>(<span class="keyword">new</span> <span class="built_in">MsgNode</span>(buf.<span class="built_in">c_str</span>(), buf.<span class="built_in">length</span>()));</span><br><span class="line"> <span class="comment">//如果还有数据未发送完，直接返回</span></span><br><span class="line"> <span class="keyword">if</span> (_send_pending) &#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//异步发送数据，因为异步所以不会一下发送完</span></span><br><span class="line"> <span class="keyword">this</span>-&gt;sock-&gt;<span class="built_in">async_write_some</span>(boost::asio::<span class="built_in">buffer</span>(buf), std::<span class="built_in">bind</span>(&amp;Session::WriteCallBack, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2));</span><br><span class="line"> _send_pending = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个回调函数被调用并且没有异常肯定是发完了一个数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::WriteAllCallBack</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec, std::<span class="type">size_t</span> bytes_transferred)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (ec.<span class="built_in">value</span>() != <span class="number">0</span>) &#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Error occured! Error code = &quot;</span></span><br><span class="line">   &lt;&lt; ec.<span class="built_in">value</span>()</span><br><span class="line">   &lt;&lt; <span class="string">&quot;. Message: &quot;</span> &lt;&lt; ec.<span class="built_in">message</span>();</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//如果发送完，则pop出队首元素</span></span><br><span class="line"> _send_queue.<span class="built_in">pop</span>();</span><br><span class="line"> <span class="comment">//如果队列为空，则说明所有数据都发送完,将pending设置为false</span></span><br><span class="line"> <span class="keyword">if</span> (_send_queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">  _send_pending = <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//如果队列不是空，则继续将队首元素发送</span></span><br><span class="line"> <span class="keyword">if</span> (!_send_queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">  <span class="keyword">auto</span>&amp; send_data = _send_queue.<span class="built_in">front</span>();</span><br><span class="line">  <span class="keyword">this</span>-&gt;sock-&gt;<span class="built_in">async_send</span>(boost::asio::<span class="built_in">buffer</span>(send_data-&gt;_msg + send_data-&gt;_cur_len, send_data-&gt;_total_len - send_data-&gt;_cur_len),</span><br><span class="line">   std::<span class="built_in">bind</span>(&amp;Session::WriteAllCallBack,</span><br><span class="line">    <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2));</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不能与async_write_some混合使用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::WriteAllToSocket</span><span class="params">(<span class="type">const</span> std::string buf)</span> </span>&#123;</span><br><span class="line"> <span class="comment">//插入发送队列</span></span><br><span class="line"> _send_queue.<span class="built_in">emplace</span>(<span class="keyword">new</span> <span class="built_in">MsgNode</span>(buf.<span class="built_in">c_str</span>(), buf.<span class="built_in">length</span>()));</span><br><span class="line"> <span class="comment">//pending状态说明上一次有未发送完的数据</span></span><br><span class="line"> <span class="keyword">if</span> (_send_pending) &#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//异步发送数据，因为异步所以不会一下发送完</span></span><br><span class="line"> <span class="keyword">this</span>-&gt;sock-&gt;<span class="built_in">async_send</span>(boost::asio::<span class="built_in">buffer</span>(buf),</span><br><span class="line">  std::<span class="built_in">bind</span>(&amp;Session::WriteAllCallBack, <span class="keyword">this</span>,</span><br><span class="line">   std::placeholders::_1, std::placeholders::_2));</span><br><span class="line"> _send_pending = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::ReadFromSocket</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (_recv_pending) &#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//可以调用构造函数直接构造，但不可用已经构造好的智能指针赋值</span></span><br><span class="line"> <span class="comment">/*auto _recv_nodez = std::make_unique&lt;MsgNode&gt;(RECVSIZE);</span></span><br><span class="line"><span class="comment"> _recv_node = _recv_nodez;*/</span></span><br><span class="line"> _recv_node = std::<span class="built_in">make_shared</span>&lt;MsgNode&gt;(RECVSIZE);</span><br><span class="line"> sock-&gt;<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_recv_node-&gt;_msg, _recv_node-&gt;_total_len), std::<span class="built_in">bind</span>(&amp;Session::ReadCallBack, <span class="keyword">this</span>,</span><br><span class="line">  std::placeholders::_1, std::placeholders::_2));</span><br><span class="line"> _recv_pending = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::ReadCallBack</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec, std::<span class="type">size_t</span> bytes_transferred)</span> </span>&#123;</span><br><span class="line"> _recv_node-&gt;_cur_len += bytes_transferred;</span><br><span class="line"> <span class="comment">//没读完继续读</span></span><br><span class="line"> <span class="keyword">if</span> (_recv_node-&gt;_cur_len &lt; _recv_node-&gt;_total_len) &#123;</span><br><span class="line">  sock-&gt;<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_recv_node-&gt;_msg + _recv_node-&gt;_cur_len,</span><br><span class="line">   _recv_node-&gt;_total_len - _recv_node-&gt;_cur_len), std::<span class="built_in">bind</span>(&amp;Session::ReadCallBack, <span class="keyword">this</span>,</span><br><span class="line">    std::placeholders::_1, std::placeholders::_2));</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//将数据投递到队列里交给逻辑线程处理，此处略去</span></span><br><span class="line"> <span class="comment">//如果读完了则将标记置为false</span></span><br><span class="line"> _recv_pending = <span class="literal">false</span>;</span><br><span class="line"> <span class="comment">//指针置空</span></span><br><span class="line"> _recv_node = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::ReadAllFromSocket</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (_recv_pending) &#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//可以调用构造函数直接构造，但不可用已经构造好的智能指针赋值</span></span><br><span class="line"> <span class="comment">/*auto _recv_nodez = std::make_unique&lt;MsgNode&gt;(RECVSIZE);</span></span><br><span class="line"><span class="comment"> _recv_node = _recv_nodez;*/</span></span><br><span class="line"> _recv_node = std::<span class="built_in">make_shared</span>&lt;MsgNode&gt;(RECVSIZE);</span><br><span class="line"> sock-&gt;<span class="built_in">async_receive</span>(boost::asio::<span class="built_in">buffer</span>(_recv_node-&gt;_msg, _recv_node-&gt;_total_len), std::<span class="built_in">bind</span>(&amp;Session::ReadAllCallBack, <span class="keyword">this</span>,</span><br><span class="line">  std::placeholders::_1, std::placeholders::_2));</span><br><span class="line"> _recv_pending = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::ReadAllCallBack</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec, std::<span class="type">size_t</span> bytes_transferred)</span> </span>&#123;</span><br><span class="line"> _recv_node-&gt;_cur_len += bytes_transferred;</span><br><span class="line"> <span class="comment">//将数据投递到队列里交给逻辑线程处理，此处略去</span></span><br><span class="line"> <span class="comment">//如果读完了则将标记置为false</span></span><br><span class="line"> _recv_pending = <span class="literal">false</span>;</span><br><span class="line"> <span class="comment">//指针置空</span></span><br><span class="line"> _recv_node = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>发送的时候推荐使用 <strong>asyc_send</strong> 而接受的时候 推荐使用 <strong>asyc_rend_some 函数</strong></li>
</ul>
<h2 id="asio官方案例存在的隐患"><a href="#asio官方案例存在的隐患" class="headerlink" title="asio官方案例存在的隐患"></a>asio官方案例存在的隐患</h2><h3 id="Session类"><a href="#Session类" class="headerlink" title="Session类"></a>Session类</h3><ul>
<li>Session类主要是处理客户端消息收发的会话类，为了简单起见，我们不考虑粘包问题，也不考虑支持手动调用发送的接口，只以应答的方式发送和接收固定长度(1024字节长度)的数据。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Session</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">Session</span>(boost::asio::io_context&amp; ioc) :<span class="built_in">sock</span>(ioc) &#123;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> boost::asio::ip::<span class="function">tcp::socket&amp; <span class="title">Socket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sock;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">handle_read</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">size_t</span> bytes_transferred)</span></span>;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">handle_write</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec)</span></span>;</span><br><span class="line"> boost::asio::ip::tcp::socket sock;</span><br><span class="line"> <span class="keyword">enum</span>&#123;max_length = <span class="number">1024</span>&#125;;</span><br><span class="line"> <span class="type">char</span> _data[max_length];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol>
<li>_data用来接收客户端传递的数据</li>
<li>socket为单独处理客户端读写的socket。</li>
<li>handle_read和handle_write分别为读回调函数和写回调函数。</li>
</ol>
<ul>
<li>接下来我们实现Session类</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Session.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::Start</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="built_in">memset</span>(_data, <span class="number">0</span>, max_length);</span><br><span class="line"> sock.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, max_length),</span><br><span class="line">  std::<span class="built_in">bind</span>(&amp;Session::handle_read, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::handle_read</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error,</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="type">size_t</span> bytes_transferred)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;server receive data is &quot;</span> &lt;&lt; _data &lt;&lt; std::endl;</span><br><span class="line">        boost::asio::<span class="built_in">async_write</span>(sock, boost::asio::<span class="built_in">buffer</span>(_data, bytes_transfered),</span><br><span class="line">            std::<span class="built_in">bind</span>(&amp;Session::handle_write, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;read error&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::handle_write</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!error)&#123;</span><br><span class="line">    <span class="built_in">memset</span>(_data, <span class="number">0</span>, max_length);</span><br><span class="line">    sock.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, max_length), std::<span class="built_in">bind</span>(&amp;Session::handle_read,</span><br><span class="line">        <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2));</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在Start方法中我们调用异步读操作，监听对端发送的消息。当对端发送数据后，触发handle_read函数</li>
<li>handle_read函数内将收到的数据发送给对端，当发送完成后触发handle_write回调函数。</li>
<li>handle_write函数内又一次监听了读事件，如果对端有数据发送过来则触发handle_read，我们再将收到的数据发回去。从而达到应答式服务的效果。</li>
</ul>
<h3 id="Server类"><a href="#Server类" class="headerlink" title="Server类"></a>Server类</h3><ul>
<li>Server类为服务器接收连接的管理类</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">Server</span>(boost::asio::io_context&amp; ioc, <span class="type">unsigned</span> <span class="type">short</span> port);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">start_accept</span><span class="params">()</span></span>;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">handle_accept</span><span class="params">(Session* new_session, <span class="type">const</span> boost::system::error_code&amp; error)</span></span>;</span><br><span class="line"> boost::asio::io_context&amp; _ioc;</span><br><span class="line"> boost::asio::ip::tcp::acceptor _acceptor;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="Server实现"><a href="#Server实现" class="headerlink" title="Server实现"></a>Server实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Server::<span class="built_in">Server</span>(boost::asio::io_context&amp; ioc, <span class="type">unsigned</span> <span class="type">short</span> port) : _ioc(ioc), _acceptor(ioc, boost::asio::ip::tcp::<span class="built_in">endpoint</span>(boost::asio::ip::tcp::<span class="built_in">v4</span>(), port)) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Server start success, on port: &quot;</span> &lt;&lt; port &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">start_accept</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Server::start_accept</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Session* new_session = <span class="keyword">new</span> <span class="built_in">Session</span>(_ioc);</span><br><span class="line">    _acceptor.<span class="built_in">async_accept</span>(new_session-&gt;<span class="built_in">Socket</span>(),</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;Server::handle_accept, <span class="keyword">this</span>, new_session, std::placeholders::_1));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Server::handle_accept</span><span class="params">(Session* new_session, <span class="type">const</span> boost::system::error_code&amp; error)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        new_session-&gt;<span class="built_in">Start</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;accept error&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">delete</span> new_session;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理完事件后继续监听连接</span></span><br><span class="line">    <span class="built_in">start_accept</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="隐患"><a href="#隐患" class="headerlink" title="隐患"></a>隐患</h3><ul>
<li>该demo示例为仿照asio官网编写的，其中存在隐患，<strong>就是当服务器即将发送数据前(调用async_write前)，此刻客户端中断</strong>，服务器此时调用async_write会触发发送回调函数，判断ec为非0进而执行<strong>delete this逻辑回收session</strong>。但要注意的是客户端关闭后，在tcp层面会触发读就绪事件，服务器会触发读事件回调函数。在读事件回调函数中判断错误码ec为非0，<strong>进而再次执行delete操作，从而造成二次析构，这是极度危险的。</strong></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>本文介绍了异步的应答服务器设计，但是这种服务器并不会在实际生产中使用，主要有两个原因:</li>
</ul>
<ol>
<li>因为该服务器的发送和接收以应答的方式交互，而并不能做到应用层想随意发送的目的，也就是未做到完全的收发分离(全双工逻辑)。</li>
<li>该服务器未处理粘包，序列化，以及逻辑和收发线程解耦等问题。</li>
<li>该服务器存在二次析构的风险。</li>
</ol>
<ul>
<li>对于官方案例，他考虑到了这个二次析构问题，所以它只会在读成功后进行写，这就保证了同一时期只有一个读取或者写(单工)，但是这依然是一个隐患。</li>
</ul>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><h4 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Session</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">Session</span>(boost::asio::io_context&amp; ioc) :<span class="built_in">sock</span>(ioc) &#123;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> boost::asio::ip::<span class="function">tcp::socket&amp; <span class="title">Socket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sock;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">handle_read</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">size_t</span> bytes_transferred)</span></span>;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">handle_write</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec)</span></span>;</span><br><span class="line"> boost::asio::ip::tcp::socket sock;</span><br><span class="line"> <span class="keyword">enum</span>&#123;max_length = <span class="number">1024</span>&#125;;</span><br><span class="line"> <span class="type">char</span> _data[max_length];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">Server</span>(boost::asio::io_context&amp; ioc, <span class="type">unsigned</span> <span class="type">short</span> port);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">start_accept</span><span class="params">()</span></span>;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">handle_accept</span><span class="params">(Session* new_session, <span class="type">const</span> boost::system::error_code&amp; error)</span></span>;</span><br><span class="line"> boost::asio::io_context&amp; _ioc;</span><br><span class="line"> boost::asio::ip::tcp::acceptor _acceptor;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Session.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::Start</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="built_in">memset</span>(_data, <span class="number">0</span>, max_length);</span><br><span class="line"> sock.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, max_length),</span><br><span class="line">  std::<span class="built_in">bind</span>(&amp;Session::handle_read, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::handle_read</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error,</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="type">size_t</span> bytes_transferred)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;server receive data is &quot;</span> &lt;&lt; _data &lt;&lt; std::endl;</span><br><span class="line">        boost::asio::<span class="built_in">async_write</span>(sock, boost::asio::<span class="built_in">buffer</span>(_data, bytes_transferred),</span><br><span class="line">            std::<span class="built_in">bind</span>(&amp;Session::handle_write, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;read error&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::handle_write</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!error)&#123;</span><br><span class="line">    <span class="built_in">memset</span>(_data, <span class="number">0</span>, max_length);</span><br><span class="line">    sock.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, max_length), std::<span class="built_in">bind</span>(&amp;Session::handle_read,</span><br><span class="line">        <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2));</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Server::<span class="built_in">Server</span>(boost::asio::io_context&amp; ioc, <span class="type">unsigned</span> <span class="type">short</span> port) : _ioc(ioc), _acceptor(ioc, boost::asio::ip::tcp::<span class="built_in">endpoint</span>(boost::asio::ip::tcp::<span class="built_in">v4</span>(), port)) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Server start success, on port: &quot;</span> &lt;&lt; port &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">start_accept</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Server::start_accept</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Session* new_session = <span class="keyword">new</span> <span class="built_in">Session</span>(_ioc);</span><br><span class="line">    _acceptor.<span class="built_in">async_accept</span>(new_session-&gt;<span class="built_in">Socket</span>(),</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;Server::handle_accept, <span class="keyword">this</span>, new_session, std::placeholders::_1));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Server::handle_accept</span><span class="params">(Session* new_session, <span class="type">const</span> boost::system::error_code&amp; error)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        new_session-&gt;<span class="built_in">Start</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;accept error&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">delete</span> new_session;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理完事件后继续监听连接</span></span><br><span class="line">    <span class="built_in">start_accept</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用伪闭包实现连接的安全回收"><a href="#使用伪闭包实现连接的安全回收" class="headerlink" title="使用伪闭包实现连接的安全回收"></a>使用伪闭包实现连接的安全回收</h2><ul>
<li>之前的异步服务器为echo模式，但其存在安全隐患，就是在极端情况下客户端关闭导致触发写和读回调函数，二者都进入错误处理逻辑，进而造成二次析构的问题。</li>
<li>下面我们介绍通过C11智能指针构造成一个伪闭包的状态延长session的生命周期。</li>
</ul>
<h3 id="智能指针管理Session"><a href="#智能指针管理Session" class="headerlink" title="智能指针管理Session"></a>智能指针管理Session</h3><ul>
<li>我们可以通过智能指针的方式管理Session类，将acceptor接收的链接保存在Session类型的智能指针里。由于智能指针会在引用计数为0时自动析构，所以为了防止其被自动回收，也方便Server管理Session，因为我们后期会做一些重连踢人等业务逻辑，我们在Server类中添加成员变量，该变量为一个map类型，key为Session的uid，value为该Session的智能指针。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CServer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CServer</span>(<span class="type">const</span> boost::asio::io_context&amp; io_context, <span class="type">short</span> port);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ClearSession</span><span class="params">(std::string)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">HandleAccept</span><span class="params">(std::shared_ptr&lt;CSession&gt;, <span class="type">const</span> boost::system::error_code&amp; error)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">StartAccept</span><span class="params">()</span></span>;</span><br><span class="line">    boost::asio::io_context&amp; _io_context;</span><br><span class="line">    <span class="type">short</span> _port;</span><br><span class="line">    boost::asio::ip::tcp::acceptor _acceptor;</span><br><span class="line">    std::map&lt;std::string, std::shared_ptr&lt;CSession&gt;&gt; _sessions;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>通过Server中的_sessions这个map管理链接，可以增加Session智能指针的引用计数，只有当Session从这个map中移除后，Session才会被释放。</p>
</li>
<li><p>所以在接收连接的逻辑里将Session放入map</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CServer::StartAccept</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;CSession&gt; new_session = std::<span class="built_in">make_shared</span>&lt;CSession&gt;(_ioc, <span class="keyword">this</span>);</span><br><span class="line">    _acceptor.<span class="built_in">async_accept</span>(new_session-&gt;<span class="built_in">GetSocket</span>(), std::<span class="built_in">bind</span>(&amp;CServer::HandleAccept, <span class="keyword">this</span>, new_session, std::placeholders::_1));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CServer::HandleAccept</span><span class="params">(std::shared_ptr&lt;CSession&gt; new_session, <span class="type">const</span> boost::system::error_code&amp; error)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        new_session-&gt;<span class="built_in">Start</span>();</span><br><span class="line">        <span class="comment">//将session加入map</span></span><br><span class="line">        _sessions.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(new_session-&gt;<span class="built_in">GetUuid</span>(), new_session));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;session accept failed, error is &quot;</span> &lt;&lt; error.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">StartAccept</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>StartAccept函数中虽然new_session是一个局部变量，但是我们通过bind操作，将new_session作为数值传递给bind函数，而bind函数返回的函数对象内部引用了该new_session所以引用计数增加1，这样保证了new_session不会被释放。</li>
<li><p>在HandleAccept函数里调用session的start函数监听对端收发数据，并将session放入map中，保证session不被自动释放。</p>
</li>
<li><p>此外，需要封装一个释放函数，将session从map中移除，当其引用计数为0则自动释放</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CServer::ClearSession</span><span class="params">(std::string&amp; uuid)</span> </span>&#123;</span><br><span class="line">    _sessions.<span class="built_in">erase</span>(uuid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Session的uuid"><a href="#Session的uuid" class="headerlink" title="Session的uuid"></a>Session的uuid</h3><ul>
<li>关于session的uuid可以通过boost提供的生成唯一id的函数获得，当然你也可以自己实现雪花算法。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CSession</span>(boost::asio::io_context&amp; ioc, CServer* server) :<span class="built_in">sock</span>(ioc),_server(server) &#123;</span><br><span class="line"> boost::uuids::uuid a_uuid = boost::uuids::<span class="built_in">random_generator</span>()();</span><br><span class="line"> _uuid = boost::uuids::<span class="built_in">to_string</span>(a_uuid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>另外我们修改Session中读写回调函数关于错误的处理，当读写出错的时候清除连接</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::Start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(_data, <span class="number">0</span>, max_length);</span><br><span class="line">    <span class="comment">// 错误用法, 因为会生成两个shared_ptr来管理同一块内存，他们两的引用计数可能不同</span></span><br><span class="line">  <span class="comment">/*  sock.async_read_some(boost::asio::buffer(_data, max_length),</span></span><br><span class="line"><span class="comment">        std::bind(&amp;CSession::handle_read, this, std::placeholders::_1, std::placeholders::_2, std::shared_ptr&lt;CSession&gt;(this)));*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//正确用法，使用 std::shared_from_this()需要继承std::enable_shared_from_this&lt;CSession&gt; 模板类</span></span><br><span class="line">    <span class="comment">//shared_from_this()内部实现是返回一个智能指针，和存在的智能指针去同步</span></span><br><span class="line">    sock.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, max_length),</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;CSession::handle_read, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, <span class="built_in">shared_from_this</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::handle_read</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">size_t</span> bytes_transferred, std::shared_ptr&lt;CSession&gt; _self_shared)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;server receive data is &quot;</span> &lt;&lt; _data &lt;&lt; std::endl;</span><br><span class="line">        boost::asio::<span class="built_in">async_write</span>(sock, boost::asio::<span class="built_in">buffer</span>(_data, bytes_transferred),</span><br><span class="line">            std::<span class="built_in">bind</span>(&amp;CSession::handle_write, <span class="keyword">this</span>, std::placeholders::_1, _self_shared));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;read error&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        _server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::handle_write</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, std::shared_ptr&lt;CSession&gt; _self_shared)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(_data, <span class="number">0</span>, max_length);</span><br><span class="line">        sock.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, max_length), std::<span class="built_in">bind</span>(&amp;CSession::handle_read,</span><br><span class="line">            <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, _self_shared));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;write error&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        _server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="隐患1"><a href="#隐患1" class="headerlink" title="隐患1"></a>隐患1</h3><ul>
<li>正常情况下上述服务器运行不会出现问题，但是当我们像上次一样模拟，在服务器要发送数据前打个断点，此时关闭客户端，在服务器就会先触发写回调函数的错误处理，再触发读回调函数的错误处理，这样session就会两次从map中移除，因为map中key唯一，所以第二次map判断没有session的key就不做移除操作了。</li>
<li>但是这么做还是会有崩溃问题，因为第一次在session写回调函数中移除session，session的引用计数就为0了，调用了session的析构函数，这样在触发session读回调函数时此时session的内存已经被回收了自然会出现崩溃的问题。解决这个问题可以利用智能指针引用计数和bind的特性，实现一个伪闭包的机制延长session的生命周期。</li>
</ul>
<h3 id="如何实现伪闭包"><a href="#如何实现伪闭包" class="headerlink" title="如何实现伪闭包"></a>如何实现伪闭包</h3><p>思路：</p>
<ol>
<li>利用智能指针被复制或使用引用计数加一的原理保证内存不被回收</li>
<li>bind操作可以将值绑定在一个函数对象上生成新的函数对象，如果将智能指针作为参数绑定给函数对象，那么智能指针就以值的方式被新函数对象使用，那么智能指针的生命周期将和新生成的函数对象一致，从而达到延长生命的效果。</li>
</ol>
<ul>
<li>以HandleWrite举例,在<strong>bind时传递_self_shared指针增加其引用计数</strong>，这样_self_shared的生命周期就和async_write的第二个参数(也就是asio要求的回调函数对象)生命周期一致了。</li>
<li>除此之外，我们也要在第一次绑定读写回调函数的时候传入智能指针的值,但是要注意传入的方式，不能用两个智能指针管理同一块内存，如下用法是错误的。</li>
<li>shared_ptr<CSession>(this)生成的新智能指针和this之前绑定的智能指针并不共享引用计数，所以要通过shared_from_this()函数返回智能指针，该智能指针和其他管理这块内存的智能指针共享引用计数。</li>
<li>shared_from_this()函数并不是session的成员函数，要使用这个函数需要继承std::enable_shared_from_this<Session></li>
</ul>
<h3 id="完整的代码"><a href="#完整的代码" class="headerlink" title="完整的代码"></a>完整的代码</h3><h4 id="实现1"><a href="#实现1" class="headerlink" title="实现1"></a>实现1</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Session.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CServer::StartAccept</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;CSession&gt; new_session = std::<span class="built_in">make_shared</span>&lt;CSession&gt;(_ioc, <span class="keyword">this</span>);</span><br><span class="line">    _acceptor.<span class="built_in">async_accept</span>(new_session-&gt;<span class="built_in">GetSocket</span>(), std::<span class="built_in">bind</span>(&amp;CServer::HandleAccept, <span class="keyword">this</span>, new_session, std::placeholders::_1));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CServer::HandleAccept</span><span class="params">(std::shared_ptr&lt;CSession&gt; new_session, <span class="type">const</span> boost::system::error_code&amp; error)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        new_session-&gt;<span class="built_in">Start</span>();</span><br><span class="line">        <span class="comment">//将session加入map</span></span><br><span class="line">        _sessions.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(new_session-&gt;<span class="built_in">GetUuid</span>(), new_session));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;session accept failed, error is &quot;</span> &lt;&lt; error.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">StartAccept</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CServer::ClearSession</span><span class="params">(std::string&amp; uuid)</span> </span>&#123;</span><br><span class="line">    _sessions.<span class="built_in">erase</span>(uuid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CServer::<span class="built_in">CServer</span>(boost::asio::io_context&amp; ioc, <span class="type">unsigned</span> <span class="type">short</span> port) : _ioc(ioc), _acceptor(ioc, boost::asio::ip::tcp::<span class="built_in">endpoint</span>(boost::asio::ip::tcp::<span class="built_in">v4</span>(), port)) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Server start success, on port: &quot;</span> &lt;&lt; port &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">StartAccept</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::Start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(_data, <span class="number">0</span>, max_length);</span><br><span class="line">    <span class="comment">// 错误用法, 因为会生成两个shared_ptr来管理同一块内存，他们两的引用计数可能不同</span></span><br><span class="line">  <span class="comment">/*  sock.async_read_some(boost::asio::buffer(_data, max_length),</span></span><br><span class="line"><span class="comment">        std::bind(&amp;CSession::handle_read, this, std::placeholders::_1, std::placeholders::_2, std::shared_ptr&lt;CSession&gt;(this)));*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//正确用法，使用 std::shared_from_this()需要继承std::enable_shared_from_this&lt;CSession&gt; 模板类</span></span><br><span class="line">    <span class="comment">//shared_from_this()内部实现是返回一个智能指针，和存在的智能指针去同步</span></span><br><span class="line">    sock.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, max_length),</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;CSession::handle_read, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, <span class="built_in">shared_from_this</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::handle_read</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">size_t</span> bytes_transferred, std::shared_ptr&lt;CSession&gt; _self_shared)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;server receive data is &quot;</span> &lt;&lt; _data &lt;&lt; std::endl;</span><br><span class="line">        boost::asio::<span class="built_in">async_write</span>(sock, boost::asio::<span class="built_in">buffer</span>(_data, bytes_transferred),</span><br><span class="line">            std::<span class="built_in">bind</span>(&amp;CSession::handle_write, <span class="keyword">this</span>, std::placeholders::_1, _self_shared));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;read error&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        _server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::handle_write</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, std::shared_ptr&lt;CSession&gt; _self_shared)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(_data, <span class="number">0</span>, max_length);</span><br><span class="line">        sock.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, max_length), std::<span class="built_in">bind</span>(&amp;CSession::handle_read,</span><br><span class="line">            <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, _self_shared));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;write error&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        _server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="头文件1"><a href="#头文件1" class="headerlink" title="头文件1"></a>头文件1</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/uuid/uuid_generators.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/uuid/uuid_io.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CServer</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CSession</span>: <span class="keyword">public</span> std::enable_shared_from_this&lt;CSession&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">CSession</span>(boost::asio::io_context&amp; ioc, CServer* server) :<span class="built_in">sock</span>(ioc),_server(server) &#123;</span><br><span class="line">  boost::uuids::uuid a_uuid = boost::uuids::<span class="built_in">random_generator</span>()();</span><br><span class="line">  _uuid = boost::uuids::<span class="built_in">to_string</span>(a_uuid);</span><br><span class="line"> &#125;</span><br><span class="line"> boost::asio::ip::<span class="function">tcp::socket&amp; <span class="title">GetSocket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sock;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function">std::string&amp; <span class="title">GetUuid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> _uuid;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">handle_read</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">size_t</span> bytes_transferred, std::shared_ptr&lt;CSession&gt; _self_shared)</span></span>;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">handle_write</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec, std::shared_ptr&lt;CSession&gt; _self_shared)</span></span>;</span><br><span class="line"> boost::asio::ip::tcp::socket sock;</span><br><span class="line"> <span class="keyword">enum</span> &#123; max_length = <span class="number">1024</span> &#125;;</span><br><span class="line"> <span class="type">char</span> _data[max_length];</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 存储唯一标识</span></span><br><span class="line"> std::string _uuid;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 指向CServer的指针</span></span><br><span class="line"> CServer* _server;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CServer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CServer</span>(boost::asio::io_context&amp; ioc, <span class="type">unsigned</span> <span class="type">short</span> port);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ClearSession</span><span class="params">(std::string&amp; uuid)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">HandleAccept</span><span class="params">(std::shared_ptr&lt;CSession&gt;, <span class="type">const</span> boost::system::error_code&amp; error)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">StartAccept</span><span class="params">()</span></span>;</span><br><span class="line"> boost::asio::io_context&amp; _ioc;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> port;</span><br><span class="line">    boost::asio::ip::tcp::acceptor _acceptor;</span><br><span class="line">    std::map&lt;std::string, std::shared_ptr&lt;CSession&gt;&gt; _sessions;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="封装服务器发送队列"><a href="#封装服务器发送队列" class="headerlink" title="封装服务器发送队列"></a>封装服务器发送队列</h2><ul>
<li><strong>封装发送队列来保证发送数据的有序性</strong></li>
</ul>
<h3 id="数据节点设计"><a href="#数据节点设计" class="headerlink" title="数据节点设计"></a>数据节点设计</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MsgNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="comment">//用来构造发送节点</span></span><br><span class="line"> <span class="built_in">MsgNode</span>(<span class="type">char</span>* msg, <span class="type">int</span> max_len):_total_len(max_len), _cur_len(<span class="number">0</span>) &#123;</span><br><span class="line">  _data = <span class="keyword">new</span> <span class="type">char</span>[max_len];</span><br><span class="line">  <span class="built_in">memcpy</span>(_data, msg, max_len);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> ~<span class="built_in">MsgNode</span>() &#123;</span><br><span class="line">  <span class="keyword">delete</span>[] _data;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="comment">//已发送的数据</span></span><br><span class="line"> <span class="type">int</span> _cur_len;</span><br><span class="line"> <span class="comment">//总共需要发送的数据</span></span><br><span class="line"> <span class="type">int</span> _total_len;</span><br><span class="line"> <span class="comment">//存取数据的数组</span></span><br><span class="line"> <span class="type">char</span>* _data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol>
<li>_cur_len表示数据当前已处理的长度(已经发送的数据或者已经接收的数据长度)，因为一个数据包存在未发送完或者未接收完的情况。</li>
<li>_max_len表示数据的总长度。</li>
<li>_data表示数据域，已接收或者已发送的数据都放在此空间内。</li>
</ol>
<h3 id="封装发送接口"><a href="#封装发送接口" class="headerlink" title="封装发送接口"></a>封装发送接口</h3><ul>
<li><p>首先在CSession类里新增一个队列存储要发送的数据，因为我们不能保证每次调用发送接口的时候上一次数据已经发送完，就要把要发送的数据放入队列中，通过回调函数不断地发送。而且我们不能保证发送的接口和回调函数的接口在一个线程，所以要增加一个锁保证发送队列安全性。</p>
</li>
<li><p>我们新增一个发送接口Send</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送接口</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Send</span><span class="params">(<span class="type">char</span>* msg, <span class="type">int</span> max_length)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 发送队列</span></span><br><span class="line">std::queue&lt;std::shared_ptr&lt;MsgNode&gt;&gt; _send_que;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保证多线程的安全性</span></span><br><span class="line">std::mutex _send_lock;</span><br></pre></td></tr></table></figure>
<ul>
<li>实现发送接口</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::Send</span><span class="params">(<span class="type">char</span>* msg, <span class="type">int</span> max_length)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//pending 为false表示发送缓冲区是空的</span></span><br><span class="line">    <span class="type">bool</span> pending = <span class="literal">false</span>;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_send_lock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!_send_que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        pending = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _send_que.<span class="built_in">push</span>(std::<span class="built_in">make_shared</span>&lt;MsgNode&gt;(msg, max_length));</span><br><span class="line">    <span class="keyword">if</span> (pending) <span class="keyword">return</span>;</span><br><span class="line">    boost::asio::<span class="built_in">async_write</span>(sock, boost::asio::<span class="built_in">buffer</span>(msg, max_length),</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;CSession::HandleWrite, <span class="keyword">this</span>, std::placeholders::_1, <span class="built_in">shared_from_this</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>发送接口里判断发送队列是否为空，如果不为空说明有数据未发送完，需要将数据放入队列，然后返回。如果发送队列为空，则说明当前没有未发送完的数据，将要发送的数据放入队列并调用async_write函数发送数据。</p>
</li>
<li><p>回调函数的实现</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::HandleWrite</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, std::shared_ptr&lt;CSession&gt; _self_shared)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_send_lock)</span></span>;</span><br><span class="line">        <span class="comment">//因为使用的是async_write，数据一定被发送玩所以可以直接出队</span></span><br><span class="line">        _send_que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (!_send_que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span>&amp; msgnode = _send_que.<span class="built_in">front</span>();</span><br><span class="line">            boost::asio::<span class="built_in">async_write</span>(sock, boost::asio::<span class="built_in">buffer</span>(msgnode-&gt;_data, msgnode-&gt;_total_len),</span><br><span class="line">                std::<span class="built_in">bind</span>(&amp;CSession::HandleWrite, <span class="keyword">this</span>, std::placeholders::_1, _self_shared));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;handle write failed, error is &quot;</span> &lt;&lt; error.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">        _server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>判断发送队列是否为空，为空则发送完，否则不断取出队列数据调用async_write发送，直到队列为空。</li>
</ul>
<h2 id="修改读回调"><a href="#修改读回调" class="headerlink" title="修改读回调"></a>修改读回调</h2><ul>
<li>因为我们要一直监听对端发送的数据，所以要在每次收到数据后继续绑定监听事件</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::HandleRead</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">size_t</span> bytes_transferred, std::shared_ptr&lt;CSession&gt; _self_shared)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;server receive data is &quot;</span> &lt;&lt; _data &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">Send</span>(_data, bytes_transferred);</span><br><span class="line">        <span class="built_in">memset</span>(_data, <span class="number">0</span>, max_length);</span><br><span class="line">        sock.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, max_length),</span><br><span class="line">            std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, _self_shared));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;read error&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        _server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="该节总结"><a href="#该节总结" class="headerlink" title="该节总结"></a>该节总结</h3><ul>
<li>虽然实现了全双工，但是未处理粘包问题</li>
</ul>
<h3 id="封装后完整代码"><a href="#封装后完整代码" class="headerlink" title="封装后完整代码"></a>封装后完整代码</h3><h4 id="msgNode"><a href="#msgNode" class="headerlink" title="msgNode"></a>msgNode</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MsgNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="comment">//用来构造发送节点</span></span><br><span class="line"> <span class="built_in">MsgNode</span>(<span class="type">char</span>* msg, <span class="type">int</span> max_len):_total_len(max_len), _cur_len(<span class="number">0</span>) &#123;</span><br><span class="line">  _data = <span class="keyword">new</span> <span class="type">char</span>[max_len];</span><br><span class="line">  <span class="built_in">memcpy</span>(_data, msg, max_len);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> ~<span class="built_in">MsgNode</span>() &#123;</span><br><span class="line">  <span class="keyword">delete</span>[] _data;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//已发送的数据</span></span><br><span class="line"> <span class="type">int</span> _cur_len;</span><br><span class="line"> <span class="comment">//总共需要发送的数据</span></span><br><span class="line"> <span class="type">int</span> _total_len;</span><br><span class="line"> <span class="comment">//存取数据的数组</span></span><br><span class="line"> <span class="type">char</span>* _data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="CSession"><a href="#CSession" class="headerlink" title="CSession"></a>CSession</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/uuid/uuid_generators.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/uuid/uuid_io.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MsgNode.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CServer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CServer</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CSession</span>: <span class="keyword">public</span> std::enable_shared_from_this&lt;CSession&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">CSession</span>(boost::asio::io_context&amp; ioc, CServer* server) :<span class="built_in">sock</span>(ioc),_server(server) &#123;</span><br><span class="line">  boost::uuids::uuid a_uuid = boost::uuids::<span class="built_in">random_generator</span>()();</span><br><span class="line">  _uuid = boost::uuids::<span class="built_in">to_string</span>(a_uuid);</span><br><span class="line"> &#125;</span><br><span class="line"> boost::asio::ip::<span class="function">tcp::socket&amp; <span class="title">GetSocket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sock;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function">std::string&amp; <span class="title">GetUuid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> _uuid;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 发送接口</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">Send</span><span class="params">(<span class="type">char</span>* msg, <span class="type">int</span> max_length)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">HandleRead</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">size_t</span> bytes_transferred, std::shared_ptr&lt;CSession&gt; _self_shared)</span></span>;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">HandleWrite</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec, std::shared_ptr&lt;CSession&gt; _self_shared)</span></span>;</span><br><span class="line"> boost::asio::ip::tcp::socket sock;</span><br><span class="line"> <span class="keyword">enum</span> &#123; max_length = <span class="number">1024</span> &#125;;</span><br><span class="line"> <span class="type">char</span> _data[max_length];</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 存储唯一标识</span></span><br><span class="line"> std::string _uuid;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 指向CServer的指针</span></span><br><span class="line"> CServer* _server;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 发送队列</span></span><br><span class="line"> std::queue&lt;std::shared_ptr&lt;MsgNode&gt;&gt; _send_que;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//保证多线程的安全性</span></span><br><span class="line"> std::mutex _send_lock;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CSession.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::Send</span><span class="params">(<span class="type">char</span>* msg, <span class="type">int</span> max_length)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//pending 为false表示发送缓冲区是空的</span></span><br><span class="line">    <span class="type">bool</span> pending = <span class="literal">false</span>;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_send_lock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!_send_que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        pending = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _send_que.<span class="built_in">push</span>(std::<span class="built_in">make_shared</span>&lt;MsgNode&gt;(msg, max_length));</span><br><span class="line">    <span class="keyword">if</span> (pending) <span class="keyword">return</span>;</span><br><span class="line">    boost::asio::<span class="built_in">async_write</span>(sock, boost::asio::<span class="built_in">buffer</span>(msg, max_length),</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;CSession::HandleWrite, <span class="keyword">this</span>, std::placeholders::_1, <span class="built_in">shared_from_this</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::Start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(_data, <span class="number">0</span>, max_length);</span><br><span class="line">    <span class="comment">// 错误用法, 因为会生成两个shared_ptr来管理同一块内存，他们两的引用计数可能不同</span></span><br><span class="line">  <span class="comment">/*  sock.async_read_some(boost::asio::buffer(_data, max_length),</span></span><br><span class="line"><span class="comment">        std::bind(&amp;CSession::handle_read, this, std::placeholders::_1, std::placeholders::_2, std::shared_ptr&lt;CSession&gt;(this)));*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//正确用法，使用 std::shared_from_this()需要继承std::enable_shared_from_this&lt;CSession&gt; 模板类</span></span><br><span class="line">    <span class="comment">//shared_from_this()内部实现是返回一个智能指针，和存在的智能指针去同步</span></span><br><span class="line">    sock.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, max_length),</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, <span class="built_in">shared_from_this</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::HandleRead</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">size_t</span> bytes_transferred, std::shared_ptr&lt;CSession&gt; _self_shared)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;server receive data is &quot;</span> &lt;&lt; _data &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">Send</span>(_data, bytes_transferred);</span><br><span class="line">        <span class="built_in">memset</span>(_data, <span class="number">0</span>, max_length);</span><br><span class="line">        sock.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, max_length),</span><br><span class="line">            std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, _self_shared));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;read error&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        _server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::HandleWrite</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, std::shared_ptr&lt;CSession&gt; _self_shared)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_send_lock)</span></span>;</span><br><span class="line">        <span class="comment">//因为使用的是async_write，数据一定被发送玩所以可以直接出队</span></span><br><span class="line">        _send_que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (!_send_que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span>&amp; msgnode = _send_que.<span class="built_in">front</span>();</span><br><span class="line">            boost::asio::<span class="built_in">async_write</span>(sock, boost::asio::<span class="built_in">buffer</span>(msgnode-&gt;_data, msgnode-&gt;_total_len),</span><br><span class="line">                std::<span class="built_in">bind</span>(&amp;CSession::HandleWrite, <span class="keyword">this</span>, std::placeholders::_1, _self_shared));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;handle write failed, error is &quot;</span> &lt;&lt; error.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">        _server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="CServer"><a href="#CServer" class="headerlink" title="CServer"></a>CServer</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CSession.h&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CSession</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CServer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CServer</span>(boost::asio::io_context&amp; ioc, <span class="type">unsigned</span> <span class="type">short</span> port);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ClearSession</span><span class="params">(std::string&amp; uuid)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">HandleAccept</span><span class="params">(std::shared_ptr&lt;CSession&gt;, <span class="type">const</span> boost::system::error_code&amp; error)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">StartAccept</span><span class="params">()</span></span>;</span><br><span class="line">    boost::asio::io_context&amp; _ioc;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> port;</span><br><span class="line">    boost::asio::ip::tcp::acceptor _acceptor;</span><br><span class="line">    std::map&lt;std::string, std::shared_ptr&lt;CSession&gt;&gt; _sessions;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CServer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CServer::StartAccept</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;CSession&gt; new_session = std::<span class="built_in">make_shared</span>&lt;CSession&gt;(_ioc, <span class="keyword">this</span>);</span><br><span class="line">    _acceptor.<span class="built_in">async_accept</span>(new_session-&gt;<span class="built_in">GetSocket</span>(), std::<span class="built_in">bind</span>(&amp;CServer::HandleAccept, <span class="keyword">this</span>, new_session, std::placeholders::_1));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CServer::HandleAccept</span><span class="params">(std::shared_ptr&lt;CSession&gt; new_session, <span class="type">const</span> boost::system::error_code&amp; error)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        new_session-&gt;<span class="built_in">Start</span>();</span><br><span class="line">        <span class="comment">//将session加入map</span></span><br><span class="line">        _sessions.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(new_session-&gt;<span class="built_in">GetUuid</span>(), new_session));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;session accept failed, error is &quot;</span> &lt;&lt; error.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">StartAccept</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CServer::ClearSession</span><span class="params">(std::string&amp; uuid)</span> </span>&#123;</span><br><span class="line">    _sessions.<span class="built_in">erase</span>(uuid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CServer::<span class="built_in">CServer</span>(boost::asio::io_context&amp; ioc, <span class="type">unsigned</span> <span class="type">short</span> port) : _ioc(ioc), _acceptor(ioc, boost::asio::ip::tcp::<span class="built_in">endpoint</span>(boost::asio::ip::tcp::<span class="built_in">v4</span>(), port)) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Server start success, on port: &quot;</span> &lt;&lt; port &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">StartAccept</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="处理网络粘包问题"><a href="#处理网络粘包问题" class="headerlink" title="处理网络粘包问题"></a>处理网络粘包问题</h2><h3 id="什么是粘包"><a href="#什么是粘包" class="headerlink" title="什么是粘包"></a>什么是粘包</h3><ul>
<li>粘包问题是服务器收发数据常遇到的一个现象，当客户端发送多个数据包给服务器时，服务器底层的tcp接收缓冲区收到的数据为粘连在一起的，如下图所示：</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/C++asio网络编程/image-3.png" alt="示例图片" style="zoom:100%;" /></p>
<ul>
<li>当客户端发送两个Hello World！给服务器，服务器TCP接收缓冲区接收了两次，一次是Hello World!Hello, 第二次是World！。</li>
</ul>
<h3 id="粘包原因"><a href="#粘包原因" class="headerlink" title="粘包原因"></a>粘包原因</h3><ul>
<li>因为TCP底层通信是面向字节流的，TCP只保证发送数据的准确性和顺序性，字节流以字节为单位，客户端每次发送N个字节给服务端，N取决于当前客户端的发送缓冲区是否有数据，比如发送缓冲区总大小为10个字节，当前有5个字节数据(上次要发送的数据比如’loveu’)未发送完，那么此时只有5个字节空闲空间，我们调用发送接口发送hello world！其实就是只能发送Hello给服务器，那么服务器一次性读取到的数据就很可能是loveuhello。而剩余的world！只能留给下一次发送，下一次服务器接收到的就是world！如下图：</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/C++asio网络编程/image-4.png" alt="示例图片" style="zoom:100%;" /></p>
<ul>
<li>这是最好理解的粘包问题的产生原因。还有一些其他的原因比如<ol>
<li>客户端的发送频率远高于服务器的接收频率，就会导致数据在服务器的tcp接收缓冲区滞留形成粘连，比如客户端1s内连续发送了两个hello world！,服务器过了2s才接收数据，那一次性读出两个hello world！。</li>
<li>tcp底层的安全和效率机制不允许字节数特别少的小包发送频率过高，tcp会在底层累计数据长度到一定大小才一起发送，比如连续发送1字节的数据要累计到多个字节才发送，可以了解下tcp底层的Nagle算法。</li>
<li>再就是我们提到的最简单的情况，发送端缓冲区有上次未发送完的数据或者接收端的缓冲区里有未取出的数据导致数据粘连。</li>
</ol>
</li>
</ul>
<h3 id="处理粘包"><a href="#处理粘包" class="headerlink" title="处理粘包"></a>处理粘包</h3><ul>
<li>处理粘包的方式主要采用应用层定义收发包格式的方式，这个过程俗称切包处理，常用的协议被称为tlv协议(消息id+消息长度+消息内容)，如下图：</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/C++asio网络编程/image-5.png" alt="示例图片" style="zoom:100%;" /></p>
<ul>
<li>为保证大家容易理解，我们先简化发送的格式，格式变为消息长度+消息内容的方式，之后再完善为tlv格式。</li>
<li>简化后的结构如下图：</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/C++asio网络编程/image-6.png" alt="示例图片" style="zoom:100%;" /></p>
<h3 id="完善消息节点"><a href="#完善消息节点" class="headerlink" title="完善消息节点"></a>完善消息节点</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/uuid/uuid_io.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/uuid/uuid_generators.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MAX_LENGTH = <span class="number">1024</span> * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> HEAD_LENGTH = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MsgNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//用来构造发送节点</span></span><br><span class="line">	<span class="built_in">MsgNode</span>(<span class="type">char</span>* msg, <span class="type">short</span> max_len):_total_len(max_len + HEAD_LENGTN), _cur_len(<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// 要多留一个空间存/0</span></span><br><span class="line">		_data = <span class="keyword">new</span> <span class="type">char</span>[_total_len + <span class="number">1</span>];</span><br><span class="line">		<span class="comment">// 将前两个字节赋值为长度</span></span><br><span class="line">		<span class="built_in">memcpy</span>(_data, &amp;max_len, HEAD_LENGTN);</span><br><span class="line">		<span class="comment">//偏移两个字节存数据长度</span></span><br><span class="line">		<span class="built_in">memcpy</span>(_data + HEAD_LENGTN, msg, max_len);</span><br><span class="line">		_data[_total_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">MsgNode</span>(<span class="type">short</span> max_len):_total_len(max_len), _cur_len(<span class="number">0</span>) &#123;</span><br><span class="line">		_data = <span class="keyword">new</span> <span class="type">char</span>[_total_len + <span class="number">1</span>]();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">MsgNode</span>() &#123;</span><br><span class="line">		<span class="keyword">delete</span>[] _data;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		::<span class="built_in">memset</span>(_data, <span class="number">0</span>, _total_len);</span><br><span class="line">		_cur_len = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//已发送的数据</span></span><br><span class="line">	<span class="type">int</span> _cur_len;</span><br><span class="line">	<span class="comment">//总共需要发送的数据</span></span><br><span class="line">	<span class="type">int</span> _total_len;</span><br><span class="line">	<span class="comment">//存取数据的数组</span></span><br><span class="line">	<span class="type">char</span>* _data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol>
<li>两个参数的构造函数做了完善，之前的构造函数通过消息首地址和长度构造节点数据，现在需要在构造节点的同时把长度信息也写入节点,该构造函数主要用来发送数据时构造发送信息的节点。</li>
<li>一个参数的构造函数为较上次新增的，主要根据消息的长度构造消息节点，该构造函数主要是接收对端数据时构造接收节点调用的。</li>
<li>新增一个Clear函数清除消息节点的数据，主要是避免多次构造节点造成开销。</li>
</ol>
<ul>
<li>数据这么传输</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/C++asio网络编程/image-7.png" alt="示例图片" style="zoom:100%;" /></p>
<h3 id="CSession类完善"><a href="#CSession类完善" class="headerlink" title="CSession类完善"></a>CSession类完善</h3><ul>
<li>为能够对收到的数据切包处理，需要定义一个消息接收节点，一个bool类型的变量表示头部是否解析完成，以及将处理好的头部先缓存起来的结构。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//收到的消息结构</span></span><br><span class="line">std::shared_ptr&lt;MsgNode&gt; _recv_msg_node;</span><br><span class="line"><span class="comment">// 表示头部结构是否接收完</span></span><br><span class="line"><span class="type">bool</span> _b_head_parse;</span><br><span class="line"><span class="comment">//收到的头部结构</span></span><br><span class="line">std::shared_ptr&lt;MsgNode&gt; _recv_head_node;</span><br></pre></td></tr></table></figure>
<ul>
<li>_recv_msg_node用来存储接受的消息体信息</li>
<li>_recv_head_node用来存储接收的头部信息</li>
<li><p>_b_head_parse表示是否处理完头部信息</p>
</li>
<li><p>同时我们新增一个HEAD_LENGTH变量表示数据包头部的大小，修改原消息最大长度为1024*2</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MAX_LENGTH = <span class="number">1024</span> * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> HEAD_LENGTN = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>修改完后的头文件</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/uuid/uuid_generators.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/uuid/uuid_io.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MsgNode.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CServer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CServer</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CSession</span>: <span class="keyword">public</span> std::enable_shared_from_this&lt;CSession&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CSession</span>(boost::asio::io_context&amp; ioc, CServer* server);</span><br><span class="line">	</span><br><span class="line">	~<span class="built_in">CSession</span>();</span><br><span class="line"></span><br><span class="line">	boost::asio::ip::<span class="function">tcp::socket&amp; <span class="title">GetSocket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> sock;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">std::string&amp; <span class="title">GetUuid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _uuid;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Close</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">std::shared_ptr&lt;CSession&gt; <span class="title">SharedSelf</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 发送接口</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Send</span><span class="params">(<span class="type">char</span>* msg, <span class="type">int</span> max_length)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">HandleRead</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="type">size_t</span> bytes_transferred, std::shared_ptr&lt;CSession&gt; _self_shared)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">HandleWrite</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec, std::shared_ptr&lt;CSession&gt; _self_shared)</span></span>;</span><br><span class="line">	boost::asio::ip::tcp::socket sock;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//这个为socket接收数据时候先存入的</span></span><br><span class="line">	<span class="type">char</span> _data[MAX_LENGTH];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 存储唯一标识</span></span><br><span class="line">	std::string _uuid;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 指向CServer的指针</span></span><br><span class="line">	CServer* _server;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 发送队列</span></span><br><span class="line">	std::queue&lt;std::shared_ptr&lt;MsgNode&gt;&gt; _send_que;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//保证多线程的安全性</span></span><br><span class="line">	std::mutex _send_lock;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//收到的消息结构，也就是完整的数据</span></span><br><span class="line">	std::shared_ptr&lt;MsgNode&gt; _recv_msg_node;</span><br><span class="line">	<span class="comment">// 表示头部结构是否接收完</span></span><br><span class="line">	<span class="type">bool</span> _b_head_parse;</span><br><span class="line">	<span class="comment">//收到的头部结构，也就是完整的数据长度</span></span><br><span class="line">	std::shared_ptr&lt;MsgNode&gt; _recv_head_node;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 用于标记是否关闭</span></span><br><span class="line">	<span class="type">bool</span> _b_close;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="完善接收逻辑"><a href="#完善接收逻辑" class="headerlink" title="完善接收逻辑"></a>完善接收逻辑</h3><ul>
<li>需要修改HandleRead函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第二个参数为你接收到的需要读的字节数，第三个参数增加引用计数，防止未处理为就被析构以及二次析构问题</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::HandleRead</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, <span class="type">size_t</span>  bytes_transferred, std::shared_ptr&lt;CSession&gt; shared_self)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        <span class="comment">//已经存入数组的字符数</span></span><br><span class="line">        <span class="type">int</span> copy_len = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 需要读的字节数大于0</span></span><br><span class="line">        <span class="keyword">while</span> (bytes_transferred &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 头部结构未被处理完</span></span><br><span class="line">            <span class="keyword">if</span> (!_b_head_parse) &#123;</span><br><span class="line">                <span class="comment">//收到的数据不足头部大小（待接收的数据字节数加上当前接收完的字节数小于头部结构（两字节））</span></span><br><span class="line">                <span class="keyword">if</span> (bytes_transferred + _recv_head_node-&gt;_cur_len &lt; HEAD_LENGTH) &#123;</span><br><span class="line">                    <span class="comment">//拷贝接收到的头部大小</span></span><br><span class="line">                    <span class="built_in">memcpy</span>(_recv_head_node-&gt;_data + _recv_head_node-&gt;_cur_len, _data + copy_len, bytes_transferred);</span><br><span class="line">                    <span class="comment">//更新已经接收到的字节数</span></span><br><span class="line">                    _recv_head_node-&gt;_cur_len += bytes_transferred;</span><br><span class="line">                    <span class="comment">//将接收数组清空</span></span><br><span class="line">                    ::<span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);</span><br><span class="line">                    <span class="comment">//继续监听读事件</span></span><br><span class="line">                    sock.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, MAX_LENGTH),</span><br><span class="line">                        std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//收到的数据比头部多</span></span><br><span class="line">                <span class="comment">//头部剩余未复制的长度，剩余可能为0 可能&gt;0，不可能&lt;0</span></span><br><span class="line">                <span class="type">int</span> head_remain = HEAD_LENGTH - _recv_head_node-&gt;_cur_len;</span><br><span class="line">                <span class="comment">//将头部补充完整</span></span><br><span class="line">                <span class="built_in">memcpy</span>(_recv_head_node-&gt;_data + _recv_head_node-&gt;_cur_len, _data + copy_len, head_remain);</span><br><span class="line">                <span class="comment">//更新已处理的data长度和剩余未处理的长度</span></span><br><span class="line">                copy_len += head_remain;</span><br><span class="line">                bytes_transferred -= head_remain;</span><br><span class="line">                <span class="comment">//获取头部数据</span></span><br><span class="line">                <span class="type">short</span> data_len = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">//把两字节的数据拷贝出来，得到实际数据的长度</span></span><br><span class="line">                <span class="built_in">memcpy</span>(&amp;data_len, _recv_head_node-&gt;_data, HEAD_LENGTH);</span><br><span class="line"></span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;data_len is &quot;</span> &lt;&lt; data_len &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//头部长度非法</span></span><br><span class="line">                <span class="keyword">if</span> (data_len &gt; MAX_LENGTH) &#123;</span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot;invalid data length is &quot;</span> &lt;&lt; data_len &lt;&lt; std::endl;</span><br><span class="line">                    <span class="comment">//断开连接</span></span><br><span class="line">                    _server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//头部长度合法的话继续执行，接收一个short，构造一个接收节点</span></span><br><span class="line">                _recv_msg_node = std::<span class="built_in">make_shared</span>&lt;MsgNode&gt;(data_len);</span><br><span class="line">                <span class="comment">//消息的长度小于头部规定的长度，说明数据未收全，则先将部分消息放到接收节点里</span></span><br><span class="line">                <span class="keyword">if</span> (bytes_transferred &lt; data_len) &#123;</span><br><span class="line">                    <span class="comment">//先缓存数据道接收节点里</span></span><br><span class="line">                    <span class="built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, bytes_transferred);</span><br><span class="line">                    _recv_msg_node-&gt;_cur_len += bytes_transferred;</span><br><span class="line">                    ::<span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);</span><br><span class="line">                    <span class="comment">//继续监听读事件</span></span><br><span class="line">                    sock.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, MAX_LENGTH),</span><br><span class="line">                        std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));</span><br><span class="line">                    <span class="comment">//头部处理完成</span></span><br><span class="line">                    _b_head_parse = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//消息的长度大于等于头部规定的长度，说明数据粘包了，并且由于进入此逻辑时，头部节点刚被处理完，剩下的一定是接收的数据且能一次性读完</span></span><br><span class="line">                <span class="built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, data_len);</span><br><span class="line"></span><br><span class="line">                _recv_msg_node-&gt;_cur_len += data_len;</span><br><span class="line">                copy_len += data_len;</span><br><span class="line">                bytes_transferred -= data_len;</span><br><span class="line">                _recv_msg_node-&gt;_data[_recv_msg_node-&gt;_total_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;receive data is &quot;</span> &lt;&lt; _recv_msg_node-&gt;_data &lt;&lt; std::endl;</span><br><span class="line">                <span class="comment">//此处可以调用Send发送测试</span></span><br><span class="line">                <span class="built_in">Send</span>(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//继续轮询剩余未处理数据，也就是处理粘包的数据</span></span><br><span class="line">                _b_head_parse = <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">//清空接收节点</span></span><br><span class="line">                _recv_head_node-&gt;<span class="built_in">Clear</span>();</span><br><span class="line">                <span class="comment">//如果待接收的数据字节数小于等于0，也就是处理完了接收到的所有数据</span></span><br><span class="line">                <span class="keyword">if</span> (bytes_transferred &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//清空接收数据的数组</span></span><br><span class="line">                    ::<span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);</span><br><span class="line">                    sock.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, MAX_LENGTH),</span><br><span class="line">                        std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//继续循环</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//已经处理完头部，处理上次未接受完的消息数据</span></span><br><span class="line">            <span class="comment">//得到剩余未处理的数据总字节数</span></span><br><span class="line">            <span class="type">int</span> remain_msg = _recv_msg_node-&gt;_total_len - _recv_msg_node-&gt;_cur_len;</span><br><span class="line">            <span class="comment">//待接收的数据小于剩余数据总量，bytes_trabsferred就是表示_data里数据剩余未读取的数据</span></span><br><span class="line">            <span class="keyword">if</span> (bytes_transferred &lt; remain_msg) &#123;</span><br><span class="line">                <span class="comment">//继续装数据</span></span><br><span class="line">                <span class="built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, bytes_transferred);</span><br><span class="line">                <span class="comment">//更新当前已经缓冲的数据量</span></span><br><span class="line">                _recv_msg_node-&gt;_cur_len += bytes_transferred;</span><br><span class="line">                <span class="comment">//因为此时已经处理完_data里的数据了 所以可以直接清零，继续处理</span></span><br><span class="line">                ::<span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);</span><br><span class="line">                sock.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, MAX_LENGTH),</span><br><span class="line">                    std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//待接收的数据大于等于剩余数据总量的话，也就是说此次处理后，仍有剩余数据未被缓存，出现了粘包问题</span></span><br><span class="line">            <span class="built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, remain_msg);</span><br><span class="line">            _recv_msg_node-&gt;_cur_len += remain_msg;</span><br><span class="line">            bytes_transferred -= remain_msg;</span><br><span class="line">            <span class="comment">//更新_data里被读取的位置</span></span><br><span class="line">            copy_len += remain_msg;</span><br><span class="line">            <span class="comment">//数据已经接收完整，此时节点里存的是完整数据可以发送</span></span><br><span class="line">            _recv_msg_node-&gt;_data[_recv_msg_node-&gt;_total_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;receive data is &quot;</span> &lt;&lt; _recv_msg_node-&gt;_data &lt;&lt; std::endl;</span><br><span class="line">            <span class="comment">//此处可以调用Send发送测试</span></span><br><span class="line">            <span class="built_in">Send</span>(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len);</span><br><span class="line">            <span class="comment">//继续轮询剩余未处理数据</span></span><br><span class="line">            _b_head_parse = <span class="literal">false</span>;</span><br><span class="line">            _recv_head_node-&gt;<span class="built_in">Clear</span>();</span><br><span class="line">            <span class="keyword">if</span> (bytes_transferred &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                ::<span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);</span><br><span class="line">                sock.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, MAX_LENGTH),</span><br><span class="line">                    std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;handle read failed, error is &quot;</span> &lt;&lt; error.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">//Close();</span></span><br><span class="line">        _server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>copy_len记录的是已经处理过数据的长度，因为存在一次接收多个包的情况，所以copy_len用来做已经处理的数据长度的。</li>
<li>首先判断_b_head_parse是否为false，如果为false则说明头部未处理，先判断接收的数据是否小于头部, 如果小于头部大小则将接收到的数据放入_recv_head_node节点保存，然后继续调用读取函数监听对端发送数据。否则进入步骤3.</li>
<li>如果收到的数据比头部多，可能是多个逻辑包，所以要做切包处理。根据之前保留在_recv_head_node的长度，计算出剩余未取出的头部长度，然后取出剩余的头部长度保存在_recv_head_node节点，然后通过memcpy方式从节点拷贝出数据写入short类型的data_len里，进而获取消息的长度。接下来继续处理包体，也就是消息体，判断接收到的数据未处理部分的长度和总共要接收的数据长度大小，如果小于总共要接受的长度，说明消息体没接收完，则将未处理部分先写入_recv_msg_node里，并且继续监听读事件。否则说明消息体接收完全，进入步骤4</li>
<li>将消息体数据接收到_recv_msg_node中，接受完全后返回给对端。当然存在多个逻辑包粘连，此时要判断bytes_transferred是否小于等于0，如果是说明只有一个逻辑包，我们处理完了，继续监听读事件，就直接返回即可。否则说明有多个数据包粘连，就继续执行上述操作。</li>
<li>因为存在_b_head_parse为true，也就是包头接收并处理完的情况，但是包体未接受完，再次触发HandleRead，此时要继续处理上次未接受完的消息体，大体逻辑和3，4一样。</li>
</ol>
<ul>
<li>以上就是处理粘包的过程，我们绘制流程图更明了一些</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/C++asio网络编程/image-8.png" alt="示例图片" style="zoom:100%;" /></p>
<h3 id="服务端完整代码"><a href="#服务端完整代码" class="headerlink" title="服务端完整代码"></a>服务端完整代码</h3><h4 id="CSession头文件"><a href="#CSession头文件" class="headerlink" title="CSession头文件"></a>CSession头文件</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/uuid/uuid_generators.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/uuid/uuid_io.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MsgNode.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CServer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CServer</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CSession</span>: <span class="keyword">public</span> std::enable_shared_from_this&lt;CSession&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CSession</span>(boost::asio::io_context&amp; ioc, CServer* server);</span><br><span class="line">	</span><br><span class="line">	~<span class="built_in">CSession</span>();</span><br><span class="line"></span><br><span class="line">	boost::asio::ip::<span class="function">tcp::socket&amp; <span class="title">GetSocket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> sock;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">std::string&amp; <span class="title">GetUuid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _uuid;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Close</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">std::shared_ptr&lt;CSession&gt; <span class="title">SharedSelf</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 发送接口</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Send</span><span class="params">(<span class="type">char</span>* msg, <span class="type">int</span> max_length)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">HandleRead</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="type">size_t</span> bytes_transferred, std::shared_ptr&lt;CSession&gt; _self_shared)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">HandleWrite</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec, std::shared_ptr&lt;CSession&gt; _self_shared)</span></span>;</span><br><span class="line">	boost::asio::ip::tcp::socket sock;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//这个为socket接收数据时候先存入的</span></span><br><span class="line">	<span class="type">char</span> _data[MAX_LENGTH];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 存储唯一标识</span></span><br><span class="line">	std::string _uuid;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 指向CServer的指针</span></span><br><span class="line">	CServer* _server;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 发送队列</span></span><br><span class="line">	std::queue&lt;std::shared_ptr&lt;MsgNode&gt;&gt; _send_que;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//保证多线程的安全性</span></span><br><span class="line">	std::mutex _send_lock;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//收到的消息结构，也就是完整的数据</span></span><br><span class="line">	std::shared_ptr&lt;MsgNode&gt; _recv_msg_node;</span><br><span class="line">	<span class="comment">// 表示头部结构是否接收完</span></span><br><span class="line">	<span class="type">bool</span> _b_head_parse;</span><br><span class="line">	<span class="comment">//收到的头部结构，也就是完整的数据长度</span></span><br><span class="line">	std::shared_ptr&lt;MsgNode&gt; _recv_head_node;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 用于标记是否关闭</span></span><br><span class="line">	<span class="type">bool</span> _b_close;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="CSession-实现"><a href="#CSession-实现" class="headerlink" title="CSession 实现"></a>CSession 实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CSession.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line">CSession::<span class="built_in">CSession</span>(boost::asio::io_context&amp; io_context, CServer* server) :</span><br><span class="line">    <span class="built_in">sock</span>(io_context), _server(server), _b_close(<span class="literal">false</span>), _b_head_parse(<span class="literal">false</span>) &#123;</span><br><span class="line">    boost::uuids::uuid  a_uuid = boost::uuids::<span class="built_in">random_generator</span>()();</span><br><span class="line">    _uuid = boost::uuids::<span class="built_in">to_string</span>(a_uuid);</span><br><span class="line">    _recv_head_node = std::<span class="built_in">make_shared</span>&lt;MsgNode&gt;(HEAD_LENGTH);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CSession::~<span class="built_in">CSession</span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;~CSession destruct &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::Send</span><span class="params">(<span class="type">char</span>* msg, <span class="type">int</span> max_length)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//pending 为false表示发送缓冲区是空的</span></span><br><span class="line">    <span class="type">bool</span> pending = <span class="literal">false</span>;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_send_lock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!_send_que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        pending = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _send_que.<span class="built_in">push</span>(std::<span class="built_in">make_shared</span>&lt;MsgNode&gt;(msg, max_length));</span><br><span class="line">    <span class="keyword">if</span> (pending) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">auto</span>&amp; msgnode = _send_que.<span class="built_in">front</span>();</span><br><span class="line">    boost::asio::<span class="built_in">async_write</span>(sock, boost::asio::<span class="built_in">buffer</span>(msgnode-&gt;_data, msgnode-&gt;_total_len),</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;CSession::HandleWrite, <span class="keyword">this</span>, std::placeholders::_1, <span class="built_in">shared_from_this</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::Start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);</span><br><span class="line">    <span class="comment">// 错误用法, 因为会生成两个shared_ptr来管理同一块内存，他们两的引用计数可能不同</span></span><br><span class="line">  <span class="comment">/*  sock.async_read_some(boost::asio::buffer(_data, max_length),</span></span><br><span class="line"><span class="comment">        std::bind(&amp;CSession::handle_read, this, std::placeholders::_1, std::placeholders::_2, std::shared_ptr&lt;CSession&gt;(this)));*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//正确用法，使用 std::shared_from_this()需要继承std::enable_shared_from_this&lt;CSession&gt; 模板类</span></span><br><span class="line">    <span class="comment">//shared_from_this()内部实现是返回一个智能指针，和存在的智能指针去同步</span></span><br><span class="line">    sock.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, MAX_LENGTH),</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, <span class="built_in">shared_from_this</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::Close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//关闭套接字</span></span><br><span class="line">    sock.<span class="built_in">close</span>();</span><br><span class="line">    _b_close = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::shared_ptr&lt;CSession&gt; <span class="title">CSession::SharedSelf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">shared_from_this</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二个参数为你接收到的需要读的字节数，第三个参数增加引用计数，防止未处理为就被析构以及二次析构问题</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::HandleRead</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, <span class="type">size_t</span>  bytes_transferred, std::shared_ptr&lt;CSession&gt; shared_self)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        <span class="comment">//已经存入数组的字符数</span></span><br><span class="line">        <span class="type">int</span> copy_len = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 需要读的字节数大于0</span></span><br><span class="line">        <span class="keyword">while</span> (bytes_transferred &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 头部结构未被处理完</span></span><br><span class="line">            <span class="keyword">if</span> (!_b_head_parse) &#123;</span><br><span class="line">                <span class="comment">//收到的数据不足头部大小（待接收的数据字节数加上当前接收完的字节数小于头部结构（两字节））</span></span><br><span class="line">                <span class="keyword">if</span> (bytes_transferred + _recv_head_node-&gt;_cur_len &lt; HEAD_LENGTH) &#123;</span><br><span class="line">                    <span class="comment">//拷贝接收到的头部大小</span></span><br><span class="line">                    <span class="built_in">memcpy</span>(_recv_head_node-&gt;_data + _recv_head_node-&gt;_cur_len, _data + copy_len, bytes_transferred);</span><br><span class="line">                    <span class="comment">//更新已经接收到的字节数</span></span><br><span class="line">                    _recv_head_node-&gt;_cur_len += bytes_transferred;</span><br><span class="line">                    <span class="comment">//将接收数组清空</span></span><br><span class="line">                    ::<span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);</span><br><span class="line">                    <span class="comment">//继续监听读事件</span></span><br><span class="line">                    sock.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, MAX_LENGTH),</span><br><span class="line">                        std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//收到的数据比头部多</span></span><br><span class="line">                <span class="comment">//头部剩余未复制的长度，剩余可能为0 可能&gt;0，不可能&lt;0</span></span><br><span class="line">                <span class="type">int</span> head_remain = HEAD_LENGTH - _recv_head_node-&gt;_cur_len;</span><br><span class="line">                <span class="comment">//将头部补充完整</span></span><br><span class="line">                <span class="built_in">memcpy</span>(_recv_head_node-&gt;_data + _recv_head_node-&gt;_cur_len, _data + copy_len, head_remain);</span><br><span class="line">                <span class="comment">//更新已处理的data长度和剩余未处理的长度</span></span><br><span class="line">                copy_len += head_remain;</span><br><span class="line">                bytes_transferred -= head_remain;</span><br><span class="line">                <span class="comment">//获取头部数据</span></span><br><span class="line">                <span class="type">short</span> data_len = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">//把两字节的数据拷贝出来，得到实际数据的长度</span></span><br><span class="line">                <span class="built_in">memcpy</span>(&amp;data_len, _recv_head_node-&gt;_data, HEAD_LENGTH);</span><br><span class="line"></span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;data_len is &quot;</span> &lt;&lt; data_len &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//头部长度非法</span></span><br><span class="line">                <span class="keyword">if</span> (data_len &gt; MAX_LENGTH) &#123;</span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot;invalid data length is &quot;</span> &lt;&lt; data_len &lt;&lt; std::endl;</span><br><span class="line">                    <span class="comment">//断开连接</span></span><br><span class="line">                    _server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//头部长度合法的话继续执行，接收一个short，构造一个接收节点</span></span><br><span class="line">                _recv_msg_node = std::<span class="built_in">make_shared</span>&lt;MsgNode&gt;(data_len);</span><br><span class="line">                <span class="comment">//消息的长度小于头部规定的长度，说明数据未收全，则先将部分消息放到接收节点里</span></span><br><span class="line">                <span class="keyword">if</span> (bytes_transferred &lt; data_len) &#123;</span><br><span class="line">                    <span class="comment">//先缓存数据道接收节点里</span></span><br><span class="line">                    <span class="built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, bytes_transferred);</span><br><span class="line">                    _recv_msg_node-&gt;_cur_len += bytes_transferred;</span><br><span class="line">                    ::<span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);</span><br><span class="line">                    <span class="comment">//继续监听读事件</span></span><br><span class="line">                    sock.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, MAX_LENGTH),</span><br><span class="line">                        std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));</span><br><span class="line">                    <span class="comment">//头部处理完成</span></span><br><span class="line">                    _b_head_parse = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//消息的长度大于等于头部规定的长度，说明数据粘包了，并且由于进入此逻辑时，头部节点刚被处理完，剩下的一定是接收的数据且能一次性读完</span></span><br><span class="line">                <span class="built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, data_len);</span><br><span class="line"></span><br><span class="line">                _recv_msg_node-&gt;_cur_len += data_len;</span><br><span class="line">                copy_len += data_len;</span><br><span class="line">                bytes_transferred -= data_len;</span><br><span class="line">                _recv_msg_node-&gt;_data[_recv_msg_node-&gt;_total_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;receive data is &quot;</span> &lt;&lt; _recv_msg_node-&gt;_data &lt;&lt; std::endl;</span><br><span class="line">                <span class="comment">//此处可以调用Send发送测试</span></span><br><span class="line">                <span class="built_in">Send</span>(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//继续轮询剩余未处理数据，也就是处理粘包的数据</span></span><br><span class="line">                _b_head_parse = <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">//清空接收节点</span></span><br><span class="line">                _recv_head_node-&gt;<span class="built_in">Clear</span>();</span><br><span class="line">                <span class="comment">//如果待接收的数据字节数小于等于0，也就是处理完了接收到的所有数据</span></span><br><span class="line">                <span class="keyword">if</span> (bytes_transferred &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//清空接收数据的数组</span></span><br><span class="line">                    ::<span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);</span><br><span class="line">                    sock.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, MAX_LENGTH),</span><br><span class="line">                        std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//继续循环</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//已经处理完头部，处理上次未接受完的消息数据</span></span><br><span class="line">            <span class="comment">//得到剩余未处理的数据总字节数</span></span><br><span class="line">            <span class="type">int</span> remain_msg = _recv_msg_node-&gt;_total_len - _recv_msg_node-&gt;_cur_len;</span><br><span class="line">            <span class="comment">//待接收的数据小于剩余数据总量，bytes_trabsferred就是表示_data里数据剩余未读取的数据</span></span><br><span class="line">            <span class="keyword">if</span> (bytes_transferred &lt; remain_msg) &#123;</span><br><span class="line">                <span class="comment">//继续装数据</span></span><br><span class="line">                <span class="built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, bytes_transferred);</span><br><span class="line">                <span class="comment">//更新当前已经缓冲的数据量</span></span><br><span class="line">                _recv_msg_node-&gt;_cur_len += bytes_transferred;</span><br><span class="line">                <span class="comment">//因为此时已经处理完_data里的数据了 所以可以直接清零，继续处理</span></span><br><span class="line">                ::<span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);</span><br><span class="line">                sock.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, MAX_LENGTH),</span><br><span class="line">                    std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//待接收的数据大于等于剩余数据总量的话，也就是说此次处理后，仍有剩余数据未被缓存，出现了粘包问题</span></span><br><span class="line">            <span class="built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, remain_msg);</span><br><span class="line">            _recv_msg_node-&gt;_cur_len += remain_msg;</span><br><span class="line">            bytes_transferred -= remain_msg;</span><br><span class="line">            <span class="comment">//更新_data里被读取的位置</span></span><br><span class="line">            copy_len += remain_msg;</span><br><span class="line">            <span class="comment">//数据已经接收完整，此时节点里存的是完整数据可以发送</span></span><br><span class="line">            _recv_msg_node-&gt;_data[_recv_msg_node-&gt;_total_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;receive data is &quot;</span> &lt;&lt; _recv_msg_node-&gt;_data &lt;&lt; std::endl;</span><br><span class="line">            <span class="comment">//此处可以调用Send发送测试</span></span><br><span class="line">            <span class="built_in">Send</span>(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len);</span><br><span class="line">            <span class="comment">//继续轮询剩余未处理数据</span></span><br><span class="line">            _b_head_parse = <span class="literal">false</span>;</span><br><span class="line">            _recv_head_node-&gt;<span class="built_in">Clear</span>();</span><br><span class="line">            <span class="keyword">if</span> (bytes_transferred &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                ::<span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);</span><br><span class="line">                sock.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, MAX_LENGTH),</span><br><span class="line">                    std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;handle read failed, error is &quot;</span> &lt;&lt; error.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">//Close();</span></span><br><span class="line">        _server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::HandleWrite</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, std::shared_ptr&lt;CSession&gt; _self_shared)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_send_lock)</span></span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;send data &quot;</span> &lt;&lt; _send_que.<span class="built_in">front</span>()-&gt;_data + HEAD_LENGTH &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">//因为使用的是async_write，数据一定被发送玩所以可以直接出队</span></span><br><span class="line">        _send_que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (!_send_que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span>&amp; msgnode = _send_que.<span class="built_in">front</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; msgnode-&gt;_total_len; i++) std::cout &lt;&lt; msgnode-&gt;_data[i + <span class="number">2</span>];</span><br><span class="line">            boost::asio::<span class="built_in">async_write</span>(sock, boost::asio::<span class="built_in">buffer</span>(msgnode-&gt;_data, msgnode-&gt;_total_len),</span><br><span class="line">                std::<span class="built_in">bind</span>(&amp;CSession::HandleWrite, <span class="keyword">this</span>, std::placeholders::_1, _self_shared));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;handle write failed, error is &quot;</span> &lt;&lt; error.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">Close</span>();</span><br><span class="line">        _server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="CServer头文件"><a href="#CServer头文件" class="headerlink" title="CServer头文件"></a>CServer头文件</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CSession.h&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CSession</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CServer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CServer</span>(boost::asio::io_context&amp; ioc, <span class="type">unsigned</span> <span class="type">short</span> port);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ClearSession</span><span class="params">(std::string&amp; uuid)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">HandleAccept</span><span class="params">(std::shared_ptr&lt;CSession&gt;, <span class="type">const</span> boost::system::error_code&amp; error)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">StartAccept</span><span class="params">()</span></span>;</span><br><span class="line">    boost::asio::io_context&amp; _ioc;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> port;</span><br><span class="line">    boost::asio::ip::tcp::acceptor _acceptor;</span><br><span class="line">    std::map&lt;std::string, std::shared_ptr&lt;CSession&gt;&gt; _sessions;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="CServer实现"><a href="#CServer实现" class="headerlink" title="CServer实现"></a>CServer实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CServer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CServer::StartAccept</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;CSession&gt; new_session = std::<span class="built_in">make_shared</span>&lt;CSession&gt;(_ioc, <span class="keyword">this</span>);</span><br><span class="line">    _acceptor.<span class="built_in">async_accept</span>(new_session-&gt;<span class="built_in">GetSocket</span>(), std::<span class="built_in">bind</span>(&amp;CServer::HandleAccept, <span class="keyword">this</span>, new_session, std::placeholders::_1));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CServer::HandleAccept</span><span class="params">(std::shared_ptr&lt;CSession&gt; new_session, <span class="type">const</span> boost::system::error_code&amp; error)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        new_session-&gt;<span class="built_in">Start</span>();</span><br><span class="line">        <span class="comment">//将session加入map</span></span><br><span class="line">        _sessions.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(new_session-&gt;<span class="built_in">GetUuid</span>(), new_session));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;session accept failed, error is &quot;</span> &lt;&lt; error.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">StartAccept</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CServer::ClearSession</span><span class="params">(std::string&amp; uuid)</span> </span>&#123;</span><br><span class="line">    _sessions.<span class="built_in">erase</span>(uuid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CServer::<span class="built_in">CServer</span>(boost::asio::io_context&amp; ioc, <span class="type">unsigned</span> <span class="type">short</span> port) : _ioc(ioc), _acceptor(ioc, boost::asio::ip::tcp::<span class="built_in">endpoint</span>(boost::asio::ip::tcp::<span class="built_in">v4</span>(), port)) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Server start success, on port: &quot;</span> &lt;&lt; port &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">StartAccept</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="MsgNode"><a href="#MsgNode" class="headerlink" title="MsgNode"></a>MsgNode</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/uuid/uuid_io.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/uuid/uuid_generators.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MAX_LENGTH = <span class="number">1024</span> * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> HEAD_LENGTH = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MsgNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//用来构造发送节点</span></span><br><span class="line">	<span class="built_in">MsgNode</span>(<span class="type">char</span>* msg, <span class="type">short</span> max_len):_total_len(max_len + HEAD_LENGTH), _cur_len(<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// 要多留一个空间存/0</span></span><br><span class="line">		_data = <span class="keyword">new</span> <span class="type">char</span>[_total_len + <span class="number">1</span>]();</span><br><span class="line">		<span class="comment">// 将前两个字节赋值为长度</span></span><br><span class="line">		<span class="built_in">memcpy</span>(_data, &amp;max_len, HEAD_LENGTH);</span><br><span class="line">		<span class="comment">//偏移两个字节存数据长度</span></span><br><span class="line">		<span class="built_in">memcpy</span>(_data + HEAD_LENGTH, msg, max_len);</span><br><span class="line">		_data[_total_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//用来接收事件</span></span><br><span class="line">	<span class="built_in">MsgNode</span>(<span class="type">short</span> max_len):_total_len(max_len), _cur_len(<span class="number">0</span>) &#123;</span><br><span class="line">		_data = <span class="keyword">new</span> <span class="type">char</span>[_total_len + <span class="number">1</span>]();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">MsgNode</span>() &#123;</span><br><span class="line">		<span class="keyword">delete</span>[] _data;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		::<span class="built_in">memset</span>(_data, <span class="number">0</span>, _total_len);</span><br><span class="line">		_cur_len = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//已发送的数据</span></span><br><span class="line">	<span class="type">short</span> _cur_len;</span><br><span class="line">	<span class="comment">//总共需要发送的数据</span></span><br><span class="line">	<span class="type">short</span> _total_len;</span><br><span class="line">	<span class="comment">//存取数据的数组</span></span><br><span class="line">	<span class="type">char</span>* _data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="客户端修改"><a href="#客户端修改" class="headerlink" title="客户端修改"></a>客户端修改</h3><ul>
<li>客户端的发送也要遵循先发送数据2个字节的数据长度，再发送数据消息的结构。<br>接收时也是先接收两个字节数据获取数据长度，再根据长度接收消息。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::asio::ip;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_LENGTH = <span class="number">1024</span>*<span class="number">2</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> HEAD_LENGTH = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">//创建上下文服务</span></span><br><span class="line">		boost::asio::io_context   ioc;</span><br><span class="line">		<span class="comment">//构造endpoint</span></span><br><span class="line">		<span class="function">tcp::endpoint  <span class="title">remote_ep</span><span class="params">(address::from_string(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="number">8888</span>)</span></span>;</span><br><span class="line">		<span class="function">tcp::socket  <span class="title">sock</span><span class="params">(ioc)</span></span>;</span><br><span class="line">		boost::system::error_code   error = boost::asio::error::host_not_found; ;</span><br><span class="line">		sock.<span class="built_in">connect</span>(remote_ep, error);</span><br><span class="line">		<span class="keyword">if</span> (error) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;connect failed, code is &quot;</span> &lt;&lt; error.<span class="built_in">value</span>() &lt;&lt; <span class="string">&quot; error msg is &quot;</span> &lt;&lt; error.<span class="built_in">message</span>();</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Enter message: &quot;</span>;</span><br><span class="line">		<span class="type">char</span> request[MAX_LENGTH];</span><br><span class="line">		std::cin.<span class="built_in">getline</span>(request, MAX_LENGTH);</span><br><span class="line">		<span class="type">size_t</span> request_length = <span class="built_in">strlen</span>(request);</span><br><span class="line">		<span class="type">char</span> send_data[MAX_LENGTH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">		<span class="built_in">memcpy</span>(send_data, &amp;request_length, <span class="number">2</span>);</span><br><span class="line">		<span class="built_in">memcpy</span>(send_data + <span class="number">2</span>, request, request_length);</span><br><span class="line">		boost::asio::<span class="built_in">write</span>(sock, boost::asio::<span class="built_in">buffer</span>(send_data, request_length<span class="number">+2</span>));</span><br><span class="line">		</span><br><span class="line">		<span class="type">char</span> reply_head[HEAD_LENGTH];</span><br><span class="line">		<span class="type">size_t</span> reply_length = boost::asio::<span class="built_in">read</span>(sock,boost::asio::<span class="built_in">buffer</span>(reply_head, HEAD_LENGTH));</span><br><span class="line">		<span class="type">short</span> msglen = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">memcpy</span>(&amp;msglen, reply_head, HEAD_LENGTH);</span><br><span class="line">		<span class="type">char</span> msg[MAX_LENGTH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">		<span class="type">size_t</span>  msg_length = boost::asio::<span class="built_in">read</span>(sock,boost::asio::<span class="built_in">buffer</span>(msg, msglen));</span><br><span class="line">		</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Reply is: &quot;</span>;</span><br><span class="line">		std::cout.<span class="built_in">write</span>(msg, msglen) &lt;&lt; endl;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Reply len is &quot;</span> &lt;&lt; msglen;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">		std::cerr &lt;&lt; <span class="string">&quot;Exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="粘包测试"><a href="#粘包测试" class="headerlink" title="粘包测试"></a>粘包测试</h3><ul>
<li><p>为了测试粘包，需要制造粘包产生的现象，可以让客户端发送的频率高一些，服务器接收的频率低一些，这样造成前后端收发数据不一致导致多个数据包在服务器tcp缓冲区滞留产生粘包现象。</p>
</li>
<li><p>测试粘包之前，在服务器的CSession类里添加打印二进制数据的函数，便于查看缓冲区的数据</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件#include &lt;iomanip&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::PrintRecvData</span><span class="params">(<span class="type">char</span>* data, <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">    std::stringstream ss;</span><br><span class="line">    std::string result = <span class="string">&quot;0x&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        std::string hexstr;</span><br><span class="line">        ss &lt;&lt; std::hex &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; <span class="built_in">int</span>(data[i]) &lt;&lt; std::endl;</span><br><span class="line">        ss &gt;&gt; hexstr;</span><br><span class="line">        result += hexstr;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;receive raw data is : &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>然后将这个函数放到HandleRead里，每次收到数据就调用这个函数打印接收到的最原始的数据，然后睡眠2秒再进行收发操作，用来延迟接收对端数据制造粘包，之后的逻辑不变</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::HandleRead</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, <span class="type">size_t</span>  bytes_transferred, std::shared_ptr&lt;CSession&gt; shared_self)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        <span class="built_in">PrintRecvData</span>(_data, bytes_transferred);</span><br><span class="line">        std::<span class="function">chrono::milliseconds <span class="title">dura</span><span class="params">(<span class="number">2000</span>)</span></span>;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(dura);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>修改客户端逻辑实现手收发分离</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::asio::ip;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_LENGTH = <span class="number">1024</span>*<span class="number">2</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> HEAD_LENGTH = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//创建上下文服务</span></span><br><span class="line">        boost::asio::io_context   ioc;</span><br><span class="line">        <span class="comment">//构造endpoint</span></span><br><span class="line">        <span class="function">tcp::endpoint  <span class="title">remote_ep</span><span class="params">(address::from_string(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="number">10086</span>)</span></span>;</span><br><span class="line">        <span class="function">tcp::socket  <span class="title">sock</span><span class="params">(ioc)</span></span>;</span><br><span class="line">        boost::system::error_code   error = boost::asio::error::host_not_found; ;</span><br><span class="line">        sock.<span class="built_in">connect</span>(remote_ep, error);</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;connect failed, code is &quot;</span> &lt;&lt; error.<span class="built_in">value</span>() &lt;&lt; <span class="string">&quot; error msg is &quot;</span> &lt;&lt; error.<span class="built_in">message</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//发送数据线程</span></span><br><span class="line">        <span class="function">thread <span class="title">send_thread</span><span class="params">([&amp;sock] &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">for</span> (;;) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="comment">//防止一直占用CPU，使用休眠</span></span></span></span><br><span class="line"><span class="params"><span class="function">                this_thread::sleep_for(std::chrono::milliseconds(<span class="number">2</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">const</span> <span class="type">char</span>* request = <span class="string">&quot;hello world!&quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">size_t</span> request_length = strlen(request);</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">char</span> send_data[MAX_LENGTH] = &#123; <span class="number">0</span> &#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">                memcpy(send_data, &amp;request_length, <span class="number">2</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">                memcpy(send_data + <span class="number">2</span>, request, request_length);</span></span></span><br><span class="line"><span class="params"><span class="function">                boost::asio::write(sock, boost::asio::buffer(send_data, request_length + <span class="number">2</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;)</span></span>;</span><br><span class="line">        <span class="comment">//接收数据线程</span></span><br><span class="line">        <span class="function">thread <span class="title">recv_thread</span><span class="params">([&amp;sock] &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">for</span> (;;) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                this_thread::sleep_for(std::chrono::milliseconds(<span class="number">2</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">                cout &lt;&lt; <span class="string">&quot;begin to receive...&quot;</span> &lt;&lt; endl;</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">char</span> reply_head[HEAD_LENGTH];</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">size_t</span> reply_length = boost::asio::read(sock, boost::asio::buffer(reply_head, HEAD_LENGTH));</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">short</span> msglen = <span class="number">0</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">                memcpy(&amp;msglen, reply_head, HEAD_LENGTH);</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">char</span> msg[MAX_LENGTH] = &#123; <span class="number">0</span> &#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">size_t</span>  msg_length = boost::asio::read(sock, boost::asio::buffer(msg, msglen));</span></span></span><br><span class="line"><span class="params"><span class="function">                std::cout &lt;&lt; <span class="string">&quot;Reply is: &quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">                std::cout.write(msg, msglen) &lt;&lt; endl;</span></span></span><br><span class="line"><span class="params"><span class="function">                std::cout &lt;&lt; <span class="string">&quot;Reply len is &quot;</span> &lt;&lt; msglen;</span></span></span><br><span class="line"><span class="params"><span class="function">                std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;)</span></span>;</span><br><span class="line">        send_thread.<span class="built_in">join</span>();</span><br><span class="line">        recv_thread.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="目前服务端通信流程图"><a href="#目前服务端通信流程图" class="headerlink" title="目前服务端通信流程图"></a>目前服务端通信流程图</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/C++asio网络编程/image-10.png" alt="示例图片" style="zoom:100%;" /></p>
<h3 id="io-context"><a href="#io-context" class="headerlink" title="io_context"></a>io_context</h3><ul>
<li>里面维护了一个队列，会把注册的回调函数以及读写函数写入队列中</li>
</ul>
<h2 id="字节序处理和发送队列控制"><a href="#字节序处理和发送队列控制" class="headerlink" title="字节序处理和发送队列控制"></a>字节序处理和发送队列控制</h2><h3 id="字节序问题"><a href="#字节序问题" class="headerlink" title="字节序问题"></a>字节序问题</h3><ul>
<li><p>在计算机网络中，由于不同的计算机使用的 CPU 架构和字节顺序可能不同，因此在传输数据时需要对数据的字节序进行统一，以保证数据能够正常传输和解析。这就是网络字节序的作用。</p>
</li>
<li><p>具体来说，计算机内部存储数据的方式有两种：大端序（Big-Endian）和小端序（Little-Endian）。在大端序中，高位字节存储在低地址处，而低位字节存储在高地址处；在小端序中，高位字节存储在高地址处，而低位字节存储在低地址处。</p>
</li>
<li><p>在网络通信过程中，通常使用的是大端序。这是因为早期的网络硬件大多采用了 Motorola 处理器，而 Motorola 处理器使用的是大端序。此外，大多数网络协议规定了网络字节序必须为大端序。</p>
</li>
<li><p>因此，在进行网络编程时，需要将主机字节序转换为网络字节序，也就是将数据从本地字节序转换为大端序。可以使用诸如 htonl、htons、ntohl 和 ntohs 等函数来实现字节序转换操作。</p>
</li>
<li><p>综上所述，网络字节序的主要作用是统一不同计算机间的数据表示方式，以保证数据在网络中的正确传输和解析。</p>
</li>
</ul>
<h3 id="如何区分本机字节序"><a href="#如何区分本机字节序" class="headerlink" title="如何区分本机字节序"></a>如何区分本机字节序</h3><ul>
<li>如何区分本机字节序，可以通过判断低地址存储的数据是否为低字节数据，如果是则为小端，否则为大端，下面写一段代码讲述这个逻辑</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 判断当前系统的字节序是大端序还是小端序</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_big_endian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (*(<span class="type">char</span>*)&amp;num == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前系统为小端序</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当前系统为大端序</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0x12345678</span>;</span><br><span class="line">    <span class="type">char</span>* p = (<span class="type">char</span>*)&amp;num;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;原始数据：&quot;</span> &lt;&lt; hex &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">is_big_endian</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;当前系统为大端序&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;字节序为：&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">sizeof</span>(num); i++) &#123;</span><br><span class="line">            cout &lt;&lt; hex &lt;&lt; (<span class="type">int</span>)*(p + i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;当前系统为小端序&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;字节序为：&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">sizeof</span>(num) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            cout &lt;&lt; hex &lt;&lt; (<span class="type">int</span>)*(p + i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>在上述代码中，使用了一个 is_big_endian() 函数来判断当前系统的字节序是否为大端序。该函数通过创建一个整型变量 num，并将其最低位设置为 1，然后通过指针强制转换成字符指针，判断第一个字节是否为 1 来判断当前系统的字节序。</p>
</li>
<li><p>在 main 函数中，定义了一个整型变量 num，并将其初始化为 0x12345678。接着，使用 char* 类型的指针 p 来指向 num 的地址。然后，通过判断当前系统的字节序来输出 num 的字节序。</p>
</li>
<li><p>如果当前系统为大端序，则按照原始顺序输出各个字节；如果当前系统为小端序，则需要逆序输出各个字节。</p>
</li>
<li><p>大端模式</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/C++asio网络编程/image-12.png" alt="示例图片" style="zoom:100%;" /></p>
<ul>
<li>小端模式</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/C++asio网络编程/image-13.png" alt="示例图片" style="zoom:100%;" /></p>
<h3 id="服务器使用网络字节序"><a href="#服务器使用网络字节序" class="headerlink" title="服务器使用网络字节序"></a>服务器使用网络字节序</h3><ul>
<li>为保证字节序一致性，网络传输使用网络字节序，也就是大端模式。<br>在 boost::asio 库中，可以使用 boost::asio::detail::socket_ops::host_to_network_long() 和 boost::asio::detail::socket_ops::host_to_network_short() 函数将主机字节序转换为网络字节序。具体方法如下：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> host_long_value = <span class="number">0x12345678</span>;</span><br><span class="line">    <span class="type">uint16_t</span> host_short_value = <span class="number">0x5678</span>;</span><br><span class="line">    <span class="type">uint32_t</span> network_long_value = boost::asio::detail::socket_ops::<span class="built_in">host_to_network_long</span>(host_long_value);</span><br><span class="line">    <span class="type">uint16_t</span> network_short_value = boost::asio::detail::socket_ops::<span class="built_in">host_to_network_short</span>(host_short_value);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Host long value: 0x&quot;</span> &lt;&lt; std::hex &lt;&lt; host_long_value &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Network long value: 0x&quot;</span> &lt;&lt; std::hex &lt;&lt; network_long_value &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Host short value: 0x&quot;</span> &lt;&lt; std::hex &lt;&lt; host_short_value &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Network short value: 0x&quot;</span> &lt;&lt; std::hex &lt;&lt; network_short_value &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>上述代码中，使用了 boost::asio::detail::socket_ops::host_to_network_long() 和 boost::asio::detail::socket_ops::host_to_network_short() 函数将主机字节序转换为网络字节序。</p>
</li>
<li><p>host_to_network_long() 函数将一个 32 位无符号整数从主机字节序转换为网络字节序，返回转换后的结果。host_to_network_short() 函数将一个 16 位无符号整数从主机字节序转换为网络字节序，返回转换后的结果。</p>
</li>
<li><p>在上述代码中，分别将 32 位和 16 位的主机字节序数值转换为网络字节序，并输出转换结果。需要注意的是，在使用这些函数时，应该确保输入参数和返回结果都是无符号整数类型，否则可能会出现错误。</p>
</li>
<li><p>同样的道理，我们只需要在服务器发送数据时，将数据长度转化为网络字节序，在接收数据时，将长度转为本机字节序。</p>
</li>
<li><p>在服务器的HandleRead函数里，添加对data_len的转换，将网络字节转为本地字节序</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取头部数据</span></span><br><span class="line"><span class="type">short</span> data_len = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//把两字节的数据拷贝出来，得到实际数据的长度</span></span><br><span class="line"><span class="built_in">memcpy</span>(&amp;data_len, _recv_head_node-&gt;_data, HEAD_LENGTH);</span><br><span class="line">data_len = boost::asio::detail::socket_ops::<span class="built_in">network_to_host_short</span>(data_len);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;data_len is &quot;</span> &lt;&lt; data_len &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<ul>
<li>在服务器的发送数据时会构造消息节点，构造消息节点时，将发送长度由本地字节序转化为网络字节序</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用来构造发送节点</span></span><br><span class="line"><span class="built_in">MsgNode</span>(<span class="type">char</span>* msg, <span class="type">short</span> max_len):_total_len(max_len + HEAD_LENGTH), _cur_len(<span class="number">0</span>) &#123;</span><br><span class="line">	<span class="comment">// 要多留一个空间存/0</span></span><br><span class="line">	_data = <span class="keyword">new</span> <span class="type">char</span>[_total_len + <span class="number">1</span>]();</span><br><span class="line">	<span class="comment">//转为网络字节序</span></span><br><span class="line">	<span class="type">int</span> max_len_network = boost::asio::detail::socket_ops::<span class="built_in">host_to_network_short</span>(max_len);</span><br><span class="line">	<span class="comment">// 将前两个字节赋值为长度</span></span><br><span class="line">	<span class="built_in">memcpy</span>(_data, &amp;max_len_network, HEAD_LENGTH);</span><br><span class="line">	<span class="comment">//偏移两个字节存数据长度</span></span><br><span class="line">	<span class="built_in">memcpy</span>(_data + HEAD_LENGTH, msg, max_len);</span><br><span class="line">	_data[_total_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="消息队列控制"><a href="#消息队列控制" class="headerlink" title="消息队列控制"></a>消息队列控制</h3><ul>
<li>发送时我们会将发送的消息放入队列里以保证发送的时序性，每个session都有一个发送队列，因为有的时候发送的频率过高会导致队列增大，所以要对队列的大小做限制，当队列大于指定数量的长度时，就丢弃要发送的数据包，以保证消息的快速收发。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::Send</span><span class="params">(<span class="type">char</span>* msg, <span class="type">int</span> max_length)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_send_lock)</span></span>;</span><br><span class="line">    <span class="type">int</span> send_que_size = _send_que.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (send_que_size &gt; MAX_SENDQUE) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;session: &quot;</span> &lt;&lt; _uuid &lt;&lt; <span class="string">&quot; send que fulled, size is &quot;</span> &lt;&lt; MAX_SENDQUE &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _send_que.<span class="built_in">push</span>(<span class="built_in">make_shared</span>&lt;MsgNode&gt;(msg, max_length));</span><br><span class="line">    <span class="keyword">if</span> (send_que_size&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span>&amp; msgnode = _send_que.<span class="built_in">front</span>();</span><br><span class="line">    boost::asio::<span class="built_in">async_write</span>(_socket, boost::asio::<span class="built_in">buffer</span>(msgnode-&gt;_data, msgnode-&gt;_total_len), </span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;CSession::HandleWrite, <span class="keyword">this</span>, std::placeholders::_1, <span class="built_in">SharedSelf</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="protobuf配置和使用"><a href="#protobuf配置和使用" class="headerlink" title="protobuf配置和使用"></a>protobuf配置和使用</h2><h3 id="portobuf简介"><a href="#portobuf简介" class="headerlink" title="portobuf简介"></a>portobuf简介</h3><ul>
<li><p>Protocol Buffers（简称 Protobuf）是一种轻便高效的序列化数据结构的协议，由 Google 开发。它可以用于将结构化数据序列化到二进制格式，并广泛用于数据存储、通信协议、配置文件等领域。</p>
</li>
<li><p>我们的逻辑是有类等抽象数据构成的，而tcp是面向字节流的，我们需要将类结构序列化为字符串来传输。</p>
</li>
</ul>
<h3 id="生成pb文件"><a href="#生成pb文件" class="headerlink" title="生成pb文件"></a>生成pb文件</h3><ul>
<li>要想使用protobuf的序列化功能，需要生成pb文件，pb文件包含了我们要序列化的类信息。我们先创建一个msg.proto，该文件用来定义我们要发送的类信息</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="comment">//一个类</span></span><br><span class="line">message Book</span><br><span class="line">&#123;</span><br><span class="line">   string name = <span class="number">1</span>;</span><br><span class="line">   int32 pages = <span class="number">2</span>;</span><br><span class="line">   <span class="type">float</span> price = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这个文件定义了一个名为Book的消息类型，包含三个字段：name、pages和price。其中每个字段都有一个数字标识符，用于标识该字段在二进制流中的位置。</li>
<li>我们使用protoc.exe 基于msg.proto生成我们要用的C++类</li>
<li>在proto所在文件夹执行如下命令：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --cpp_out=. ./msg.proto</span><br></pre></td></tr></table></figure>
<ul>
<li>—cpp_out= 表示指定要生成的pb文件所在的位置<br>./msg.proto 表示msg.proto所在的位置，因为我们是在msg.proto所在文件夹中执行的protoc命令,所以是当前路径即可。</li>
<li>执行后，会看到当前目录生成了msg.pb.h和msg.pb.cc两个文件，这两个文件就是我们要用到的头文件和cpp文件。</li>
<li>我们将这两个文件添加到项目里，然后在主函数中包含msg.pb.h，做如下测试</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;msg.pb.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//客户端做的事情</span></span><br><span class="line">    Book book;</span><br><span class="line">    book.<span class="built_in">set_name</span>(<span class="string">&quot;CPP programing&quot;</span>);</span><br><span class="line">    book.<span class="built_in">set_pages</span>(<span class="number">100</span>);</span><br><span class="line">    book.<span class="built_in">set_price</span>(<span class="number">200</span>);</span><br><span class="line">    std::string bookstr;</span><br><span class="line">    <span class="comment">//序列化写到字符串里</span></span><br><span class="line">    book.<span class="built_in">SerializeToString</span>(&amp;bookstr);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;serialize str is &quot;</span> &lt;&lt; bookstr &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//假设以下是服务端做的事情</span></span><br><span class="line">    Book book2;</span><br><span class="line">    <span class="comment">//从字符串中反序列化</span></span><br><span class="line">    book<span class="number">2.</span><span class="built_in">ParseFromString</span>(bookstr);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;book2 name is &quot;</span> &lt;&lt; book<span class="number">2.</span><span class="built_in">name</span>() &lt;&lt; <span class="string">&quot; price is &quot;</span></span><br><span class="line">        &lt;&lt; book<span class="number">2.</span><span class="built_in">price</span>() &lt;&lt; <span class="string">&quot; pages is &quot;</span> &lt;&lt; book<span class="number">2.</span><span class="built_in">pages</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>测试发现报错了</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/C++asio网络编程/image-14.png" alt="示例图片" style="zoom:100%;" /></p>
<ul>
<li>解决办法</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PROTOBUF_USE_DLLS</span><br></pre></td></tr></table></figure>
<ul>
<li><p>运行后又发现无法找到dll文件</p>
</li>
<li><p>解决办法</p>
</li>
<li><p>将缺失的dll文件放在.exe的同级目录下</p>
</li>
</ul>
<h3 id="在网络编程中的应用"><a href="#在网络编程中的应用" class="headerlink" title="在网络编程中的应用"></a>在网络编程中的应用</h3><ul>
<li>先为服务器定义一个用来通信的proto,根据你设计发送的数据来定</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line">message MsgData</span><br><span class="line">&#123;</span><br><span class="line">   int32  id = <span class="number">1</span>;</span><br><span class="line">   string data = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>id代表消息id，data代表消息内容</li>
<li>我们用protoc生成对应的pb.h和pb.cc文件,方法见上</li>
<li><p>将proto,pb.cc,pb.h三个文件复制到我们之前的服务器项目里并且配置。</p>
</li>
<li><p>我们修改服务器接收数据和发送数据的逻辑</p>
</li>
<li><p>当服务器收到数据后，完成切包处理后，将信息反序列化为具体要使用的结构,打印相关的信息，然后再发送给客户端</p>
</li>
<li><p>服务端</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">MsgData msgdata;</span><br><span class="line">  std::string receive_data;</span><br><span class="line">  <span class="comment">//反序列化</span></span><br><span class="line">  msgdata.<span class="built_in">ParseFromString</span>(std::<span class="built_in">string</span>(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len));</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;recevie msg id  is &quot;</span> &lt;&lt; msgdata.<span class="built_in">id</span>() &lt;&lt; <span class="string">&quot; msg data is &quot;</span> &lt;&lt; msgdata.<span class="built_in">data</span>() &lt;&lt; endl;</span><br><span class="line">  std::string return_str = <span class="string">&quot;server has received msg, msg data is &quot;</span> + msgdata.<span class="built_in">data</span>();</span><br><span class="line">  MsgData msgreturn;</span><br><span class="line">  msgreturn.<span class="built_in">set_id</span>(msgdata.<span class="built_in">id</span>());</span><br><span class="line">  msgreturn.<span class="built_in">set_data</span>(return_str);</span><br><span class="line">  <span class="comment">//序列化</span></span><br><span class="line">  msgreturn.<span class="built_in">SerializeToString</span>(&amp;return_str);</span><br><span class="line">  <span class="built_in">Send</span>(return_str);</span><br></pre></td></tr></table></figure>
<ul>
<li>客户端</li>
<li>同样的道理，客户端在发送的时候也利用protobuf进行消息的序列化，然后发给服务器</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MsgData msgdata;</span><br><span class="line">msgdata.<span class="built_in">set_id</span>(<span class="number">1001</span>);</span><br><span class="line">msgdata.<span class="built_in">set_data</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">std::string request;</span><br><span class="line">msgdata.<span class="built_in">SerializeToString</span>(&amp;request);</span><br></pre></td></tr></table></figure>
<h2 id="jsoncpp的使用与配置"><a href="#jsoncpp的使用与配置" class="headerlink" title="jsoncpp的使用与配置"></a>jsoncpp的使用与配置</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul>
<li><p>jsoncpp 是一个 C++ JSON 库，它提供了将 JSON 数据解析为 C++ 对象、将 C++ 对象序列化为 JSON 数据的功能。它支持所有主流操作系统（包括 Windows、Linux、Mac OS X 等），并且可以与常见编译器（包括 Visual Studio、GCC 等）兼容。</p>
</li>
<li><p>jsoncpp 库是以源代码的形式发布的，因此使用者需要自己构建和链接库文件。该库文件不依赖于第三方库，只需包含头文件即可使用。</p>
</li>
<li><p>jsoncpp 库的特点包括：</p>
</li>
</ul>
<ol>
<li><p>轻量级：JSON 解析器和序列化器都非常快速，不会占用太多的 CPU 和内存资源；</p>
</li>
<li><p>易于使用：提供简单的 API，易于理解和使用；</p>
</li>
<li><p>可靠性高：经过广泛测试，已被许多企业和开发者用于生产环境中；</p>
</li>
<li><p>开源免费：遵循 MIT 许可证发布，使用和修改均免费。</p>
</li>
</ol>
<ul>
<li>总之，jsoncpp 是一款优秀的 C++ JSON 库，它可以帮助你轻松地处理 JSON 数据，为你的项目带来便利和高效, 一般在前后端交互中用的多</li>
</ul>
<h3 id="配置参考我的csdn收藏"><a href="#配置参考我的csdn收藏" class="headerlink" title="配置参考我的csdn收藏"></a>配置参考我的csdn收藏</h3><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;json/json.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;json/value.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;json/reader.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Json::Value root;</span><br><span class="line">    root[<span class="string">&quot;id&quot;</span>] = <span class="number">1001</span>;</span><br><span class="line">    root[<span class="string">&quot;data&quot;</span>] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    std::string request = root.<span class="built_in">toStyledString</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;request is &quot;</span> &lt;&lt; request &lt;&lt; std::endl;</span><br><span class="line">    Json::Value root2;</span><br><span class="line">    Json::Reader reader;</span><br><span class="line">    reader.<span class="built_in">parse</span>(request, root2);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;msg id is &quot;</span> &lt;&lt; root2[<span class="string">&quot;id&quot;</span>] &lt;&lt; <span class="string">&quot; msg is &quot;</span> &lt;&lt; root2[<span class="string">&quot;data&quot;</span>] &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/C++asio网络编程/image-15.png" alt="示例图片" style="zoom:100%;" /></p>
<h3 id="网络编程中的应用"><a href="#网络编程中的应用" class="headerlink" title="网络编程中的应用"></a>网络编程中的应用</h3><ul>
<li>在客户端发送数据时对发送的数据进行序列化</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Json::Value root;</span><br><span class="line">  root[<span class="string">&quot;id&quot;</span>] = <span class="number">1001</span>;</span><br><span class="line">  root[<span class="string">&quot;data&quot;</span>] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">  std::string request = root.<span class="built_in">toStyledString</span>();</span><br><span class="line">  <span class="type">size_t</span> request_length = request.<span class="built_in">length</span>();</span><br><span class="line">  <span class="type">char</span> send_data[MAX_LENGTH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">  <span class="comment">//转为网络字节序</span></span><br><span class="line">  <span class="type">int</span> request_host_length = boost::asio::detail::socket_ops::<span class="built_in">host_to_network_short</span>(request_length);</span><br><span class="line">  <span class="built_in">memcpy</span>(send_data, &amp;request_host_length, <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">memcpy</span>(send_data + <span class="number">2</span>, request.<span class="built_in">c_str</span>(), request_length);</span><br><span class="line">  boost::asio::<span class="built_in">write</span>(sock, boost::asio::<span class="built_in">buffer</span>(send_data, request_length + <span class="number">2</span>));</span><br></pre></td></tr></table></figure>
<ul>
<li>我们可以在服务器收到数据时进行json反序列化</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Json::Reader reader;</span><br><span class="line">    Json::Value root;</span><br><span class="line">    reader.<span class="built_in">parse</span>(std::<span class="built_in">string</span>(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len), root);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;recevie msg id  is &quot;</span> &lt;&lt; root[<span class="string">&quot;id&quot;</span>].<span class="built_in">asInt</span>() &lt;&lt; <span class="string">&quot; msg data is &quot;</span></span><br><span class="line">    &lt;&lt; root[<span class="string">&quot;data&quot;</span>].<span class="built_in">asString</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h3 id="新版JSON库-nlohmann-json"><a href="#新版JSON库-nlohmann-json" class="headerlink" title="新版JSON库 nlohmann/json"></a>新版JSON库 nlohmann/json</h3><h2 id="asio粘包处理的简单方式"><a href="#asio粘包处理的简单方式" class="headerlink" title="asio粘包处理的简单方式"></a>asio粘包处理的简单方式</h2><h3 id="简单方式"><a href="#简单方式" class="headerlink" title="简单方式"></a>简单方式</h3><ul>
<li>之前我们介绍了通过async_read_some函数监听读事件，并且绑定了读事件的回调函数HandleRead</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_socket.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, MAX_LENGTH), std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, </span><br><span class="line">std::placeholders::_1, std::placeholders::_2, <span class="built_in">SharedSelf</span>()));</span><br></pre></td></tr></table></figure>
<ul>
<li>async_read_some 这个函数的特点是只要对端发数据，服务器接收到数据，即使没有收全对端发送的数据也会触发HandleRead函数，所以我们会在HandleRead回调函数里判断接收的字节数，接收的数据可能不满足头部长度，可能大于头部长度但小于消息体的长度，可能大于消息体的长度，还可能大于多个消息体的长度，所以要切包等，这些逻辑写起来很复杂，所以我们可以通过读取指定字节数，直到读完这些字节才触发回调函数，那么可以采用async_read函数，这个函数指定读取指定字节数，只有完全读完才会触发回调函数。</li>
</ul>
<h3 id="获取头部数据"><a href="#获取头部数据" class="headerlink" title="获取头部数据"></a>获取头部数据</h3><ul>
<li>我们可以读取指定的头部长度，大小为HEAD_LENGTH字节数，只有读完HEAD_LENGTH字节才触发HandleReadHead函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::Start</span><span class="params">()</span></span>&#123;</span><br><span class="line">    _recv_head_node-&gt;<span class="built_in">Clear</span>();</span><br><span class="line">    boost::asio::<span class="built_in">async_read</span>(_socket, boost::asio::<span class="built_in">buffer</span>(_recv_head_node-&gt;_data, HEAD_LENGTH), std::<span class="built_in">bind</span>(&amp;CSession::HandleReadHead, <span class="keyword">this</span>, </span><br><span class="line">        std::placeholders::_1, std::placeholders::_2, <span class="built_in">SharedSelf</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这样我们可以直接在HandleReadHead函数内处理头部信息</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::HandleReadHead</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, <span class="type">size_t</span>  bytes_transferred, std::shared_ptr&lt;CSession&gt; shared_self)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bytes_transferred &lt; HEAD_LENGTH) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;read head lenth error&quot;</span>;</span><br><span class="line">            <span class="built_in">Close</span>();</span><br><span class="line">            _server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//头部接收完，解析头部</span></span><br><span class="line">        <span class="type">short</span> data_len = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;data_len, _recv_head_node-&gt;_data, HEAD_LENGTH);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;data_len is &quot;</span> &lt;&lt; data_len &lt;&lt; endl;</span><br><span class="line">        <span class="comment">//此处省略字节序转换</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">//头部长度非法</span></span><br><span class="line">        <span class="keyword">if</span> (data_len &gt; MAX_LENGTH) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;invalid data length is &quot;</span> &lt;&lt; data_len &lt;&lt; endl;</span><br><span class="line">            _server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _recv_msg_node= <span class="built_in">make_shared</span>&lt;MsgNode&gt;(data_len);</span><br><span class="line">        boost::asio::<span class="built_in">async_read</span>(_socket, boost::asio::<span class="built_in">buffer</span>(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len), </span><br><span class="line">            std::<span class="built_in">bind</span>(&amp;CSession::HandleReadMsg, <span class="keyword">this</span>,</span><br><span class="line">            std::placeholders::_1, std::placeholders::_2, <span class="built_in">SharedSelf</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;handle read failed, error is &quot;</span> &lt;&lt; error.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">Close</span>();</span><br><span class="line">        _server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>接下来根据头部内存储的消息体长度，获取指定长度的消息体数据，所以再次调用async_read，指定读取_recv_msg_node-&gt;_total_len长度，然后触发HandleReadMsg函数</li>
</ul>
<h3 id="获取消息体"><a href="#获取消息体" class="headerlink" title="获取消息体"></a>获取消息体</h3><ul>
<li>HandleReadMsg函数内解析消息体，解析完成后打印收到的消息，接下来继续监听读事件，监听读取指定头部大小字节，触发HandleReadHead函数， 然后再在HandleReadHead内继续监听读事件，获取消息体长度数据后触发HandleReadMsg函数，从而达到循环监听的目的。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::HandleReadMsg</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, <span class="type">size_t</span>  bytes_transferred,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::shared_ptr&lt;CSession&gt; shared_self)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        <span class="built_in">PrintRecvData</span>(_data, bytes_transferred);</span><br><span class="line">        std::<span class="function">chrono::milliseconds <span class="title">dura</span><span class="params">(<span class="number">2000</span>)</span></span>;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(dura);</span><br><span class="line">        _recv_msg_node-&gt;_data[_recv_msg_node-&gt;_total_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;receive data is &quot;</span> &lt;&lt; _recv_msg_node-&gt;_data &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">Send</span>(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len);</span><br><span class="line">        <span class="comment">//再次接收头部数据</span></span><br><span class="line">        _recv_head_node-&gt;<span class="built_in">Clear</span>();</span><br><span class="line">        boost::asio::<span class="built_in">async_read</span>(_socket, boost::asio::<span class="built_in">buffer</span>(_recv_head_node-&gt;_data, HEAD_LENGTH),</span><br><span class="line">            std::<span class="built_in">bind</span>(&amp;CSession::HandleReadHead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2,</span><br><span class="line">                <span class="built_in">SharedSelf</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;handle read msg failed,  error is &quot;</span> &lt;&lt; error.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">Close</span>();</span><br><span class="line">        _server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="服务器逻辑层设计和消息完善"><a href="#服务器逻辑层设计和消息完善" class="headerlink" title="服务器逻辑层设计和消息完善"></a>服务器逻辑层设计和消息完善</h2><h3 id="简介1"><a href="#简介1" class="headerlink" title="简介1"></a>简介1</h3><ul>
<li>本文概述基于boost::asio实现的服务器逻辑层结构，并且完善之前设计的消息结构。因为为了简化粘包处理，我们简化了发送数据的结构,这次我们给出完整的消息设计，以及服务器架构设计。</li>
</ul>
<h3 id="服务器架构设计"><a href="#服务器架构设计" class="headerlink" title="服务器架构设计"></a>服务器架构设计</h3><ul>
<li>之前我们设计了Session(会话层)，并且给大家讲述了Asio底层的通信过程，如下图</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/C++asio网络编程/image-16.png" alt="示例图片" style="zoom:100%;" /></p>
<ul>
<li>我们接下来要设计的服务器结构是这样的</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/C++asio网络编程/image-17.png" alt="示例图片" style="zoom:100%;" /></p>
<h3 id="消息头完善"><a href="#消息头完善" class="headerlink" title="消息头完善"></a>消息头完善</h3><ul>
<li>我们之前的消息头仅包含数据域的长度，但是要进行逻辑处理，就需要传递一个id字段表示要处理的消息id，当然可以不在包头传id字段，将id序列化到消息体也是可以的，但是我们为了便于处理也便于回调逻辑层对应的函数，最好是将id写入包头。</li>
<li>之前我们设计的消息结构是这样的</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/C++asio网络编程/image-18.png" alt="示例图片" style="zoom:100%;" /></p>
<ul>
<li>现在改为这样</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/C++asio网络编程/image-19.png" alt="示例图片" style="zoom:100%;" /></p>
<ul>
<li><p>为了减少耦合和歧义，我们重新设计消息节点。</p>
<ol>
<li>MsgNode表示消息节点的基类，头部的消息用这个结构存储。</li>
<li>RecvNode表示接收消息的节点。</li>
<li>SendNode表示发送消息的节点。</li>
</ol>
</li>
</ul>
<h4 id="我们将上述结构定义在MsgNode-h中"><a href="#我们将上述结构定义在MsgNode-h中" class="headerlink" title="我们将上述结构定义在MsgNode.h中"></a>我们将上述结构定义在MsgNode.h中</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;const.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MsgNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MsgNode</span>(<span class="type">short</span> max_len) :_total_len(max_len), _cur_len(<span class="number">0</span>) &#123;</span><br><span class="line">		_data = <span class="keyword">new</span> <span class="type">char</span>[_total_len + <span class="number">1</span>];</span><br><span class="line">		_data[_total_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">MsgNode</span>() &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;destruct MsgNode&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">memset</span>(_data, <span class="number">0</span>, _total_len);</span><br><span class="line">		_cur_len = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">short</span> _cur_len;</span><br><span class="line">	<span class="type">short</span> _total_len;</span><br><span class="line">	<span class="type">char</span>* _data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RecvNode</span> :<span class="keyword">public</span> MsgNode &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">RecvNode</span>(<span class="type">short</span> max_len, <span class="type">short</span> msg_id);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">short</span> _msg_id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SendNode</span> : <span class="keyword">public</span> MsgNode &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">SendNode</span>(<span class="type">const</span> <span class="type">char</span>* msg, <span class="type">short</span> max_len, <span class="type">short</span> msg_id);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">short</span> _msg_id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="实现MsgNode"><a href="#实现MsgNode" class="headerlink" title="实现MsgNode"></a>实现MsgNode</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MsgNode.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">RecvNode::<span class="built_in">RecvNode</span>(<span class="type">short</span> max_len, <span class="type">short</span> msg_id):<span class="built_in">MsgNode</span>(max_len),_msg_id(msg_id)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SendNode::<span class="built_in">SendNode</span>(<span class="type">const</span> <span class="type">char</span>* msg, <span class="type">short</span> max_len, <span class="type">short</span> msg_id):<span class="built_in">MsgNode</span>(max_len + HEAD_TOTAL_LENGTH),_msg_id(msg_id)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//先发送id,转成网络字节序，网络字节序为大端</span></span><br><span class="line">	<span class="type">short</span> msg_id_network = boost::asio::detail::socket_ops::<span class="built_in">host_to_network_short</span>(msg_id);</span><br><span class="line">	<span class="built_in">memcpy</span>(_data, &amp;msg_id_network, HEAD_ID_LEN);</span><br><span class="line">	<span class="comment">//在发送长度,转成网络字节序</span></span><br><span class="line">	<span class="type">short</span> msg_len_network = boost::asio::detail::socket_ops::<span class="built_in">host_to_network_short</span>(max_len);</span><br><span class="line">	<span class="built_in">memcpy</span>(_data + HEAD_ID_LEN, &amp;msg_len_network, HEAD_DATA_LEN);</span><br><span class="line">	<span class="comment">//最后发送实际消息,我们传的是protobuf或json序列化的字节流所以不用转字节序</span></span><br><span class="line">	<span class="built_in">memcpy</span>(_data + HEAD_TOTAL_LENGTH, msg, max_len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>SendNode发送节点构造时，先将id转为网络字节序，然后写入_data数据域。</li>
<li>然后将要发送数据的长度转为大端字节序，写入_data数据域，注意要偏移HEAD_ID_LEN长度。</li>
<li>最后将要发送的数据msg写入_data数据域，注意要偏移HEAD_ID_LEN+HEAD_DATA_LEN</li>
</ul>
<h3 id="Session类改写"><a href="#Session类改写" class="headerlink" title="Session类改写"></a>Session类改写</h3><h4 id="完整的代码2"><a href="#完整的代码2" class="headerlink" title="完整的代码2"></a>完整的代码2</h4><h5 id="Session-h"><a href="#Session-h" class="headerlink" title="Session.h"></a>Session.h</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/uuid/uuid_io.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/uuid/uuid_generators.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MsgNode.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;const.h&quot;</span></span></span><br><span class="line"><span class="comment">//避免循环依赖问题使用前置声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CServer</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CSession</span>: <span class="keyword">public</span> std::enable_shared_from_this&lt;CSession&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CSession</span>(boost::asio::io_context&amp; ioc, CServer* server);</span><br><span class="line">	~<span class="built_in">CSession</span>();</span><br><span class="line">	boost::asio::ip::<span class="function">tcp::socket&amp; <span class="title">GetSocket</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">std::string&amp; <span class="title">GetUuid</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Send</span><span class="params">(<span class="type">char</span>* msg, <span class="type">short</span> max_len, <span class="type">short</span> msgid)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Send</span><span class="params">(std::string msg, <span class="type">short</span> msgid)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Close</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">std::shared_ptr&lt;CSession&gt; <span class="title">SharedSelf</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">HandleRead</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, <span class="type">size_t</span> bytes_transferred, std::shared_ptr&lt;CSession&gt; shared_self)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">HandleWrite</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, std::shared_ptr&lt;CSession&gt; shared_self)</span></span>;</span><br><span class="line">	boost::asio::ip::tcp::socket _socket;</span><br><span class="line">	std::string _uuid;</span><br><span class="line">	<span class="type">char</span> _data[MAX_LENGTH];</span><br><span class="line">	CServer* _server;</span><br><span class="line">	<span class="comment">//标志是否关闭</span></span><br><span class="line">	<span class="type">bool</span> _b_close;</span><br><span class="line">	<span class="comment">//用于保证发送信息的时序性</span></span><br><span class="line">	std::queue&lt;std::shared_ptr&lt;SendNode&gt;&gt; _send_que;</span><br><span class="line">	<span class="comment">//对队列加锁</span></span><br><span class="line">	std::mutex _send_lock;</span><br><span class="line">	<span class="comment">// 收到的消息结构</span></span><br><span class="line">	std::shared_ptr&lt;RecvNode&gt; _recv_msg_node;</span><br><span class="line">	<span class="comment">//判断头部节点是否构造完成</span></span><br><span class="line">	<span class="type">bool</span> _b_head_parse;</span><br><span class="line">	<span class="comment">//收到的头部结构,包括消息id与消息体长度</span></span><br><span class="line">	std::shared_ptr&lt;MsgNode&gt; _recv_head_node;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="Session-cpp-1"><a href="#Session-cpp-1" class="headerlink" title="Session.cpp"></a>Session.cpp</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CSession.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CServer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;json/json.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;json/value.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;json/reader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">CSession::<span class="built_in">CSession</span>(boost::asio::io_context&amp; ioc, CServer* server):</span><br><span class="line">	_socket(ioc), _server(server), _b_close(<span class="literal">false</span>), _b_head_parse(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//创建一个没有重复的id</span></span><br><span class="line">	boost::uuids::uuid a_uuid = boost::uuids::<span class="built_in">random_generator</span>()();</span><br><span class="line">	_uuid = boost::uuids::<span class="built_in">to_string</span>(a_uuid);</span><br><span class="line">	<span class="comment">//不管是收到的信息还是发出的信息都有头部节点，所以放在构造函数中</span></span><br><span class="line">	_recv_head_node = std::<span class="built_in">make_shared</span>&lt;MsgNode&gt;(HEAD_TOTAL_LENGTH);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CSession::~<span class="built_in">CSession</span>()</span><br><span class="line">&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;~CSession destruct&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">boost::asio::ip::<span class="function">tcp::socket&amp; <span class="title">CSession::GetSocket</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> 在此处插入 return 语句</span></span><br><span class="line">	<span class="keyword">return</span> _socket;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string&amp; <span class="title">CSession::GetUuid</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> 在此处插入 return 语句</span></span><br><span class="line">	<span class="keyword">return</span> _uuid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对接收数据清零，并且开始异步非阻塞读取</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);</span><br><span class="line">	_socket.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, MAX_LENGTH), std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>,</span><br><span class="line">		std::placeholders::_1, std::placeholders::_2, <span class="built_in">SharedSelf</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送C++风格的string信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::Send</span><span class="params">(std::string msg, <span class="type">short</span> msgid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//由于需要对队列操作，所以要加锁</span></span><br><span class="line">	<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_send_lock)</span></span>;</span><br><span class="line">	<span class="comment">//队列的长度</span></span><br><span class="line">	<span class="type">int</span> send_que_size = _send_que.<span class="built_in">size</span>();</span><br><span class="line">	<span class="comment">//限制队列长度</span></span><br><span class="line">	<span class="keyword">if</span> (send_que_size &gt; MAX_SENDQUE) &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;session: &quot;</span> &lt;&lt; _uuid &lt;&lt; <span class="string">&quot; send que fulled, size is &quot;</span> &lt;&lt; MAX_SENDQUE &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//把数据插入队列，保证时序性</span></span><br><span class="line">	_send_que.<span class="built_in">push</span>(std::<span class="built_in">make_shared</span>&lt;SendNode&gt;(msg.<span class="built_in">c_str</span>(), msg.<span class="built_in">length</span>(), msgid));</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//对于多个套接字，只允许当队列长度为1的时候发送数据，因为我们是在插入之前计算的队列长度，所以是判断大于0</span></span><br><span class="line">	<span class="keyword">if</span> (send_que_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//从队列取出数据，写入发送缓冲区</span></span><br><span class="line">	<span class="keyword">auto</span>&amp; msgnode = _send_que.<span class="built_in">front</span>();</span><br><span class="line">	boost::asio::<span class="built_in">async_write</span>(_socket, boost::asio::<span class="built_in">buffer</span>(msgnode-&gt;_data, msgnode-&gt;_total_len),</span><br><span class="line">		std::<span class="built_in">bind</span>(&amp;CSession::HandleWrite, <span class="keyword">this</span>, std::placeholders::_1, <span class="built_in">SharedSelf</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::Send</span><span class="params">(<span class="type">char</span>* msg, <span class="type">short</span> max_length, <span class="type">short</span> msgid)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_send_lock)</span></span>;</span><br><span class="line">	<span class="type">int</span> send_que_size = _send_que.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">if</span> (send_que_size &gt; MAX_SENDQUE) &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;session: &quot;</span> &lt;&lt; _uuid &lt;&lt; <span class="string">&quot; send que fulled, size is &quot;</span> &lt;&lt; MAX_SENDQUE &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_send_que.<span class="built_in">push</span>(std::<span class="built_in">make_shared</span>&lt;SendNode&gt;(msg, max_length, msgid));</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (send_que_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span>&amp; msgnode = _send_que.<span class="built_in">front</span>();</span><br><span class="line">	boost::asio::<span class="built_in">async_write</span>(_socket, boost::asio::<span class="built_in">buffer</span>(msgnode-&gt;_data, msgnode-&gt;_total_len),</span><br><span class="line">		std::<span class="built_in">bind</span>(&amp;CSession::HandleWrite, <span class="keyword">this</span>, std::placeholders::_1, <span class="built_in">SharedSelf</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::Close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	_socket.<span class="built_in">close</span>();</span><br><span class="line">	_b_close = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用来让指针同步引用，而不会导致指向一个内存的两个智能指针引用计数不一致问题</span></span><br><span class="line">std::shared_ptr&lt;CSession&gt;CSession::<span class="built_in">SharedSelf</span>() &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">shared_from_this</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::HandleWrite</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, std::shared_ptr&lt;CSession&gt; shared_self)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//增加异常处理</span></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (!error) &#123;</span><br><span class="line">			<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_send_lock)</span></span>;</span><br><span class="line">			<span class="comment">//cout &lt;&lt; &quot;send data &quot; &lt;&lt; _send_que.front()-&gt;_data+HEAD_LENGTH &lt;&lt; endl;</span></span><br><span class="line">			_send_que.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">			<span class="comment">//如果队列不为空，继续发送数据</span></span><br><span class="line">			<span class="keyword">if</span> (!_send_que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">				<span class="keyword">auto</span>&amp; msgnode = _send_que.<span class="built_in">front</span>();</span><br><span class="line">				boost::asio::<span class="built_in">async_write</span>(_socket, boost::asio::<span class="built_in">buffer</span>(msgnode-&gt;_data, msgnode-&gt;_total_len),</span><br><span class="line">					std::<span class="built_in">bind</span>(&amp;CSession::HandleWrite, <span class="keyword">this</span>, std::placeholders::_1, shared_self));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;handle write failed, error is &quot;</span> &lt;&lt; error.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">			<span class="built_in">Close</span>();</span><br><span class="line">			_server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">		std::cerr &lt;&lt; <span class="string">&quot;Exception code : &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::HandleRead</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, <span class="type">size_t</span>  bytes_transferred, std::shared_ptr&lt;CSession&gt; shared_self)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (!error) &#123;</span><br><span class="line">			<span class="comment">//已经移动的字符数</span></span><br><span class="line">			<span class="type">int</span> copy_len = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span> (bytes_transferred &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!_b_head_parse) &#123;</span><br><span class="line">					<span class="comment">//收到的数据不足头部大小</span></span><br><span class="line">					<span class="keyword">if</span> (bytes_transferred + _recv_head_node-&gt;_cur_len &lt; HEAD_TOTAL_LENGTH) &#123;</span><br><span class="line">						<span class="built_in">memcpy</span>(_recv_head_node-&gt;_data + _recv_head_node-&gt;_cur_len, _data + copy_len, bytes_transferred);</span><br><span class="line">						_recv_head_node-&gt;_cur_len += bytes_transferred;</span><br><span class="line">						::<span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);</span><br><span class="line">						_socket.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, MAX_LENGTH),</span><br><span class="line">							std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));</span><br><span class="line">						<span class="keyword">return</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">//收到的数据比头部多</span></span><br><span class="line">					<span class="comment">//处理头部剩余未复制的长度</span></span><br><span class="line">					<span class="type">int</span> head_remain = HEAD_TOTAL_LENGTH - _recv_head_node-&gt;_cur_len;</span><br><span class="line">					<span class="built_in">memcpy</span>(_recv_head_node-&gt;_data + _recv_head_node-&gt;_cur_len, _data + copy_len, head_remain);</span><br><span class="line">					<span class="comment">//更新已处理的data长度和剩余未处理的长度</span></span><br><span class="line">					copy_len += head_remain;</span><br><span class="line">					bytes_transferred -= head_remain;</span><br><span class="line">					<span class="comment">//获取头部MSGID数据</span></span><br><span class="line">					<span class="type">short</span> msg_id = <span class="number">0</span>;</span><br><span class="line">					<span class="built_in">memcpy</span>(&amp;msg_id, _recv_head_node-&gt;_data, HEAD_ID_LEN);</span><br><span class="line">					<span class="comment">//网络字节序转化为本地字节序</span></span><br><span class="line">					msg_id = boost::asio::detail::socket_ops::<span class="built_in">network_to_host_short</span>(msg_id);</span><br><span class="line">					std::cout &lt;&lt; <span class="string">&quot;msg_id is &quot;</span> &lt;&lt; msg_id &lt;&lt; std::endl;</span><br><span class="line">					<span class="comment">//id非法</span></span><br><span class="line">					<span class="keyword">if</span> (msg_id &gt; MAX_LENGTH) &#123;</span><br><span class="line">						std::cout &lt;&lt; <span class="string">&quot;invalid msg_id is &quot;</span> &lt;&lt; msg_id &lt;&lt; std::endl;</span><br><span class="line">						_server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">						<span class="keyword">return</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="type">short</span> msg_len = <span class="number">0</span>;</span><br><span class="line">					<span class="built_in">memcpy</span>(&amp;msg_len, _recv_head_node-&gt;_data + HEAD_ID_LEN, HEAD_DATA_LEN);</span><br><span class="line">					<span class="comment">//网络字节序转化为本地字节序</span></span><br><span class="line">					msg_len = boost::asio::detail::socket_ops::<span class="built_in">network_to_host_short</span>(msg_len);</span><br><span class="line">					std::cout &lt;&lt; <span class="string">&quot;msg_len is &quot;</span> &lt;&lt; msg_len &lt;&lt; std::endl;</span><br><span class="line">					<span class="comment">//id非法</span></span><br><span class="line">					<span class="keyword">if</span> (msg_len &gt; MAX_LENGTH) &#123;</span><br><span class="line">						std::cout &lt;&lt; <span class="string">&quot;invalid data length is &quot;</span> &lt;&lt; msg_len &lt;&lt; std::endl;</span><br><span class="line">						_server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">						<span class="keyword">return</span>;</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					_recv_msg_node = std::<span class="built_in">make_shared</span>&lt;RecvNode&gt;(msg_len, msg_id);</span><br><span class="line"></span><br><span class="line">					<span class="comment">//消息的长度小于头部规定的长度，说明数据未收全，则先将部分消息放到接收节点里</span></span><br><span class="line">					<span class="keyword">if</span> (bytes_transferred &lt; msg_len) &#123;</span><br><span class="line">						<span class="built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, bytes_transferred);</span><br><span class="line">						_recv_msg_node-&gt;_cur_len += bytes_transferred;</span><br><span class="line">						::<span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);</span><br><span class="line">						_socket.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, MAX_LENGTH),</span><br><span class="line">							std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));</span><br><span class="line">						<span class="comment">//头部处理完成</span></span><br><span class="line">						_b_head_parse = <span class="literal">true</span>;</span><br><span class="line">						<span class="keyword">return</span>;</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					<span class="comment">//消息的长度大于等于头部规定的长度，说明数据收全，解析消息体</span></span><br><span class="line">					<span class="built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, msg_len);</span><br><span class="line">					_recv_msg_node-&gt;_cur_len += msg_len;</span><br><span class="line">					copy_len += msg_len;</span><br><span class="line">					bytes_transferred -= msg_len;</span><br><span class="line">					_recv_msg_node-&gt;_data[_recv_msg_node-&gt;_total_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">					<span class="comment">//cout &lt;&lt; &quot;receive data is &quot; &lt;&lt; _recv_msg_node-&gt;_data &lt;&lt; endl;</span></span><br><span class="line">					</span><br><span class="line">					<span class="comment">//此处可以调用Send发送测试</span></span><br><span class="line">					Json::Reader reader;</span><br><span class="line">					Json::Value root;</span><br><span class="line"></span><br><span class="line">					<span class="comment">//解析成json对象</span></span><br><span class="line">					reader.<span class="built_in">parse</span>(std::<span class="built_in">string</span>(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len), root);</span><br><span class="line"></span><br><span class="line">					<span class="comment">// 将json格式转换为不同格式</span></span><br><span class="line">					std::cout &lt;&lt; <span class="string">&quot;recevie msg id is &quot;</span> &lt;&lt; root[<span class="string">&quot;id&quot;</span>].<span class="built_in">asInt</span>() &lt;&lt; <span class="string">&quot; msg data is &quot;</span></span><br><span class="line">						&lt;&lt; root[<span class="string">&quot;data&quot;</span>].<span class="built_in">asString</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">					root[<span class="string">&quot;data&quot;</span>] = <span class="string">&quot;server has received msg, msg data is &quot;</span> + root[<span class="string">&quot;data&quot;</span>].<span class="built_in">asString</span>();</span><br><span class="line"></span><br><span class="line">					<span class="comment">//反序列化成字符串</span></span><br><span class="line">					std::string return_str = root.<span class="built_in">toStyledString</span>();</span><br><span class="line"></span><br><span class="line">					<span class="comment">//发送接受的消息</span></span><br><span class="line">					<span class="built_in">Send</span>(return_str, root[<span class="string">&quot;id&quot;</span>].<span class="built_in">asInt</span>());</span><br><span class="line"></span><br><span class="line">					<span class="comment">//继续轮询剩余未处理数据</span></span><br><span class="line">					_b_head_parse = <span class="literal">false</span>;</span><br><span class="line">					_recv_head_node-&gt;<span class="built_in">Clear</span>();</span><br><span class="line">					<span class="keyword">if</span> (bytes_transferred &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">						::<span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);</span><br><span class="line">						_socket.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, MAX_LENGTH),</span><br><span class="line">							std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));</span><br><span class="line">						<span class="keyword">return</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">//已经处理完头部，处理上次未接受完的消息数据</span></span><br><span class="line">				<span class="comment">//接收的数据仍不足剩余未处理的</span></span><br><span class="line">				<span class="type">int</span> remain_msg = _recv_msg_node-&gt;_total_len - _recv_msg_node-&gt;_cur_len;</span><br><span class="line">				<span class="keyword">if</span> (bytes_transferred &lt; remain_msg) &#123;</span><br><span class="line">					<span class="built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, bytes_transferred);</span><br><span class="line">					_recv_msg_node-&gt;_cur_len += bytes_transferred;</span><br><span class="line">					::<span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);</span><br><span class="line">					_socket.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, MAX_LENGTH),</span><br><span class="line">						std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, remain_msg);</span><br><span class="line">				_recv_msg_node-&gt;_cur_len += remain_msg;</span><br><span class="line">				bytes_transferred -= remain_msg;</span><br><span class="line">				copy_len += remain_msg;</span><br><span class="line">				_recv_msg_node-&gt;_data[_recv_msg_node-&gt;_total_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">				<span class="comment">//cout &lt;&lt; &quot;receive data is &quot; &lt;&lt; _recv_msg_node-&gt;_data &lt;&lt; endl;</span></span><br><span class="line">					<span class="comment">//此处可以调用Send发送测试</span></span><br><span class="line">				Json::Reader reader;</span><br><span class="line">				Json::Value root;</span><br><span class="line">				reader.<span class="built_in">parse</span>(std::<span class="built_in">string</span>(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len), root);</span><br><span class="line">				std::cout &lt;&lt; <span class="string">&quot;recevie msg id  is &quot;</span> &lt;&lt; root[<span class="string">&quot;id&quot;</span>].<span class="built_in">asInt</span>() &lt;&lt; <span class="string">&quot; msg data is &quot;</span></span><br><span class="line">					&lt;&lt; root[<span class="string">&quot;data&quot;</span>].<span class="built_in">asString</span>() &lt;&lt; std::endl;</span><br><span class="line">				root[<span class="string">&quot;data&quot;</span>] = <span class="string">&quot;server has received msg, msg data is &quot;</span> + root[<span class="string">&quot;data&quot;</span>].<span class="built_in">asString</span>();</span><br><span class="line">				std::string return_str = root.<span class="built_in">toStyledString</span>();</span><br><span class="line">				<span class="built_in">Send</span>(return_str, root[<span class="string">&quot;id&quot;</span>].<span class="built_in">asInt</span>());</span><br><span class="line">				<span class="comment">//继续轮询剩余未处理数据</span></span><br><span class="line">				_b_head_parse = <span class="literal">false</span>;</span><br><span class="line">				_recv_head_node-&gt;<span class="built_in">Clear</span>();</span><br><span class="line">				<span class="keyword">if</span> (bytes_transferred &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">					::<span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);</span><br><span class="line">					_socket.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, MAX_LENGTH),</span><br><span class="line">						std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;handle read failed, error is &quot;</span> &lt;&lt; error.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">			<span class="built_in">Close</span>();</span><br><span class="line">			_server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Exception code is &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="单例模式实现逻辑层设计"><a href="#单例模式实现逻辑层设计" class="headerlink" title="单例模式实现逻辑层设计"></a>单例模式实现逻辑层设计</h2><h3 id="单例模板类"><a href="#单例模板类" class="headerlink" title="单例模板类"></a>单例模板类</h3><ul>
<li>接下来我们实现一个单例模板类，因为服务器的逻辑处理需要单例模式，后期可能还会有一些模块的设计也需要单例模式，所以先实现一个单例模板类，然后其他想实现单例类只需要继承这个模板类即可。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> std::shared_ptr&lt;T&gt; <span class="title">GetInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//只有第一次调用的时候会初始化，再次调用就不会初始化</span></span><br><span class="line">		<span class="comment">//其声明周期与进程生命周期相同</span></span><br><span class="line">		<span class="type">static</span> std::once_flag s_flag;</span><br><span class="line">		std::<span class="built_in">call_once</span>(s_flag, [&amp;]() &#123;</span><br><span class="line">			_instance = <span class="built_in">shared_ptr</span>&lt;T&gt;(<span class="keyword">new</span> T);</span><br><span class="line">			&#125;);</span><br><span class="line">		<span class="keyword">return</span> _instance;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">PrintAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; _instance-&gt;<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line">	<span class="built_in">Singleton</span>(Singleton&lt;T&gt;&amp; st) = <span class="keyword">delete</span>;</span><br><span class="line">	Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&lt;T&gt;&amp; st) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">static</span> std::shared_ptr&lt;T&gt; _instance;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	~<span class="built_in">Singleton</span>() &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;this is singleton destruct &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为是模板类，所以初始化的时候不能放在.cpp里，得放在.h里</span></span><br><span class="line"><span class="comment">// 并且又由于是模板类的静态成员，所以如果省略了 std::shared_ptr&lt;T&gt;，编译器将无法识别 _instance 的类型，并且无法进行类型推断。因此，在定义静态成员变量时，必须明确指明其类型。</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">std::shared_ptr&lt;T&gt; Singleton&lt;T&gt;::_instance = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>其中的细节</p>
<ol>
<li>因为是模板类，所以初始化的时候不能放在.cpp里，得放在.h里，并且又由于是模板类的静态成员，所以如果省略了 std::shared_ptr<T>，编译器将无法识别 _instance 的类型，并且无法进行类型推断。因此，在定义静态成员变量时，必须明确指明其类型。</li>
<li><p>得保证线程安全，可以使用C++11的once_flag 与 call_once，std::call_once 函数接受一个 std::once_flag 对象和一个函数作为参数，它会确保这个函数只被调用一次，实现原理是用加锁和一个标志位来实现,其逻辑与下属类似：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span>* instance</span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(flag) <span class="keyword">return</span> instance;</span><br><span class="line">std::mutex mtx;</span><br><span class="line"><span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line"><span class="keyword">if</span>(flag) <span class="keyword">return</span> instance;</span><br><span class="line">instance = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">2</span>);</span><br><span class="line">flag = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>单例模式模板类将无参构造，拷贝构造，拷贝赋值都设定为protected属性，其他的类无法访问，其实也可以设置为私有属性。析构函数设置为公有的，其实设置为私有的更合理一点。<br>Singleton有一个static类型的属性_instance, 它是我们实际要开辟类型的智能指针类型。<br>s_flag是函数GetInstance内的局部静态变量，该变量在函数GetInstance第一次调用时被初始化。以后无论调用多少次GetInstance s_flag都不会被重复初始化，而且s_flag存在静态区，会随着进程结束而自动释放。<br>call_once只会调用一次，而且是线程安全的， 其内部的原理就是调用该函数时加锁，然后设置s_flag内部的标记，设置为已经初始化，执行lambda表达式逻辑初始化智能指针，然后解锁。第二次调用GetInstance 内部还会调用call_once, 只是call_once判断s_flag已经被初始化了就不执行初始化智能指针的操作了。</p>
</li>
</ul>
<h3 id="LogicSystem单例类"><a href="#LogicSystem单例类" class="headerlink" title="LogicSystem单例类"></a>LogicSystem单例类</h3><ul>
<li>我们实现逻辑系统的单例类，继承自Singleton<LogicSystem>，这样LogicSystem的构造函数和拷贝构造函数就都变为私有的了，因为基类的构造函数和拷贝构造函数都是私有的。另外LogicSystem也用了基类的成员_instance和GetInstance函数。从而达到单例效果。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;json/json.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;json/value.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;json/reader.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Singleton.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;const.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CSession.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">void</span>(std::shared_ptr&lt;CSession&gt; session, <span class="type">const</span> <span class="type">short</span>&amp; msg_id, <span class="type">const</span> std::string&amp; msg_data)&gt; FunCallBack;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LogicSystem</span> :<span class="keyword">public</span> Singleton&lt;LogicSystem&gt; &#123;</span><br><span class="line">	<span class="comment">//由于在Singleton的GetInstacne中调用了LogicSystem的私有构造函数</span></span><br><span class="line">	<span class="comment">//所以得声明友元，让对方能够调用</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&lt;LogicSystem&gt;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//设置为公有是为了让单例类能够正常析构</span></span><br><span class="line">	~<span class="built_in">LogicSystem</span>();</span><br><span class="line">	<span class="comment">//将逻辑节点投递到消息队列里</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">PostMsgToQue</span><span class="params">(std::shared_ptr&lt;LogicNode&gt; msg)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">LogicSystem</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//注册功能</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">RegisterCallBacks</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">HelloWordCallBacks</span><span class="params">(std::shared_ptr&lt;CSession&gt; new_session, <span class="type">const</span> <span class="type">short</span>&amp; msg_id, <span class="type">const</span> std::string&amp; msg_data)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">DealMsg</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//用来存储逻辑节点</span></span><br><span class="line">	std::queue&lt;std::shared_ptr&lt;LogicNode&gt;&gt; _msg_que;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//需要加锁</span></span><br><span class="line">	std::mutex mtx;</span><br><span class="line">	<span class="comment">//由于有消息队列，所以需要阻塞线程，所以需要</span></span><br><span class="line">	<span class="comment">//条件变量来通知被阻塞的线程</span></span><br><span class="line">	std::condition_variable _consume;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//还需要工作线程来消费逻辑消息</span></span><br><span class="line">	std::thread _worker_thread;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//使用这个来标记逻辑停止</span></span><br><span class="line">	<span class="type">bool</span> _b_stop;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//用来存储回调函数，也就是注册进来</span></span><br><span class="line">	std::map&lt;<span class="type">short</span>, FunCallBack&gt; _fun_callbacks;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol>
<li>FunCallBack为要注册的回调函数类型，其参数为绘画类智能指针，消息id，以及消息内容</li>
<li>_msg_que为逻辑队列</li>
<li>_mutex 为保证逻辑队列安全的互斥量</li>
<li>_consume表示消费者条件变量，用来控制当逻辑队列为空时保证线程暂时挂起等待，不要干扰其他线程。</li>
<li>_fun_callbacks表示回调函数的map，根据id查找对应的逻辑处理函数。</li>
<li>_worker_thread表示工作线程，用来从逻辑队列中取数据并执行回调函数。</li>
<li>_b_stop表示收到外部的停止信号，逻辑类要中止工作线程并优雅退出。</li>
</ol>
<ul>
<li>LogicNode定义在CSession.h中</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LogicNode</span> &#123;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">LogicSystem</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">LogicNode</span>(std::shared_ptr&lt;CSession&gt; session, std::shared_ptr&lt;RecvNode&gt; recvnode);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::shared_ptr&lt;CSession&gt; _session;</span><br><span class="line">	std::shared_ptr&lt;RecvNode&gt; _recvnode;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>其包含了会话类的智能指针，主要是为了实现伪闭包，防止session被释放。<br>其次包含了接收消息的节点类的智能指针。</li>
<li>实现如下:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LogicNode::<span class="built_in">LogicNode</span>(std::shared_ptr&lt;CSession&gt; session, std::shared_ptr&lt;RecvNode&gt; recvnode): _session(session), _recvnode(recvnode)</span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>LogicSystem的构造函数如下</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LogicSystem::<span class="built_in">LogicSystem</span>(): _b_stop(<span class="literal">false</span>) &#123;</span><br><span class="line">	<span class="comment">//用于绑定回调函数</span></span><br><span class="line">	<span class="built_in">RegisterCallBacks</span>();</span><br><span class="line">	<span class="comment">//启动工作线程</span></span><br><span class="line">	_worker_thread = std::<span class="built_in">thread</span>(&amp;LogicSystem::DealMsg, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>构造函数中将停止信息初始化为false，注册消息处理函数并且启动了一个工作线程，工作线程执行DealMsg逻辑。<br>注册消息处理函数的逻辑如下:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LogicSystem::RegisterCallBacks</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	_fun_callbacks[MSG_HELLO_WORD] = std::<span class="built_in">bind</span>(&amp;LogicSystem::HelloWordCallBacks, <span class="keyword">this</span>,</span><br><span class="line">		std::placeholders::_1, std::placeholders::_2, std::placeholders::_3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>MSG_HELLO_WORD定义在const.h中</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">MSG_IDS</span> &#123;</span><br><span class="line">    MSG_HELLO_WORD = <span class="number">1001</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>MSG_HELLO_WORD表示消息id，HelloWordCallBack为对应的回调处理函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LogicSystem::HelloWordCallBacks</span><span class="params">(std::shared_ptr&lt;CSession&gt; session, <span class="type">const</span> <span class="type">short</span>&amp; msg_id, <span class="type">const</span> std::string&amp; msg_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Json::Reader reader;</span><br><span class="line">	Json::Value root;</span><br><span class="line">	<span class="comment">//将msg_data 内容系列化到root里</span></span><br><span class="line">	reader.<span class="built_in">parse</span>(msg_data, root);</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;receive msg id is&quot;</span> &lt;&lt; root[<span class="string">&quot;id&quot;</span>].<span class="built_in">asInt</span>() &lt;&lt; <span class="string">&quot;msg data is &quot;</span></span><br><span class="line">		&lt;&lt; root[<span class="string">&quot;data&quot;</span>].<span class="built_in">asString</span>() &lt;&lt; std::endl;</span><br><span class="line">	root[<span class="string">&quot;data&quot;</span>] = <span class="string">&quot;server has receive msg, msg data is &quot;</span> + root[<span class="string">&quot;data&quot;</span>].<span class="built_in">asString</span>();</span><br><span class="line"></span><br><span class="line">	std::string return_str = root.<span class="built_in">toStyledString</span>();</span><br><span class="line">	<span class="comment">//发送信息</span></span><br><span class="line">	session-&gt;<span class="built_in">Send</span>(return_str, root[<span class="string">&quot;id&quot;</span>].<span class="built_in">asInt</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>在HelloWordCallBack里我们根据消息id和收到的消息，做了相应的处理并且回应给客户端。</p>
</li>
<li><p>工作线程的处理函数DealMsg逻辑</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LogicSystem::DealMsg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="comment">//配合条件变量使用，以及加锁</span></span><br><span class="line">		<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">unique_lk</span><span class="params">(mtx)</span></span>;</span><br><span class="line">		<span class="comment">//判断队列为空则用条件变量阻塞等待，并释放锁</span></span><br><span class="line">		<span class="keyword">while</span> (_msg_que.<span class="built_in">empty</span>() &amp;&amp; !_b_stop) &#123;</span><br><span class="line">			_consume.<span class="built_in">wait</span>(unique_lk);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* 也可以这么写</span></span><br><span class="line"><span class="comment">			_consume.wait(unique_lk, [this]()&#123;</span></span><br><span class="line"><span class="comment">				return !_msg_que.empty() &amp;&amp; _b_stop</span></span><br><span class="line"><span class="comment">			&#125;)</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//判断是否为关闭状态，把所有逻辑执行完后则退出循环</span></span><br><span class="line">		<span class="keyword">if</span> (_b_stop) &#123;</span><br><span class="line">			<span class="keyword">while</span> (!_msg_que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">				<span class="keyword">auto</span> msg_node = _msg_que.<span class="built_in">front</span>();</span><br><span class="line">				std::cout &lt;&lt; <span class="string">&quot;recv_msg id  is &quot;</span> &lt;&lt; msg_node-&gt;_recvnode-&gt;_msg_id &lt;&lt; std::endl;</span><br><span class="line">				<span class="keyword">auto</span> call_back_iter = _fun_callbacks.<span class="built_in">find</span>(msg_node-&gt;_recvnode-&gt;_msg_id);</span><br><span class="line">				<span class="keyword">if</span> (call_back_iter == _fun_callbacks.<span class="built_in">end</span>()) &#123;</span><br><span class="line">					_msg_que.<span class="built_in">pop</span>();</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				call_back_iter-&gt;<span class="built_in">second</span>(msg_node-&gt;_session, msg_node-&gt;_recvnode-&gt;_msg_id,</span><br><span class="line">					std::<span class="built_in">string</span>(msg_node-&gt;_recvnode-&gt;_data, msg_node-&gt;_recvnode-&gt;_cur_len));</span><br><span class="line">				_msg_que.<span class="built_in">pop</span>();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//如果没有停服，且说明队列中有数据</span></span><br><span class="line">		<span class="keyword">auto</span> msg_node = _msg_que.<span class="built_in">front</span>();</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;recv_msg id  is &quot;</span> &lt;&lt; msg_node-&gt;_recvnode-&gt;_msg_id &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">auto</span> call_back_iter = _fun_callbacks.<span class="built_in">find</span>(msg_node-&gt;_recvnode-&gt;_msg_id);</span><br><span class="line">		<span class="keyword">if</span> (call_back_iter == _fun_callbacks.<span class="built_in">end</span>()) &#123;</span><br><span class="line">			_msg_que.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//因为second为FunCallBack其参数为三个，所以需要三个函数</span></span><br><span class="line">		call_back_iter-&gt;<span class="built_in">second</span>(msg_node-&gt;_session, msg_node-&gt;_recvnode-&gt;_msg_id,</span><br><span class="line">			std::<span class="built_in">string</span>(msg_node-&gt;_recvnode-&gt;_data, msg_node-&gt;_recvnode-&gt;_cur_len));</span><br><span class="line">		_msg_que.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>DealMsg逻辑中初始化了一个unique_lock，主要是用来控制队列安全，并且配合条件变量可以随时解锁。lock_guard不具备解锁功能，所以此处用unique_lock。</li>
<li>我们判断队列为空，并且不是停止状态，就挂起线程。否则继续执行之后的逻辑，如果_b_stop为true，说明处于停服状态，则将队列中未处理的消息全部处理完然后退出循环。如果_b_stop未false，则说明没有停服，是consumer发送的激活信号激活了线程，则继续取队列中的数据处理。</li>
</ol>
<ul>
<li>LogicSystem的析构函数需要等待工作线程处理完再退出，但是工作线程可能处于挂起状态，所以要发送一个激活信号唤醒工作线程。并且将_b_stop标记设置为true。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LogicSystem::~<span class="built_in">LogicSystem</span>()&#123;</span><br><span class="line">    _b_stop = <span class="literal">true</span>;</span><br><span class="line">    _consume.<span class="built_in">notify_one</span>();</span><br><span class="line">    _worker_thread.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>因为网络层收到消息后我们需要将消息投递给逻辑队列进行处理，那么LogicSystem就要封装一个投递函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LogicSystem::PostMsgToQue</span><span class="params">(std::shared_ptr&lt;LogicNode&gt; msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">unique_lk</span><span class="params">(mtx)</span></span>;</span><br><span class="line">	_msg_que.<span class="built_in">push</span>(msg);</span><br><span class="line">	<span class="comment">//由0变为1则发送通知信号,通知被阻塞的线程</span></span><br><span class="line">	<span class="keyword">if</span> (_msg_que.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">		unique_lk.<span class="built_in">unlock</span>();</span><br><span class="line">		_consume.<span class="built_in">notify_one</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在Session收到数据时这样调用</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LogicSystem::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">PostMsgToQue</span>(<span class="built_in">make_shared</span>&lt;LogicNode&gt;(<span class="built_in">shared_from_this</span>(), _recv_msg_node));</span><br></pre></td></tr></table></figure>
<h4 id="LogicSystem-完整代码"><a href="#LogicSystem-完整代码" class="headerlink" title="LogicSystem 完整代码"></a>LogicSystem 完整代码</h4><h5 id="头文件-1"><a href="#头文件-1" class="headerlink" title="头文件"></a>头文件</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;json/json.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;json/value.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;json/reader.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Singleton.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;const.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CSession.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">void</span>(std::shared_ptr&lt;CSession&gt; session, <span class="type">const</span> <span class="type">short</span>&amp; msg_id, <span class="type">const</span> std::string&amp; msg_data)&gt; FunCallBack;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LogicSystem</span> :<span class="keyword">public</span> Singleton&lt;LogicSystem&gt; &#123;</span><br><span class="line">	<span class="comment">//由于在Singleton的GetInstacne中调用了LogicSystem的私有构造函数</span></span><br><span class="line">	<span class="comment">//所以得声明友元，让对方能够调用</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&lt;LogicSystem&gt;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//设置为公有是为了让单例类能够正常析构</span></span><br><span class="line">	~<span class="built_in">LogicSystem</span>();</span><br><span class="line">	<span class="comment">//将逻辑节点投递到消息队列里</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">PostMsgToQue</span><span class="params">(std::shared_ptr&lt;LogicNode&gt; msg)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">LogicSystem</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//注册功能,是注册函数的统一接口</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">RegisterCallBacks</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//具体的注册的函数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">HelloWordCallBacks</span><span class="params">(std::shared_ptr&lt;CSession&gt; new_session, <span class="type">const</span> <span class="type">short</span>&amp; msg_id, <span class="type">const</span> std::string&amp; msg_data)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">DealMsg</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//用来存储逻辑节点</span></span><br><span class="line">	std::queue&lt;std::shared_ptr&lt;LogicNode&gt;&gt; _msg_que;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//需要加锁</span></span><br><span class="line">	std::mutex mtx;</span><br><span class="line">	<span class="comment">//由于有消息队列，所以需要阻塞线程，所以需要</span></span><br><span class="line">	<span class="comment">//条件变量来通知被阻塞的线程</span></span><br><span class="line">	std::condition_variable _consume;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//还需要工作线程来消费逻辑消息</span></span><br><span class="line">	std::thread _worker_thread;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//使用这个来标记逻辑停止</span></span><br><span class="line">	<span class="type">bool</span> _b_stop;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//用来存储回调函数，也就是注册进来</span></span><br><span class="line">	std::map&lt;<span class="type">short</span>, FunCallBack&gt; _fun_callbacks;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LogicSystem.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">LogicSystem::~<span class="built_in">LogicSystem</span>()</span><br><span class="line">&#123;</span><br><span class="line">	_b_stop = <span class="literal">true</span>;</span><br><span class="line">	<span class="comment">// 可能还有被挂起的线程</span></span><br><span class="line">	_consume.<span class="built_in">notify_one</span>();</span><br><span class="line"></span><br><span class="line">	_worker_thread.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LogicSystem::PostMsgToQue</span><span class="params">(std::shared_ptr&lt;LogicNode&gt; msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">unique_lk</span><span class="params">(mtx)</span></span>;</span><br><span class="line">	_msg_que.<span class="built_in">push</span>(msg);</span><br><span class="line">	<span class="comment">//由0变为1则发送通知信号,通知被阻塞的线程</span></span><br><span class="line">	<span class="keyword">if</span> (_msg_que.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">		unique_lk.<span class="built_in">unlock</span>();</span><br><span class="line">		_consume.<span class="built_in">notify_one</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LogicSystem::RegisterCallBacks</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	_fun_callbacks[MSG_HELLO_WORD] = std::<span class="built_in">bind</span>(&amp;LogicSystem::HelloWordCallBacks, <span class="keyword">this</span>,</span><br><span class="line">		std::placeholders::_1, std::placeholders::_2, std::placeholders::_3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LogicSystem::HelloWordCallBacks</span><span class="params">(std::shared_ptr&lt;CSession&gt; session, <span class="type">const</span> <span class="type">short</span>&amp; msg_id, <span class="type">const</span> std::string&amp; msg_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Json::Reader reader;</span><br><span class="line">	Json::Value root;</span><br><span class="line">	<span class="comment">//将msg_data 内容系列化到root里</span></span><br><span class="line">	reader.<span class="built_in">parse</span>(msg_data, root);</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;receive msg id is&quot;</span> &lt;&lt; root[<span class="string">&quot;id&quot;</span>].<span class="built_in">asInt</span>() &lt;&lt; <span class="string">&quot;msg data is &quot;</span></span><br><span class="line">		&lt;&lt; root[<span class="string">&quot;data&quot;</span>].<span class="built_in">asString</span>() &lt;&lt; std::endl;</span><br><span class="line">	root[<span class="string">&quot;data&quot;</span>] = <span class="string">&quot;server has receive msg, msg data is &quot;</span> + root[<span class="string">&quot;data&quot;</span>].<span class="built_in">asString</span>();</span><br><span class="line"></span><br><span class="line">	std::string return_str = root.<span class="built_in">toStyledString</span>();</span><br><span class="line">	<span class="comment">//发送信息</span></span><br><span class="line">	session-&gt;<span class="built_in">Send</span>(return_str, root[<span class="string">&quot;id&quot;</span>].<span class="built_in">asInt</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LogicSystem::DealMsg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="comment">//配合条件变量使用，以及加锁</span></span><br><span class="line">		<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">unique_lk</span><span class="params">(mtx)</span></span>;</span><br><span class="line">		<span class="comment">//判断队列为空则用条件变量阻塞等待，并释放锁</span></span><br><span class="line">		<span class="keyword">while</span> (_msg_que.<span class="built_in">empty</span>() &amp;&amp; !_b_stop) &#123;</span><br><span class="line">			_consume.<span class="built_in">wait</span>(unique_lk);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* 也可以这么写</span></span><br><span class="line"><span class="comment">			_consume.wait(unique_lk, [this]()&#123;</span></span><br><span class="line"><span class="comment">				return !_msg_que.empty() &amp;&amp; _b_stop</span></span><br><span class="line"><span class="comment">			&#125;)</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//判断是否为关闭状态，把所有逻辑执行完后则退出循环</span></span><br><span class="line">		<span class="keyword">if</span> (_b_stop) &#123;</span><br><span class="line">			<span class="keyword">while</span> (!_msg_que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">				<span class="keyword">auto</span> msg_node = _msg_que.<span class="built_in">front</span>();</span><br><span class="line">				std::cout &lt;&lt; <span class="string">&quot;recv_msg id  is &quot;</span> &lt;&lt; msg_node-&gt;_recvnode-&gt;_msg_id &lt;&lt; std::endl;</span><br><span class="line">				<span class="keyword">auto</span> call_back_iter = _fun_callbacks.<span class="built_in">find</span>(msg_node-&gt;_recvnode-&gt;_msg_id);</span><br><span class="line">				<span class="keyword">if</span> (call_back_iter == _fun_callbacks.<span class="built_in">end</span>()) &#123;</span><br><span class="line">					_msg_que.<span class="built_in">pop</span>();</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				call_back_iter-&gt;<span class="built_in">second</span>(msg_node-&gt;_session, msg_node-&gt;_recvnode-&gt;_msg_id,</span><br><span class="line">					std::<span class="built_in">string</span>(msg_node-&gt;_recvnode-&gt;_data, msg_node-&gt;_recvnode-&gt;_cur_len));</span><br><span class="line">				_msg_que.<span class="built_in">pop</span>();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//如果没有停服，且说明队列中有数据</span></span><br><span class="line">		<span class="keyword">auto</span> msg_node = _msg_que.<span class="built_in">front</span>();</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;recv_msg id  is &quot;</span> &lt;&lt; msg_node-&gt;_recvnode-&gt;_msg_id &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">auto</span> call_back_iter = _fun_callbacks.<span class="built_in">find</span>(msg_node-&gt;_recvnode-&gt;_msg_id);</span><br><span class="line">		<span class="keyword">if</span> (call_back_iter == _fun_callbacks.<span class="built_in">end</span>()) &#123;</span><br><span class="line">			_msg_que.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//因为second为FunCallBack其参数为三个，所以需要三个函数</span></span><br><span class="line">		call_back_iter-&gt;<span class="built_in">second</span>(msg_node-&gt;_session, msg_node-&gt;_recvnode-&gt;_msg_id,</span><br><span class="line">			std::<span class="built_in">string</span>(msg_node-&gt;_recvnode-&gt;_data, msg_node-&gt;_recvnode-&gt;_cur_len));</span><br><span class="line">		_msg_que.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LogicSystem::<span class="built_in">LogicSystem</span>(): _b_stop(<span class="literal">false</span>) &#123;</span><br><span class="line">	<span class="comment">//用于绑定回调函数</span></span><br><span class="line">	<span class="built_in">RegisterCallBacks</span>();</span><br><span class="line">	<span class="comment">//启动工作线程</span></span><br><span class="line">	_worker_thread = std::<span class="built_in">thread</span>(&amp;LogicSystem::DealMsg, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="服务器优雅退出"><a href="#服务器优雅退出" class="headerlink" title="服务器优雅退出"></a>服务器优雅退出</h2><h3 id="退出方式1：开辟线程，让服务器运行在线程中并接受退出信号退出"><a href="#退出方式1：开辟线程，让服务器运行在线程中并接受退出信号退出" class="headerlink" title="退出方式1：开辟线程，让服务器运行在线程中并接受退出信号退出"></a>退出方式1：开辟线程，让服务器运行在线程中并接受退出信号退出</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CServer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;csignal&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">bool</span> bstop = <span class="literal">false</span>;</span><br><span class="line">std::condition_variable cond_quit;</span><br><span class="line">std::mutex mutex_quit;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">signal_handler</span><span class="params">(<span class="type">int</span> sig)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (sig == SIGINT || sig == SIGTERM) &#123;</span><br><span class="line">		<span class="comment">//访问共享数据接得加锁</span></span><br><span class="line">		<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_quit)</span></span>;</span><br><span class="line">		bstop = <span class="literal">true</span>;</span><br><span class="line">		cond_quit.<span class="built_in">notify_one</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		boost::asio::io_context ioc;</span><br><span class="line">		<span class="function">std::thread <span class="title">network_thread</span><span class="params">([&amp;ioc]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">			CServer server(ioc, <span class="number">8888</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">			ioc.run();</span></span></span><br><span class="line"><span class="params"><span class="function">			&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">signal</span>(SIGINT, signal_handler);</span><br><span class="line">		<span class="built_in">signal</span>(SIGTERM, signal_handler);</span><br><span class="line"></span><br><span class="line">		<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_quit)</span></span>;</span><br><span class="line">		<span class="comment">//阻塞的时候自动解锁</span></span><br><span class="line">		cond_quit.<span class="built_in">wait</span>(lock, []() &#123; &#123;</span><br><span class="line">				<span class="keyword">return</span> bstop;</span><br><span class="line">			&#125;&#125;);</span><br><span class="line"></span><br><span class="line">		ioc.<span class="built_in">stop</span>();</span><br><span class="line">		network_thread.<span class="built_in">join</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">		std::cerr &lt;&lt; <span class="string">&quot;Exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="退出方式2：使用asio底层异步等待函数"><a href="#退出方式2：使用asio底层异步等待函数" class="headerlink" title="退出方式2：使用asio底层异步等待函数"></a>退出方式2：使用asio底层异步等待函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CServer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;csignal&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		boost::asio::io_context ioc;</span><br><span class="line">		boost::<span class="function">asio::signal_set <span class="title">signals</span><span class="params">(ioc, SIGINT, SIGTERM)</span></span>;</span><br><span class="line">		<span class="comment">//参数列表有两个参数表示接收到的信号</span></span><br><span class="line">		signals.<span class="built_in">async_wait</span>([&amp;ioc](<span class="keyword">auto</span>, <span class="keyword">auto</span>) &#123;</span><br><span class="line">			ioc.<span class="built_in">stop</span>();</span><br><span class="line">			&#125;);</span><br><span class="line">		<span class="function">CServer <span class="title">server</span><span class="params">(ioc, <span class="number">8888</span>)</span></span>;</span><br><span class="line">		ioc.<span class="built_in">run</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">		std::cerr &lt;&lt; <span class="string">&quot;Exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li>两种方式都对服务器进行了优雅的退出</li>
</ul>
<h2 id="asio多线程模型IOServicePool"><a href="#asio多线程模型IOServicePool" class="headerlink" title="asio多线程模型IOServicePool"></a>asio多线程模型IOServicePool</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><ul>
<li>前面的设计，我们对asio的使用都是单线程模式，为了提升网络io并发处理的效率，这一次我们设计多线程模式下asio的使用方式。总体来说asio有两个多线程模型，第一个是启动多个线程，每个线程管理一个iocontext。第二种是只启动一个iocontext，被多个线程共享，后面的文章会对比两个模式的区别，<strong>这里先介绍第一种模式，多个线程，每个线程管理独立的iocontext服务</strong>。</li>
</ul>
<h3 id="单线程和多线程对比"><a href="#单线程和多线程对比" class="headerlink" title="单线程和多线程对比"></a>单线程和多线程对比</h3><ul>
<li>之前的单线程模式图如下</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/C++asio网络编程/image-20.png" alt="示例图片" style="zoom:100%;" /></p>
<ul>
<li>我们设计的IOServicePool类型的多线程模型如下：</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/C++asio网络编程/image-21.png" alt="示例图片" style="zoom:100%;" /></p>
<ul>
<li>IOServicePool多线程模式特点<ol>
<li>每一个io_context跑在不同的线程里，所以同一个socket会被注册在同一个io_context里，它的回调函数也会被单独的一个线程回调，那么对于同一个socket，他的回调函数每次触发都是在同一个线程里，就不会有线程安全问题，网络io层面上的并发是线程安全的。</li>
<li>但是对于不同的socket，回调函数的触发可能是同一个线程(两个socket被分配到同一个io_context)，也可能不是同一个线程(两个socket被分配到不同的io_context里)。所以如果两个socket对应的上层逻辑处理，如果有交互或者访问共享区，会存在线程安全问题。比如socket1代表玩家1，socket2代表玩家2，玩家1和玩家2在逻辑层存在交互，比如两个玩家都在做工会任务，他们属于同一个工会，工会积分的增加就是共享区的数据，需要保证线程安全。可以通过加锁或者逻辑队列的方式解决安全问题，我们目前采取了后者。</li>
<li>多线程相比单线程，极大的提高了并发能力，因为单线程仅有一个io_context服务用来监听读写事件，就绪后回调函数在一个线程里串行调用, 如果一个回调函数的调用时间较长肯定会影响后续的函数调用，毕竟是穿行调用。而采用多线程方式，可以在一定程度上减少前一个逻辑调用影响下一个调用的情况，比如两个socket被部署到不同的iocontext上，但是当两个socket部署到同一个iocontext上时仍然存在调用时间影响的问题。不过我们已经通过逻辑队列的方式将网络线程和逻辑线程解耦合了，不会出现前一个调用时间影响下一个回调触发的问题。</li>
</ol>
</li>
</ul>
<h3 id="IOServicePool实现"><a href="#IOServicePool实现" class="headerlink" title="IOServicePool实现"></a>IOServicePool实现</h3><ul>
<li>在使用拷贝构造的时候参数列表的&amp;是必须的，原因：<strong>这不仅仅只是为了减少一次构造成本，更重要是为了避免递归构造</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Pool</span>(<span class="type">const</span> Pool x);</span><br><span class="line"></span><br><span class="line">Pool p1 = p2;</span><br></pre></td></tr></table></figure>
<ul>
<li>以上就会有循环构造的情况，p2传给参数列表的时候又要调用拷贝构造 Pool x = p2, 之后又要进行拷贝构造，如此循环</li>
<li><p>同时一定要判断拷贝的是不是自己这种情况</p>
</li>
<li><p>IOServicePool本质上是一个线程池，基本功能就是根据构造函数传入的数量创建n个线程和iocontext，然后每个线程跑一个iocontext，这样就可以并发处理不同iocontext读写事件了。</p>
</li>
</ul>
<h4 id="IOServicePool的声明"><a href="#IOServicePool的声明" class="headerlink" title="IOServicePool的声明:"></a>IOServicePool的声明:</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CSession.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CServer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CServer</span>(boost::asio::io_context&amp; ioc, <span class="type">unsigned</span> <span class="type">short</span> port);</span><br><span class="line">	~<span class="built_in">CServer</span>();</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ClearSession</span><span class="params">(std::string&amp; uuid)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//处理连接的回调函数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">HandleAccept</span><span class="params">(std::shared_ptr&lt;CSession&gt; session, <span class="type">const</span> boost::system::error_code&amp; error)</span></span>;</span><br><span class="line">	<span class="comment">//开始建立连接的函数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">StartAccept</span><span class="params">()</span></span>;</span><br><span class="line">	boost::asio::ip::tcp::acceptor _acceptor;</span><br><span class="line">	boost::asio::io_context&amp; _ioc;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> _port;</span><br><span class="line">	<span class="comment">//将连接加入map，增加引用计数，防止未执行完逻辑就被析构</span></span><br><span class="line">	std::map&lt;std::string, std::shared_ptr&lt;CSession&gt;&gt; _sessions;</span><br><span class="line">	std::mutex mtx;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol>
<li>_ioServices是一个IOService的vector变量，用来存储初始化的多个IOService。</li>
<li>WorkPtr是boost::asio::io_context::work类型的unique指针。<br>在实际使用中，我们通常会将一些异步操作提交给io_context进行处理，然后该操作会被异步执行，而不会立即返回结果。如果没有其他任务需要执行，那么io_context就会停止工作，导致所有正在进行的异步操作都被取消。这时，我们需要使用boost::asio::io_context::work对象来防止io_context停止工作。</li>
</ol>
<ul>
<li>boost::asio::io_context::work的作用是持有一个指向io_context的引用，并通过创建一个“工作”项来保证io_context不会停止工作，直到work对象被销毁或者调用reset()方法为止。当所有异步操作完成后，程序可以使用work.reset()方法来释放io_context，从而让其正常退出。</li>
</ul>
<ol>
<li>_threads是一个线程vector,管理我们开辟的所有线程。</li>
<li>_nextIOService是一个轮询索引，我们用最简单的轮询算法为每个新创建的连接分配io_context.</li>
<li>因为IOServicePool不允许被copy构造，所以我们将其拷贝构造和拷贝复制函数置为delete</li>
</ol>
<h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;IOServicePool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">IOServicePool::~<span class="built_in">IOServicePool</span>()</span><br><span class="line">&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;destruct IOServicePool&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IOServicePool::Stop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; work : _works) &#123;</span><br><span class="line">		<span class="comment">//因为仅仅执行work.reset并不能让iocontext从run的状态中退出</span></span><br><span class="line">		<span class="comment">//当iocontext已经绑定了读或写的监听事件后，还需要手动stop该服务。</span></span><br><span class="line">		<span class="comment">//停止与work相关的上下文</span></span><br><span class="line">		work-&gt;<span class="built_in">get_io_context</span>().<span class="built_in">stop</span>();</span><br><span class="line">		<span class="comment">//重新设成空</span></span><br><span class="line">		work.<span class="built_in">reset</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; td : _threads) &#123;</span><br><span class="line">		<span class="keyword">if</span> (td.<span class="built_in">joinable</span>()) &#123;</span><br><span class="line">			td.<span class="built_in">join</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">boost::<span class="function">asio::io_context&amp; <span class="title">IOServicePool::GetIOService</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span>&amp; service =  _ioService[_nextIOService++];</span><br><span class="line">	<span class="keyword">if</span> (_nextIOService == _ioService.<span class="built_in">size</span>()) &#123;</span><br><span class="line">		_nextIOService = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> service;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IOServicePool::<span class="built_in">IOServicePool</span>(std::<span class="type">size_t</span> size) : _works(size), _ioService(size),_nextIOService(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//初始化works</span></span><br><span class="line">	<span class="keyword">for</span> (std::<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">		_works[i] = std::<span class="built_in">unique_ptr</span>&lt;Work&gt;(<span class="keyword">new</span> <span class="built_in">Work</span>(_ioService[i]));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历多个ioservice，创建多个线程，每个线程内部启动ioservice</span></span><br><span class="line">	<span class="keyword">for</span> (std::<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; _ioService.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		_threads.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>, i]() &#123;</span><br><span class="line">			_ioService[i].<span class="built_in">run</span>();</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="优雅退出"><a href="#优雅退出" class="headerlink" title="优雅退出"></a>优雅退出</h3><ul>
<li>IOServicePool多线程服务器退出时，需要捕获退出信号如SIGINT,SIGTERM等，将退出信号和一个iocontext绑定，当收到退出信号时，我们将IOServicePool停止，并且停止iocontext即可。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">auto</span> pool = AsioIOServicePool::<span class="built_in">GetInstance</span>();</span><br><span class="line">        boost::asio::io_context  io_context;</span><br><span class="line">        boost::<span class="function">asio::signal_set <span class="title">signals</span><span class="params">(io_context, SIGINT, SIGTERM)</span></span>;</span><br><span class="line">        signals.<span class="built_in">async_wait</span>([&amp;io_context,pool](<span class="keyword">auto</span>, <span class="keyword">auto</span>) &#123;</span><br><span class="line">            io_context.<span class="built_in">stop</span>();</span><br><span class="line">            pool-&gt;<span class="built_in">Stop</span>();</span><br><span class="line">            &#125;);</span><br><span class="line">        <span class="function">CServer <span class="title">s</span><span class="params">(io_context, <span class="number">10086</span>)</span></span>;</span><br><span class="line">        io_context.<span class="built_in">run</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="asio多线程模式IOThreadPool"><a href="#asio多线程模式IOThreadPool" class="headerlink" title="asio多线程模式IOThreadPool"></a>asio多线程模式IOThreadPool</h2><ul>
<li>今天给大家介绍asio多线程模式的第二种，之前我们介绍了IOServicePool的方式，一个IOServicePool开启n个线程和n个iocontext，每个线程内独立运行iocontext, 各个iocontext监听各自绑定的socket是否就绪，如果就绪就在各自线程里触发回调函数。为避免线程安全问题，我们将网络数据封装为逻辑包投递给逻辑系统，逻辑系统有一个单独线程处理，这样将网络IO和逻辑处理解耦合，极大的提高了服务器IO层面的吞吐率。<strong>这一次介绍的另一种多线程模式IOThreadPool，我们只初始化一个iocontext用来监听服务器的读写事件，包括新连接到来的监听也用这个iocontext。只是我们让iocontext.run在多个线程中调用，这样回调函数就会被不同的线程触发，从这个角度看回调函数被并发调用了。</strong></li>
</ul>
<h3 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h3><ul>
<li>线程池模式的多线程模型调度结构图,如下</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/C++asio网络编程/image-22.png" alt="示例图片" style="zoom:100%;" /></p>
<h3 id="先实现IOThreadPool"><a href="#先实现IOThreadPool" class="headerlink" title="先实现IOThreadPool"></a>先实现IOThreadPool</h3><h4 id="IOThreadPool-头文件"><a href="#IOThreadPool-头文件" class="headerlink" title="IOThreadPool 头文件"></a>IOThreadPool 头文件</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Singleton.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IOThreadPool</span> :<span class="keyword">public</span> Singleton&lt;IOThreadPool&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">using</span> Work = boost::asio::io_context::work;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&lt;IOThreadPool&gt;;</span><br><span class="line">	~<span class="built_in">IOThreadPool</span>();</span><br><span class="line">	boost::<span class="function">asio::io_context&amp; <span class="title">GetIOService</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Stop</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">IOThreadPool</span>(<span class="type">int</span> threadNum = std::thread::<span class="built_in">hardware_concurrency</span>());</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="built_in">IOThreadPool</span>(<span class="type">const</span> IOThreadPool&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">	IOThreadPool&amp; <span class="keyword">operator</span> = (<span class="type">const</span> IOThreadPool&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">	</span><br><span class="line">	std::atomic_int thread_nums;</span><br><span class="line"></span><br><span class="line">	boost::asio::io_context _service;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//防止io_context.run的时候退出</span></span><br><span class="line">	std::unique_ptr&lt;Work&gt; _work;</span><br><span class="line"></span><br><span class="line">	std::vector&lt;std::thread&gt; pools;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>IOThreadPool继承了Singleton<IOThreadPool>，实现了一个函数GetIOService获取iocontext</li>
</ul>
<h4 id="IOThreadPool-实现"><a href="#IOThreadPool-实现" class="headerlink" title="IOThreadPool 实现"></a>IOThreadPool 实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;IOThreadPool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">IOThreadPool::~<span class="built_in">IOThreadPool</span>()</span><br><span class="line">&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;destruct IOThreadPool &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">boost::<span class="function">asio::io_context&amp; <span class="title">IOThreadPool::GetIOService</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> 在此处插入 return 语句</span></span><br><span class="line">	<span class="keyword">return</span> _service;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IOThreadPool::Stop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	_work.<span class="built_in">reset</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; td : pools) &#123;</span><br><span class="line">		td.<span class="built_in">join</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IOThreadPool::Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; thread_nums; i++) &#123;</span><br><span class="line">		pools.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>]() &#123;</span><br><span class="line">			_service.<span class="built_in">run</span>();</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IOThreadPool::<span class="built_in">IOThreadPool</span>(<span class="type">int</span> threadNum):</span><br><span class="line">	_work(<span class="keyword">new</span> <span class="built_in">Work</span>(_service))</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (threadNum &lt; <span class="number">1</span>) thread_nums = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> thread_nums = threadNum;</span><br><span class="line">	<span class="built_in">Start</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>构造函数中实现了一个线程池，线程池里每个线程都会运行_service.run函数，_service.run函数内部就是从iocp或者epoll获取就绪描述符和绑定的回调函数，进而调用回调函数，因为回调函数是在不同的线程里调用的，所以会存在不同的线程调用同一个socket的回调函数的情况。</p>
</li>
<li><p>_service.run 内部在Linux环境下调用的是epoll_wait返回所有就绪的描述符列表，在windows上会循环调用GetQueuedCompletionStatus函数返回就绪的描述符，二者原理类似，进而通过描述符找到对应的注册的回调函数，然后调用回调函数。</p>
</li>
</ul>
<h5 id="iocp的流程是这样的"><a href="#iocp的流程是这样的" class="headerlink" title="iocp的流程是这样的"></a>iocp的流程是这样的</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IOCP的使用主要分为以下几步：</span><br><span class="line"><span class="number">1</span> 创建完成端口(iocp)对象</span><br><span class="line"><span class="number">2</span> 创建一个或多个工作线程，在完成端口上执行并处理投递到完成端口上的I/O请求</span><br><span class="line"><span class="number">3</span> Socket关联iocp对象，在Socket上投递网络事件</span><br><span class="line"><span class="number">4</span> 工作线程调用GetQueuedCompletionStatus函数获取完成通知封包，取得事件信息并进行处理</span><br></pre></td></tr></table></figure>
<h5 id="epoll流程是这样的"><a href="#epoll流程是这样的" class="headerlink" title="epoll流程是这样的"></a>epoll流程是这样的</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> 调用epoll_creat在内核中创建一张epoll表</span><br><span class="line"><span class="number">2</span> 开辟一片包含n个epoll_event大小的连续空间</span><br><span class="line"><span class="number">3</span> 将要监听的socket注册到epoll表里</span><br><span class="line"><span class="number">4</span> 调用epoll_wait，传入之前我们开辟的连续空间，epoll_wait返回就绪的epoll_event列表，epoll会将就绪的socket信息写入我们之前开辟的连续空间</span><br></pre></td></tr></table></figure>
<h3 id="隐患-1"><a href="#隐患-1" class="headerlink" title="隐患"></a>隐患</h3><ul>
<li>IOThreadPool模式有一个隐患，同一个socket的就绪后，触发的回调函数可能在不同的线程里，比如第一次是在线程1，第二次是在线程3，如果这两次触发间隔时间不大，那么很可能出现不同线程并发访问数据的情况，比如在处理读事件时，第一次回调触发后我们从socket的接收缓冲区读数据出来，第二次回调触发,还是从socket的接收缓冲区读数据，就会造成两个线程同时从socket中读数据的情况，会造成数据混乱。</li>
</ul>
<h3 id="利用strand改进"><a href="#利用strand改进" class="headerlink" title="利用strand改进"></a>利用strand改进</h3><ul>
<li>对于多线程触发回调函数的情况，我们可以利用asio提供的串行类strand封装一下，这样就可以被串行调用了，其基本原理就是在线程各自调用函数时取消了直接调用的方式，而是利用一个strand类型的对象将要调用的函数投递到strand管理的队列中，再由一个统一的线程调用回调函数，调用是串行的，解决了线程并发带来的安全问题。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="image-23.png" alt="alt text"></p>
<ul>
<li><p>图中当socket就绪后并不是由多个线程调用每个socket注册的回调函数，而是将回调函数投递给strand管理的队列，再由strand统一调度派发。</p>
</li>
<li><p>为了让回调函数被派发到strand的队列，我们只需要在注册回调函数时加一层strand的包装即可。</p>
</li>
<li><p>在CSession类中添加一个成员变量</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strand&lt;io_context::executor_type&gt; _strand;</span><br></pre></td></tr></table></figure>
<ul>
<li>CSession构造函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CSession::<span class="built_in">CSession</span>(boost::asio::io_context&amp; io_context, CServer* server):</span><br><span class="line">    _socket(io_context), _server(server), _b_close(<span class="literal">false</span>),</span><br><span class="line">    _b_head_parse(<span class="literal">false</span>), _strand(io_context.<span class="built_in">get_executor</span>())&#123;</span><br><span class="line">    boost::uuids::uuid  a_uuid = boost::uuids::<span class="built_in">random_generator</span>()();</span><br><span class="line">    _uuid = boost::uuids::<span class="built_in">to_string</span>(a_uuid);</span><br><span class="line">    _recv_head_node = <span class="built_in">make_shared</span>&lt;MsgNode&gt;(HEAD_TOTAL_LEN);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>可以看到_strand的初始化是放在初始化列表里，利用io_context.get_executor()返回的执行器构造strand。</p>
</li>
<li><p>因为在asio中无论iocontext还是strand，底层都是通过executor调度的，我们将他理解为调度器就可以了，如果多个iocontext和strand的调度器是一个，那他们的消息派发统一由这个调度器执行。</p>
</li>
<li><p>我们利用iocontext的调度器构造strand，这样他们统一由一个调度器管理。在绑定回调函数的调度器时，我们选择strand绑定即可。</p>
</li>
<li><p>比如我们在Start函数里添加绑定 ，将回调函数的调用者绑定为_strand</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::Start</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ::<span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);</span><br><span class="line">    _socket.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, MAX_LENGTH),</span><br><span class="line">        boost::asio::<span class="built_in">bind_executor</span>(_strand, std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>,</span><br><span class="line">            std::placeholders::_1, std::placeholders::_2, <span class="built_in">SharedSelf</span>())));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>同样的道理，在所有收发的地方，都将调度器绑定为_strand， 比如发送部分我们需要修改为如下</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>&amp; msgnode = _send_que.<span class="built_in">front</span>();</span><br><span class="line">    boost::asio::<span class="built_in">async_write</span>(_socket, boost::asio::<span class="built_in">buffer</span>(msgnode-&gt;_data, msgnode-&gt;_total_len), </span><br><span class="line">    boost::asio::<span class="built_in">bind_executor</span>(_strand, std::<span class="built_in">bind</span>(&amp;CSession::HandleWrite, <span class="keyword">this</span>, std::placeholders::_1, <span class="built_in">SharedSelf</span>()))</span><br><span class="line">        );</span><br></pre></td></tr></table></figure>
<ul>
<li>修改main函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CServer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;csignal&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;IOThreadPool.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">bool</span> bstop = <span class="literal">false</span>;</span><br><span class="line">std::condition_variable cond_quit;</span><br><span class="line">std::mutex mtx;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">auto</span> pool = IOThreadPool::<span class="built_in">GetInstance</span>();</span><br><span class="line">		boost::asio::io_context ioc;</span><br><span class="line">		boost::<span class="function">asio::signal_set <span class="title">signals</span><span class="params">(ioc, SIGINT, SIGTERM)</span></span>;</span><br><span class="line">		<span class="comment">//参数列表有两个参数表示接收到的信号,他的注册函数会在asio的独立线程里</span></span><br><span class="line">        <span class="comment">//所以共享变量需要加锁</span></span><br><span class="line">		signals.<span class="built_in">async_wait</span>([&amp;ioc](<span class="keyword">auto</span>, <span class="keyword">auto</span>) &#123;</span><br><span class="line">			ioc.<span class="built_in">stop</span>();</span><br><span class="line">			pool-&gt;<span class="built_in">stop</span>();</span><br><span class="line">			<span class="comment">//加锁与条件变量是因为在主线程里并没有调用</span></span><br><span class="line">			<span class="comment">//io_context.run()函数，而是在线程池里调用</span></span><br><span class="line">			<span class="comment">//线程池相当于主线程的子线程</span></span><br><span class="line">			std::unique_lock&lt;std::mutex&gt; <span class="built_in">lock</span>(mtx);</span><br><span class="line">			bstop = <span class="literal">true</span>;</span><br><span class="line">			cond_quit.<span class="built_in">notify_one</span>();</span><br><span class="line">			&#125;);</span><br><span class="line">		<span class="comment">//修改这里</span></span><br><span class="line">		<span class="function">CServer <span class="title">server</span><span class="params">(pool-&gt;GetIOService(), <span class="number">8888</span>)</span></span>;</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">			<span class="keyword">while</span> (!bstop) &#123;</span><br><span class="line">                <span class="comment">//线程挂起，锁释放</span></span><br><span class="line">				cond_quit.<span class="built_in">wait</span>(lock);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">		std::cerr &lt;&lt; <span class="string">&quot;Exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CSession代码"><a href="#CSession代码" class="headerlink" title="CSession代码"></a>CSession代码</h3><ul>
<li>改动了将回调函数绑定到_strand的处理器里上</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/uuid/uuid_io.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/uuid/uuid_generators.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MsgNode.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;const.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//避免循环依赖问题使用前置声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CServer</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LogicSystem</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CSession</span>: <span class="keyword">public</span> std::enable_shared_from_this&lt;CSession&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CSession</span>(boost::asio::io_context&amp; ioc, CServer* server);</span><br><span class="line">	~<span class="built_in">CSession</span>();</span><br><span class="line">	boost::asio::ip::<span class="function">tcp::socket&amp; <span class="title">GetSocket</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">std::string&amp; <span class="title">GetUuid</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Send</span><span class="params">(<span class="type">char</span>* msg, <span class="type">short</span> max_len, <span class="type">short</span> msgid)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Send</span><span class="params">(std::string msg, <span class="type">short</span> msgid)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Close</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">std::shared_ptr&lt;CSession&gt; <span class="title">SharedSelf</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">HandleRead</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, <span class="type">size_t</span> bytes_transferred, std::shared_ptr&lt;CSession&gt; shared_self)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">HandleWrite</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, std::shared_ptr&lt;CSession&gt; shared_self)</span></span>;</span><br><span class="line">	boost::asio::ip::tcp::socket _socket;</span><br><span class="line">	std::string _uuid;</span><br><span class="line">	<span class="type">char</span> _data[MAX_LENGTH];</span><br><span class="line">	CServer* _server;</span><br><span class="line">	<span class="comment">//标志是否关闭</span></span><br><span class="line">	<span class="type">bool</span> _b_close;</span><br><span class="line">	<span class="comment">//用于保证发送信息的时序性</span></span><br><span class="line">	std::queue&lt;std::shared_ptr&lt;SendNode&gt;&gt; _send_que;</span><br><span class="line">	<span class="comment">//对队列加锁</span></span><br><span class="line">	std::mutex _send_lock;</span><br><span class="line">	<span class="comment">// 收到的消息结构</span></span><br><span class="line">	std::shared_ptr&lt;RecvNode&gt; _recv_msg_node;</span><br><span class="line">	<span class="comment">//判断头部节点是否构造完成</span></span><br><span class="line">	<span class="type">bool</span> _b_head_parse;</span><br><span class="line">	<span class="comment">//收到的头部结构,包括消息id与消息体长度</span></span><br><span class="line">	std::shared_ptr&lt;MsgNode&gt; _recv_head_node;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//并行执行事件改为串行执行，使用strand</span></span><br><span class="line">	<span class="comment">//每个srand有个执行类型，让他为上下文的执行类型</span></span><br><span class="line">	<span class="comment">//类似我们封装的logic system</span></span><br><span class="line">	boost::asio::strand&lt;boost::asio::io_context::executor_type&gt; _strand;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LogicNode</span> &#123;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">LogicSystem</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">LogicNode</span>(std::shared_ptr&lt;CSession&gt; session, std::shared_ptr&lt;RecvNode&gt; recvnode);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::shared_ptr&lt;CSession&gt; _session;</span><br><span class="line">	std::shared_ptr&lt;RecvNode&gt; _recvnode;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h3><ul>
<li><p>为了比较两种服务器多线程模式的性能，我们还是利用之前测试的客户端，客户端每隔10ms建立一个连接，总共建立100个连接，每个连接收发500次，总计10万个数据包，测试一下性能。</p>
</li>
<li><p>客户端测试代码如下</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;json/json.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;json/value.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;json/reader.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::asio::ip;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_LENGTH = <span class="number">1024</span> * <span class="number">2</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> HEAD_LENGTH = <span class="number">2</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> HEAD_TOTAL = <span class="number">4</span>;</span><br><span class="line">std::vector&lt;thread&gt; vec_threads;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> start = std::chrono::high_resolution_clock::<span class="built_in">now</span>(); <span class="comment">// 获取开始时间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        vec_threads.<span class="built_in">emplace_back</span>([]() &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//创建上下文服务</span></span><br><span class="line">                boost::asio::io_context   ioc;</span><br><span class="line">                <span class="comment">//构造endpoint</span></span><br><span class="line">                tcp::endpoint  <span class="built_in">remote_ep</span>(address::<span class="built_in">from_string</span>(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="number">10086</span>);</span><br><span class="line">                tcp::socket  <span class="built_in">sock</span>(ioc);</span><br><span class="line">                boost::system::error_code   error = boost::asio::error::host_not_found; ;</span><br><span class="line">                sock.<span class="built_in">connect</span>(remote_ep, error);</span><br><span class="line">                <span class="keyword">if</span> (error) &#123;</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;connect failed, code is &quot;</span> &lt;&lt; error.<span class="built_in">value</span>() &lt;&lt; <span class="string">&quot; error msg is &quot;</span> &lt;&lt; error.<span class="built_in">message</span>();</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (i &lt; <span class="number">500</span>) &#123;</span><br><span class="line">                    Json::Value root;</span><br><span class="line">                    root[<span class="string">&quot;id&quot;</span>] = <span class="number">1001</span>;</span><br><span class="line">                    root[<span class="string">&quot;data&quot;</span>] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">                    std::string request = root.<span class="built_in">toStyledString</span>();</span><br><span class="line">                    <span class="type">size_t</span> request_length = request.<span class="built_in">length</span>();</span><br><span class="line">                    <span class="type">char</span> send_data[MAX_LENGTH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">                    <span class="type">int</span> msgid = <span class="number">1001</span>;</span><br><span class="line">                    <span class="type">int</span> msgid_host = boost::asio::detail::socket_ops::<span class="built_in">host_to_network_short</span>(msgid);</span><br><span class="line">                    <span class="built_in">memcpy</span>(send_data, &amp;msgid_host, <span class="number">2</span>);</span><br><span class="line">                    <span class="comment">//转为网络字节序</span></span><br><span class="line">                    <span class="type">int</span> request_host_length = boost::asio::detail::socket_ops::<span class="built_in">host_to_network_short</span>(request_length);</span><br><span class="line">                    <span class="built_in">memcpy</span>(send_data + <span class="number">2</span>, &amp;request_host_length, <span class="number">2</span>);</span><br><span class="line">                    <span class="built_in">memcpy</span>(send_data + <span class="number">4</span>, request.<span class="built_in">c_str</span>(), request_length);</span><br><span class="line">                    boost::asio::<span class="built_in">write</span>(sock, boost::asio::<span class="built_in">buffer</span>(send_data, request_length + <span class="number">4</span>));</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;begin to receive...&quot;</span> &lt;&lt; endl;</span><br><span class="line">                    <span class="type">char</span> reply_head[HEAD_TOTAL];</span><br><span class="line">                    <span class="type">size_t</span> reply_length = boost::asio::<span class="built_in">read</span>(sock, boost::asio::<span class="built_in">buffer</span>(reply_head, HEAD_TOTAL));</span><br><span class="line">                    msgid = <span class="number">0</span>;</span><br><span class="line">                    <span class="built_in">memcpy</span>(&amp;msgid, reply_head, HEAD_LENGTH);</span><br><span class="line">                    <span class="type">short</span> msglen = <span class="number">0</span>;</span><br><span class="line">                    <span class="built_in">memcpy</span>(&amp;msglen, reply_head + <span class="number">2</span>, HEAD_LENGTH);</span><br><span class="line">                    <span class="comment">//转为本地字节序</span></span><br><span class="line">                    msglen = boost::asio::detail::socket_ops::<span class="built_in">network_to_host_short</span>(msglen);</span><br><span class="line">                    msgid = boost::asio::detail::socket_ops::<span class="built_in">network_to_host_short</span>(msgid);</span><br><span class="line">                    <span class="type">char</span> msg[MAX_LENGTH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">                    <span class="type">size_t</span>  msg_length = boost::asio::<span class="built_in">read</span>(sock, boost::asio::<span class="built_in">buffer</span>(msg, msglen));</span><br><span class="line">                    Json::Reader reader;</span><br><span class="line">                    reader.<span class="built_in">parse</span>(std::<span class="built_in">string</span>(msg, msg_length), root);</span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot;msg id is &quot;</span> &lt;&lt; root[<span class="string">&quot;id&quot;</span>] &lt;&lt; <span class="string">&quot; msg is &quot;</span> &lt;&lt; root[<span class="string">&quot;data&quot;</span>] &lt;&lt; endl;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">                std::cerr &lt;&lt; <span class="string">&quot;Exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : vec_threads) &#123;</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行一些需要计时的操作</span></span><br><span class="line">    <span class="keyword">auto</span> end = std::chrono::high_resolution_clock::<span class="built_in">now</span>(); <span class="comment">// 获取结束时间</span></span><br><span class="line">    <span class="keyword">auto</span> duration = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::seconds&gt;(end - start); <span class="comment">// 计算时间差，单位为微秒</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Time spent: &quot;</span> &lt;&lt; duration.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; seconds.&quot;</span> &lt;&lt; std::endl; <span class="comment">// 输</span></span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>测试得出今天实现的多线程模式较之前的IOServicePool版本慢了7秒</li>
</ul>
<h3 id="取舍"><a href="#取舍" class="headerlink" title="取舍"></a>取舍</h3><ul>
<li>实际的生产和开发中，我们尽可能利用C++特性，使用多核的优势，将iocontext分布在不同的线程中效率更可取一点（也就是第一种），但也要防止线程过多导致cpu切换带来的时间片开销，所以尽量让开辟的线程数小于或等于cpu的核数，从而利用多核优势。</li>
</ul>
<h2 id="boost-asio协程实现并发服务器"><a href="#boost-asio协程实现并发服务器" class="headerlink" title="boost::asio协程实现并发服务器"></a>boost::asio协程实现并发服务器</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><ul>
<li>之前介绍了asio服务器并发编程的几种模型，包括单线程，多线程IOServicePool，多线程IOThreadPool等，今天带着大家利用asio协程实现并发服务器。利用协程实现并发程序有两个好处<ol>
<li>将回调函数改写为顺序调用，提高开发效率。</li>
<li>协程调度比线程调度更轻量化，因为协程是运行在用户空间的，线程切换需要在用户空间和内核空间切换。</li>
</ol>
</li>
</ul>
<h3 id="协程案例"><a href="#协程案例" class="headerlink" title="协程案例"></a>协程案例</h3><ul>
<li>asio官网提供了一个协程并发编程的案例，我们列举一下</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio/co_spawn.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio/detached.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio/io_context.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio/ip/tcp.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio/signal_set.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio/write.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//允许异步等待</span></span><br><span class="line"><span class="keyword">using</span> boost::asio::awaitable;</span><br><span class="line"><span class="comment">//启动协程需要</span></span><br><span class="line"><span class="keyword">using</span> boost::asio::co_spawn;</span><br><span class="line"><span class="comment">//启动协程的方式，让协程独立启动</span></span><br><span class="line"><span class="keyword">using</span> boost::asio::detached;</span><br><span class="line"><span class="comment">//让协程可以等待</span></span><br><span class="line"><span class="keyword">using</span> boost::asio::use_awaitable;</span><br><span class="line"><span class="comment">//返回协程当前执行的环境，将此可以作为调度器</span></span><br><span class="line"><span class="keyword">namespace</span> this_coro = boost::asio::this_coro;</span><br><span class="line"></span><br><span class="line"><span class="function">awaitable&lt;<span class="type">void</span>&gt; <span class="title">echo</span><span class="params">(boost::asio::ip::tcp::socket sock)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="type">char</span> data[<span class="number">1024</span>];</span><br><span class="line">		<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">			<span class="type">size_t</span> n = <span class="keyword">co_await</span> sock.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(data), use_awaitable);</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;receive message is &quot;</span> &lt;&lt; std::<span class="built_in">string</span>(data, n) &lt;&lt; std::endl;</span><br><span class="line">			<span class="keyword">co_await</span> boost::asio::<span class="built_in">async_write</span>(sock, boost::asio::<span class="built_in">buffer</span>(data, n), use_awaitable);</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;send message: &quot;</span> &lt;&lt; std::<span class="built_in">string</span>(data, n) &lt;&lt; <span class="string">&quot;successed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;echo Exception is &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为了让协程能够使用，得需要加入关键字awaitable</span></span><br><span class="line"><span class="function">awaitable&lt;<span class="type">void</span>&gt; <span class="title">listener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//co_await 是异步查询来获得调度器，如果没查到就挂起</span></span><br><span class="line">	<span class="comment">//执行主线程中的别的协程，知道能捕获到执行器再切回来</span></span><br><span class="line">	<span class="keyword">auto</span> executor = <span class="keyword">co_await</span> this_coro::executor;</span><br><span class="line">	boost::asio::ip::<span class="function">tcp::endpoint <span class="title">ep</span><span class="params">(boost::asio::ip::tcp::v4(), <span class="number">8888</span>)</span></span>;</span><br><span class="line">	boost::asio::ip::<span class="function">tcp::acceptor <span class="title">acceptor</span><span class="params">(executor, ep)</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;等待客户端的连接&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="comment">//加入co_await关键字就不需要传递回调函数了，挂起回释放协程使用权</span></span><br><span class="line">		<span class="comment">//use_awaitable让这个函数能够阻塞等待</span></span><br><span class="line">		boost::asio::ip::tcp::socket sock = <span class="keyword">co_await</span> acceptor.<span class="built_in">async_accept</span>(use_awaitable);</span><br><span class="line">		<span class="built_in">co_spawn</span>(executor, <span class="built_in">echo</span>(std::<span class="built_in">move</span>(sock)), detached);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">//参数是用来指定并发的级别，如果是1就表示只开一个工作线程</span></span><br><span class="line">		<span class="comment">//如果是0就是默认，如果大于os的实际，则根据os的实际来运行</span></span><br><span class="line">		boost::<span class="function">asio::io_context <span class="title">ioc</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">		boost::<span class="function">asio::signal_set <span class="title">signals</span><span class="params">(ioc, SIGINT, SIGTERM)</span></span>;</span><br><span class="line">		signals.<span class="built_in">async_wait</span>([&amp;](<span class="keyword">auto</span>, <span class="keyword">auto</span>) &#123;</span><br><span class="line">			ioc.<span class="built_in">stop</span>();</span><br><span class="line">			&#125;);</span><br><span class="line">		<span class="comment">//协程创建函数，第一个参数为上下文，第二个参数为一个协程函数</span></span><br><span class="line">		<span class="comment">//第三个参数为执行策略，策略表示协程将在执行完成后自动销毁，而不会等待其父协程的完成</span></span><br><span class="line">		<span class="built_in">co_spawn</span>(ioc, <span class="built_in">listener</span>(), detached);</span><br><span class="line">		ioc.<span class="built_in">run</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Exception is&quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>我们用awaitable<void>声明了一个函数，那么这个函数就变为可等待的函数了，比如listener被添加awaitable<void>之后，就可以被协程调用和等待了。</li>
<li>co_spawn表示启动一个协程，参数分别为调度器，执行的函数，以及启动方式, 比如我们启动了一个协程，deatched表示将协程对象分离出来，这种启动方式可以启动多个协程，他们都是独立的，如何调度取决于调度器，在用户的感知上更像是线程调度的模式，类似于并发运行，其实底层都是串行的。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">co_spawn</span>(io_context, <span class="built_in">listener</span>(), detached);</span><br></pre></td></tr></table></figure>
<p>我们启动了一个协程，执行listener中的逻辑，listener内部co_await 等待 acceptor接收连接，如果没有连接到来则挂起协程。执行之后的io_context.run()逻辑。所以协程实际上是在一个线程中串行调度的，只是感知上像是并发而已。</p>
<ol>
<li>当acceptor接收到连接后，继续调用co_spawn启动一个协程，用来执行echo逻辑。echo逻辑里也是通过co_wait的方式接收和发送数据的，如果对端不发数据，执行echo的协程就会挂起，另一个协程启动，继续接收新的连接。当没有连接到来，接收新连接的协程挂起，如果所有协程都挂起，则等待新的就绪事件(对端发数据，或者新连接)到来唤醒。</li>
</ol>
<ul>
<li><strong>使用协程的时候有没有 co_await的区别</strong><ol>
<li>不使用 co_await：<br>如果不使用 co_await，acceptor.async_accept 将会返回一个可等待对象，但不会在此处等待该对象的完成。相反，它将立即返回，继续执行后续的代码，而不管是否有连接请求到来。这可能导致后续的代码在没有获得有效的 tcp::socket 对象的情况下进行执行，从而产生错误或未定义的行为。<ol>
<li>使用 co_await：<br>当使用 co_await 时，协程会在 acceptor.async_accept 返回的可等待对象完成之前挂起，并暂停当前协程的执行。这意味着协程会等待连接请求到来，并在收到请求后继续执行。在这种情况下，async_accept 返回的 tcp::socket 对象将被分配给变量 sock，以便后续与客户端进行通信。</li>
</ol>
</li>
</ol>
</li>
</ul>
<h3 id="完整并发服务器"><a href="#完整并发服务器" class="headerlink" title="完整并发服务器"></a>完整并发服务器</h3><ul>
<li>由于服务器发送数据或者请求比较频繁，所以考虑设计为不用协程而用线程的方式，这样相比协程可以增加效率，而且发送可能会在其他线程</li>
<li>我们可以利用协程改进服务器编码流程，用一个iocontext管理绑定acceptor用来接收新的连接，再用一个iocontext或以IOServicePool的方式管理连接的收发操作，在每个连接的接收数据时改为启动一个协程，通过顺序的方式读取收到的数据</li>
</ul>
<h4 id="AsiIOServicePool"><a href="#AsiIOServicePool" class="headerlink" title="AsiIOServicePool"></a>AsiIOServicePool</h4><h5 id="AsioIOServicePool头文件"><a href="#AsioIOServicePool头文件" class="headerlink" title="AsioIOServicePool头文件"></a>AsioIOServicePool头文件</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AsioIOServicePool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">using</span> IOService = boost::asio::io_context;</span><br><span class="line">	<span class="keyword">using</span> Work = boost::asio::io_context::work;</span><br><span class="line">	<span class="keyword">using</span> WorkPtr = std::unique_ptr&lt;Work&gt;;</span><br><span class="line">	~<span class="built_in">AsioIOServicePool</span>();</span><br><span class="line">	<span class="built_in">AsioIOServicePool</span>(<span class="type">const</span> AsioIOServicePool&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">	AsioIOServicePool&amp; <span class="keyword">operator</span>=(<span class="type">const</span> AsioIOServicePool&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">	<span class="function"><span class="type">static</span> AsioIOServicePool&amp; <span class="title">GetInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="type">static</span> AsioIOServicePool ins;</span><br><span class="line">		<span class="keyword">return</span> ins;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Stop</span><span class="params">()</span></span>;</span><br><span class="line">	boost::<span class="function">asio::io_context&amp; <span class="title">GetIOService</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">AsioIOServicePool</span>(<span class="type">const</span> <span class="type">int</span> nums = std::thread::<span class="built_in">hardware_concurrency</span>());</span><br><span class="line">	std::vector&lt;IOService&gt; _ioService;</span><br><span class="line">	std::vector&lt;WorkPtr&gt; _works;</span><br><span class="line">	std::vector&lt;std::thread&gt; _threads;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//因为轮询，所以要记录下一个io_context的下标是多少</span></span><br><span class="line">	std::<span class="type">size_t</span> _nextIOService;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="AsioIOServicePool实现"><a href="#AsioIOServicePool实现" class="headerlink" title="AsioIOServicePool实现"></a>AsioIOServicePool实现</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AsioIOServicePool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">AsioIOServicePool::~<span class="built_in">AsioIOServicePool</span>()</span><br><span class="line">&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;AsioIOService Pool destruct &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AsioIOServicePool::Stop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//将work置空，会让ioService自动析构</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; work:_works) &#123;</span><br><span class="line">		work.<span class="built_in">reset</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//等待线程完成任务</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; td : _threads) &#123;</span><br><span class="line">		<span class="keyword">if</span> (td.<span class="built_in">joinable</span>()) &#123;</span><br><span class="line">			td.<span class="built_in">join</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">boost::<span class="function">asio::io_context&amp; <span class="title">AsioIOServicePool::GetIOService</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span>&amp; service = _ioService[_nextIOService++];</span><br><span class="line">	<span class="keyword">if</span> (_nextIOService == _ioService.<span class="built_in">size</span>()) &#123;</span><br><span class="line">		_nextIOService = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> service;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AsioIOServicePool::<span class="built_in">AsioIOServicePool</span>(<span class="type">const</span> <span class="type">int</span> nums):_ioService(nums),</span><br><span class="line">_works(nums),_nextIOService(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//初始化works指针</span></span><br><span class="line">	<span class="keyword">for</span> (std::<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; nums; i++) &#123;</span><br><span class="line">		<span class="comment">//右边为右值</span></span><br><span class="line">		_works[i] = std::<span class="built_in">unique_ptr</span>&lt;Work&gt;(<span class="keyword">new</span> <span class="built_in">Work</span>(_ioService[i]));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//遍历多个ioService 创建多个线程，每个线程内部启动一个ioService</span></span><br><span class="line">	<span class="keyword">for</span> (std::<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; nums; i++) &#123;</span><br><span class="line">		_threads.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>, i]() &#123;</span><br><span class="line">			_ioService[i].<span class="built_in">run</span>();</span><br><span class="line">			&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="cosnt-h"><a href="#cosnt-h" class="headerlink" title="cosnt.h"></a>cosnt.h</h4><ul>
<li>专门用来存放常量</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MAX_LENGTH = <span class="number">1024</span> * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> HEAD_TOTAL_LEN = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> HEAD_ID_LEN = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> HEAD_DATA_LEN = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MAX_RECVQUE = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MAX_SENDQUE = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">MSG_IDS</span> &#123;</span><br><span class="line">	MSG_HELLO_WORLD = <span class="number">1001</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="CServer-1"><a href="#CServer-1" class="headerlink" title="CServer"></a>CServer</h4><h5 id="CServer头文件-1"><a href="#CServer头文件-1" class="headerlink" title="CServer头文件"></a>CServer头文件</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CSession.h&quot;</span></span></span><br><span class="line"><span class="comment">//负责监听客户端的链接，处理链接</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CServer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CServer</span>(boost::asio::io_context&amp; io_context, <span class="type">short</span> port);</span><br><span class="line">	~<span class="built_in">CServer</span>();</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ClearSession</span><span class="params">(std::string&amp; uuid)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">HandleAccpet</span><span class="params">(std::shared_ptr&lt;CSession&gt; session, <span class="type">const</span> boost::system::error_code&amp; error)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">StartAccept</span><span class="params">()</span></span>;</span><br><span class="line">	boost::asio::io_context&amp; _io_context;</span><br><span class="line">	std::mutex mtx;</span><br><span class="line">	<span class="type">short</span> _port;</span><br><span class="line">	boost::asio::ip::tcp::acceptor _acceptor;</span><br><span class="line">	std::map&lt;std::string, std::shared_ptr&lt;CSession&gt;&gt; _sessions;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="CServer实现-1"><a href="#CServer实现-1" class="headerlink" title="CServer实现"></a>CServer实现</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CServer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AsioIOServicePool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">CServer::<span class="built_in">CServer</span>(boost::asio::io_context&amp; io_context, <span class="type">short</span> port)</span><br><span class="line">	:_io_context(io_context),_port(port),_acceptor(io_context, boost::asio::ip::tcp::<span class="built_in">endpoint</span>(boost::asio::ip::tcp::<span class="built_in">v4</span>(), port))</span><br><span class="line">&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Server start success, on port: &quot;</span> &lt;&lt; _port &lt;&lt; std::endl;</span><br><span class="line">	<span class="built_in">StartAccept</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CServer::~<span class="built_in">CServer</span>()</span><br><span class="line">&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Server destruct listen on port : &quot;</span> &lt;&lt; _port &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CServer::ClearSession</span><span class="params">(std::string&amp; uuid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//加锁</span></span><br><span class="line">	<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">	<span class="keyword">if</span> (_sessions.<span class="built_in">find</span>(uuid) != _sessions.<span class="built_in">end</span>()) _sessions.<span class="built_in">erase</span>(uuid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CServer::HandleAccpet</span><span class="params">(std::shared_ptr&lt;CSession&gt; session, <span class="type">const</span> boost::system::error_code&amp; error)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!error) &#123;</span><br><span class="line">		<span class="comment">//启动服务</span></span><br><span class="line">		session-&gt;<span class="built_in">Start</span>();</span><br><span class="line">		<span class="comment">//加锁</span></span><br><span class="line">		<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">		_sessions.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(session-&gt;<span class="built_in">GetUuid</span>(), session));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;session accept failed, error is &quot;</span> &lt;&lt; error.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">StartAccept</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CServer::StartAccept</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//取得上下文</span></span><br><span class="line">	<span class="keyword">auto</span>&amp; io_context = AsioIOServicePool::<span class="built_in">GetInstance</span>().<span class="built_in">GetIOService</span>();</span><br><span class="line">	<span class="comment">//构造一个CSession的智能指针,也就是创建连接</span></span><br><span class="line">	std::shared_ptr&lt;CSession&gt; new_session = std::<span class="built_in">make_shared</span>&lt;CSession&gt;(_io_context, <span class="keyword">this</span>);</span><br><span class="line">	<span class="comment">//进行异步连接</span></span><br><span class="line">	_acceptor.<span class="built_in">async_accept</span>(new_session-&gt;<span class="built_in">GetSocket</span>(),</span><br><span class="line">		std::<span class="built_in">bind</span>(&amp;CServer::HandleAccpet, <span class="keyword">this</span>, new_session, std::placeholders::_1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="CSession-1"><a href="#CSession-1" class="headerlink" title="CSession"></a>CSession</h4><h5 id="CSession-h"><a href="#CSession-h" class="headerlink" title="CSession.h"></a>CSession.h</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio/co_spawn.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio/detached.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;const.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MsgNode.h&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CServer</span>;</span><br><span class="line"><span class="comment">//用来处理客户端与服务器之间通s信的作用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CSession</span>:<span class="keyword">public</span> std::enable_shared_from_this&lt;CSession&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CSession</span>(boost::asio::io_context&amp; io_context, CServer* server);</span><br><span class="line">	~<span class="built_in">CSession</span>();</span><br><span class="line">	boost::asio::ip::<span class="function">tcp::socket&amp; <span class="title">GetSocket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _socket;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Close</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">std::string&amp; <span class="title">GetUuid</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Send</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg, <span class="type">short</span> max_length, <span class="type">short</span> msg_id)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Send</span><span class="params">(std::string msg, <span class="type">short</span> msg_id)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">HandleWrite</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, std::shared_ptr&lt;CSession&gt; shared_self)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	boost::asio::io_context&amp; _io_context;</span><br><span class="line">	CServer* _server;</span><br><span class="line">	boost::asio::ip::tcp::socket _socket;</span><br><span class="line">	std::string _uuid;</span><br><span class="line">	<span class="type">bool</span> _b_close;</span><br><span class="line">	std::mutex mtx;</span><br><span class="line">	std::queue&lt;std::shared_ptr&lt;SendNode&gt;&gt; _send_que;</span><br><span class="line">	std::shared_ptr&lt;RecvNode&gt; _recv_msg_node;</span><br><span class="line">	std::shared_ptr&lt;MsgNode&gt; _recv_head_node;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LogicNode</span> &#123;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">LogicSystem</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">LogicNode</span>(std::shared_ptr&lt;CSession&gt; session, std::shared_ptr&lt;RecvNode&gt; recvnode) :</span><br><span class="line">		_session(session), _recvnode(recvnode)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::shared_ptr&lt;CSession&gt; _session;</span><br><span class="line">	std::shared_ptr&lt;RecvNode&gt; _recvnode;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="CSession实现"><a href="#CSession实现" class="headerlink" title="CSession实现"></a>CSession实现</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CSession.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CServer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/uuid/uuid_io.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/uuid/uuid_generators.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LogicSystem.h&quot;</span></span></span><br><span class="line">CSession::<span class="built_in">CSession</span>(boost::asio::io_context&amp; io_context, CServer* server):</span><br><span class="line">_io_context(io_context), _server(server),_socket(io_context),_b_close(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">	boost::uuids::uuid a_uuid = boost::uuids::<span class="built_in">random_generator</span>()();</span><br><span class="line">	_uuid = boost::uuids::<span class="built_in">to_string</span>(a_uuid);</span><br><span class="line">	<span class="comment">//初始化头部节点</span></span><br><span class="line">	_recv_head_node = std::<span class="built_in">make_shared</span>&lt;MsgNode&gt;(HEAD_TOTAL_LEN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CSession::~<span class="built_in">CSession</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;~CSession destruct&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="built_in">Close</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;exception is &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//为了防止智能指针被意外的释放</span></span><br><span class="line">	<span class="keyword">auto</span> shared_this = <span class="built_in">shared_from_this</span>();</span><br><span class="line">	<span class="comment">//开启协程</span></span><br><span class="line">	boost::asio::<span class="built_in">co_spawn</span>(_io_context, [=, <span class="keyword">this</span>]()-&gt;boost::asio::awaitable&lt;<span class="type">void</span>&gt; &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">while</span> (!_b_close)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//接收数据前先清空数组</span></span><br><span class="line">				_recv_head_node-&gt;<span class="built_in">Clear</span>();</span><br><span class="line">				<span class="comment">//开始接收数据</span></span><br><span class="line">				<span class="type">size_t</span> n = <span class="keyword">co_await</span> boost::asio::<span class="built_in">async_read</span>(_socket, boost::asio::<span class="built_in">buffer</span>(_recv_head_node-&gt;_data,</span><br><span class="line">					HEAD_TOTAL_LEN), boost::asio::use_awaitable);</span><br><span class="line">				<span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">					std::cout &lt;&lt; <span class="string">&quot;receive peer closed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">					<span class="built_in">Close</span>();</span><br><span class="line">					_server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">					<span class="comment">//协程的返回</span></span><br><span class="line">					<span class="keyword">co_return</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">//获取头部MSGID数据</span></span><br><span class="line">				<span class="type">short</span> msg_id = <span class="number">0</span>;</span><br><span class="line">				<span class="built_in">memcpy</span>(&amp;msg_id, _recv_head_node-&gt;_data, HEAD_ID_LEN);</span><br><span class="line">				<span class="comment">//将网络字节序转成本地字节序</span></span><br><span class="line">				<span class="type">short</span> msg_id_host = boost::asio::detail::socket_ops::<span class="built_in">network_to_host_short</span>(msg_id);</span><br><span class="line">				std::cout &lt;&lt; <span class="string">&quot;msg_id is&quot;</span> &lt;&lt; msg_id_host &lt;&lt; std::endl;</span><br><span class="line">				<span class="keyword">if</span> (msg_id_host &gt; MAX_LENGTH) &#123;</span><br><span class="line">					std::cout &lt;&lt; <span class="string">&quot;invaild msg id is &quot;</span> &lt;&lt; msg_id_host &lt;&lt; std::endl;</span><br><span class="line">					<span class="comment">//std::cout &lt;&lt; &quot;hello&quot; &lt;&lt; std::endl;</span></span><br><span class="line">					<span class="built_in">Close</span>();</span><br><span class="line">					_server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">					<span class="keyword">co_return</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">//获取数据长度</span></span><br><span class="line">				<span class="type">short</span> msg_len = <span class="number">0</span>;</span><br><span class="line">				<span class="built_in">memcpy</span>(&amp;msg_len, _recv_head_node-&gt;_data + HEAD_ID_LEN, HEAD_DATA_LEN);</span><br><span class="line">				<span class="type">short</span> msg_len_host = boost::asio::detail::socket_ops::<span class="built_in">network_to_host_short</span>(msg_len);</span><br><span class="line">				std::cout &lt;&lt; <span class="string">&quot;msg len is&quot;</span> &lt;&lt; msg_len_host &lt;&lt; std::endl;</span><br><span class="line">				<span class="keyword">if</span> (msg_len_host &gt; MAX_LENGTH) &#123;</span><br><span class="line">					std::cout &lt;&lt; <span class="string">&quot;invaild msg len is &quot;</span> &lt;&lt; msg_len_host &lt;&lt; std::endl;</span><br><span class="line">					<span class="built_in">Close</span>();</span><br><span class="line">					_server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">					<span class="keyword">co_return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				<span class="comment">//实际数据</span></span><br><span class="line">				_recv_msg_node = std::<span class="built_in">make_shared</span>&lt;RecvNode&gt;(msg_len_host, msg_id_host);</span><br><span class="line">				</span><br><span class="line">				<span class="comment">//读出包体</span></span><br><span class="line">				n = <span class="keyword">co_await</span> boost::asio::<span class="built_in">async_read</span>(_socket, boost::asio::<span class="built_in">buffer</span>(_recv_msg_node-&gt;_data,</span><br><span class="line">					_recv_msg_node-&gt;_total_len), boost::asio::use_awaitable);</span><br><span class="line">				<span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">					std::cout &lt;&lt; <span class="string">&quot;receive peer closed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">					<span class="built_in">Close</span>();</span><br><span class="line">					_server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">					<span class="comment">//协程的返回</span></span><br><span class="line">					<span class="keyword">co_return</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				_recv_msg_node-&gt;_data[_recv_msg_node-&gt;_total_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">				std::cout &lt;&lt; <span class="string">&quot;recv data is&quot;</span> &lt;&lt; _recv_msg_node-&gt;_data &lt;&lt; std::endl;</span><br><span class="line">				</span><br><span class="line">				<span class="comment">//投递到逻辑系统的逻辑队列里，交给队列处理</span></span><br><span class="line">				LogicSystem::<span class="built_in">GetInstance</span>().<span class="built_in">PostMsgToQue</span>(std::<span class="built_in">make_shared</span>&lt;LogicNode&gt;(<span class="built_in">shared_from_this</span>(), _recv_msg_node));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">catch</span> (std::exception e) &#123;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;Exception is &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">			<span class="built_in">Close</span>();</span><br><span class="line">			<span class="comment">//关闭后从map中移除session</span></span><br><span class="line">			_server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">		&#125;</span><br><span class="line">		&#125;, boost::asio::detached);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::Close</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	_b_close = <span class="literal">true</span>;</span><br><span class="line">	<span class="comment">//关闭socket</span></span><br><span class="line">	_socket.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string&amp; <span class="title">CSession::GetUuid</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> _uuid;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> 在此处插入 return 语句</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::Send</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg, <span class="type">short</span> max_length, <span class="type">short</span> msg_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">	<span class="type">int</span> send_que_size = _send_que.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">if</span> (send_que_size &gt; MAX_SENDQUE) &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;session: &quot;</span> &lt;&lt; _uuid &lt;&lt; <span class="string">&quot;send que fulled, size is &quot;</span></span><br><span class="line">			&lt;&lt; MAX_SENDQUE &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//往消息队列里插入数据</span></span><br><span class="line">	_send_que.<span class="built_in">push</span>(std::<span class="built_in">make_shared</span>&lt;SendNode&gt;(msg, max_length, msg_id));</span><br><span class="line">	<span class="comment">//判断数据量是否大于0，大于0就不发送数据，只有当发送队列里长度为1的时候才发送数据</span></span><br><span class="line">	<span class="comment">//那么为什么他判断大于0呢，因为我们是先统计的数据量，再插入队列</span></span><br><span class="line">	<span class="keyword">if</span> (send_que_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	std::shared_ptr&lt;SendNode&gt; msgnode = _send_que.<span class="built_in">front</span>();</span><br><span class="line">	lock.<span class="built_in">unlock</span>();</span><br><span class="line">	<span class="comment">//传递shread_from_this可以增加引用，防止session意外的释放</span></span><br><span class="line">	boost::asio::<span class="built_in">async_write</span>(_socket, boost::asio::<span class="built_in">buffer</span>(msgnode-&gt;_data, msgnode-&gt;_total_len),</span><br><span class="line">		std::<span class="built_in">bind</span>(&amp;CSession::HandleWrite, <span class="keyword">this</span>, std::placeholders::_1, <span class="built_in">shared_from_this</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::Send</span><span class="params">(std::string msg, <span class="type">short</span> msg_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">Send</span>(msg.<span class="built_in">c_str</span>(), msg.<span class="built_in">length</span>(), msg_id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意对于error_code 必须加入const，否则会在async_write处会报错</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::HandleWrite</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, std::shared_ptr&lt;CSession&gt; shared_self)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (!error) &#123;</span><br><span class="line">			<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">			<span class="comment">//调用这个回调函数的时候说明数据已经处理完了</span></span><br><span class="line">			_send_que.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="comment">//如果队列不为空就要继续发送数据</span></span><br><span class="line">			<span class="keyword">if</span> (!_send_que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">				<span class="keyword">auto</span>&amp; msgnode = _send_que.<span class="built_in">front</span>();</span><br><span class="line">				boost::asio::<span class="built_in">async_write</span>(_socket, boost::asio::<span class="built_in">buffer</span>(msgnode-&gt;_data, msgnode-&gt;_total_len),</span><br><span class="line">					std::<span class="built_in">bind</span>(&amp;CSession::HandleWrite, <span class="keyword">this</span>, std::placeholders::_1, <span class="built_in">shared_from_this</span>()));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;handle write failed, error is&quot;</span> &lt;&lt; error.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">			<span class="built_in">Close</span>();</span><br><span class="line">			_server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;exception is &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">		<span class="built_in">Close</span>();</span><br><span class="line">		_server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="LogicSystem"><a href="#LogicSystem" class="headerlink" title="LogicSystem"></a>LogicSystem</h4><h5 id="LogicSystem头文件"><a href="#LogicSystem头文件" class="headerlink" title="LogicSystem头文件"></a>LogicSystem头文件</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;json/json.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;json/reader.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;json/value.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;const.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CSession.h&quot;</span></span></span><br><span class="line"><span class="comment">//因为是string 可以调用函数获取长度，所以不需要传长度</span></span><br><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">void</span>(std::shared_ptr&lt;CSession&gt; session, <span class="type">const</span> <span class="type">short</span>&amp; msg_id, <span class="type">const</span> std::string&amp; msg_data)&gt; FunCallBack;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LogicSystem</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">LogicSystem</span>(<span class="type">const</span> LogicSystem&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">	LogicSystem&amp; <span class="keyword">operator</span>=(<span class="type">const</span> LogicSystem&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">	~<span class="built_in">LogicSystem</span>();</span><br><span class="line">	<span class="function"><span class="type">static</span> LogicSystem&amp; <span class="title">GetInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="type">static</span> LogicSystem ins;</span><br><span class="line">		<span class="keyword">return</span> ins;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">PostMsgToQue</span><span class="params">(std::shared_ptr&lt;LogicNode&gt; msg)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">LogicSystem</span>();</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">RegisterCallBacks</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">HelloWorldCallBack</span><span class="params">(std::shared_ptr&lt;CSession&gt; session, <span class="type">const</span> <span class="type">short</span>&amp; msg_id, <span class="type">const</span> std::string&amp; msg_data)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">DealMsg</span><span class="params">()</span></span>;</span><br><span class="line">	std::thread _worker;</span><br><span class="line">	std::mutex mtx;</span><br><span class="line">	<span class="comment">//与直接使用LogicNode的区别</span></span><br><span class="line">	std::queue&lt;std::shared_ptr&lt;LogicNode&gt;&gt; _msg_que;</span><br><span class="line">	std::condition_variable _consume;</span><br><span class="line">	<span class="type">bool</span> _b_stop;</span><br><span class="line">	std::map&lt;<span class="type">short</span>, FunCallBack&gt; _fun_callbacks;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="LogicSystem实现"><a href="#LogicSystem实现" class="headerlink" title="LogicSystem实现"></a>LogicSystem实现</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LogicSystem.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">LogicSystem::~<span class="built_in">LogicSystem</span>()</span><br><span class="line">&#123;</span><br><span class="line">	_b_stop = <span class="literal">true</span>;</span><br><span class="line">	_consume.<span class="built_in">notify_one</span>();</span><br><span class="line">	_worker.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LogicSystem::PostMsgToQue</span><span class="params">(std::shared_ptr&lt;LogicNode&gt; msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">unique_lk</span><span class="params">(mtx)</span></span>;</span><br><span class="line">	_msg_que.<span class="built_in">push</span>(msg);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//由0变为1则发送通知信号</span></span><br><span class="line">	<span class="keyword">if</span> (_msg_que.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">		unique_lk.<span class="built_in">unlock</span>();</span><br><span class="line">		_consume.<span class="built_in">notify_one</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LogicSystem::<span class="built_in">LogicSystem</span>():_b_stop(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">RegisterCallBacks</span>();</span><br><span class="line">	_worker = std::<span class="built_in">thread</span>(&amp;LogicSystem::DealMsg, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LogicSystem::RegisterCallBacks</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//任务编号,将他存储起来</span></span><br><span class="line">	_fun_callbacks[MSG_HELLO_WORLD] = std::<span class="built_in">bind</span>(&amp;LogicSystem::HelloWorldCallBack, <span class="keyword">this</span>, </span><br><span class="line">		std::placeholders::_1, std::placeholders::_2, std::placeholders::_3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LogicSystem::HelloWorldCallBack</span><span class="params">(std::shared_ptr&lt;CSession&gt; session, <span class="type">const</span> <span class="type">short</span>&amp; msg_id, <span class="type">const</span> std::string&amp; msg_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Json::Reader reader;</span><br><span class="line">	Json::Value root;</span><br><span class="line">	reader.<span class="built_in">parse</span>(msg_data, root);</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;recevie msg id is &quot;</span> &lt;&lt; root[<span class="string">&quot;id&quot;</span>].<span class="built_in">asInt</span>() &lt;&lt; <span class="string">&quot;receive msg data is &quot;</span></span><br><span class="line">		&lt;&lt; root[<span class="string">&quot;data&quot;</span>].<span class="built_in">asString</span>() &lt;&lt; std::endl;</span><br><span class="line">	root[<span class="string">&quot;data&quot;</span>] = <span class="string">&quot;server has received msg, msg data is &quot;</span> + root[<span class="string">&quot;data&quot;</span>].<span class="built_in">asString</span>();</span><br><span class="line">	std::string return_str = root.<span class="built_in">toStyledString</span>();</span><br><span class="line">	session-&gt;<span class="built_in">Send</span>(return_str, root[<span class="string">&quot;id&quot;</span>].<span class="built_in">asInt</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LogicSystem::DealMsg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">		_consume.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]() &#123;</span><br><span class="line">			<span class="keyword">return</span> _b_stop || !_msg_que.<span class="built_in">empty</span>();</span><br><span class="line">			&#125;);</span><br><span class="line">		<span class="keyword">if</span> (_b_stop) &#123;</span><br><span class="line">			<span class="keyword">while</span> (!_msg_que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">				std::shared_ptr&lt;LogicNode&gt; msg_node = _msg_que.<span class="built_in">front</span>();</span><br><span class="line">				std::cout &lt;&lt; <span class="string">&quot;recv_msg id  is &quot;</span> &lt;&lt; msg_node-&gt;_recvnode-&gt;_msg_id &lt;&lt; std::endl;</span><br><span class="line">				<span class="keyword">auto</span> call_back_iter = _fun_callbacks.<span class="built_in">find</span>(msg_node-&gt;_recvnode-&gt;_msg_id);</span><br><span class="line">				<span class="comment">//如果没有注册回调函数就直接出队</span></span><br><span class="line">				<span class="keyword">if</span> (call_back_iter == _fun_callbacks.<span class="built_in">end</span>()) &#123;</span><br><span class="line">					_msg_que.<span class="built_in">pop</span>();</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//否则调用回调函数</span></span><br><span class="line">				call_back_iter-&gt;<span class="built_in">second</span>(msg_node-&gt;_session, msg_node-&gt;_recvnode-&gt;_msg_id,</span><br><span class="line">					std::<span class="built_in">string</span>(msg_node-&gt;_recvnode-&gt;_data, msg_node-&gt;_recvnode-&gt;_total_len));</span><br><span class="line">				_msg_que.<span class="built_in">pop</span>();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//如果没有停服，且说明队列中有数据</span></span><br><span class="line">		<span class="keyword">auto</span> msg_node = _msg_que.<span class="built_in">front</span>();</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;recv_msg id  is &quot;</span> &lt;&lt; msg_node-&gt;_recvnode-&gt;_msg_id &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">auto</span> call_back_iter = _fun_callbacks.<span class="built_in">find</span>(msg_node-&gt;_recvnode-&gt;_msg_id);</span><br><span class="line">		<span class="keyword">if</span> (call_back_iter == _fun_callbacks.<span class="built_in">end</span>()) &#123;</span><br><span class="line">			_msg_que.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		call_back_iter-&gt;<span class="built_in">second</span>(msg_node-&gt;_session, msg_node-&gt;_recvnode-&gt;_msg_id,</span><br><span class="line">			std::<span class="built_in">string</span>(msg_node-&gt;_recvnode-&gt;_data, msg_node-&gt;_recvnode-&gt;_total_len));</span><br><span class="line">		_msg_que.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="MsgNode-1"><a href="#MsgNode-1" class="headerlink" title="MsgNode"></a>MsgNode</h4><h5 id="MsgNode头文件"><a href="#MsgNode头文件" class="headerlink" title="MsgNode头文件"></a>MsgNode头文件</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;const.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MsgNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MsgNode</span>(<span class="type">short</span> max_len) :_total_len(max_len), _cur_len(<span class="number">0</span>) &#123;</span><br><span class="line">		_data = <span class="keyword">new</span> <span class="type">char</span>[_total_len + <span class="number">1</span>];</span><br><span class="line">		_data[_total_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">MsgNode</span>() &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;destruct MsgNode&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">delete</span>[] _data;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">memset</span>(_data, <span class="number">0</span>, _total_len);</span><br><span class="line">		_cur_len = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> _cur_len;</span><br><span class="line">	<span class="type">int</span> _total_len;</span><br><span class="line">	<span class="type">char</span>* _data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RecvNode</span> :<span class="keyword">public</span> MsgNode &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">RecvNode</span>(<span class="type">short</span> max_len, <span class="type">short</span> msg_id);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">short</span> _msg_id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SendNode</span> :<span class="keyword">public</span> MsgNode &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">SendNode</span>(<span class="type">const</span> <span class="type">char</span>* msg, <span class="type">short</span> max_len, <span class="type">short</span> msg_id);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">short</span> _msg_id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="MsgNode-实现"><a href="#MsgNode-实现" class="headerlink" title="MsgNode 实现"></a>MsgNode 实现</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MsgNode.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">RecvNode::<span class="built_in">RecvNode</span>(<span class="type">short</span> max_len, <span class="type">short</span> msg_id):<span class="built_in">MsgNode</span>(max_len), _msg_id(msg_id)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SendNode::<span class="built_in">SendNode</span>(<span class="type">const</span> <span class="type">char</span>* msg, <span class="type">short</span> max_len, <span class="type">short</span> msg_id):<span class="built_in">MsgNode</span>(max_len + HEAD_TOTAL_LEN), _msg_id(msg_id)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//先发送id,转为网络字节序</span></span><br><span class="line">	<span class="type">short</span> msg_id_net = boost::asio::detail::socket_ops::<span class="built_in">host_to_network_short</span>(msg_id);</span><br><span class="line">	<span class="built_in">memcpy</span>(_data, &amp;msg_id_net, HEAD_ID_LEN);</span><br><span class="line">	<span class="comment">//再发送长度，转为网络字节序</span></span><br><span class="line">	<span class="type">short</span> msg_len_net = boost::asio::detail::socket_ops::<span class="built_in">host_to_network_short</span>(max_len);</span><br><span class="line">	<span class="built_in">memcpy</span>(_data + HEAD_ID_LEN, &amp;msg_len_net, HEAD_DATA_LEN);</span><br><span class="line">	<span class="comment">//最后在发送数据</span></span><br><span class="line">	<span class="built_in">memcpy</span>(_data + HEAD_TOTAL_LEN, msg, max_len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="使用asio实现http服务器"><a href="#使用asio实现http服务器" class="headerlink" title="使用asio实现http服务器"></a>使用asio实现http服务器</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><ul>
<li>前文介绍了asio如何实现并发的长连接tcp服务器，今天介绍如何实现http服务器，在介绍实现http服务器之前，需要讲述下http报文头的格式，其实http报文头的格式就是为了避免我们之前提到的粘包现象，告诉服务器一个数据包的开始和结尾，并在包头里标识请求的类型如get或post等信息。</li>
</ul>
<h3 id="Http包头信息"><a href="#Http包头信息" class="headerlink" title="Http包头信息"></a>Http包头信息</h3><ul>
<li>一个标准的HTTP报文头通常由请求头和响应头两部分组成。</li>
</ul>
<h4 id="HTTP请求头"><a href="#HTTP请求头" class="headerlink" title="HTTP请求头"></a>HTTP请求头</h4><ul>
<li><p>HTTP请求头包括以下字段：</p>
<ol>
<li>Request-line：包含用于描述请求类型、要访问的资源以及所使用的HTTP版本的信息。</li>
<li>Host：指定被请求资源的主机名或IP地址和端口号。</li>
<li>Accept：指定客户端能够接收的媒体类型列表，用逗号分隔，例如 text/plain, text/html。</li>
<li>User-Agent：客户端使用的浏览器类型和版本号，供服务器统计用户代理信息。</li>
<li>Cookie：如果请求中包含cookie信息，则通过这个字段将cookie信息发送给Web服务器。</li>
<li>Connection：表示是否需要持久连接（keep-alive）</li>
</ol>
</li>
<li><p>比如下面就是一个实际应用</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET /index.html HTTP/<span class="number">1.1</span></span><br><span class="line">Host: www.example.com</span><br><span class="line">Accept: text/html, application/xhtml+xml, *<span class="comment">/*</span></span><br><span class="line"><span class="comment">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:123.0) Gecko/20100101 Firefox/123.0</span></span><br><span class="line"><span class="comment">Cookie: sessionid=abcdefg1234567</span></span><br><span class="line"><span class="comment">Connection: keep-alive</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Request-line：指定使用GET方法请求/index.html资源，并使用HTTP/1.1协议版本。</li>
<li>Host：指定被请求资源所在主机名或IP地址和端口号。</li>
<li>Accept：客户端期望接收的媒体类型列表，本例中指定了text/html、application/xhtml+xml和任意类型的文件（/）。</li>
<li>User-Agent：客户端浏览器类型和版本号。</li>
<li>Cookie：客户端发送给服务器的cookie信息。</li>
<li>Connection：客户端请求后是否需要保持长连接。</li>
</ul>
<h4 id="HTTP响应头"><a href="#HTTP响应头" class="headerlink" title="HTTP响应头"></a>HTTP响应头</h4><ul>
<li><p>HTTP响应头包括以下字段：</p>
<ol>
<li>Status-line：包含协议版本、状态码和状态消息。</li>
<li>Content-Type：响应体的MIME类型。</li>
<li>Content-Length：响应体的字节数。</li>
<li>Set-Cookie：服务器向客户端发送cookie信息时使用该字段。</li>
<li>Server：服务器类型和版本号。</li>
<li>Connection：表示是否需要保持长连接（keep-alive）。</li>
</ol>
</li>
<li><p>在实际的HTTP报文头中，还可以包含其他可选字段。</p>
</li>
<li>如下就是一个例子</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">Content-Type: text/html; charset=UTF<span class="number">-8</span></span><br><span class="line">Content-Length: <span class="number">1024</span></span><br><span class="line">Set-Cookie: sessionid=abcdefg1234567; HttpOnly; Path=/</span><br><span class="line">Server: Apache/<span class="number">2.2</span><span class="number">.32</span> (Unix) mod_ssl/<span class="number">2.2</span><span class="number">.32</span> OpenSSL/<span class="number">1.0</span><span class="number">.1</span>e-fips mod_bwlimited/<span class="number">1.4</span></span><br><span class="line">Connection: keep-alive</span><br><span class="line">上述响应头包括了以下字段：</span><br></pre></td></tr></table></figure>
<ul>
<li>Status-line：指定HTTP协议版本、状态码和状态消息。</li>
<li>Content-Type：指定响应体的MIME类型及字符编码格式。</li>
<li>Content-Length：指定响应体的字节数。</li>
<li>Set-Cookie：服务器向客户端发送cookie信息时使用该字段。</li>
<li>Server：服务器类型和版本号。</li>
<li><p>Connection：服务器是否需要保持长连接。</p>
</li>
<li><p>源码请看<a target="_blank" rel="noopener" href="https://gitee.com/secondtonone1/boostasio-learn">https://gitee.com/secondtonone1/boostasio-learn</a></p>
</li>
</ul>
<h2 id="使用beast网络库实现http服务器"><a href="#使用beast网络库实现http服务器" class="headerlink" title="使用beast网络库实现http服务器"></a>使用beast网络库实现http服务器</h2><h3 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h3><ul>
<li>前面的几篇文章已经介绍了如何使用asio搭建高并发的tcp服务器，以及http服务器。但是纯手写http服务器太麻烦了，有网络库beast已经帮我们实现了。这一期讲讲如何使用beast实现一个http服务器。</li>
</ul>
<h3 id="连接类"><a href="#连接类" class="headerlink" title="连接类"></a>连接类</h3><ul>
<li>我们先实现http_server函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">http_server</span><span class="params">(boost::asio::ip::tcp::acceptor&amp; acceptor, boost::asio::ip::tcp::socket&amp; socket)</span> </span>&#123;</span><br><span class="line">	acceptor.<span class="built_in">async_accept</span>(socket, [&amp;](boost::system::error_code ec) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!ec) &#123;</span><br><span class="line">			<span class="comment">//启动http的connection</span></span><br><span class="line">			std::<span class="built_in">make_shared</span>&lt;http_connection&gt;(std::<span class="built_in">move</span>(socket))-&gt;<span class="built_in">Start</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//不管成功与失败都要继续监听请求</span></span><br><span class="line">		<span class="built_in">http_server</span>(acceptor, socket);</span><br><span class="line">		&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>http_server中添加了异步接收连接的逻辑，当有新的连接到来时创建http_connection,然后启动服务，新连接监听对端数据。接下来http_server继续监听对端的新连接。</p>
</li>
<li><p>连接类http_connection里实现了start函数监听对端数据</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//读取请求</span></span><br><span class="line">	<span class="built_in">read_request</span>();</span><br><span class="line">	<span class="comment">//开始超时返回机制,对于短连接</span></span><br><span class="line">	<span class="built_in">check_deadline</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>处理读请求,将读到的数据存储再成员变量request_中，然后调用process_request处理请求</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现读请求</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//千万不要用make_shared</span></span><br><span class="line">	<span class="keyword">auto</span> self = <span class="built_in">shared_from_this</span>();</span><br><span class="line">	boost::beast::http::<span class="built_in">async_read</span>(socket_, buffer_, request_,</span><br><span class="line">		[self](boost::system::error_code ec, std::<span class="type">size_t</span> bytes_transferred) &#123;</span><br><span class="line">			<span class="comment">//因为用不到后面那个参数，所以忽略他</span></span><br><span class="line">			<span class="comment">//由于底层必须接收它，所以即使不用也要声明</span></span><br><span class="line">			boost::<span class="built_in">ignore_unused</span>(bytes_transferred);</span><br><span class="line">			<span class="keyword">if</span> (!ec) &#123;</span><br><span class="line">				self-&gt;<span class="built_in">process_request</span>();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>check_deadline主要时用来检测超时，当超过一定时间后自动关闭连接，因为http请求时短链接</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检测定时器</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">check_deadline</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//构造伪闭包，防止被析构的时候，意外地被释放</span></span><br><span class="line">	<span class="keyword">auto</span> self = <span class="built_in">shared_from_this</span>();</span><br><span class="line">	<span class="comment">//开始异步等待60s,传递的时候多传递一个self，这样做是为了</span></span><br><span class="line">	<span class="comment">//防止在60之内的等待中，http_connection先被释放掉</span></span><br><span class="line">	<span class="comment">//而导致this为空的崩溃</span></span><br><span class="line">	deadline_.<span class="built_in">async_wait</span>([self](boost::system::error_code ec) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!ec) &#123;</span><br><span class="line">			self-&gt;socket_.<span class="built_in">close</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>process_request函数中区分请求的类型，进行不同类型的处理如post还是get请求</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">process_request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//设置回应版本,设置为请求回来的</span></span><br><span class="line">	response_.<span class="built_in">version</span>(request_.<span class="built_in">version</span>());</span><br><span class="line">	<span class="comment">//设置为短连接</span></span><br><span class="line">	response_.<span class="built_in">keep_alive</span>(<span class="literal">false</span>);</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="keyword">switch</span> (request_.<span class="built_in">method</span>()) &#123;</span><br><span class="line">	<span class="keyword">case</span> boost::beast::http::verb::get:</span><br><span class="line">		<span class="comment">//设置为错误请求的状态码</span></span><br><span class="line">		response_.<span class="built_in">result</span>(boost::beast::http::status::ok);</span><br><span class="line">		<span class="comment">//设置响应头的MIME类型，也就是回应的数据类型</span></span><br><span class="line">		response_.<span class="built_in">set</span>(boost::beast::http::field::server, <span class="string">&quot;Beast&quot;</span>);</span><br><span class="line">		<span class="comment">//创建回应</span></span><br><span class="line">		<span class="built_in">create_get_response</span>();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> boost::beast::http::verb::post:</span><br><span class="line">		<span class="comment">//设置为错误请求的状态码</span></span><br><span class="line">		response_.<span class="built_in">result</span>(boost::beast::http::status::ok);</span><br><span class="line">		<span class="comment">//设置响应头的MIME类型，也就是回应的数据类型</span></span><br><span class="line">		response_.<span class="built_in">set</span>(boost::beast::http::field::server, <span class="string">&quot;Beast&quot;</span>);</span><br><span class="line">		<span class="comment">//创建回应</span></span><br><span class="line">		<span class="built_in">create_post_response</span>();</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="comment">//设置为错误请求的状态码</span></span><br><span class="line">		response_.<span class="built_in">result</span>(boost::beast::http::status::bad_request);</span><br><span class="line">		<span class="comment">//设置响应头的MIME类型，也就是回应的数据类型</span></span><br><span class="line">		response_.<span class="built_in">set</span>(boost::beast::http::field::content_type, <span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line">		<span class="comment">//在响应头的body写数据</span></span><br><span class="line">		boost::beast::<span class="built_in">ostream</span>(response_.<span class="built_in">body</span>()) &lt;&lt; <span class="string">&quot;invaild request-method&quot;</span></span><br><span class="line">			&lt;&lt; std::<span class="built_in">string</span>(request_.<span class="built_in">method_string</span>()) &lt;&lt; <span class="string">&quot;`&quot;</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>create_response函数中解析了不同的路由处理get请求</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">create_get_response</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//判断请求的路由,假设他要问请求了多少次</span></span><br><span class="line">	<span class="keyword">if</span> (request_.<span class="built_in">target</span>() == <span class="string">&quot;/count&quot;</span>) &#123;</span><br><span class="line">		<span class="comment">//设置返回的MIME类型为HTML</span></span><br><span class="line">		response_.<span class="built_in">set</span>(boost::beast::http::field::content_type, <span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">		boost::beast::<span class="built_in">ostream</span>(response_.<span class="built_in">body</span>())</span><br><span class="line">			&lt;&lt; <span class="string">&quot;&lt;html&gt;\n&quot;</span></span><br><span class="line">			&lt;&lt; <span class="string">&quot;&lt;head&gt;&lt;title&gt;Current time&lt;/title&gt;&lt;/head&gt;\n&quot;</span></span><br><span class="line">			&lt;&lt; <span class="string">&quot;&lt;body&gt;\n&quot;</span></span><br><span class="line">			&lt;&lt; <span class="string">&quot;&lt;h1&gt;Current time&lt;/h1&gt;\n&quot;</span></span><br><span class="line">			&lt;&lt; <span class="string">&quot;&lt;p&gt;The current time is &quot;</span></span><br><span class="line">			&lt;&lt; my_program_state::<span class="built_in">request_count</span>()</span><br><span class="line">			&lt;&lt; <span class="string">&quot; seconds since the epoch.&lt;/p&gt;\n&quot;</span></span><br><span class="line">			&lt;&lt; <span class="string">&quot;&lt;/body&gt;\n&quot;</span></span><br><span class="line">			&lt;&lt; <span class="string">&quot;&lt;/html&gt;\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//假设问的是时间</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (request_.<span class="built_in">target</span>() == <span class="string">&quot;/time&quot;</span>) &#123;</span><br><span class="line">		<span class="comment">//设置返回的MIME类型为HTML</span></span><br><span class="line">		response_.<span class="built_in">set</span>(boost::beast::http::field::content_type, <span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">		boost::beast::<span class="built_in">ostream</span>(response_.<span class="built_in">body</span>())</span><br><span class="line">			&lt;&lt; <span class="string">&quot;&lt;html&gt;\n&quot;</span></span><br><span class="line">			&lt;&lt; <span class="string">&quot;&lt;head&gt;&lt;title&gt;Current time&lt;/title&gt;&lt;/head&gt;\n&quot;</span></span><br><span class="line">			&lt;&lt; <span class="string">&quot;&lt;body&gt;\n&quot;</span></span><br><span class="line">			&lt;&lt; <span class="string">&quot;&lt;h1&gt;Current time&lt;/h1&gt;\n&quot;</span></span><br><span class="line">			&lt;&lt; <span class="string">&quot;&lt;p&gt;The current time is &quot;</span></span><br><span class="line">			&lt;&lt; my_program_state::<span class="built_in">now</span>()</span><br><span class="line">			&lt;&lt; <span class="string">&quot; seconds since the epoch.&lt;/p&gt;\n&quot;</span></span><br><span class="line">			&lt;&lt; <span class="string">&quot;&lt;/body&gt;\n&quot;</span></span><br><span class="line">			&lt;&lt; <span class="string">&quot;&lt;/html&gt;\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//设置状态为404，未找到页面</span></span><br><span class="line">		response_.<span class="built_in">result</span>(boost::beast::http::status::not_found);</span><br><span class="line">		boost::beast::<span class="built_in">ostream</span>(response_.<span class="built_in">body</span>())</span><br><span class="line">			&lt;&lt; <span class="string">&quot;File not found\r\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>create_post_response处理了post请求中的一部分路由</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">	<span class="function"><span class="type">void</span> <span class="title">create_post_response</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//判断路由是不是email</span></span><br><span class="line">		<span class="keyword">if</span> (request_.<span class="built_in">target</span>() == <span class="string">&quot;/email&quot;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//取出body</span></span><br><span class="line">			<span class="keyword">auto</span>&amp; body = <span class="keyword">this</span>-&gt;request_.<span class="built_in">body</span>();</span><br><span class="line">			<span class="comment">//得到body里的内容。将buffer转换为string</span></span><br><span class="line">			<span class="keyword">auto</span> body_str = boost::beast::<span class="built_in">buffers_to_string</span>(body.<span class="built_in">data</span>());</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;receive body is &quot;</span> &lt;&lt; body_str &lt;&lt; std::endl;</span><br><span class="line">			<span class="comment">//设置为json</span></span><br><span class="line">			<span class="keyword">this</span>-&gt;response_.<span class="built_in">set</span>(boost::beast::http::field::content_type, <span class="string">&quot;text/json&quot;</span>);</span><br><span class="line">			<span class="comment">//这是回应给对方用的json</span></span><br><span class="line">			Json::Value root;</span><br><span class="line">			<span class="comment">//用于解析请求</span></span><br><span class="line">			Json::Reader reader;</span><br><span class="line">			<span class="comment">//表示原始的根</span></span><br><span class="line">			Json::Value src_root;</span><br><span class="line">			<span class="comment">//解析到原始的根里</span></span><br><span class="line">			<span class="type">bool</span> parse_success = reader.<span class="built_in">parse</span>(body_str, src_root);</span><br><span class="line">			<span class="comment">//如果解析错误</span></span><br><span class="line">			<span class="keyword">if</span> (!parse_success) &#123;</span><br><span class="line">				std::cout &lt;&lt; <span class="string">&quot;Failed to parse JSON data!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">				root[<span class="string">&quot;error&quot;</span>] = <span class="number">1001</span>;</span><br><span class="line">				<span class="comment">//将json序列化为字符串</span></span><br><span class="line">				std::string jsonstr = root.<span class="built_in">toStyledString</span>();</span><br><span class="line">				<span class="comment">//写道回应里的body里</span></span><br><span class="line">				boost::beast::<span class="built_in">ostream</span>(<span class="keyword">this</span>-&gt;response_.<span class="built_in">body</span>()) &lt;&lt; jsonstr;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//如果解析正确</span></span><br><span class="line">			<span class="keyword">auto</span> email = src_root[<span class="string">&quot;email&quot;</span>].<span class="built_in">asString</span>();</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;email is &quot;</span> &lt;&lt; email &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">			root[<span class="string">&quot;error&quot;</span>] = <span class="number">0</span>;</span><br><span class="line">			root[<span class="string">&quot;email&quot;</span>] = src_root[<span class="string">&quot;email&quot;</span>];</span><br><span class="line">			root[<span class="string">&quot;msg&quot;</span>] = <span class="string">&quot;recevie email post success&quot;</span>;</span><br><span class="line">			<span class="comment">//也就是以字符串的形式显示，其内部还是json格式</span></span><br><span class="line">			std::string jsonstr = root.<span class="built_in">toStyledString</span>();</span><br><span class="line">			boost::beast::<span class="built_in">ostream</span>(<span class="keyword">this</span>-&gt;response_.<span class="built_in">body</span>()) &lt;&lt; jsonstr;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			response_.<span class="built_in">result</span>(boost::beast::http::status::not_found);</span><br><span class="line">			response_.<span class="built_in">set</span>(boost::beast::http::field::content_type, <span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line">			boost::beast::<span class="built_in">ostream</span>(response_.<span class="built_in">body</span>()) &lt;&lt; <span class="string">&quot;File not found\r\n&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>write_response发送请求</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_response</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> self = <span class="built_in">shared_from_this</span>();</span><br><span class="line">	<span class="comment">//设置数据的长度类似tlv的长度</span></span><br><span class="line">	response_.<span class="built_in">content_length</span>(response_.<span class="built_in">body</span>().<span class="built_in">size</span>());</span><br><span class="line">	<span class="comment">//调用写函数</span></span><br><span class="line">	boost::beast::http::<span class="built_in">async_write</span>(socket_, response_,</span><br><span class="line">		[self](boost::system::error_code ec, std::<span class="type">size_t</span> bytes_transgerred) &#123;</span><br><span class="line">			<span class="comment">//由于服务器是全双工的，我们关闭服务器的时候不能直接调用close</span></span><br><span class="line">			<span class="comment">//因为一个服务器会调用很多很多连接，如果服务器主动断开连接</span></span><br><span class="line">			<span class="comment">//会有很多客户端都需要等待四次挥手，所以我们为了避免这种情况</span></span><br><span class="line">			<span class="comment">//可以只关闭服务器的发送端</span></span><br><span class="line">			self-&gt;socket_.<span class="built_in">shutdown</span>(boost::asio::ip::tcp::socket::shutdown_send,ec);</span><br><span class="line">			<span class="comment">//将定时器取消掉</span></span><br><span class="line">			self-&gt;deadline_.<span class="built_in">cancel</span>();</span><br><span class="line">		&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/beast/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/beast/http.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/beast/version.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;json/json.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;json/value.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;json/reader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> my_program_state &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//统计别人请求的个数</span></span><br><span class="line">	<span class="function">std::<span class="type">size_t</span> <span class="title">request_count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="type">static</span> std::<span class="type">size_t</span> count = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> ++count;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//得到当前时间</span></span><br><span class="line">	<span class="function">std::<span class="type">time_t</span> <span class="title">now</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> std::<span class="built_in">time</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建立连接，实际上建立过程和tcp服务器类似</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">http_connection</span> :<span class="keyword">public</span> std::enable_shared_from_this&lt;http_connection&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//不用引用是为了让每一个connection都独立管理自己的socket</span></span><br><span class="line">	<span class="comment">//所以为了避免构造 得使用移动构造函数</span></span><br><span class="line">	<span class="built_in">http_connection</span>(boost::asio::ip::tcp::socket socket) :</span><br><span class="line">		<span class="built_in">socket_</span>(std::<span class="built_in">move</span>(socket)) </span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//读取请求</span></span><br><span class="line">		<span class="built_in">read_request</span>();</span><br><span class="line">		<span class="comment">//开始超时返回机制,对于短连接</span></span><br><span class="line">		<span class="built_in">check_deadline</span>();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//用于读取与发送的套接字</span></span><br><span class="line">	boost::asio::ip::tcp::socket socket_;</span><br><span class="line">	<span class="comment">//接收缓冲区,指定最大为8K</span></span><br><span class="line">	boost::beast::flat_buffer buffer_&#123; <span class="number">8192</span> &#125;;</span><br><span class="line">	<span class="comment">//请求头,其中dynamic_body 表示接收任意类型请求可以是html可以是javaScript</span></span><br><span class="line">	boost::beast::http::request&lt; boost::beast::http::dynamic_body&gt; request_;</span><br><span class="line">	<span class="comment">//响应头</span></span><br><span class="line">	boost::beast::http::response&lt;boost::beast::http::dynamic_body&gt; response_;</span><br><span class="line">	<span class="comment">//构造一个计时器</span></span><br><span class="line">	boost::asio::steady_timer deadline_&#123;</span><br><span class="line">		socket_.<span class="built_in">get_executor</span>(),std::chrono::<span class="built_in">seconds</span>(<span class="number">60</span>) &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//实现读请求</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">read_request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//千万不要用make_shared</span></span><br><span class="line">		<span class="keyword">auto</span> self = <span class="built_in">shared_from_this</span>();</span><br><span class="line">		boost::beast::http::<span class="built_in">async_read</span>(socket_, buffer_, request_,</span><br><span class="line">			[self](boost::system::error_code ec, std::<span class="type">size_t</span> bytes_transferred) &#123;</span><br><span class="line">				<span class="comment">//因为用不到后面那个参数，所以忽略他</span></span><br><span class="line">				<span class="comment">//由于底层必须接收它，所以即使不用也要声明</span></span><br><span class="line">				boost::<span class="built_in">ignore_unused</span>(bytes_transferred);</span><br><span class="line">				<span class="keyword">if</span> (!ec) &#123;</span><br><span class="line">					self-&gt;<span class="built_in">process_request</span>();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 检测定时器</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">check_deadline</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//构造伪闭包，防止被析构的时候，意外地被释放</span></span><br><span class="line">		<span class="keyword">auto</span> self = <span class="built_in">shared_from_this</span>();</span><br><span class="line">		<span class="comment">//开始异步等待60s,传递的时候多传递一个self，这样做是为了</span></span><br><span class="line">		<span class="comment">//防止在60之内的等待中，http_connection先被释放掉</span></span><br><span class="line">		<span class="comment">//而导致this为空的崩溃</span></span><br><span class="line">		deadline_.<span class="built_in">async_wait</span>([self](boost::system::error_code ec) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!ec) &#123;</span><br><span class="line">				self-&gt;socket_.<span class="built_in">close</span>();</span><br><span class="line">			&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">process_request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//设置回应版本,设置为请求回来的</span></span><br><span class="line">		response_.<span class="built_in">version</span>(request_.<span class="built_in">version</span>());</span><br><span class="line">		<span class="comment">//设置为短连接</span></span><br><span class="line">		response_.<span class="built_in">keep_alive</span>(<span class="literal">false</span>);</span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="keyword">switch</span> (request_.<span class="built_in">method</span>()) &#123;</span><br><span class="line">		<span class="keyword">case</span> boost::beast::http::verb::get:</span><br><span class="line">			<span class="comment">//设置为错误请求的状态码</span></span><br><span class="line">			response_.<span class="built_in">result</span>(boost::beast::http::status::ok);</span><br><span class="line">			<span class="comment">//设置响应头的MIME类型，也就是回应的数据类型</span></span><br><span class="line">			response_.<span class="built_in">set</span>(boost::beast::http::field::server, <span class="string">&quot;Beast&quot;</span>);</span><br><span class="line">			<span class="comment">//创建回应</span></span><br><span class="line">			<span class="built_in">create_get_response</span>();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> boost::beast::http::verb::post:</span><br><span class="line">			<span class="comment">//设置为错误请求的状态码</span></span><br><span class="line">			response_.<span class="built_in">result</span>(boost::beast::http::status::ok);</span><br><span class="line">			<span class="comment">//设置响应头的MIME类型，也就是回应的数据类型</span></span><br><span class="line">			response_.<span class="built_in">set</span>(boost::beast::http::field::server, <span class="string">&quot;Beast&quot;</span>);</span><br><span class="line">			<span class="comment">//创建回应</span></span><br><span class="line">			<span class="built_in">create_post_response</span>();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="comment">//设置为错误请求的状态码</span></span><br><span class="line">			response_.<span class="built_in">result</span>(boost::beast::http::status::bad_request);</span><br><span class="line">			<span class="comment">//设置响应头的MIME类型，也就是回应的数据类型</span></span><br><span class="line">			response_.<span class="built_in">set</span>(boost::beast::http::field::content_type, <span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line">			<span class="comment">//在响应头的body写数据</span></span><br><span class="line">			boost::beast::<span class="built_in">ostream</span>(response_.<span class="built_in">body</span>()) &lt;&lt; <span class="string">&quot;invaild request-method&quot;</span></span><br><span class="line">				&lt;&lt; std::<span class="built_in">string</span>(request_.<span class="built_in">method_string</span>()) &lt;&lt; <span class="string">&quot;`&quot;</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">create_get_response</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//判断请求的路由,假设他要问请求了多少次</span></span><br><span class="line">		<span class="keyword">if</span> (request_.<span class="built_in">target</span>() == <span class="string">&quot;/count&quot;</span>) &#123;</span><br><span class="line">			<span class="comment">//设置返回的MIME类型为HTML</span></span><br><span class="line">			response_.<span class="built_in">set</span>(boost::beast::http::field::content_type, <span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">			boost::beast::<span class="built_in">ostream</span>(response_.<span class="built_in">body</span>())</span><br><span class="line">				&lt;&lt; <span class="string">&quot;&lt;html&gt;\n&quot;</span></span><br><span class="line">				&lt;&lt; <span class="string">&quot;&lt;head&gt;&lt;title&gt;Current time&lt;/title&gt;&lt;/head&gt;\n&quot;</span></span><br><span class="line">				&lt;&lt; <span class="string">&quot;&lt;body&gt;\n&quot;</span></span><br><span class="line">				&lt;&lt; <span class="string">&quot;&lt;h1&gt;Current time&lt;/h1&gt;\n&quot;</span></span><br><span class="line">				&lt;&lt; <span class="string">&quot;&lt;p&gt;The current time is &quot;</span></span><br><span class="line">				&lt;&lt; my_program_state::<span class="built_in">request_count</span>()</span><br><span class="line">				&lt;&lt; <span class="string">&quot; seconds since the epoch.&lt;/p&gt;\n&quot;</span></span><br><span class="line">				&lt;&lt; <span class="string">&quot;&lt;/body&gt;\n&quot;</span></span><br><span class="line">				&lt;&lt; <span class="string">&quot;&lt;/html&gt;\n&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//假设问的是时间</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (request_.<span class="built_in">target</span>() == <span class="string">&quot;/time&quot;</span>) &#123;</span><br><span class="line">			<span class="comment">//设置返回的MIME类型为HTML</span></span><br><span class="line">			response_.<span class="built_in">set</span>(boost::beast::http::field::content_type, <span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">			boost::beast::<span class="built_in">ostream</span>(response_.<span class="built_in">body</span>())</span><br><span class="line">				&lt;&lt; <span class="string">&quot;&lt;html&gt;\n&quot;</span></span><br><span class="line">				&lt;&lt; <span class="string">&quot;&lt;head&gt;&lt;title&gt;Current time&lt;/title&gt;&lt;/head&gt;\n&quot;</span></span><br><span class="line">				&lt;&lt; <span class="string">&quot;&lt;body&gt;\n&quot;</span></span><br><span class="line">				&lt;&lt; <span class="string">&quot;&lt;h1&gt;Current time&lt;/h1&gt;\n&quot;</span></span><br><span class="line">				&lt;&lt; <span class="string">&quot;&lt;p&gt;The current time is &quot;</span></span><br><span class="line">				&lt;&lt; my_program_state::<span class="built_in">now</span>()</span><br><span class="line">				&lt;&lt; <span class="string">&quot; seconds since the epoch.&lt;/p&gt;\n&quot;</span></span><br><span class="line">				&lt;&lt; <span class="string">&quot;&lt;/body&gt;\n&quot;</span></span><br><span class="line">				&lt;&lt; <span class="string">&quot;&lt;/html&gt;\n&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//设置状态为404，未找到页面</span></span><br><span class="line">			response_.<span class="built_in">result</span>(boost::beast::http::status::not_found);</span><br><span class="line">			boost::beast::<span class="built_in">ostream</span>(response_.<span class="built_in">body</span>())</span><br><span class="line">				&lt;&lt; <span class="string">&quot;File not found\r\n&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">write_response</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">auto</span> self = <span class="built_in">shared_from_this</span>();</span><br><span class="line">		<span class="comment">//设置数据的长度类似tlv的长度</span></span><br><span class="line">		response_.<span class="built_in">content_length</span>(response_.<span class="built_in">body</span>().<span class="built_in">size</span>());</span><br><span class="line">		<span class="comment">//调用写函数</span></span><br><span class="line">		boost::beast::http::<span class="built_in">async_write</span>(socket_, response_,</span><br><span class="line">			[self](boost::system::error_code ec, std::<span class="type">size_t</span> bytes_transgerred) &#123;</span><br><span class="line">				<span class="comment">//由于服务器是全双工的，我们关闭服务器的时候不能直接调用close</span></span><br><span class="line">				<span class="comment">//因为一个服务器会调用很多很多连接，如果服务器主动断开连接</span></span><br><span class="line">				<span class="comment">//会有很多客户端都需要等待四次挥手，所以我们为了避免这种情况</span></span><br><span class="line">				<span class="comment">//可以只关闭服务器的发送端</span></span><br><span class="line">				self-&gt;socket_.<span class="built_in">shutdown</span>(boost::asio::ip::tcp::socket::shutdown_send,ec);</span><br><span class="line">				<span class="comment">//将定时器取消掉</span></span><br><span class="line">				self-&gt;deadline_.<span class="built_in">cancel</span>();</span><br><span class="line">			&#125;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">create_post_response</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//判断路由是不是email</span></span><br><span class="line">		<span class="keyword">if</span> (request_.<span class="built_in">target</span>() == <span class="string">&quot;/email&quot;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//取出body</span></span><br><span class="line">			<span class="keyword">auto</span>&amp; body = <span class="keyword">this</span>-&gt;request_.<span class="built_in">body</span>();</span><br><span class="line">			<span class="comment">//得到body里的内容。将buffer转换为string</span></span><br><span class="line">			<span class="keyword">auto</span> body_str = boost::beast::<span class="built_in">buffers_to_string</span>(body.<span class="built_in">data</span>());</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;receive body is &quot;</span> &lt;&lt; body_str &lt;&lt; std::endl;</span><br><span class="line">			<span class="comment">//设置为json</span></span><br><span class="line">			<span class="keyword">this</span>-&gt;response_.<span class="built_in">set</span>(boost::beast::http::field::content_type, <span class="string">&quot;text/json&quot;</span>);</span><br><span class="line">			<span class="comment">//这是回应给对方用的json</span></span><br><span class="line">			Json::Value root;</span><br><span class="line">			<span class="comment">//用于解析请求</span></span><br><span class="line">			Json::Reader reader;</span><br><span class="line">			<span class="comment">//表示原始的根</span></span><br><span class="line">			Json::Value src_root;</span><br><span class="line">			<span class="comment">//解析到原始的根里</span></span><br><span class="line">			<span class="type">bool</span> parse_success = reader.<span class="built_in">parse</span>(body_str, src_root);</span><br><span class="line">			<span class="comment">//如果解析错误</span></span><br><span class="line">			<span class="keyword">if</span> (!parse_success) &#123;</span><br><span class="line">				std::cout &lt;&lt; <span class="string">&quot;Failed to parse JSON data!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">				root[<span class="string">&quot;error&quot;</span>] = <span class="number">1001</span>;</span><br><span class="line">				<span class="comment">//将json序列化为字符串</span></span><br><span class="line">				std::string jsonstr = root.<span class="built_in">toStyledString</span>();</span><br><span class="line">				<span class="comment">//写道回应里的body里</span></span><br><span class="line">				boost::beast::<span class="built_in">ostream</span>(<span class="keyword">this</span>-&gt;response_.<span class="built_in">body</span>()) &lt;&lt; jsonstr;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//如果解析正确</span></span><br><span class="line">			<span class="keyword">auto</span> email = src_root[<span class="string">&quot;email&quot;</span>].<span class="built_in">asString</span>();</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;email is &quot;</span> &lt;&lt; email &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">			root[<span class="string">&quot;error&quot;</span>] = <span class="number">0</span>;</span><br><span class="line">			root[<span class="string">&quot;email&quot;</span>] = src_root[<span class="string">&quot;email&quot;</span>];</span><br><span class="line">			root[<span class="string">&quot;msg&quot;</span>] = <span class="string">&quot;recevie email post success&quot;</span>;</span><br><span class="line">			<span class="comment">//也就是以字符串的形式显示，其内部还是json格式</span></span><br><span class="line">			std::string jsonstr = root.<span class="built_in">toStyledString</span>();</span><br><span class="line">			boost::beast::<span class="built_in">ostream</span>(<span class="keyword">this</span>-&gt;response_.<span class="built_in">body</span>()) &lt;&lt; jsonstr;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			response_.<span class="built_in">result</span>(boost::beast::http::status::not_found);</span><br><span class="line">			response_.<span class="built_in">set</span>(boost::beast::http::field::content_type, <span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line">			boost::beast::<span class="built_in">ostream</span>(response_.<span class="built_in">body</span>()) &lt;&lt; <span class="string">&quot;File not found\r\n&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">http_server</span><span class="params">(boost::asio::ip::tcp::acceptor&amp; acceptor, boost::asio::ip::tcp::socket&amp; socket)</span> </span>&#123;</span><br><span class="line">	acceptor.<span class="built_in">async_accept</span>(socket, [&amp;](boost::system::error_code ec) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!ec) &#123;</span><br><span class="line">			<span class="comment">//启动http的connection</span></span><br><span class="line">			std::<span class="built_in">make_shared</span>&lt;http_connection&gt;(std::<span class="built_in">move</span>(socket))-&gt;<span class="built_in">Start</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//不管成功与失败都要继续监听请求</span></span><br><span class="line">		<span class="built_in">http_server</span>(acceptor, socket);</span><br><span class="line">		&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">//服务器的地址，最后不要写内网，现在为了测试写内网</span></span><br><span class="line">		<span class="keyword">auto</span> <span class="type">const</span> address = boost::asio::ip::<span class="built_in">make_address</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">short</span> port = <span class="built_in">static_cast</span>&lt;<span class="type">unsigned</span> <span class="type">short</span>&gt;(<span class="number">8080</span>);</span><br><span class="line">		boost::<span class="function">asio::io_context <span class="title">io_context</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">		boost::asio::ip::tcp::acceptor acceptor&#123; io_context, &#123;address, port&#125; &#125;;</span><br><span class="line">		boost::asio::ip::<span class="function">tcp::socket <span class="title">socket</span><span class="params">(io_context)</span></span>;</span><br><span class="line">		<span class="built_in">http_server</span>(acceptor, socket);</span><br><span class="line">		io_context.<span class="built_in">run</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span> (std::exception e) &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="beast网络库实现websocket服务器"><a href="#beast网络库实现websocket服务器" class="headerlink" title="beast网络库实现websocket服务器"></a>beast网络库实现websocket服务器</h2><h3 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h3><ul>
<li>使用beast网络库实现websocket服务器，一般来说websocket是一个长连接的协议，但是自动包含了解包处理，当我们在浏览器输入一个http请求时如果是以ws开头的如ws://127.0.0.1:9501就是请求本地9501端口的websocket服务器处理。而beast为我们提供了websocket的处理方案，我们可以在http服务器的基础上升级协议为websocket，处理部分websocket请求。如果服务器收到的是普通的http请求则按照http请求处理。我们可以从官方文档中按照示例逐步搭建websocket服务器。</li>
</ul>
<h3 id="构造websocket"><a href="#构造websocket" class="headerlink" title="构造websocket"></a>构造websocket</h3><ul>
<li>原文档连接：<a target="_blank" rel="noopener" href="https://llfc.club/category?catid=225RaiVNI8pFDD5L4m807g7ZwmF#!aid/2Rlhdbut49eOVgjIVq9aj6nF7Rg">https://llfc.club/category?catid=225RaiVNI8pFDD5L4m807g7ZwmF#!aid/2Rlhdbut49eOVgjIVq9aj6nF7Rg</a></li>
</ul>
<h3 id="开发的websocket代码"><a href="#开发的websocket代码" class="headerlink" title="开发的websocket代码"></a>开发的websocket代码</h3><h4 id="Connection-h"><a href="#Connection-h" class="headerlink" title="Connection.h"></a>Connection.h</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/beast.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/uuid/uuid.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/uuid/uuid_generators.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/uuid/uuid_io.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> net = boost::asio;</span><br><span class="line"><span class="keyword">namespace</span> beast = boost::beast;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Connection</span>:<span class="keyword">public</span> std::enable_shared_from_this&lt;Connection&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Connection</span>(net::io_context&amp; ioc);</span><br><span class="line">	<span class="comment">//启动连接</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//发送数据</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Async_Send</span><span class="params">(std::string data)</span></span>;</span><br><span class="line">	<span class="comment">//用于升级为websocket</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Async_Accept</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//发送回调函数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SendCallBack</span><span class="params">(std::string msg)</span></span>;</span><br><span class="line">	<span class="comment">//得到底层socket</span></span><br><span class="line">	net::ip::<span class="function">tcp::socket&amp; <span class="title">GetSocket</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//得到id</span></span><br><span class="line">	<span class="function">std::string <span class="title">GetUuid</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//指向websocket的智能指针</span></span><br><span class="line">	std::unique_ptr&lt;beast::websocket::stream&lt;beast::tcp_stream&gt;&gt; _ws_ptr;</span><br><span class="line">	<span class="comment">//保证时序性的队列</span></span><br><span class="line">	std::queue&lt;std::string&gt; _send_que;</span><br><span class="line">	net::io_context&amp; _ioc;</span><br><span class="line">	<span class="comment">//websocket的缓冲区数据</span></span><br><span class="line">	beast::flat_buffer _recv_buffer;</span><br><span class="line">	std::mutex mtx;</span><br><span class="line">	std::condition_variable cv;</span><br><span class="line">	std::string _uuid;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="Connection-cpp"><a href="#Connection-cpp" class="headerlink" title="Connection.cpp"></a>Connection.cpp</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Connection.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ConnectionMgr.h&quot;</span></span></span><br><span class="line"><span class="comment">//使用strand来让处理变成串行</span></span><br><span class="line">Connection::<span class="built_in">Connection</span>(net::io_context&amp; ioc):_ioc(ioc),</span><br><span class="line">_ws_ptr(std::make_unique&lt;beast::websocket::stream&lt;beast::tcp_stream&gt;&gt;(net::<span class="built_in">make_strand</span>(ioc)))</span><br><span class="line">&#123;</span><br><span class="line">	boost::uuids::random_generator grenerator;</span><br><span class="line">	boost::uuids::uuid uuid = <span class="built_in">grenerator</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//转换为string</span></span><br><span class="line">	_uuid = boost::uuids::<span class="built_in">to_string</span>(uuid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Connection::Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//增加有引用计数</span></span><br><span class="line">	<span class="keyword">auto</span> self = <span class="built_in">shared_from_this</span>();</span><br><span class="line">	<span class="comment">//先接受数据</span></span><br><span class="line">	_ws_ptr-&gt;<span class="built_in">async_read</span>(_recv_buffer, [self](boost::system::error_code ec, std::<span class="type">size_t</span> t) &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;fer.<span class="built_in">size</span>());</span><br><span class="line">			<span class="keyword">if</span> (ec) &#123;</span><br><span class="line">				std::cout &lt;&lt; <span class="string">&quot;websocket async read error is &quot;</span> &lt;&lt; ec.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">				ConnectionMgr::<span class="built_in">GetInstance</span>().<span class="built_in">Remove_Connection</span>(self-&gt;<span class="built_in">GetUuid</span>());</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//用于创建文本消息数据帧，是用来发送的</span></span><br><span class="line">			self-&gt;_ws_ptr-&gt;<span class="built_in">text</span>(self-&gt;_ws_ptr-&gt;<span class="built_in">got_text</span>());</span><br><span class="line">			<span class="comment">//将缓冲区数据转为string格式</span></span><br><span class="line">			<span class="comment">//.data是为了得到起始位置的指针</span></span><br><span class="line">			std::string recv_data = boost::beast::<span class="built_in">buffers_to_string</span>(self-&gt;_recv_buffer.<span class="built_in">data</span>());</span><br><span class="line">			<span class="comment">//清空缓冲区，方便下次接收</span></span><br><span class="line">			self-&gt;_recv_buffer.<span class="built_in">consume</span>(self-&gt;_recv_buffer.<span class="built_in">size</span>());</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;Recevie data is &quot;</span> &lt;&lt; recv_data &lt;&lt; std::endl;</span><br><span class="line">			<span class="comment">//发送回去</span></span><br><span class="line">			self-&gt;<span class="built_in">Async_Send</span>(std::<span class="built_in">move</span>(recv_data));</span><br><span class="line">			<span class="comment">//继续接收数据</span></span><br><span class="line">			self-&gt;<span class="built_in">Start</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">			std::cerr &lt;&lt; <span class="string">&quot;Exception is &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">		&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Connection::Async_Send</span><span class="params">(std::string data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">			<span class="type">int</span> que_len = _send_que.<span class="built_in">size</span>();</span><br><span class="line">			_send_que.<span class="built_in">push</span>(data);</span><br><span class="line">			<span class="keyword">if</span> (que_len &gt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">SendCallBack</span>(std::<span class="built_in">move</span>(data));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">		std::cerr &lt;&lt; <span class="string">&quot;Async Send failed, Exception is &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Connection::Async_Accept</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> self = <span class="built_in">shared_from_this</span>();</span><br><span class="line">	_ws_ptr-&gt;<span class="built_in">async_accept</span>([self](boost::system::error_code err) &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (!err) &#123;</span><br><span class="line">				ConnectionMgr::<span class="built_in">GetInstance</span>().<span class="built_in">Add_Connection</span>(self);</span><br><span class="line">				self-&gt;<span class="built_in">Start</span>();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				std::cout &lt;&lt; <span class="string">&quot;websocket accept failed, err is &quot;</span> &lt;&lt; err.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">catch</span> (std::exception&amp; exp) &#123;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;websocket async accept exception is &quot;</span> &lt;&lt; exp.<span class="built_in">what</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Connection::SendCallBack</span><span class="params">(std::string msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> self = <span class="built_in">shared_from_this</span>();</span><br><span class="line">	<span class="comment">//发送数据给客户端</span></span><br><span class="line">	_ws_ptr-&gt;<span class="built_in">async_write</span>(boost::asio::<span class="built_in">buffer</span>(msg.<span class="built_in">c_str</span>(), msg.<span class="built_in">length</span>()),</span><br><span class="line">		[self](boost::system::error_code err, std::<span class="type">size_t</span>  nsize) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (err) &#123;</span><br><span class="line">					std::cout &lt;&lt; <span class="string">&quot;async send err is &quot;</span> &lt;&lt; err.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">					ConnectionMgr::<span class="built_in">GetInstance</span>().<span class="built_in">Remove_Connection</span>(self-&gt;_uuid);</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				std::string send_msg;</span><br><span class="line">				&#123;</span><br><span class="line">					std::lock_guard&lt;std::mutex&gt; <span class="built_in">lck_gurad</span>(self-&gt;mtx);</span><br><span class="line">					self-&gt;_send_que.<span class="built_in">pop</span>();</span><br><span class="line">					<span class="comment">//如果数据空了就返回</span></span><br><span class="line">					<span class="keyword">if</span> (self-&gt;_send_que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">						<span class="keyword">return</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					send_msg = self-&gt;_send_que.<span class="built_in">front</span>();</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				self-&gt;<span class="built_in">SendCallBack</span>(std::<span class="built_in">move</span>(send_msg));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">catch</span> (std::exception&amp; exp) &#123;</span><br><span class="line">				std::cout &lt;&lt; <span class="string">&quot;async send exception is &quot;</span> &lt;&lt; exp.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">				ConnectionMgr::<span class="built_in">GetInstance</span>().<span class="built_in">Remove_Connection</span>(self-&gt;_uuid);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">net::ip::<span class="function">tcp::socket&amp; <span class="title">Connection::GetSocket</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span>&amp; con_ptr = beast::<span class="built_in">get_lowest_layer</span>(*_ws_ptr).<span class="built_in">socket</span>();</span><br><span class="line">	<span class="keyword">return</span> con_ptr;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> 在此处插入 return 语句</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">Connection::GetUuid</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> _uuid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="ConnectionMgr-h"><a href="#ConnectionMgr-h" class="headerlink" title="ConnectionMgr.h"></a>ConnectionMgr.h</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Connection.h&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConnectionMgr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> ConnectionMgr&amp; <span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Remove_Connection</span><span class="params">(std::string uuid)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Add_Connection</span><span class="params">(std::shared_ptr&lt;Connection&gt; con)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">ConnectionMgr</span>();</span><br><span class="line">	<span class="built_in">ConnectionMgr</span>(<span class="type">const</span> ConnectionMgr&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">	ConnectionMgr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> ConnectionMgr&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">	<span class="comment">//存储连接</span></span><br><span class="line">	std::unordered_map&lt;std::string, std::shared_ptr&lt;Connection&gt;&gt; _cons;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="ConnectionMgr-cpp"><a href="#ConnectionMgr-cpp" class="headerlink" title="ConnectionMgr.cpp"></a>ConnectionMgr.cpp</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ConnectionMgr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">ConnectionMgr&amp; <span class="title">ConnectionMgr::GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">static</span> ConnectionMgr ins;</span><br><span class="line">	<span class="keyword">return</span> ins;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConnectionMgr::Remove_Connection</span><span class="params">(std::string uuid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	_cons.<span class="built_in">erase</span>(uuid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConnectionMgr::Add_Connection</span><span class="params">(std::shared_ptr&lt;Connection&gt; con)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (_cons.<span class="built_in">count</span>(con-&gt;<span class="built_in">GetUuid</span>()) == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">	_cons[con-&gt;<span class="built_in">GetUuid</span>()] = con;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个必须写</span></span><br><span class="line">ConnectionMgr::<span class="built_in">ConnectionMgr</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="WebSocketServer-h"><a href="#WebSocketServer-h" class="headerlink" title="WebSocketServer.h"></a>WebSocketServer.h</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ConnectionMgr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> net = boost::asio;</span><br><span class="line"><span class="keyword">namespace</span> beast = boost::beast;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WebSocketServer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">WebSocketServer</span>(net::io_context&amp; ioc, <span class="type">unsigned</span> <span class="type">short</span> port);</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">StartAccept</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">WebSocketServer</span>(<span class="type">const</span> WebSocketServer&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">	WebSocketServer&amp; <span class="keyword">operator</span>=(<span class="type">const</span> WebSocketServer&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">	</span><br><span class="line">	net::ip::tcp::acceptor _acceptor;</span><br><span class="line">	net::io_context&amp; _io_context;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="WebSocketServer-cpp"><a href="#WebSocketServer-cpp" class="headerlink" title="WebSocketServer.cpp"></a>WebSocketServer.cpp</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;WebSocketServer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Connection.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebSocketServer::StartAccept</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">auto</span> con_ptr = std::<span class="built_in">make_shared</span>&lt;Connection&gt;(_io_context);</span><br><span class="line">		<span class="comment">//监听连接</span></span><br><span class="line">		_acceptor.<span class="built_in">async_accept</span>(con_ptr-&gt;<span class="built_in">GetSocket</span>(), [<span class="keyword">this</span>, con_ptr](boost::system::error_code ec) &#123;</span><br><span class="line">			<span class="keyword">if</span> (ec) &#123;</span><br><span class="line">				std::cout &lt;&lt; <span class="string">&quot;accept failed, error is &quot;</span> &lt;&lt; ec.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//升级http为websocket</span></span><br><span class="line">			con_ptr-&gt;<span class="built_in">Async_Accept</span>();</span><br><span class="line">			<span class="comment">//继续监听连接</span></span><br><span class="line">			<span class="built_in">StartAccept</span>();</span><br><span class="line">			&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">		std::cerr &lt;&lt; <span class="string">&quot;Exception is &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">WebSocketServer::<span class="built_in">WebSocketServer</span>(net::io_context&amp; ioc, <span class="type">unsigned</span> <span class="type">short</span> port):_io_context(ioc),</span><br><span class="line">_acceptor(ioc, net::ip::tcp::<span class="built_in">endpoint</span>(net::ip::tcp::<span class="built_in">v4</span>(), port))</span><br><span class="line">&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Server start on port : &quot;</span> &lt;&lt; port &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="main-cpp"><a href="#main-cpp" class="headerlink" title="main.cpp"></a>main.cpp</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;WebSocketServer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	net::io_context ioc;</span><br><span class="line">	<span class="function">WebSocketServer <span class="title">server</span><span class="params">(ioc, <span class="number">8888</span>)</span></span>;</span><br><span class="line">	server.<span class="built_in">StartAccept</span>();</span><br><span class="line">	ioc.<span class="built_in">run</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><ul>
<li><p>头文件预编译的时候不要出现父子的情况，也就是说beast.hpp 包含了 beast/core，两个一起被编译就会出现问题</p>
</li>
<li><p>一旦声明构造函数，就要显示写出构造函数，因为他不会提供默认构造函数</p>
</li>
</ul>
<h2 id="gRPC的使用"><a href="#gRPC的使用" class="headerlink" title="gRPC的使用"></a>gRPC的使用</h2><ul>
<li>有关gRPC的配置及下载等请查阅<a target="_blank" rel="noopener" href="https://llfc.club/articlepage?id=2QYdExDcUDazjD6ZKNjs8KLcyAp">https://llfc.club/articlepage?id=2QYdExDcUDazjD6ZKNjs8KLcyAp</a></li>
</ul>
<h3 id="gRPC客户端"><a href="#gRPC客户端" class="headerlink" title="gRPC客户端"></a>gRPC客户端</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;grpcpp/grpcpp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;demo.grpc.pb.h&quot;</span> <span class="comment">// 导入生成的 gRPC 协议文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> grpc::ClientContext;</span><br><span class="line"><span class="keyword">using</span> grpc::Channel;</span><br><span class="line"><span class="keyword">using</span> grpc::Status;</span><br><span class="line"><span class="keyword">using</span> hello::HelloReply; <span class="comment">// 导入生成的 HelloReply 类</span></span><br><span class="line"><span class="keyword">using</span> hello::HelloRequest; <span class="comment">// 导入生成的 HelloRequest 类</span></span><br><span class="line"><span class="keyword">using</span> hello::Greeter; <span class="comment">// 导入生成的 Greeter 服务</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 gRPC 客户端类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FCClient</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，传入 gRPC 通道，初始化 stub_</span></span><br><span class="line">    <span class="built_in">FCClient</span>(std::shared_ptr&lt;Channel&gt; channel) : <span class="built_in">stub_</span>(Greeter::<span class="built_in">NewStub</span>(channel)) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 客户端调用远程服务的方法</span></span><br><span class="line">    <span class="function">std::string <span class="title">SayHello</span><span class="params">(std::string name)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建客户端上下文</span></span><br><span class="line">        ClientContext context;</span><br><span class="line">        <span class="comment">// 创建请求和响应对象</span></span><br><span class="line">        HelloReply reply;</span><br><span class="line">        HelloRequest request;</span><br><span class="line">        <span class="comment">// 设置请求消息内容</span></span><br><span class="line">        request.<span class="built_in">set_message</span>(name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用远程服务的 SayHello 方法，并传入请求和响应对象</span></span><br><span class="line">        <span class="comment">// 注意：此处是同步调用，会阻塞当前线程直到得到响应或者发生错误</span></span><br><span class="line">        Status status = stub_-&gt;<span class="built_in">SayHello</span>(&amp;context, request, &amp;reply);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查调用是否成功</span></span><br><span class="line">        <span class="keyword">if</span> (status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">            <span class="comment">// 返回服务端返回的消息内容</span></span><br><span class="line">            <span class="keyword">return</span> reply.<span class="built_in">message</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 返回失败信息，包含错误信息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;failure &quot;</span> + status.<span class="built_in">error_message</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 定义 gRPC 客户端 stub</span></span><br><span class="line">    std::unique_ptr&lt;Greeter::Stub&gt; stub_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建 gRPC 通道，连接 gRPC 服务器</span></span><br><span class="line">    <span class="keyword">auto</span> channel = grpc::<span class="built_in">CreateChannel</span>(<span class="string">&quot;127.0.0.1:8888&quot;</span>, grpc::<span class="built_in">InsecureChannelCredentials</span>());</span><br><span class="line">    <span class="comment">// 创建 gRPC 客户端对象</span></span><br><span class="line">    <span class="function">FCClient <span class="title">client</span><span class="params">(channel)</span></span>;</span><br><span class="line">    <span class="comment">// 调用客户端方法，向服务器发送消息，并接收服务器返回的结果</span></span><br><span class="line">    std::string result = client.<span class="built_in">SayHello</span>(<span class="string">&quot;hello, zxn!&quot;</span>);</span><br><span class="line">    <span class="comment">// 打印客户端收到的结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;get result is &quot;</span> &lt;&lt; result.<span class="built_in">c_str</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>客户端创建了一个channel，然后调用NewStub生成stub，接下来就可以发送数据了，下面是运行的效果</li>
<li>其中stub是用来远程调用服务端的必要东西</li>
</ul>
<h3 id="gRPC服务端"><a href="#gRPC服务端" class="headerlink" title="gRPC服务端"></a>gRPC服务端</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;grpcpp/grpcpp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;demo.grpc.pb.h&quot;</span> <span class="comment">// 导入生成的 gRPC 协议文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> grpc::Server; <span class="comment">// gRPC 服务器</span></span><br><span class="line"><span class="keyword">using</span> grpc::ServerBuilder; <span class="comment">// 服务器构建器</span></span><br><span class="line"><span class="keyword">using</span> grpc::ServerContext; <span class="comment">// 服务器上下文</span></span><br><span class="line"><span class="keyword">using</span> grpc::Status; <span class="comment">// 状态</span></span><br><span class="line"><span class="keyword">using</span> hello::HelloRequest; <span class="comment">// 请求消息类型</span></span><br><span class="line"><span class="keyword">using</span> hello::HelloReply; <span class="comment">// 响应消息类型</span></span><br><span class="line"><span class="keyword">using</span> hello::Greeter; <span class="comment">// 服务接口类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 Greeter 服务的具体类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GreeterServiceImpl</span> <span class="keyword">final</span> : <span class="keyword">public</span> Greeter::Service &#123;</span><br><span class="line">    <span class="comment">// 实现服务定义的方法</span></span><br><span class="line">    <span class="function">Status <span class="title">SayHello</span><span class="params">(::grpc::ServerContext* context,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> ::hello::HelloRequest* request, ::hello::HelloReply* response)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 构造响应消息，包含客户端发来的消息内容</span></span><br><span class="line">        <span class="function">std::string <span class="title">prefix</span><span class="params">(<span class="string">&quot;zxn grpc server has received: &quot;</span>)</span></span>;</span><br><span class="line">        response-&gt;<span class="built_in">set_message</span>(prefix + request-&gt;<span class="built_in">message</span>());</span><br><span class="line">        <span class="comment">// 返回状态为 OK，表示处理成功</span></span><br><span class="line">        <span class="keyword">return</span> Status::OK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动 gRPC 服务器的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RunServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::string <span class="title">server_address</span><span class="params">(<span class="string">&quot;0.0.0.0:8888&quot;</span>)</span></span>; <span class="comment">// 服务器地址</span></span><br><span class="line">    GreeterServiceImpl service; <span class="comment">// 创建 Greeter 服务实现对象</span></span><br><span class="line">    ServerBuilder builder; <span class="comment">// 创建服务器构建器</span></span><br><span class="line">    builder.<span class="built_in">AddListeningPort</span>(server_address, grpc::<span class="built_in">InsecureServerCredentials</span>()); <span class="comment">// 添加监听端口和凭证</span></span><br><span class="line">    builder.<span class="built_in">RegisterService</span>(&amp;service); <span class="comment">// 注册服务</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建并启动服务器</span></span><br><span class="line">    <span class="function">std::unique_ptr&lt;Server&gt; <span class="title">server</span><span class="params">(builder.BuildAndStart())</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Server listening on &quot;</span> &lt;&lt; server_address &lt;&lt; std::endl; <span class="comment">// 输出服务器启动信息</span></span><br><span class="line">    server-&gt;<span class="built_in">Wait</span>(); <span class="comment">// 等待服务器关闭</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">RunServer</span>(); <span class="comment">// 运行 gRPC 服务器</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello World!\n&quot;</span>; <span class="comment">// 打印消息，表示服务器运行结束</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>GreeterServiceImpl 继承自 Greeter::Service，重写了SayHello函数，当收到客户端发送的SayHello请求后执行重写函数功能的逻辑。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>C++asio网络编程</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://pigcanstudy.github.io/posts/9724705.html">https://pigcanstudy.github.io/posts/9724705.html</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>PigCanStudy</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2024-07-18</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2024-07-18</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/asio%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"><div class="tags-punctuation"><svg class="faa-tada icon" style="height:1.1em;width:1.1em;fill:currentColor;position:relative;top:2px;margin-right:3px" aria-hidden="true"><use xlink:href="#icon-sekuaibiaoqian"></use></svg></div>asio网络编程</a><a class="post-meta__tags" href="/tags/C/"><div class="tags-punctuation"><svg class="faa-tada icon" style="height:1.1em;width:1.1em;fill:currentColor;position:relative;top:2px;margin-right:3px" aria-hidden="true"><use xlink:href="#icon-sekuaibiaoqian"></use></svg></div>C++</a><a class="post-meta__tags" href="/tags/boost/"><div class="tags-punctuation"><svg class="faa-tada icon" style="height:1.1em;width:1.1em;fill:currentColor;position:relative;top:2px;margin-right:3px" aria-hidden="true"><use xlink:href="#icon-sekuaibiaoqian"></use></svg></div>boost</a></div></div><link rel="stylesheet" href="/css/coin.css" media="defer" onload="this.media='all'"/><div class="post-reward"><button class="tip-button reward-button"><span class="tip-button__text">投喂作者</span><div class="coin-wrapper"><div class="coin"><div class="coin__middle"></div><div class="coin__back"></div><div class="coin__front"></div></div></div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://tuchuang.voooe.cn/images/2023/01/04/2.webp" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://tuchuang.voooe.cn/images/2023/01/04/2.webp" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://tuchuang.voooe.cn/images/2023/01/04/20f8e49805975b8f8.webp" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://tuchuang.voooe.cn/images/2023/01/04/20f8e49805975b8f8.webp" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></button></div><audio id="coinAudio" src="https://npm.elemecdn.com/akilar-candyassets@1.0.36/audio/aowu.m4a"></audio><script defer="defer" src="/js/coin.js"></script><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/4389eda5.html"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_14.webp" onerror="onerror=null;src='/assets/r2.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">muduo网络库学习</div></div></a></div><div class="next-post pull-right"><a href="/posts/6e928d8a.html"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_14.webp" onerror="onerror=null;src='/assets/r2.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">C++Qt</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/6e928d8a.html" title="C++Qt"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_14.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-07-18</div><div class="title">C++Qt</div></div></a></div><div><a href="/posts/e8e79e61.html" title="C++并发编程"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_14.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-07-18</div><div class="title">C++并发编程</div></div></a></div><div><a href="/posts/2f7ff9a3.html" title="C++面试笔记"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_14.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-07-18</div><div class="title">C++面试笔记</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><svg class="meta_icon" style="width:22px;height:22px;position:relative;top:5px"><use xlink:href="#icon-mulu1"></use></svg><span style="font-weight:bold">目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95"><span class="toc-text">目录</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B"><span class="toc-text">网络编程的基本流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%88%E7%AB%AF%E8%8A%82%E7%82%B9%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-text">终端节点的创建</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B9%8B%E7%BB%88%E7%AB%AF%E8%8A%82%E7%82%B9%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-text">客户端之终端节点的创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%B9%8B%E7%BB%88%E7%AB%AF%E8%8A%82%E7%82%B9%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-text">服务端之终端节点的创建</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAsocket"><span class="toc-text">创建socket</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B9%8B%E5%88%9B%E5%BB%BAsocket"><span class="toc-text">服务端与客户端之创建socket</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%B9%8B%E6%8E%A5%E6%94%B6%E9%93%BE%E6%8E%A5%E8%AF%B7%E6%B1%82%E7%9A%84socket%EF%BC%88%E5%AF%B9%E5%BA%94accept%EF%BC%89"><span class="toc-text">服务端之接收链接请求的socket（对应accept）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%91%E5%AE%9Aacceptor"><span class="toc-text">绑定acceptor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E4%BB%A5%E6%8A%8A%E7%AB%AF%E5%8F%A3%E7%BB%91%E5%AE%9A%E5%92%8Cacceptor%E7%9A%84%E4%BC%A0%E5%BB%BA%E5%90%88%E8%B5%B7%E6%9D%A5%E5%86%99"><span class="toc-text">可以把端口绑定和acceptor的传建合起来写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E6%8C%87%E5%AE%9A%E7%9A%84%E7%AB%AF%E7%82%B9"><span class="toc-text">链接指定的端点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A5%E6%94%B6%E6%9D%A5%E8%BF%9E%E6%8E%A5"><span class="toc-text">服务器接收来连接</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAacceptor%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-text">创建acceptor的几种方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8Ebuffer"><span class="toc-text">关于buffer</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84buffer"><span class="toc-text">字符串的buffer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84buffer"><span class="toc-text">数组的buffer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E5%BC%8F%E7%9A%84buffer"><span class="toc-text">流式的buffer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E7%9A%84buffer"><span class="toc-text">容器的buffer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E5%90%91%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E6%8C%87%E9%92%88%E7%9A%84buffer"><span class="toc-text">指向缓冲区的指针的buffer</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E8%AF%BB%E5%86%99"><span class="toc-text">同步读写</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%86%99-write-some"><span class="toc-text">同步写 write_some</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%86%99-send"><span class="toc-text">同步写 send</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%86%99-write"><span class="toc-text">同步写 write</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E8%AF%BB-read-some"><span class="toc-text">同步读 read_some</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E8%AF%BB-receive"><span class="toc-text">同步读 receive</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E8%AF%BB-read"><span class="toc-text">同步读 read</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E7%9B%B4%E5%88%B0%E6%8C%87%E5%AE%9A%E5%AD%97%E7%AC%A6"><span class="toc-text">读取直到指定字符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E8%AF%BB%E5%86%99%E7%9A%84%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-text">同步读写的客户端与服务端</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-text">客户端的设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AE%BE%E8%AE%A1"><span class="toc-text">服务端设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#session%E5%87%BD%E6%95%B0"><span class="toc-text">session函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#server%E5%87%BD%E6%95%B0"><span class="toc-text">server函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BB%A3%E7%A0%81"><span class="toc-text">完整服务端代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E8%AF%BB%E5%86%99%E7%9A%84%E4%BC%98%E5%8A%A3"><span class="toc-text">同步读写的优劣</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#asio%E5%BC%82%E6%AD%A5%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C%E5%8F%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">asio异步读写操作及注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%86%99%E6%93%8D%E4%BD%9C"><span class="toc-text">异步写操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E8%AF%BB%E6%93%8D%E4%BD%9C"><span class="toc-text">异步读操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81"><span class="toc-text">总结 完整代码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Session-h%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-text">Session.h头文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Session-cpp"><span class="toc-text">Session.cpp</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#asio%E5%AE%98%E6%96%B9%E6%A1%88%E4%BE%8B%E5%AD%98%E5%9C%A8%E7%9A%84%E9%9A%90%E6%82%A3"><span class="toc-text">asio官方案例存在的隐患</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Session%E7%B1%BB"><span class="toc-text">Session类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Server%E7%B1%BB"><span class="toc-text">Server类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Server%E5%AE%9E%E7%8E%B0"><span class="toc-text">Server实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E6%82%A3"><span class="toc-text">隐患</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81"><span class="toc-text">完整代码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-text">头文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-text">实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%BC%AA%E9%97%AD%E5%8C%85%E5%AE%9E%E7%8E%B0%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%AE%89%E5%85%A8%E5%9B%9E%E6%94%B6"><span class="toc-text">使用伪闭包实现连接的安全回收</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%AE%A1%E7%90%86Session"><span class="toc-text">智能指针管理Session</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Session%E7%9A%84uuid"><span class="toc-text">Session的uuid</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E6%82%A31"><span class="toc-text">隐患1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%BC%AA%E9%97%AD%E5%8C%85"><span class="toc-text">如何实现伪闭包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-text">完整的代码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B01"><span class="toc-text">实现1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B61"><span class="toc-text">头文件1</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%91%E9%80%81%E9%98%9F%E5%88%97"><span class="toc-text">封装服务器发送队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%8A%82%E7%82%B9%E8%AE%BE%E8%AE%A1"><span class="toc-text">数据节点设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%E5%8F%91%E9%80%81%E6%8E%A5%E5%8F%A3"><span class="toc-text">封装发送接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E8%AF%BB%E5%9B%9E%E8%B0%83"><span class="toc-text">修改读回调</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%A5%E8%8A%82%E6%80%BB%E7%BB%93"><span class="toc-text">该节总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%E5%90%8E%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81"><span class="toc-text">封装后完整代码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#msgNode"><span class="toc-text">msgNode</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CSession"><span class="toc-text">CSession</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CServer"><span class="toc-text">CServer</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-text">处理网络粘包问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B2%98%E5%8C%85"><span class="toc-text">什么是粘包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B2%98%E5%8C%85%E5%8E%9F%E5%9B%A0"><span class="toc-text">粘包原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E7%B2%98%E5%8C%85"><span class="toc-text">处理粘包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E5%96%84%E6%B6%88%E6%81%AF%E8%8A%82%E7%82%B9"><span class="toc-text">完善消息节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSession%E7%B1%BB%E5%AE%8C%E5%96%84"><span class="toc-text">CSession类完善</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E5%96%84%E6%8E%A5%E6%94%B6%E9%80%BB%E8%BE%91"><span class="toc-text">完善接收逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81"><span class="toc-text">服务端完整代码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CSession%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-text">CSession头文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CSession-%E5%AE%9E%E7%8E%B0"><span class="toc-text">CSession 实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CServer%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-text">CServer头文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CServer%E5%AE%9E%E7%8E%B0"><span class="toc-text">CServer实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MsgNode"><span class="toc-text">MsgNode</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BF%AE%E6%94%B9"><span class="toc-text">客户端修改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B2%98%E5%8C%85%E6%B5%8B%E8%AF%95"><span class="toc-text">粘包测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E5%89%8D%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-text">目前服务端通信流程图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#io-context"><span class="toc-text">io_context</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E5%BA%8F%E5%A4%84%E7%90%86%E5%92%8C%E5%8F%91%E9%80%81%E9%98%9F%E5%88%97%E6%8E%A7%E5%88%B6"><span class="toc-text">字节序处理和发送队列控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E5%BA%8F%E9%97%AE%E9%A2%98"><span class="toc-text">字节序问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%8C%BA%E5%88%86%E6%9C%AC%E6%9C%BA%E5%AD%97%E8%8A%82%E5%BA%8F"><span class="toc-text">如何区分本机字节序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BD%BF%E7%94%A8%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F"><span class="toc-text">服务器使用网络字节序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%8E%A7%E5%88%B6"><span class="toc-text">消息队列控制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#protobuf%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-text">protobuf配置和使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#portobuf%E7%AE%80%E4%BB%8B"><span class="toc-text">portobuf简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90pb%E6%96%87%E4%BB%B6"><span class="toc-text">生成pb文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">在网络编程中的应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jsoncpp%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E9%85%8D%E7%BD%AE"><span class="toc-text">jsoncpp的使用与配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E5%8F%82%E8%80%83%E6%88%91%E7%9A%84csdn%E6%94%B6%E8%97%8F"><span class="toc-text">配置参考我的csdn收藏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95"><span class="toc-text">测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">网络编程中的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E7%89%88JSON%E5%BA%93-nlohmann-json"><span class="toc-text">新版JSON库 nlohmann&#x2F;json</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#asio%E7%B2%98%E5%8C%85%E5%A4%84%E7%90%86%E7%9A%84%E7%AE%80%E5%8D%95%E6%96%B9%E5%BC%8F"><span class="toc-text">asio粘包处理的简单方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E6%96%B9%E5%BC%8F"><span class="toc-text">简单方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%A4%B4%E9%83%A8%E6%95%B0%E6%8D%AE"><span class="toc-text">获取头部数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%B6%88%E6%81%AF%E4%BD%93"><span class="toc-text">获取消息体</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%BB%E8%BE%91%E5%B1%82%E8%AE%BE%E8%AE%A1%E5%92%8C%E6%B6%88%E6%81%AF%E5%AE%8C%E5%96%84"><span class="toc-text">服务器逻辑层设计和消息完善</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B1"><span class="toc-text">简介1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-text">服务器架构设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%A4%B4%E5%AE%8C%E5%96%84"><span class="toc-text">消息头完善</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%91%E4%BB%AC%E5%B0%86%E4%B8%8A%E8%BF%B0%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89%E5%9C%A8MsgNode-h%E4%B8%AD"><span class="toc-text">我们将上述结构定义在MsgNode.h中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0MsgNode"><span class="toc-text">实现MsgNode</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Session%E7%B1%BB%E6%94%B9%E5%86%99"><span class="toc-text">Session类改写</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E7%9A%84%E4%BB%A3%E7%A0%812"><span class="toc-text">完整的代码2</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Session-h"><span class="toc-text">Session.h</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Session-cpp-1"><span class="toc-text">Session.cpp</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E9%80%BB%E8%BE%91%E5%B1%82%E8%AE%BE%E8%AE%A1"><span class="toc-text">单例模式实现逻辑层设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E6%9D%BF%E7%B1%BB"><span class="toc-text">单例模板类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LogicSystem%E5%8D%95%E4%BE%8B%E7%B1%BB"><span class="toc-text">LogicSystem单例类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#LogicSystem-%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81"><span class="toc-text">LogicSystem 完整代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6-1"><span class="toc-text">头文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-1"><span class="toc-text">实现</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BC%98%E9%9B%85%E9%80%80%E5%87%BA"><span class="toc-text">服务器优雅退出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%80%E5%87%BA%E6%96%B9%E5%BC%8F1%EF%BC%9A%E5%BC%80%E8%BE%9F%E7%BA%BF%E7%A8%8B%EF%BC%8C%E8%AE%A9%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%90%E8%A1%8C%E5%9C%A8%E7%BA%BF%E7%A8%8B%E4%B8%AD%E5%B9%B6%E6%8E%A5%E5%8F%97%E9%80%80%E5%87%BA%E4%BF%A1%E5%8F%B7%E9%80%80%E5%87%BA"><span class="toc-text">退出方式1：开辟线程，让服务器运行在线程中并接受退出信号退出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%80%E5%87%BA%E6%96%B9%E5%BC%8F2%EF%BC%9A%E4%BD%BF%E7%94%A8asio%E5%BA%95%E5%B1%82%E5%BC%82%E6%AD%A5%E7%AD%89%E5%BE%85%E5%87%BD%E6%95%B0"><span class="toc-text">退出方式2：使用asio底层异步等待函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#asio%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8BIOServicePool"><span class="toc-text">asio多线程模型IOServicePool</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-1"><span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AF%B9%E6%AF%94"><span class="toc-text">单线程和多线程对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IOServicePool%E5%AE%9E%E7%8E%B0"><span class="toc-text">IOServicePool实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IOServicePool%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-text">IOServicePool的声明:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-2"><span class="toc-text">实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E9%9B%85%E9%80%80%E5%87%BA"><span class="toc-text">优雅退出</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#asio%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%BC%8FIOThreadPool"><span class="toc-text">asio多线程模式IOThreadPool</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%9B%BE"><span class="toc-text">结构图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%88%E5%AE%9E%E7%8E%B0IOThreadPool"><span class="toc-text">先实现IOThreadPool</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IOThreadPool-%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-text">IOThreadPool 头文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IOThreadPool-%E5%AE%9E%E7%8E%B0"><span class="toc-text">IOThreadPool 实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#iocp%E7%9A%84%E6%B5%81%E7%A8%8B%E6%98%AF%E8%BF%99%E6%A0%B7%E7%9A%84"><span class="toc-text">iocp的流程是这样的</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#epoll%E6%B5%81%E7%A8%8B%E6%98%AF%E8%BF%99%E6%A0%B7%E7%9A%84"><span class="toc-text">epoll流程是这样的</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E6%82%A3-1"><span class="toc-text">隐患</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8strand%E6%94%B9%E8%BF%9B"><span class="toc-text">利用strand改进</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSession%E4%BB%A3%E7%A0%81"><span class="toc-text">CSession代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94"><span class="toc-text">性能对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%96%E8%88%8D"><span class="toc-text">取舍</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#boost-asio%E5%8D%8F%E7%A8%8B%E5%AE%9E%E7%8E%B0%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-text">boost::asio协程实现并发服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-2"><span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E6%A1%88%E4%BE%8B"><span class="toc-text">协程案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-text">完整并发服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AsiIOServicePool"><span class="toc-text">AsiIOServicePool</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#AsioIOServicePool%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-text">AsioIOServicePool头文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#AsioIOServicePool%E5%AE%9E%E7%8E%B0"><span class="toc-text">AsioIOServicePool实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cosnt-h"><span class="toc-text">cosnt.h</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CServer-1"><span class="toc-text">CServer</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#CServer%E5%A4%B4%E6%96%87%E4%BB%B6-1"><span class="toc-text">CServer头文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CServer%E5%AE%9E%E7%8E%B0-1"><span class="toc-text">CServer实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CSession-1"><span class="toc-text">CSession</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#CSession-h"><span class="toc-text">CSession.h</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CSession%E5%AE%9E%E7%8E%B0"><span class="toc-text">CSession实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LogicSystem"><span class="toc-text">LogicSystem</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#LogicSystem%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-text">LogicSystem头文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#LogicSystem%E5%AE%9E%E7%8E%B0"><span class="toc-text">LogicSystem实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MsgNode-1"><span class="toc-text">MsgNode</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#MsgNode%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-text">MsgNode头文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#MsgNode-%E5%AE%9E%E7%8E%B0"><span class="toc-text">MsgNode 实现</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8asio%E5%AE%9E%E7%8E%B0http%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-text">使用asio实现http服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-3"><span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Http%E5%8C%85%E5%A4%B4%E4%BF%A1%E6%81%AF"><span class="toc-text">Http包头信息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP%E8%AF%B7%E6%B1%82%E5%A4%B4"><span class="toc-text">HTTP请求头</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP%E5%93%8D%E5%BA%94%E5%A4%B4"><span class="toc-text">HTTP响应头</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8beast%E7%BD%91%E7%BB%9C%E5%BA%93%E5%AE%9E%E7%8E%B0http%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-text">使用beast网络库实现http服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-4"><span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E7%B1%BB"><span class="toc-text">连接类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81-1"><span class="toc-text">完整代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#beast%E7%BD%91%E7%BB%9C%E5%BA%93%E5%AE%9E%E7%8E%B0websocket%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-text">beast网络库实现websocket服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-5"><span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0websocket"><span class="toc-text">构造websocket</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E7%9A%84websocket%E4%BB%A3%E7%A0%81"><span class="toc-text">开发的websocket代码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Connection-h"><span class="toc-text">Connection.h</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Connection-cpp"><span class="toc-text">Connection.cpp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ConnectionMgr-h"><span class="toc-text">ConnectionMgr.h</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ConnectionMgr-cpp"><span class="toc-text">ConnectionMgr.cpp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WebSocketServer-h"><span class="toc-text">WebSocketServer.h</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WebSocketServer-cpp"><span class="toc-text">WebSocketServer.cpp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#main-cpp"><span class="toc-text">main.cpp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gRPC%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">gRPC的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#gRPC%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-text">gRPC客户端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gRPC%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-text">gRPC服务端</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-color: transparent;"><div id="footer-wrap"><div id="ft"><div class="ft-item-1"><div class="t-top"><div class="t-t-l"><p class="ft-t t-l-t">格言🧬</p><div class="bg-ad"><div>再看看那个光点，它就在这里，这是家园，这是我们 —— 你所爱的每一个人，你认识的一个人，你听说过的每一个人，曾经有过的每一个人，都在它上面度过他们的一生✨</div><div class="btn-xz-box"><a class="btn-xz" target="_blank" rel="noopener" href="https://stellarium.org/">点击开启星辰之旅</a></div></div></div><div class="t-t-r"><p class="ft-t t-l-t">猜你想看💡</p><ul class="ft-links"><li><a href="/posts/eec9786.html">魔改指南</a><a href="/box/nav/">网址导航</a></li><li><a href="/social/link/">我的朋友</a><a href="/comments/">留点什么</a></li><li><a href="/personal/about/">关于作者</a><a href="/archives/">文章归档</a></li><li><a href="/categories/">文章分类</a><a href="/tags/">文章标签</a></li><li><a href="/box/Gallery/">我的画廊</a><a href="/personal/bb/">我的唠叨</a></li><li><a href="/site/time/">建设进程</a><a href="/site/census/">网站统计</a></li></ul></div></div></div><div class="ft-item-2"><p class="ft-t">推荐友链⌛</p><div class="ft-img-group"><div class="img-group-item"><a target="_blank" rel="noopener" href="https://www.fomal.cc/" title="Fomalhaut🥝"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/60e5d4e39da7c077.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div></div></div></div><div class="copyright"><span><b>&copy;2022-2024</b></span><span><b>&nbsp;&nbsp;By PigCanStudy</b></span></div><div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" title="博客框架为Hexo_v6.3.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Frame-Hexo-blue.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" title="主题版本Butterfly_v4.3.1"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Theme-Butterfly-6513df.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" title="本站采用多线部署，主线路托管于Vercel"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Hosted-Vercel-brightgreen.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://user.51.la/" style="margin-inline:5px" title="本站数据分析得益于51la技术支持"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Analytics-51la-3db1eb.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://icp.gov.moe/?keyword=20226665" style="margin-inline:5px" title="本站已加入萌ICP豪华套餐，萌ICP备20226665号"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/萌ICP备-20226665-fe1384.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://bitiful.dogecast.com/buckets" style="margin-inline:5px" title="本网站经Service Worker分流至缤纷云对象存储"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src=" https://sourcebucket.s3.ladydaily.com/badge/Bucket-缤纷云-9c62da.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://www.netdun.net/" style="margin-inline:5px" title="本站使用网盾星球提供CDN加速与防护"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/CDN-网盾星球-fff2cc.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" title="本网站源码由Github提供存储仓库"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src=" https://sourcebucket.s3.ladydaily.com/badge/Source-Github-d021d6.svg" alt=""/></a></p></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button class="share" type="button" title="右键模式" onclick="changeMouseMode()"><i class="fas fa-mouse"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog right_side"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button class="share" type="button" title="分享链接" onclick="share()"><i class="fas fa-share-nodes"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i><span id="percent">0<span>%</span></span></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();"><i class="fa fa-copy"></i><span>复制</span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.baidu.com/s?wd=&quot;+window.getSelection().toString());window.location.reload();"><i class="fa fa-search"></i><span>百度搜索</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();"><i class="fa fa-link"></i><span>转到链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()"><i class="fa fa-copy"></i><span>粘贴</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-post"><a class="rightMenu-item" href="#post-comment"><i class="fas fa-comment"></i><span>空降评论</span></a><a class="rightMenu-item" href="javascript:rmf.copyWordsLink()"><i class="fa fa-link"></i><span>复制本文地址</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>新窗口打开</span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()"><i class="fa fa-link"></i><span>转到链接</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()"><i class="fa fa-download"></i><span>保存图片</span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>在新窗口打开</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制图片链接</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:randomPost()"><i class="fa fa-paper-plane"></i><span>随便逛逛</span></a><a class="rightMenu-item" href="javascript:switchNightMode();"><i class="fa fa-moon"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="/personal/about/"><i class="fa fa-info-circle"></i><span>关于博客</span></a><a class="rightMenu-item" href="javascript:toggleWinbox();"><i class="fas fa-cog"></i><span>美化设置</span></a><a class="rightMenu-item" href="javascript:rmf.fullScreen();"><i class="fas fa-expand"></i><span>切换全屏</span></a><a class="rightMenu-item" href="javascript:window.print();"><i class="fa-solid fa-print"></i><span>打印页面</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.umd.min.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/instant.page/5.1.0/instantpage.min.js" type="module"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/vanilla-lazyload/17.3.1/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><script async="async">var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())
setTimeout(function(){preloader.endLoading();}, 5000);
document.getElementById('loading-box').addEventListener('click',()=> {preloader.endLoading()})</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: '',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: '',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.staticfile.org/twikoo/1.6.8/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script src="https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js"></script><script async src="https://cdn1.tianli0.top/npm/vue@2.6.14/dist/vue.min.js"></script><script async src="https://cdn1.tianli0.top/npm/element-ui@2.15.6/lib/index.js"></script><script async src="https://cdn.bootcdn.net/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script><script defer type="text/javascript" src="https://cdn1.tianli0.top/npm/sweetalert2@8.19.0/dist/sweetalert2.all.js"></script><script async src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><script defer src="https://cdn1.tianli0.top/gh/nextapps-de/winbox/dist/winbox.bundle.min.js"></script><script async src="//at.alicdn.com/t/c/font_3586335_hsivh70x0fm.js"></script><script async src="//at.alicdn.com/t/c/font_3636804_gr02jmjr3y9.js"></script><script async src="//at.alicdn.com/t/c/font_3612150_kfv55xn3u2g.js"></script><script async src="https://cdn.wpon.cn/2022-sucai/Gold-ingot.js"></script><canvas id="universe"></canvas><canvas id="snow"></canvas><script defer src="/js/fomal.js"></script><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.js"></script><script src="https://cdn1.tianli0.top/npm/js-heo@1.0.12/metingjs/Meting.min.js"></script><script src="https://lib.baomitu.com/pjax/0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show","#web_bg",".js-pjax","#bibi","body > title","#app","#tag-echarts","#posts-echart","#categories-echarts"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><a class="magnet_link_more"  href="https://pigcanstudy.github.io/categories/" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(33.333333333333336% - 5px);background: #e9e9e9;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: var(--text-bg-hover)}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/95787e92.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-07-16</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/95787e92.html&quot;);" href="javascript:void(0);" alt="">网络编程教程</a><div class="blog-slider__text">🥧本文介绍了linux基础的系统编程和基础的Linux网络编程</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/95787e92.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/2f7ff9a3.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-07-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/2f7ff9a3.html&quot;);" href="javascript:void(0);" alt="">C++面试笔记</a><div class="blog-slider__text">本文介绍了C++面试笔记的相关知识</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/2f7ff9a3.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/e8e79e61.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-07-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/e8e79e61.html&quot;);" href="javascript:void(0);" alt="">C++并发编程</a><div class="blog-slider__text">本文介绍了C++并发编程的相关知识</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/e8e79e61.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/6e928d8a.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-07-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/6e928d8a.html&quot;);" href="javascript:void(0);" alt="">C++Qt</a><div class="blog-slider__text">本文介绍了C++Qt的相关知识</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/6e928d8a.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/9724705.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-07-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/9724705.html&quot;);" href="javascript:void(0);" alt="">C++asio网络编程</a><div class="blog-slider__text">本文介绍了C++运用asio进行网络编程的相关知识</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/9724705.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><script data-pjax src="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.js"></script><script data-pjax>
  function gitcalendar_injector_config(){
      var parent_div_git = document.getElementById('gitZone');
      var item_html = '<div class="recent-post-item" id="gitcalendarBar" style="width:100%;height:auto;padding:10px;"><style>#git_container{min-height: 320px}@media screen and (max-width:650px) {#git_container{min-height: 0px}}</style><div id="git_loading" style="width:10%;height:100%;margin:0 auto;display: block;"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animatetransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animatetransform></path></svg><style>#git_container{display: none;}</style></div><div id="git_container"></div></div>';
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      console.log('已挂载gitcalendar')
      }

    if( document.getElementById('gitZone') && (location.pathname ==='/site/census/'|| '/site/census/' ==='all')){
        gitcalendar_injector_config()
        GitCalendarInit("/api?null",['#d9e0df', '#c6e0dc', '#a8dcd4', '#9adcd2', '#89ded1', '#77e0d0', '#5fdecb', '#47dcc6', '#39dcc3', '#1fdabe', '#00dab9'],'null')
    }
  </script><!-- hexo injector body_end end --></body></html>