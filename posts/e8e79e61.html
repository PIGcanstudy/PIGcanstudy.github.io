<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><div id="myscoll"></div><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>C++并发编程 | PigCanStudy</title><meta name="keywords" content="C++,并发编程"><meta name="author" content="PigCanStudy"><meta name="copyright" content="PigCanStudy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="本文介绍了C++并发编程的相关知识">
<meta property="og:type" content="article">
<meta property="og:title" content="C++并发编程">
<meta property="og:url" content="https://pigcanstudy.github.io/posts/e8e79e61.html">
<meta property="og:site_name" content="PigCanStudy">
<meta property="og:description" content="本文介绍了C++并发编程的相关知识">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://source.fomal.cc/img/default_cover_14.webp">
<meta property="article:published_time" content="2024-07-18T02:49:00.000Z">
<meta property="article:modified_time" content="2024-07-18T02:50:00.000Z">
<meta property="article:author" content="PigCanStudy">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="并发编程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://source.fomal.cc/img/default_cover_14.webp"><link rel="shortcut icon" href="/"><link rel="canonical" href="https://pigcanstudy.github.io/posts/e8e79e61"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/6.0.0/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.js',
      css: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++并发编程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-07-18 10:50:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/element-ui@2.15.6/packages/theme-chalk/lib/index.css"><style id="themeColor"></style><style id="rightSide"></style><style id="transPercent"></style><style id="blurNum"></style><style id="settingStyle"></style><span id="fps"></span><style id="defineBg"></style><style id="menu_shadow"></style><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="PigCanStudy" type="application/atom+xml">
</head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://tuchuang.voooe.cn/images/2023/01/02/avatar.webp" onerror="onerror=null;src='/assets/r1.jpg'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-home"></use></svg><span class="menu_word" style="font-size:17px"> 首页</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--article"></use></svg><span class="menu_word" style="font-size:17px"> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-guidang1">                   </use></svg><span class="menu_word" style="font-size:17px"> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-sekuaibiaoqian">                   </use></svg><span class="menu_word" style="font-size:17px"> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-fenlei">                   </use></svg><span class="menu_word" style="font-size:17px"> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pinweishenghuo"></use></svg><span class="menu_word" style="font-size:17px"> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/life/music/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-yinle">                   </use></svg><span class="menu_word" style="font-size:17px"> 八音盒</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/movies/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-dianying1">                   </use></svg><span class="menu_word" style="font-size:17px"> 影院</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/games/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-youxishoubing">                   </use></svg><span class="menu_word" style="font-size:17px"> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xiangzi"></use></svg><span class="menu_word" style="font-size:17px"> 八宝箱</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/box/gallery/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-tubiaozhizuomoban">                   </use></svg><span class="menu_word" style="font-size:17px"> 画廊</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/animation/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-nvwumao">                   </use></svg><span class="menu_word" style="font-size:17px"> 动画</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/nav/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-zhifengche">                   </use></svg><span class="menu_word" style="font-size:17px"> 网址导航</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shejiaoxinxi"></use></svg><span class="menu_word" style="font-size:17px"> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/social/fcircle/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pengyouquan">                   </use></svg><span class="menu_word" style="font-size:17px"> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-liuyan">                   </use></svg><span class="menu_word" style="font-size:17px"> 留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/social/link/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-lianjie">                   </use></svg><span class="menu_word" style="font-size:17px"> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-wangye"></use></svg><span class="menu_word" style="font-size:17px"> 网站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/site/census/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--tongjibiao">                   </use></svg><span class="menu_word" style="font-size:17px"> 网站统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/echarts/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shujutongji1">                   </use></svg><span class="menu_word" style="font-size:17px"> 文章统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/time/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xianxingshalou">                   </use></svg><span class="menu_word" style="font-size:17px"> 旧时光</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-maoliang"></use></svg><span class="menu_word" style="font-size:17px"> 个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/personal/bb/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-qunliaotian">                   </use></svg><span class="menu_word" style="font-size:17px"> 唠叨</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/love/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-love-sign">                   </use></svg><span class="menu_word" style="font-size:17px"> 恋爱小屋</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/about/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-paperplane">                   </use></svg><span class="menu_word" style="font-size:17px"> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">PigCanStudy</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-home"></use></svg><span class="menu_word" style="font-size:17px"> 首页</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--article"></use></svg><span class="menu_word" style="font-size:17px"> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-guidang1">                   </use></svg><span class="menu_word" style="font-size:17px"> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-sekuaibiaoqian">                   </use></svg><span class="menu_word" style="font-size:17px"> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-fenlei">                   </use></svg><span class="menu_word" style="font-size:17px"> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pinweishenghuo"></use></svg><span class="menu_word" style="font-size:17px"> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/life/music/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-yinle">                   </use></svg><span class="menu_word" style="font-size:17px"> 八音盒</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/movies/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-dianying1">                   </use></svg><span class="menu_word" style="font-size:17px"> 影院</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/games/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-youxishoubing">                   </use></svg><span class="menu_word" style="font-size:17px"> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xiangzi"></use></svg><span class="menu_word" style="font-size:17px"> 八宝箱</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/box/gallery/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-tubiaozhizuomoban">                   </use></svg><span class="menu_word" style="font-size:17px"> 画廊</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/animation/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-nvwumao">                   </use></svg><span class="menu_word" style="font-size:17px"> 动画</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/nav/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-zhifengche">                   </use></svg><span class="menu_word" style="font-size:17px"> 网址导航</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shejiaoxinxi"></use></svg><span class="menu_word" style="font-size:17px"> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/social/fcircle/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pengyouquan">                   </use></svg><span class="menu_word" style="font-size:17px"> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-liuyan">                   </use></svg><span class="menu_word" style="font-size:17px"> 留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/social/link/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-lianjie">                   </use></svg><span class="menu_word" style="font-size:17px"> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-wangye"></use></svg><span class="menu_word" style="font-size:17px"> 网站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/site/census/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--tongjibiao">                   </use></svg><span class="menu_word" style="font-size:17px"> 网站统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/echarts/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shujutongji1">                   </use></svg><span class="menu_word" style="font-size:17px"> 文章统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/time/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xianxingshalou">                   </use></svg><span class="menu_word" style="font-size:17px"> 旧时光</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-maoliang"></use></svg><span class="menu_word" style="font-size:17px"> 个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/personal/bb/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-qunliaotian">                   </use></svg><span class="menu_word" style="font-size:17px"> 唠叨</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/love/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-love-sign">                   </use></svg><span class="menu_word" style="font-size:17px"> 恋爱小屋</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/about/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-paperplane">                   </use></svg><span class="menu_word" style="font-size:17px"> 关于</span></a></li></ul></div></div><center id="name-container"><a id="page-name" href="javascript:scrollToTop()">PAGE_NAME</a></center><div id="nav-right"><div id="search-button"><a class="search faa-parent animated-hover" title="检索站内任何你想要的信息"><svg class="faa-tada icon" style="height:24px;width:24px;fill:currentColor;position:relative;top:6px" aria-hidden="true"><use xlink:href="#icon-valentine_-search-love-find-heart"></use></svg><span> 搜索</span></a></div><a class="meihua faa-parent animated-hover" onclick="toggleWinbox()" title="美化设置-自定义你的风格" id="meihua-button"><svg class="faa-tada icon" style="height:26px;width:26px;fill:currentColor;position:relative;top:8px" aria-hidden="true"><use xlink:href="#icon-tupian1"></use></svg></a><a class="sun_moon faa-parent animated-hover" onclick="switchNightMode()" title="浅色和深色模式转换" id="nightmode-button"><svg class="faa-tada" style="height:25px;width:25px;fill:currentColor;position:relative;top:7px" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon">       </use></svg></a><div id="toggle-menu"><a><i class="fas fa-bars fa-fw"></i></a></div></div></div></nav><div id="post-info"><h1 class="post-title">C++并发编程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><svg class="meta_icon post-meta-icon" style="width:30px;height:30px;position:relative;top:10px"><use xlink:href="#icon-rili"></use></svg><span class="post-meta-label">发表于 </span><time class="post-meta-date-created" datetime="2024-07-18T02:49:00.000Z" title="发表于 2024-07-18 10:49:00">2024-07-18</time><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:18px;height:18px;position:relative;top:5px"><use xlink:href="#icon-gengxin1"></use></svg><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-07-18T02:50:00.000Z" title="更新于 2024-07-18 10:50:00">2024-07-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:18px;height:18px;position:relative;top:5px"><use xlink:href="#icon-biaoqian"></use></svg><a class="post-meta-categories" href="/categories/C/">C++</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><svg class="meta_icon post-meta-icon" style="width:25px;height:25px;position:relative;top:8px"><use xlink:href="#icon-charuword"></use></svg><span class="post-meta-label">字数总计:</span><span class="word-count">4w</span><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:20px;height:20px;position:relative;top:5px"><use xlink:href="#icon-shizhong"></use></svg><span class="post-meta-label">阅读时长:</span><span>162分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="C++并发编程"><svg class="meta_icon post-meta-icon" style="width:25px;height:25px;position:relative;top:5px"><use xlink:href="#icon-eye"></use></svg><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li><a href="#目录">目录</a><ul>
<li><a href="#线程基础知识">线程基础知识</a><ul>
<li><a href="#线程的发起">线程的发起</a></li>
<li><a href="#线程等待">线程等待</a></li>
<li><a href="#线程可以调用的参数">线程可以调用的参数</a><ul>
<li><a href="#调用函数对象">调用函数对象</a></li>
<li><a href="#使用lambda表达式当作其参数">使用lambda表达式当作其参数</a></li>
<li><a href="#使用成员函数指针来当作参数">使用成员函数指针来当作参数</a></li>
<li><a href="#注意当其调用函数有参数的时候需要在后面加入对应的参数">注意当其调用函数有参数的时候需要在后面加入对应的参数</a></li>
</ul>
</li>
<li><a href="#线程detach">线程detach</a><ul>
<li><a href="#解决办法">解决办法</a></li>
</ul>
</li>
<li><a href="#异常处理">异常处理</a></li>
<li><a href="#慎用隐式转换">慎用隐式转换</a></li>
<li><a href="#引用参数">引用参数</a><ul>
<li><a href="#什么是stdref">什么是std::ref？</a><ul>
<li><a href="#stdref-和不同引用的区别">std::ref 和不同引用的区别</a></li>
<li><a href="#总结">总结</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#使用move操作">使用move操作</a></li>
<li><a href="#线程底层做的处理">线程底层做的处理</a></li>
</ul>
</li>
<li><a href="#c线程管控">C++线程管控</a><ul>
<li><a href="#线程归属权">线程归属权</a></li>
<li><a href="#joining_thread">joining_thread</a></li>
<li><a href="#容器存储">容器存储</a></li>
<li><a href="#选择运行数量">选择运行数量</a></li>
<li><a href="#识别线程">识别线程</a></li>
</ul>
</li>
<li><a href="#互斥和死锁">互斥和死锁</a><ul>
<li><a href="#锁的使用">锁的使用</a></li>
<li><a href="#lock_guard的使用">lock_guard的使用</a></li>
<li><a href="#如何保证数据安全">如何保证数据安全</a><ul>
<li><a href="#解决的办法">解决的办法</a></li>
</ul>
</li>
<li><a href="#死锁是怎么造成的">死锁是怎么造成的</a><ul>
<li><a href="#死锁解决办法">死锁解决办法</a></li>
</ul>
</li>
<li><a href="#同时加锁">同时加锁</a></li>
<li><a href="#thread_local">thread_local</a></li>
<li><a href="#层级加锁">层级加锁</a></li>
</ul>
</li>
<li><a href="#cunique_lock共享锁和递归锁">C++unique_lock，共享锁和递归锁</a><ul>
<li><a href="#unique_lock">unique_lock</a><ul>
<li><a href="#unique_lock的owns_lock判断是否持有锁">unique_lock的owns_lock判断是否持有锁</a></li>
<li><a href="#unique_lock的延迟加锁defer_lock">unique_lock的延迟加锁defer_lock</a></li>
<li><a href="#unique_lock的领养加锁">unique_lock的领养加锁</a></li>
<li><a href="#锁的粒度">锁的粒度</a></li>
</ul>
</li>
<li><a href="#共享锁shared_lock以及shared_mutex">共享锁shared_lock以及shared_mutex</a></li>
<li><a href="#递归锁">递归锁</a></li>
</ul>
</li>
<li><a href="#c线程安全单例模式的演变">C++线程安全单例模式的演变</a><ul>
<li><a href="#局部静态变量">局部静态变量</a></li>
<li><a href="#饿汉与懒汉式详情看面试笔记">饿汉与懒汉式，详情看面试笔记</a></li>
<li><a href="#智能指针">智能指针</a><ul>
<li><a href="#改进方案">改进方案</a></li>
</ul>
</li>
<li><a href="#call_once">call_once</a></li>
<li><a href="#总结1">总结1</a></li>
</ul>
</li>
<li><a href="#c11多线程同步">C++11多线程同步</a><ul>
<li><a href="#使用future与promise">使用future与promise</a></li>
<li><a href="#使用条件变量来实现同步">使用条件变量来实现同步</a></li>
</ul>
</li>
<li><a href="#利用条件变量实现线程安全队列">利用条件变量实现线程安全队列</a><ul>
<li><a href="#不良实现">不良实现</a></li>
<li><a href="#条件变量">条件变量</a></li>
<li><a href="#实现安全队列">实现安全队列</a></li>
</ul>
</li>
<li><a href="#并发三剑客asyncpromisefuture">并发三剑客async,promise,future</a><ul>
<li><a href="#async用法">async用法</a><ul>
<li><a href="#async的启动策略">async的启动策略</a></li>
</ul>
</li>
<li><a href="#future的wait和get">future的wait和get</a></li>
<li><a href="#将任务和future关联paskaged_task">将任务和future关联（paskaged_task）</a></li>
<li><a href="#promise的用法">promise的用法</a></li>
<li><a href="#共享类型的future">共享类型的future</a></li>
<li><a href="#异常处理1">异常处理1</a></li>
<li><a href="#线程池">线程池</a></li>
</ul>
</li>
<li><a href="#两种并发设计模式">两种并发设计模式</a><ul>
<li><a href="#actor设计模式">Actor设计模式</a></li>
<li><a href="#csp模式">CSP模式</a></li>
</ul>
</li>
<li><a href="#thread-源码解读及一些常见问题">thread 源码解读及一些常见问题</a><ul>
<li><a href="#默认移动构造">默认移动构造</a></li>
<li><a href="#线程归属权问题">线程归属权问题</a></li>
<li><a href="#future-析构的细节">future 析构的细节</a></li>
</ul>
</li>
<li><a href="#原子操作和内存模型">原子操作和内存模型</a><ul>
<li><a href="#改动序列">改动序列</a></li>
<li><a href="#原子类型">原子类型</a></li>
<li><a href="#内存次序">内存次序</a></li>
<li><a href="#实现自旋锁">实现自旋锁</a></li>
<li><a href="#宽松内存序">宽松内存序</a></li>
<li><a href="#先行">先行</a><ul>
<li><a href="#顺序先行">顺序先行</a></li>
<li><a href="#线程间先行">线程间先行</a></li>
</ul>
</li>
<li><a href="#依赖关系">依赖关系</a></li>
<li><a href="#happens-before不代表指令执行顺序">Happens-before不代表指令执行顺序</a></li>
<li><a href="#脑图">脑图</a></li>
</ul>
</li>
<li><a href="#用内存顺序实现内存模型">用内存顺序实现内存模型</a><ul>
<li><a href="#memory_order_seq_cst">memory_order_seq_cst</a></li>
<li><a href="#memory_order_relaxed">memory_order_relaxed</a></li>
<li><a href="#acquire-release">Acquire-Release</a></li>
<li><a href="#release-sequences">Release sequences</a></li>
<li><a href="#memory_order_consume">memory_order_consume</a></li>
<li><a href="#单例模型改良">单例模型改良</a></li>
</ul>
</li>
<li><a href="#用内存顺序和原子变量实现无锁队列">用内存顺序和原子变量实现无锁队列</a><ul>
<li><a href="#环形队列">环形队列</a></li>
<li><a href="#用锁实现环形队列">用锁实现环形队列</a></li>
<li><a href="#无锁队列">无锁队列</a><ul>
<li><a href="#单一原子变量的弊端">单一原子变量的弊端</a></li>
<li><a href="#优化性能">优化性能</a></li>
</ul>
</li>
<li><a href="#思考">思考</a></li>
</ul>
</li>
<li><a href="#利用栅栏实现同步模型">利用栅栏实现同步模型</a><ul>
<li><a href="#线程可见顺序">线程可见顺序</a></li>
</ul>
</li>
<li><a href="#栅栏">栅栏</a></li>
<li><a href="#基于锁是新鲜线程安全队列与栈">基于锁是新鲜线程安全队列与栈</a><ul>
<li><a href="#线程安全的栈">线程安全的栈</a></li>
<li><a href="#线程安全队列">线程安全队列</a></li>
</ul>
</li>
<li><a href="#实现线程安全的查找表">实现线程安全的查找表</a><ul>
<li><a href="#散列表">散列表</a></li>
<li><a href="#设计思路">设计思路</a></li>
<li><a href="#代码实现">代码实现</a></li>
</ul>
</li>
<li><a href="#实现线程安全链表">实现线程安全链表</a></li>
<li><a href="#线程间切分任务的方法">线程间切分任务的方法</a><ul>
<li><a href="#按数量切分">按数量切分</a></li>
</ul>
</li>
<li><a href="#线程池原理和实现">线程池原理和实现</a></li>
</ul>
</li>
</ul>
<h2 id="线程基础知识"><a href="#线程基础知识" class="headerlink" title="线程基础知识"></a>线程基础知识</h2><h3 id="线程的发起"><a href="#线程的发起" class="headerlink" title="线程的发起"></a>线程的发起</h3><ul>
<li>线程发起顾名思义就是启动一个线程，C++11标准统一了线程操作，可以在定义一个线程变量后，该变量启动线程执行回调逻辑。如下即可发起一个线程</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thead_work1</span><span class="params">(std::string str)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str is &quot;</span> &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1 通过()初始化并启动一个线程</span></span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(thead_work1, hellostr)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="线程等待"><a href="#线程等待" class="headerlink" title="线程等待"></a>线程等待</h3><ul>
<li>当我们启动一个线程后，线程可能没有立即执行，如果在局部作用域启动了一个线程，或者main函数中，很可能子线程没运行就被回收了，回收时会调用线程的析构函数，执行terminate操作。所以为了防止主线程退出或者局部作用域结束导致子线程被析构的情况，我们可以通过join，其作用是让主线程等待子线程启动运行，子线程运行结束后主线程再运行。(也就是让当前进程等待调用join的线程运行结束后在运行)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个简单的线程函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello from thread!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个新的线程</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(threadFunction)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在主线程中做一些其他的事情</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程结束</span></span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="线程可以调用的参数"><a href="#线程可以调用的参数" class="headerlink" title="线程可以调用的参数"></a>线程可以调用的参数</h3><h4 id="调用函数对象"><a href="#调用函数对象" class="headerlink" title="调用函数对象"></a>调用函数对象</h4><ul>
<li>调用函数对象的时候可能会遇到一种情况，如果按如下方式去调用就会报错</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">func</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;hello thread&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(func())</span></span>;</span><br><span class="line">t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>原因</strong>：因为std::thread t1(func());这句话会被翻译成函数声明，即编译器会将t2当成一个函数对象, 返回一个std::thread类型的值, 函数的参数为一个函数指针,该函数指针返回值为background_task, 参数为void。可以理解为如下</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;std::thread (*)(background_task (*)())&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong><em>解决办法</em></strong>:</p>
<ol>
<li><p>使用{}来替代()</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::thread t1&#123;<span class="built_in">func</span>()&#125;;</span><br><span class="line">t<span class="number">1.</span><span class="built_in">join</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p>多加一层()来</p>
</li>
</ol>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">((func()))</span></span>;</span><br><span class="line">t<span class="number">1.</span><span class="built_in">join</span>();</span><br></pre></td></tr></table></figure>
<h4 id="使用lambda表达式当作其参数"><a href="#使用lambda表达式当作其参数" class="headerlink" title="使用lambda表达式当作其参数"></a>使用lambda表达式当作其参数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">t3</span><span class="params">([]()&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">// lambda 表达式的函数体</span></span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="使用成员函数指针来当作参数"><a href="#使用成员函数指针来当作参数" class="headerlink" title="使用成员函数指针来当作参数"></a>使用成员函数指针来当作参数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">memberFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 成员函数体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyClass obj;</span><br><span class="line"><span class="function">std::thread <span class="title">t2</span><span class="params">(&amp;MyClass::memberFunction, &amp;obj)</span></span>; <span class="comment">// memberFunction 是一个成员函数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="注意当其调用函数有参数的时候需要在后面加入对应的参数"><a href="#注意当其调用函数有参数的时候需要在后面加入对应的参数" class="headerlink" title="注意当其调用函数有参数的时候需要在后面加入对应的参数"></a>注意当其调用函数有参数的时候需要在后面加入对应的参数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程函数，接受两个参数，并返回它们的和</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sum of &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; is: &quot;</span> &lt;&lt; (a + b) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>, y = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个新线程，并传递参数</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(sum, x, y)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程结束</span></span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="线程detach"><a href="#线程detach" class="headerlink" title="线程detach"></a>线程detach</h3><ul>
<li>detach() 函数的作用是将线程托管到后台来运行，实现主线程与线程分离，这被称为守护线程，分离线程后，父子线程就不会共享同一个内存，但是却可以通过指针和引用共同访问一个堆区资源，但是需要人为增加同步机制。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">func</span> &#123;</span><br><span class="line">    <span class="type">int</span>&amp; _i;</span><br><span class="line">    <span class="built_in">func</span>(<span class="type">int</span> &amp; i): _i(i)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            _i = i;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;_i is &quot;</span> &lt;&lt; _i &lt;&lt; std::endl;</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">oops</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> some_local_state = <span class="number">0</span>;</span><br><span class="line">        <span class="function">func <span class="title">myfunc</span><span class="params">(some_local_state)</span></span>;</span><br><span class="line">        <span class="function">std::thread <span class="title">functhread</span><span class="params">(myfunc)</span></span>;</span><br><span class="line">        <span class="comment">//隐患，访问局部变量，局部变量可能会随着&#125;结束而回收或随着主线程退出而回收</span></span><br><span class="line">        functhread.<span class="built_in">detach</span>();    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// detach 注意事项</span></span><br><span class="line"><span class="built_in">oops</span>();</span><br><span class="line"><span class="comment">//防止主线程退出过快，需要停顿一下，让子线程跑起来detach</span></span><br><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>上面的例子存在隐患，因为some_local_state是局部变量, 当oops调用结束后局部变量some_local_state就可能被释放了，而线程还在detach后台运行，容易出现崩溃。</li>
</ul>
<h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><ul>
<li>使用智能指针shared_ptr,使用引用计数来保证局部变量不被释放，是伪闭包策略</li>
<li>可以将引用传递改为按值传递，这样会需要拷贝构造，增加空间消耗，减少效率</li>
<li>可以让主线程等待子线程完毕后再执行，但这样往往会影响程序的逻辑(因为这样就不是后台运行了)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_join</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> some_local_state = <span class="number">0</span>;</span><br><span class="line">    <span class="function">func <span class="title">myfunc</span><span class="params">(some_local_state)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">functhread</span><span class="params">(myfunc)</span></span>;</span><br><span class="line">    functhread.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// join 用法</span></span><br><span class="line"><span class="built_in">use_join</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><ul>
<li>当我们启动一个线程后，如果主线程产生崩溃，会导致子线程也会异常退出，就是调用terminate，如果子线程在进行一些重要的操作比如将充值信息入库等，丢失这些信息是很危险的。所以常用的做法是捕获异常，并且在异常情况下保证子线程稳定运行结束后，主线程抛出异常结束运行。如下面的逻辑：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">catch_exception</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> some_local_state = <span class="number">0</span>;</span><br><span class="line">    <span class="function">func <span class="title">myfunc</span><span class="params">(some_local_state)</span></span>;</span><br><span class="line">    std::thread  functhread&#123; myfunc &#125;;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//本线程做一些事情,可能引发崩溃</span></span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;<span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">        functhread.<span class="built_in">join</span>();</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    functhread.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>但是这种写法不完美，你需要自行添加 还得自行判断哪个必须要执行完才行，所以有什么方法可以自动判定而不需要人为选择呢？ 那就是采用<strong>RAII</strong>思想</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">func</span> &#123;</span><br><span class="line">    <span class="type">int</span>&amp; _i;</span><br><span class="line">    <span class="built_in">func</span>(<span class="type">int</span> &amp; i): _i(i)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            _i = i;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;_i is &quot;</span> &lt;&lt; _i &lt;&lt; std::endl;</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">thread_guard</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::thread&amp; <span class="type">_t</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">thread_guard</span><span class="params">(std::thread&amp; t)</span>:_t(t)&#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">thread_guard</span>() &#123;</span><br><span class="line">        <span class="comment">//join只能调用一次</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="type">_t</span>.<span class="built_in">joinable</span>()) &#123;</span><br><span class="line">            <span class="type">_t</span>.<span class="built_in">join</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">thread_guard</span>(thread_guard <span class="type">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    thread_guard&amp; <span class="keyword">operator</span>=(thread_guard <span class="type">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">auto_guard</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> some_local_state = <span class="number">0</span>;</span><br><span class="line">    <span class="function">func <span class="title">my_func</span><span class="params">(some_local_state)</span></span>;</span><br><span class="line">    <span class="function">std::thread  <span class="title">t</span><span class="params">(my_func)</span></span>;</span><br><span class="line">    <span class="function">thread_guard <span class="title">g</span><span class="params">(t)</span></span>;</span><br><span class="line">    <span class="comment">//本线程做一些事情</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;auto guard finished &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">auto_guard</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="慎用隐式转换"><a href="#慎用隐式转换" class="headerlink" title="慎用隐式转换"></a>慎用隐式转换</h3><ul>
<li>C++中会有一些隐式转换，比如char* 转换为string等。这些隐式转换在线程的调用上可能会造成崩溃问题</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_str</span><span class="params">(<span class="type">int</span> &amp; i, <span class="type">const</span> std::string &amp; buf)</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;i is&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;buf is&quot;</span> &lt;&lt; buf &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">danger_oops</span><span class="params">(<span class="type">int</span> som_param)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(buffer, <span class="string">&quot;%i&quot;</span>, som_param);</span><br><span class="line">    <span class="comment">//在线程内部将char const* 转化为std::string</span></span><br><span class="line">    <span class="comment">//指针常量  char * const  指针本身不能变</span></span><br><span class="line">    <span class="comment">//常量指针  const char * 指向的内容不能变</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(print_str, <span class="number">3</span>, buffer)</span></span>;<span class="comment">// 这里buffer 类型为char * 被隐式转换为 string</span></span><br><span class="line">    t.<span class="built_in">detach</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;danger oops finished &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>当我们定义一个线程变量thread t时，传递给这个线程的参数buffer会被保存到thread的成员变量中。而在线程对象t内部启动并运行线程时，参数才会被传递给调用函数print_str。而此时buffer可能随着’}’运行结束而释放了。</li>
<li>改进的方式很简单，我们将参数传递给thread时显示转换为string就可以了，这样thread内部保存的是string类型。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">safe_oops</span><span class="params">(<span class="type">int</span> some_param)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(buffer, <span class="string">&quot;%i&quot;</span>, some_param);</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(print_str, <span class="number">3</span>, std::string(buffer))</span></span>;</span><br><span class="line">    t.<span class="built_in">detach</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="引用参数"><a href="#引用参数" class="headerlink" title="引用参数"></a>引用参数</h3><ul>
<li>当线程要调用的回调函数参数为引用类型时，需要将参数显示转化为引用对象传递给线程的构造函数，如果采用如下调用会编译失败</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">change_param</span><span class="params">(<span class="type">int</span>&amp; param)</span> </span>&#123;</span><br><span class="line">    param++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ref_oops</span><span class="params">(<span class="type">int</span> some_param)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;before change , param is &quot;</span> &lt;&lt; some_param &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">//需使用引用显示转换</span></span><br><span class="line">    <span class="function">std::thread  <span class="title">t2</span><span class="params">(change_param, some_param)</span></span>;</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;after change , param is &quot;</span> &lt;&lt; some_param &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>即使函数change_param的参数为int&amp;类型，我们传递给t2的构造函数为some_param,也不会达到在change_param函数内部修改关联到外部some_param的效果。因为some_param在传递给thread的构造函数后（底层会转换为右值）会转变为右值保存，右值传递给一个左值引用会出问题，所以编译出了问题。</li>
<li>改为如下调用就可以了:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ref_oops</span><span class="params">(<span class="type">int</span> some_param)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;before change , param is &quot;</span> &lt;&lt; some_param &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">//需使用引用显示转换</span></span><br><span class="line">    <span class="function">std::thread  <span class="title">t2</span><span class="params">(change_param, std::ref(some_param))</span></span>;</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;after change , param is &quot;</span> &lt;&lt; some_param &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="什么是std-ref？"><a href="#什么是std-ref？" class="headerlink" title="什么是std::ref？"></a>什么是std::ref？</h4><ul>
<li><p>std::ref的作用是将一个值包装为reference_Wrapper，这个对象在bind 和 thread时会被识别为引用，这样就解决了bind与thread 无法传递引用的问题（因为原本会被拷贝为右值）</p>
</li>
<li><p>大致可以这么理解：在底层 ref函数会把 一个值的地址和类型封装成reference_wrapper，当我们调用的时候触发了仿函数()，取得了该地址下的值，使其表现为左值引用</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> _CONSTEXPR20 <span class="keyword">operator</span> _Ty&amp;() <span class="type">const</span> <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> *_Ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">_NODISCARD _CONSTEXPR20 _Ty&amp; <span class="title">get</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *_Ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="std-ref-和不同引用的区别"><a href="#std-ref-和不同引用的区别" class="headerlink" title="std::ref 和不同引用的区别"></a>std::ref 和不同引用的区别</h5><ul>
<li>std::ref只是尝试模拟引用传递，并不能真正变成引用，在非模板情况下，std::ref根本没法实现引用传递，只有模板自动推导类型或类型隐式转换时，std::ref能用包装类型reference_wrapper来代替原本会被识别的值类型，而reference_wrapper能隐式转换为被引用的值的引用类型。</li>
</ul>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul>
<li>我来给总结下，首先我们讲解了std::ref的一些用法，然后我们讲解std::ref是通过std::reference_wrapper实现，然后我们借助了cppreference上的实现来给大家剖析了他本质就是存放了对象的地址(类似指针的用法😁)，还讲解了noexcept等语法，最后我们讲解了下std::bind为什么要使用到reference_wrapper。</li>
<li>std::bind使用的是参数的拷贝而不是引用，当可调用对象期待入参为引用时，必须显示利用std::ref来进行引用绑定。</li>
<li>多线程std::thread的可调用对象期望入参为引用时，也必须显式通过std::ref来绑定引用进行传参。</li>
</ul>
<h3 id="使用move操作"><a href="#使用move操作" class="headerlink" title="使用move操作"></a>使用move操作</h3><ul>
<li>有时候传递给线程的参数是独占的，所谓独占就是不支持拷贝赋值和构造，但是我们可以通过std::move的方式将参数的所有权转移给线程，如下</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">deal_unique</span><span class="params">(std::unique_ptr&lt;<span class="type">int</span>&gt; p)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;unique ptr data is &quot;</span> &lt;&lt; *p &lt;&lt; std::endl;</span><br><span class="line">    (*p)++;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;after unique ptr data is &quot;</span> &lt;&lt; *p &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">move_oops</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> p = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">100</span>);</span><br><span class="line">    <span class="function">std::thread  <span class="title">t</span><span class="params">(deal_unique, std::move(p))</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="comment">//不能再使用p了，p已经被move废弃</span></span><br><span class="line">   <span class="comment">// std::cout &lt;&lt; &quot;after unique ptr data is &quot; &lt;&lt; *p &lt;&lt; std::endl;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线程底层做的处理"><a href="#线程底层做的处理" class="headerlink" title="线程底层做的处理"></a>线程底层做的处理</h3><ul>
<li>传递给线程的参数首先会去掉引用，并保存副本在tuple里，无论传递的是左值还是右值，最后都会被转换成右值引用给invoke调用你</li>
</ul>
<h2 id="C-线程管控"><a href="#C-线程管控" class="headerlink" title="C++线程管控"></a>C++线程管控</h2><h3 id="线程归属权"><a href="#线程归属权" class="headerlink" title="线程归属权"></a>线程归属权</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">some_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(some_function)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>t1是一个线程变量，管理一个线程，该线程执行<strong>some_function()</strong>,对于std::thread C++ 不允许其执行拷贝构造和拷贝赋值, 所以只能通过移动和局部变量返回的方式将线程变量管理的线程转移给其他变量管理。</li>
<li>C++ 中类似的类型还有<strong>std::mutex, std::ifstream, std::unique_ptr</strong>。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">some_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">some_other_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//t1 绑定some_function</span></span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(some_function)</span></span>; </span><br><span class="line"><span class="comment">//2 转移t1管理的线程给t2，转移后t1无效,因为t1move后是右值，调用的是移动构造函数</span></span><br><span class="line">std::thread t2 =  std::<span class="built_in">move</span>(t1);</span><br><span class="line"><span class="comment">//3 t1 可继续绑定其他线程,执行some_other_function</span></span><br><span class="line">t1 = std::<span class="built_in">thread</span>(some_other_function);</span><br><span class="line"><span class="comment">//4  创建一个线程变量t3</span></span><br><span class="line">std::thread t3;</span><br><span class="line"><span class="comment">//5  转移t2管理的线程给t3</span></span><br><span class="line">t3 = std::<span class="built_in">move</span>(t2);</span><br><span class="line"><span class="comment">//6  转移t3管理的线程给t1</span></span><br><span class="line">t1 = std::<span class="built_in">move</span>(t3);</span><br><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2000</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>上面的代码会引发崩溃，是因为步骤6造成的崩溃。</li>
<li>让主函数睡眠2000秒，是为了告诉规避主函数退出引发崩溃的问题，因为我们在之前给大家演示过，如果线程不detach或者join，主线程退出时会引发崩溃，而我们这些线程没有join和detach，为了给大家演示是因为步骤6引发的崩溃，所以让主线程睡眠2000秒暂时不退出，但是程序仍然会崩溃，说明是步骤6导致的崩溃。</li>
<li>上面代码将t2管理的线程交给t3，之后将t3管理的线程交给t1，此时t1管理线程运行着 some_function，步骤6导致崩溃的原因就是将t3管理的线程交给t1，而此时t1正在管理线程运行some_other_function。</li>
<li><p>所以我们可以得出一个结论，就是<strong>不要将一个线程的管理权交给一个已经绑定线程的变量</strong>，否则会触发线程的terminate函数引发崩溃。</p>
</li>
<li><p>和std::unique_ptr一样，我们可以在函数内部返回一个局部的std::thread变量。如下:</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 采用了RVO机制，编译器优化了返回值，执行了移动构造函数</span></span><br><span class="line"><span class="function">std::thread  <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">thread</span>(some_function);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">param_function</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::thread <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这是NRVO机制，具名的返回值优化</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(param_function, <span class="number">43</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>因为C++ 在返回局部变量时，会优先寻找这个类的拷贝构造函数，如果没有就会使用这个类的移动构造函数。（RVO与NRVO机制）</li>
</ul>
<h3 id="joining-thread"><a href="#joining-thread" class="headerlink" title="joining_thread"></a>joining_thread</h3><ul>
<li>曾经有一份C++17标准的备选提案，主张引入新的类joining_thread，它与std::thread类似，但只要其执行析构函数，线程即能自动汇合，这点与scoped_thread非常像。可惜C++标准委员会未能达成共识，结果C++17标准没有引入这个类，后来它改名为<strong>std::jthread</strong>，依然进入了C++20标准的议程（现已被正式纳入C++20标准）。除去这些，实际上joining_thread类的代码相对容易编写</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">joining_thread</span> &#123;</span><br><span class="line">    std::thread  <span class="type">_t</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">joining_thread</span>() <span class="keyword">noexcept</span> = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Callable, <span class="keyword">typename</span> ...  Args&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">explicit</span>  <span class="title">joining_thread</span><span class="params">(Callable&amp;&amp; func, Args&amp;&amp; ...args)</span>:</span></span><br><span class="line"><span class="function">        _t(std::forward&lt;Callable&gt;(func),  std::forward&lt;Args&gt;(args)...)&#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">joining_thread</span><span class="params">(std::thread  t)</span> <span class="keyword">noexcept</span>: _t(std::move(t))&#123;</span>&#125;</span><br><span class="line">    <span class="built_in">joining_thread</span>(joining_thread&amp;&amp; other) <span class="keyword">noexcept</span>: <span class="type">_t</span>(std::<span class="built_in">move</span>(other.<span class="type">_t</span>))&#123;&#125;</span><br><span class="line">    joining_thread&amp; <span class="keyword">operator</span>=(joining_thread&amp;&amp; other) <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果当前线程可汇合，则汇合等待线程完成再赋值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">joinable</span>()) &#123;</span><br><span class="line">            <span class="built_in">join</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">_t</span> = std::<span class="built_in">move</span>(other.<span class="type">_t</span>);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    joining_thread&amp; <span class="keyword">operator</span>=(joining_thread other) <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果当前线程可汇合，则汇合等待线程完成再赋值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">joinable</span>()) &#123;</span><br><span class="line">            <span class="built_in">join</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">_t</span> = std::<span class="built_in">move</span>(other.<span class="type">_t</span>);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">joining_thread</span>() <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">joinable</span>()) &#123;</span><br><span class="line">            <span class="built_in">join</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(joining_thread&amp; other)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="type">_t</span>.<span class="built_in">swap</span>(other.<span class="type">_t</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="function">thread::id   <span class="title">get_id</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">_t</span>.<span class="built_in">get_id</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">joinable</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">_t</span>.<span class="built_in">joinable</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">_t</span>.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">detach</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">_t</span>.<span class="built_in">detach</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::thread&amp; <span class="title">as_thread</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">_t</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> std::thread&amp; <span class="title">as_thread</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">_t</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>用起来就比较简单了</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_jointhread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1 根据线程构造函数构造joiningthread</span></span><br><span class="line">    <span class="function">joining_thread <span class="title">j1</span><span class="params">([](<span class="type">int</span> maxindex) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxindex; i++) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::cout &lt;&lt; <span class="string">&quot;in thread id &quot;</span> &lt;&lt; std::this_thread::get_id()</span></span></span><br><span class="line"><span class="params"><span class="function">                &lt;&lt; <span class="string">&quot; cur index is &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::this_thread::sleep_for(std::chrono::seconds(<span class="number">1</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="comment">//2 根据thread构造joiningthread</span></span><br><span class="line">    <span class="function">joining_thread <span class="title">j2</span><span class="params">(std::thread([](<span class="type">int</span> maxindex) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxindex; i++) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::cout &lt;&lt; <span class="string">&quot;in thread id &quot;</span> &lt;&lt; std::this_thread::get_id()</span></span></span><br><span class="line"><span class="params"><span class="function">                &lt;&lt; <span class="string">&quot; cur index is &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::this_thread::sleep_for(std::chrono::seconds(<span class="number">1</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;, <span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="comment">//3 根据thread构造j3</span></span><br><span class="line">    <span class="function">joining_thread <span class="title">j3</span><span class="params">(std::thread([](<span class="type">int</span> maxindex) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxindex; i++) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::cout &lt;&lt; <span class="string">&quot;in thread id &quot;</span> &lt;&lt; std::this_thread::get_id()</span></span></span><br><span class="line"><span class="params"><span class="function">                &lt;&lt; <span class="string">&quot; cur index is &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::this_thread::sleep_for(std::chrono::seconds(<span class="number">1</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;, <span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="comment">//4 把j3赋值给j1，joining_thread内部会等待j1汇合结束后</span></span><br><span class="line">    <span class="comment">//再将j3赋值给j1</span></span><br><span class="line">    j1 = std::<span class="built_in">move</span>(j3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="容器存储"><a href="#容器存储" class="headerlink" title="容器存储"></a>容器存储</h3><ul>
<li>容器存储线程时，比使用<strong>emplace_back()</strong>,直接创造匿名对象可以节约一次构造函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_vector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        threads.<span class="built_in">emplace_back</span>(param_function, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; entry : threads) &#123;</span><br><span class="line">        entry.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="选择运行数量"><a href="#选择运行数量" class="headerlink" title="选择运行数量"></a>选择运行数量</h3><ul>
<li>借用C++标准库的<strong>std::thread::hardware_concurrency()</strong>函数，它的返回值是一个指标，表示程序在各次运行中可真正并发的线程数量.<br>我们可以模拟实现一个并行计算的功能，计算容器内所有元素的和</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">parallel_accumulate</span><span class="params">(Iterator first, Iterator last, T init)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> length = std::<span class="built_in">distance</span>(first, last);</span><br><span class="line">    <span class="keyword">if</span> (!length)</span><br><span class="line">        <span class="keyword">return</span> init;    <span class="comment">//⇽-- - ①</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> min_per_thread = <span class="number">25</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> max_threads =</span><br><span class="line">        (length + min_per_thread - <span class="number">1</span>) / min_per_thread;    <span class="comment">//⇽-- - ②</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> hardware_threads =</span><br><span class="line">        std::thread::<span class="built_in">hardware_concurrency</span>();</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> num_threads =</span><br><span class="line">        std::<span class="built_in">min</span>(hardware_threads != <span class="number">0</span> ? hardware_threads : <span class="number">2</span>, max_threads);    <span class="comment">//⇽-- - ③</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> block_size = length / num_threads;    <span class="comment">//⇽-- - ④</span></span><br><span class="line">        <span class="function">std::vector&lt;T&gt; <span class="title">results</span><span class="params">(num_threads)</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;std::thread&gt;  <span class="title">threads</span><span class="params">(num_threads - <span class="number">1</span>)</span></span>;   <span class="comment">// ⇽-- - ⑤</span></span><br><span class="line">        Iterator block_start = first;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">long</span> i = <span class="number">0</span>; i &lt; (num_threads - <span class="number">1</span>); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        Iterator block_end = block_start;</span><br><span class="line">        std::<span class="built_in">advance</span>(block_end, block_size);    <span class="comment">//⇽-- - ⑥</span></span><br><span class="line">            threads[i] = std::<span class="built_in">thread</span>(<span class="comment">//⇽-- - ⑦</span></span><br><span class="line">                <span class="built_in">accumulate_block</span>&lt;Iterator, T&gt;(),</span><br><span class="line">                block_start, block_end, std::<span class="built_in">ref</span>(results[i]));</span><br><span class="line">        block_start = block_end;    <span class="comment">//⇽-- - ⑧</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">accumulate_block</span>&lt;Iterator, T&gt;()(</span><br><span class="line">        block_start, last, results[num_threads - <span class="number">1</span>]);    <span class="comment">//⇽-- - ⑨</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; entry : threads)</span><br><span class="line">            entry.<span class="built_in">join</span>();    <span class="comment">//⇽-- - ⑩</span></span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">accumulate</span>(results.<span class="built_in">begin</span>(), results.<span class="built_in">end</span>(), init);    <span class="comment">//⇽-- - ⑪</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_parallel_acc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector &lt;<span class="type">int</span>&gt; <span class="built_in">vec</span>(<span class="number">10000</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    sum = parallel_accumulate&lt;std::vector&lt;<span class="type">int</span>&gt;::iterator, <span class="type">int</span>&gt;(vec.<span class="built_in">begin</span>(), </span><br><span class="line">        vec.<span class="built_in">end</span>(), sum);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sum is &quot;</span> &lt;&lt; sum &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面的代码1处判断要计算的容器内元素为0个则返回。</p>
<p>2处计算最大开辟的线程数，我们预估每个线程计算25个数据长度。</p>
<p>但是我们可以通过std::thread::hardware_concurrency返回cpu的核数，我们期待的是开辟的线</p>
<p>程数小于等于cpu核数，这样才不会造成线程过多时间片切换开销。</p>
<p>所以3处计算了适合开辟线程数的最小值。</p>
<p>4处计算了步长，根据步长移动迭代器然后开辟线程计算。</p>
<p>5处初始化了线程数-1个大小的vector，因为主线程也参与计算，所以这里-1.</p>
<p>6处移动步长，7处开辟线程，8处更新起始位置。</p>
<p>9处为主线程计算。</p>
<p>10 处让所有线程join</p>
<p>11 处最后将所有计算结果再次调用std的accumulate算出结果。</p>
<h3 id="识别线程"><a href="#识别线程" class="headerlink" title="识别线程"></a>识别线程</h3><ul>
<li>所谓识别线程就是获取线程id，可以根据线程id是否相同判断是否同一个线程。</li>
<li>比如我们启动了一个线程,我们可以通过线程变量的get_id()获取线程id</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">([]()&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    std::cout &lt;&lt; <span class="string">&quot;thread start&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line">t.<span class="built_in">get_id</span>();</span><br></pre></td></tr></table></figure>
<ul>
<li>但是如果我们想在线程的运行函数中区分线程，或者判断哪些是主线程或者子线程，可以通过这种方式</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">([]()&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    std::cout &lt;&lt; <span class="string">&quot;in thread id &quot;</span> &lt;&lt; </span></span></span><br><span class="line"><span class="params"><span class="function">    std::this_thread::get_id() &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">    std::cout &lt;&lt; <span class="string">&quot;thread start&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="互斥和死锁"><a href="#互斥和死锁" class="headerlink" title="互斥和死锁"></a>互斥和死锁</h2><h3 id="锁的使用"><a href="#锁的使用" class="headerlink" title="锁的使用"></a>锁的使用</h3><ul>
<li><p>我们可以通过mutex对共享数据进行加锁，防止多线程访问共享区造成数据不一致问题。如下，我们初始化一个共享变量shared_data，然后定义了一个互斥量std::mutex，接下来启动了两个线程，分别执行use_lock增加数据，和一个lambda表达式减少数据。<br>结果可以看到两个线程对于共享数据的访问是独占的，单位时间片只有一个线程访问并输出日志。</p>
</li>
<li><p><strong>一个线程不能再次加一个自己已经锁定的锁</strong>： 如果一个线程已经持有某个锁（比如 std::mutex），则再次尝试在同一个线程中对该锁进行加锁会导致死锁。因为锁是互斥的，同一线程不能重复持有同一个互斥量。</p>
</li>
<li><p><strong>其他线程尝试加已经锁定的锁会被阻塞</strong>： 如果一个线程已经持有某个锁，并且另一个线程尝试在此时对同一个锁进行加锁，则后者线程会被阻塞，直到锁被释放。这是互斥量的基本行为，它确保了在任意时刻只有一个线程可以访问被保护的临界区，从而避免了数据竞争和不确定的行为。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lock mutex.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line">std::mutex mtx1;</span><br><span class="line"><span class="type">int</span> share_data = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        mtx<span class="number">1.l</span>ock();</span><br><span class="line">        share_data++;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;current thread is&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;share_data is &quot;</span> &lt;&lt; share_data &lt;&lt; std::endl;</span><br><span class="line">        mtx<span class="number">1.</span><span class="built_in">unlock</span>();</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">microseconds</span>(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(use_lock)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            mtx<span class="number">1.l</span>ock();</span></span></span><br><span class="line"><span class="params"><span class="function">            share_data--;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::cout &lt;&lt; <span class="string">&quot;current thread is&quot;</span> &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::cout &lt;&lt; <span class="string">&quot;share_data is &quot;</span> &lt;&lt; share_data &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">            mtx<span class="number">1.</span>unlock();</span></span></span><br><span class="line"><span class="params"><span class="function">            std::this_thread::sleep_for(std::chrono::microseconds(<span class="number">10</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test_lock</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello World!\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="lock-guard的使用"><a href="#lock-guard的使用" class="headerlink" title="lock_guard的使用"></a>lock_guard的使用</h3><ul>
<li>当然我们可以用lock_guard自动加锁和解锁,比如上面的函数可以等价简化为</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(use_lock)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                std::lock_guard&lt;std::mutex&gt; lk_lock(mtx1);</span></span></span><br><span class="line"><span class="params"><span class="function">                share_data--;</span></span></span><br><span class="line"><span class="params"><span class="function">                std::cout &lt;&lt; <span class="string">&quot;current thread is&quot;</span> &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">                std::cout &lt;&lt; <span class="string">&quot;share_data is &quot;</span> &lt;&lt; share_data &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::this_thread::sleep_for(std::chrono::microseconds(<span class="number">10</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>注意：</strong>使用lock_guard的时候，它是在创造的时候加锁，在被析构的时候解锁，如果你不注意它的作用域，就会导致一些资源浪费问题，甚至其他线程无法工作的情况，所以加入 <strong>{ }</strong> 是必要的，没有加入的话t2线程将会一直占用共享数据，这么做的一个好处是简化了一些特殊情况从函数中返回的写法，比如异常或者条件不满足时，函数内部直接return，锁也会自动解开</li>
</ul>
<h3 id="如何保证数据安全"><a href="#如何保证数据安全" class="headerlink" title="如何保证数据安全"></a>如何保证数据安全</h3><ul>
<li><p>有时候我们可以将对共享数据的访问和修改聚合到一个函数，在函数内加锁保证数据的安全性。但是对于读取类型的操作，即使读取函数是线程安全的，但是返回值抛给外边使用，存在不安全性。比如一个栈对象，我们要保证其在多线程访问的时候是安全的，可以在判断栈是否为空，判断操作内部我们可以加锁，但是判断结束后返回值就不在加锁了，就会存在线程安全问题。</p>
</li>
<li><p>比如我定义了如下栈, 对于多线程访问时判断栈是否为空，此后两个线程同时出栈，可能会造成崩溃。如下所示</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lock mutex.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadsafe_stack1</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::stack&lt;T&gt; stk;</span><br><span class="line">    <span class="keyword">mutable</span> std::mutex m;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">threadsafe_stack1</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">threadsafe_stack1</span>(<span class="type">const</span> threadsafe_stack1&amp; other) &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(other.m)</span></span>;</span><br><span class="line">        stk = other.stk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    threadsafe_stack1&amp; <span class="keyword">operator</span> = (<span class="type">const</span> threadsafe_stack1&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T new_value)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        stk.<span class="built_in">push</span>(std::<span class="built_in">move</span>(new_value));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//问题代码</span></span><br><span class="line">    <span class="function">T <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">auto</span> element = stk.<span class="built_in">top</span>();</span><br><span class="line">        stk.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//危险</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> stk.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_threadsafe_stack1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    threadsafe_stack1&lt;<span class="type">int</span>&gt; safe_stack;</span><br><span class="line">    safe_stack.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;safe_stack]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">if</span> (!safe_stack.empty()) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::this_thread::sleep_for(std::chrono::seconds(<span class="number">1</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">            safe_stack.pop();</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([&amp;safe_stack]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">if</span> (!safe_stack.empty()) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::this_thread::sleep_for(std::chrono::seconds(<span class="number">1</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">            safe_stack.pop();</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//test_lock();</span></span><br><span class="line">    <span class="built_in">test_threadsafe_stack1</span>();</span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; &quot;Hello World!\n&quot;;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>在这段代码会在出栈的时候报错，因为可能栈里就一个元素但是我们却出栈了两次</li>
</ul>
<h4 id="解决的办法"><a href="#解决的办法" class="headerlink" title="解决的办法"></a>解决的办法</h4><ul>
<li>定义一个空栈异常，然后实现我们的出栈函数，如下所示</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">empty_stack</span> : std::exception</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">what</span><span class="params">()</span> <span class="type">const</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">T <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (data.<span class="built_in">empty</span>()) <span class="keyword">throw</span> <span class="built_in">empty_stack</span>();</span><br><span class="line">    <span class="keyword">auto</span> element = data.<span class="built_in">top</span>();</span><br><span class="line">    data.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>这么做就需要在外层使用的时候捕获异常。这是C++ 并发编程中提及的建议。但是我觉得可以在函数pop内部再次判断栈是否为空，若为空则返回一个非法数据，这样比抛出异常好一些</li>
<li>但是如果T是一个复杂类型，我们很难定义一个非法值给外界知晓，这一点可以通过智能指针进行优化。之后我们再介绍更优化的方案，因为现在这个pop函数仍存在问题，比如T是一个vector<int>类型，那么在pop函数内部element就是vector<int>类型，开始element存储了一些int值，程序没问题，函数执行pop操作， 假设此时程序内存暴增，导致当程序使用的内存足够大时，可用的有效空间不够， 函数返回element时，就会就会存在vector做拷贝赋值时造成失败。即使我们捕获异常，释放部分空间但也会导致栈元素已经出栈，数据丢失了。这其实是内存管理不当造成的，但是C++ 并发编程一书中给出了优化方案。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">empty_stack</span> : std::exception</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">what</span><span class="params">()</span> <span class="type">const</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadsafe_stack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::stack&lt;T&gt; data;</span><br><span class="line">    <span class="keyword">mutable</span> std::mutex m;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">threadsafe_stack</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">threadsafe_stack</span>(<span class="type">const</span> threadsafe_stack&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(other.m)</span></span>;</span><br><span class="line">        <span class="comment">//①在构造函数的函数体（constructor body）内进行复制操作</span></span><br><span class="line">        data = other.data;   </span><br><span class="line">    &#125;</span><br><span class="line">    threadsafe_stack&amp; <span class="keyword">operator</span>=(<span class="type">const</span> threadsafe_stack&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        data.<span class="built_in">push</span>(std::<span class="built_in">move</span>(new_value));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法二</span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="comment">//②试图弹出前检查是否为空栈</span></span><br><span class="line">        <span class="keyword">if</span> (data.<span class="built_in">empty</span>()) <span class="keyword">throw</span> <span class="built_in">empty_stack</span>();</span><br><span class="line">        <span class="comment">//③改动栈容器前设置返回值</span></span><br><span class="line">            <span class="function">std::shared_ptr&lt;T&gt; <span class="type">const</span> <span class="title">res</span><span class="params">(std::make_shared&lt;T&gt;(data.top()))</span></span>;    </span><br><span class="line">            data.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法一</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(T&amp; value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (data.<span class="built_in">empty</span>()) <span class="keyword">throw</span> <span class="built_in">empty_stack</span>();</span><br><span class="line">        value = data.<span class="built_in">top</span>();</span><br><span class="line">        data.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> data.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>我们提供了两个版本的pop操作，一个是带引用类型的参数的，一个是直接pop出智能指针类型，这样在pop函数内部减少了数据的拷贝，防止内存溢出，其实这两种做法确实是相比之前直接pop固定类型的值更节省内存，运行效率也好很多。我们也完全可以基于之前的思想，在pop时如果队列为空则返回空指针，这样比抛出异常更有好一些</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;T&gt; <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="comment">//②试图弹出前检查是否为空栈</span></span><br><span class="line">    <span class="keyword">if</span> (data.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">//③改动栈容器前设置返回值</span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="type">const</span> <span class="title">res</span><span class="params">(std::make_shared&lt;T&gt;(data.top()))</span></span>;    </span><br><span class="line">    data.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="死锁是怎么造成的"><a href="#死锁是怎么造成的" class="headerlink" title="死锁是怎么造成的"></a>死锁是怎么造成的</h3><ul>
<li>死锁一般是由于调运顺序不一致导致的，比如两个线程循环调用。当线程1先加锁A，再加锁B，而线程2先加锁B，再加锁A。那么在某一时刻就可能造成死锁。比如线程1对A已经加锁，线程2对B已经加锁，那么他们都希望彼此占有对方的锁，又不释放自己占有的锁导致了死锁。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">std::mutex t_lock1;</span><br><span class="line">std::mutex t_lock2;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m_1 = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> m_2 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dead_lock1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;dead_lock1 begin &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        t_lock<span class="number">1.l</span>ock();</span><br><span class="line">        m_1 = <span class="number">1024</span>;</span><br><span class="line">        t_lock<span class="number">2.l</span>ock();</span><br><span class="line">        m_2 = <span class="number">2048</span>;</span><br><span class="line">        t_lock<span class="number">2.</span><span class="built_in">unlock</span>();</span><br><span class="line">        t_lock<span class="number">1.</span><span class="built_in">unlock</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;dead_lock1 end &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dead_lock2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;dead_lock2 begin &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        t_lock<span class="number">2.l</span>ock();</span><br><span class="line">        m_2 = <span class="number">2048</span>;</span><br><span class="line">        t_lock<span class="number">1.l</span>ock();</span><br><span class="line">        m_1 = <span class="number">1024</span>;</span><br><span class="line">        t_lock<span class="number">1.</span><span class="built_in">unlock</span>();</span><br><span class="line">        t_lock<span class="number">2.</span><span class="built_in">unlock</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;dead_lock2 end &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_dead_lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(dead_lock1)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(dead_lock2)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//test_lock();</span></span><br><span class="line">    <span class="comment">//test_threadsafe_stack1();</span></span><br><span class="line">    <span class="built_in">test_dead_lock</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这样运行之后在某一个时刻一定会导致死锁</li>
</ul>
<h4 id="死锁解决办法"><a href="#死锁解决办法" class="headerlink" title="死锁解决办法"></a>死锁解决办法</h4><ul>
<li>实际工作中避免死锁的一个方式就是将加锁和解锁的功能封装为独立的函数，这样能保证在独立的函数里执行完操作后就解锁，不会导致一个函数里使用多个锁的情况,即加锁和解锁作为原子操作解耦合，各自只管理自己的功能</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加锁和解锁作为原子操作解耦合，各自只管理自己的功能</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">atomic_lock1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;lock1 begin lock&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    t_lock<span class="number">1.l</span>ock();</span><br><span class="line">    m_1 = <span class="number">1024</span>;</span><br><span class="line">    t_lock<span class="number">1.</span><span class="built_in">unlock</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;lock1 end lock&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">atomic_lock2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;lock2 begin lock&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    t_lock<span class="number">2.l</span>ock();</span><br><span class="line">    m_2 = <span class="number">2048</span>;</span><br><span class="line">    t_lock<span class="number">2.</span><span class="built_in">unlock</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;lock2 end lock&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">safe_lock1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">atomic_lock1</span>();</span><br><span class="line">        <span class="built_in">atomic_lock2</span>();</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">safe_lock2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">atomic_lock2</span>();</span><br><span class="line">        <span class="built_in">atomic_lock1</span>();</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_safe_lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(safe_lock1)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(safe_lock2)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="同时加锁"><a href="#同时加锁" class="headerlink" title="同时加锁"></a>同时加锁</h3><ul>
<li>当我们无法避免在一个函数内部使用两个互斥量，并且都要解锁的情况，那我们可以采取<strong>同时加锁</strong>的方式。我们先定义一个类,假设这个类不推荐拷贝构造，但我们也提供了这个类的拷贝构造和移动构造</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">som_big_object</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">som_big_object</span>(<span class="type">int</span> data) :_data(data) &#123;&#125;</span><br><span class="line">    <span class="comment">//拷贝构造</span></span><br><span class="line">    <span class="built_in">som_big_object</span>(<span class="type">const</span> som_big_object&amp; b2) :_data(b<span class="number">2.</span>_data) &#123;</span><br><span class="line">        _data = b<span class="number">2.</span>_data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//移动构造</span></span><br><span class="line">    <span class="built_in">som_big_object</span>(som_big_object&amp;&amp; b2) :_data(std::<span class="built_in">move</span>(b<span class="number">2.</span>_data)) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重载输出运算符</span></span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span> &lt;&lt; (std::ostream&amp; os, <span class="type">const</span> som_big_object&amp; big_obj) &#123;</span><br><span class="line">        os &lt;&lt; big_obj._data;</span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重载赋值运算符</span></span><br><span class="line">    som_big_object&amp; <span class="keyword">operator</span> = (<span class="type">const</span> som_big_object&amp; b2) &#123;</span><br><span class="line">        <span class="comment">// _data = std::move(b2._data);</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;b2) &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _data = b<span class="number">2.</span>_data;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交换数据</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">swap</span><span class="params">(som_big_object&amp; b1, som_big_object&amp; b2)</span> </span>&#123;</span><br><span class="line">        som_big_object temp = std::<span class="built_in">move</span>(b1);</span><br><span class="line">        b1 = std::<span class="built_in">move</span>(b2);</span><br><span class="line">        b2 = std::<span class="built_in">move</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>以上代码的一个<strong>小知识</strong>：当我们提供了一个 <strong><em>移动构造函数的时候，就不会提供默认的拷贝和移动赋值函数了</em></strong></p>
</li>
<li><p>接下来我们定义一个类对上面的类做管理，为防止多线程情况下数据混乱， 包含了一个互斥量。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">big_object_mgr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">big_object_mgr</span>(<span class="type">int</span> data = <span class="number">0</span>) :_obj(data) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printinfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;current obj data is &quot;</span> &lt;&lt; _obj &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">danger_swap</span><span class="params">(big_object_mgr&amp; objm1, big_object_mgr&amp; objm2)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">safe_swap</span><span class="params">(big_object_mgr&amp; objm1, big_object_mgr&amp; objm2)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">safe_swap_scope</span><span class="params">(big_object_mgr&amp; objm1, big_object_mgr&amp; objm2)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::mutex _mtx;</span><br><span class="line">    som_big_object _obj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>接下来定义了三个交换函数看看，三个函数哪些是危险的以及为什么</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">danger_swap</span><span class="params">(big_object_mgr&amp; objm1, big_object_mgr&amp; objm2)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;thread [ &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; ] begin&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">if</span> (&amp;objm1 == &amp;objm2) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::lock_guard &lt;std::mutex&gt; <span class="built_in">gurad1</span>(objm<span class="number">1.</span>_mtx);</span><br><span class="line">    <span class="comment">//此处为了故意制造死锁，我们让线程小睡一会</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard2</span><span class="params">(objm<span class="number">2.</span>_mtx)</span></span>;</span><br><span class="line">    <span class="built_in">swap</span>(objm<span class="number">1.</span>_obj, objm<span class="number">2.</span>_obj);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;thread [ &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; ] end&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">safe_swap</span><span class="params">(big_object_mgr&amp; objm1, big_object_mgr&amp; objm2)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;thread [ &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; ] begin&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">if</span> (&amp;objm1 == &amp;objm2) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同时加多个锁</span></span><br><span class="line">    std::<span class="built_in">lock</span>(objm<span class="number">1.</span>_mtx, objm<span class="number">2.</span>_mtx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//领养锁管理它自动释放，std::adopt_lock有了这个操作后gurad1就只会负责解锁而不负责加锁</span></span><br><span class="line">    std::lock_guard &lt;std::mutex&gt; <span class="built_in">gurad1</span>(objm<span class="number">1.</span>_mtx, std::adopt_lock);</span><br><span class="line">    <span class="comment">//此处为了故意制造死锁，我们让线程小睡一会</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    std::lock_guard &lt;std::mutex&gt; <span class="built_in">gurad2</span>(objm<span class="number">2.</span>_mtx, std::adopt_lock);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">swap</span>(objm<span class="number">1.</span>_obj, objm<span class="number">2.</span>_obj);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;thread [ &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; ] end&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当然上面加锁的方式可以简化，C++17 scope_lock可以对多个互斥量同时加锁，并且自动释放</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">safe_swap_scope</span><span class="params">(big_object_mgr&amp; objm1, big_object_mgr&amp; objm2)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;thread [ &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; ] begin&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">if</span> (&amp;objm1 == &amp;objm2) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::scoped_lock  <span class="title">guard</span><span class="params">(objm<span class="number">1.</span>_mtx, objm<span class="number">2.</span>_mtx)</span></span>;</span><br><span class="line">    <span class="comment">//等价于</span></span><br><span class="line">    <span class="comment">//std::scoped_lock&lt;std::mutex, std::mutex&gt; guard(objm1._mtx, objm2._mtx);</span></span><br><span class="line">    <span class="built_in">swap</span>(objm<span class="number">1.</span>_obj, objm<span class="number">2.</span>_obj);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;thread [ &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; ] end&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">test_danger_swap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">big_object_mgr <span class="title">objm1</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="function">big_object_mgr <span class="title">objm2</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(danger_swap, std::ref(objm1), std::ref(objm2))</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(danger_swap, std::ref(objm2), std::ref(objm1))</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    objm<span class="number">1.</span><span class="built_in">printinfo</span>();</span><br><span class="line">    objm<span class="number">2.</span><span class="built_in">printinfo</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_safe_swap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">big_object_mgr <span class="title">objm1</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="function">big_object_mgr <span class="title">objm2</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(safe_swap, std::ref(objm1), std::ref(objm2))</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(safe_swap, std::ref(objm2), std::ref(objm1))</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    objm<span class="number">1.</span><span class="built_in">printinfo</span>();</span><br><span class="line">    objm<span class="number">2.</span><span class="built_in">printinfo</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>C++17的<strong>scoped_lock</strong>，用于多个互斥锁的免死锁 RAII 封装器，是一种更加灵活和安全的互斥量管理方式。是一种独占互斥锁，它可以同时锁定多个互斥锁，并保证以原子方式获得所有互斥锁，从而有效避免死锁。</p>
</li>
<li><p>它可以接受多个互斥锁作为参数，并在构造函数中自动锁定这些互斥锁。</p>
</li>
<li>当std::scoped_lock对象出作用域时，它会析构并自动解锁所有已经锁定的互斥锁，确保互斥访问的安全性和正确性。</li>
</ul>
<h3 id="thread-local"><a href="#thread-local" class="headerlink" title="thread_local"></a>thread_local</h3><ul>
<li>这个修饰符的意思是创建一个线程变量，它只会在线程创建时初始化一次，在同一个线程内部的所有对象是共享的，但是不同线程的对象之间不是共享的，也就意味着这个是线程安全的</li>
</ul>
<h3 id="层级加锁"><a href="#层级加锁" class="headerlink" title="层级加锁"></a>层级加锁</h3><ul>
<li>现实开发中常常很难规避同一个函数内部加多个锁的情况，我们要尽可能避免循环加锁，所以可以自定义一个层级锁，保证实际项目中对多个互斥量加锁时是有序的，这可以用于检测你所加的锁是否会引起死锁</li>
<li>大概原理就是：首先每个线程默认都会有一个层级(优先级)（不同线程不共享），这个优先级是ulong的最大值，还有一个变量是用来计算当前允许加锁的层级（不同线程共享），还有一个变量是记录的上一次线程加锁的层值,当线程的层级大于锁的层级时才可以加锁，否则不能，析构的时候就把层级还原（赋给thread_local的层级变量）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//层级锁</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hierarchical_mutex</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">hierarchical_mutex</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> value)</span> :_hierarchy_value(value),</span></span><br><span class="line"><span class="function">        _previous_hierarchy_value(<span class="number">0</span>) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">hierarchical_mutex</span>(<span class="type">const</span> hierarchical_mutex&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    hierarchical_mutex&amp; <span class="keyword">operator</span>=(<span class="type">const</span> hierarchical_mutex&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">check_for_hierarchy_violation</span>();</span><br><span class="line">        _internal_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="built_in">update_hierarchy_value</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解锁</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_this_thread_hierarchy_value != _hierarchy_value) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;mutex hierarchy violated&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        _this_thread_hierarchy_value = _previous_hierarchy_value;</span><br><span class="line">        _internal_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//尝试加锁</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">try_lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">check_for_hierarchy_violation</span>();</span><br><span class="line">        <span class="keyword">if</span> (!_internal_mutex.<span class="built_in">try_lock</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">update_hierarchy_value</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">//内在的锁 </span></span><br><span class="line">    std::mutex  _internal_mutex;</span><br><span class="line">    <span class="comment">//当前层级值（优先级）,只有大于等于这个值的锁才可以加锁</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> _hierarchy_value;</span><br><span class="line">    <span class="comment">//上一次层级值</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> _previous_hierarchy_value;</span><br><span class="line">    <span class="comment">//本线程记录的层级值</span></span><br><span class="line">    <span class="type">static</span> <span class="keyword">thread_local</span>  <span class="type">unsigned</span> <span class="type">long</span>  _this_thread_hierarchy_value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否能加锁，当线程当前层级大于允许加锁层级是才可加锁，否则不行</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">check_for_hierarchy_violation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_this_thread_hierarchy_value &lt;= _hierarchy_value) &#123;</span><br><span class="line">            <span class="keyword">throw</span>  std::<span class="built_in">logic_error</span>(<span class="string">&quot;mutex  hierarchy violated&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新层级</span></span><br><span class="line">    <span class="function"><span class="type">void</span>  <span class="title">update_hierarchy_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        _previous_hierarchy_value = _this_thread_hierarchy_value;</span><br><span class="line">        _this_thread_hierarchy_value = _hierarchy_value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义静态成员，thread_local 表示线程本地，是属于一个线程作用域，不是共用的，也就是说t1与t2不共享这个</span></span><br><span class="line"><span class="keyword">thread_local</span> <span class="type">unsigned</span> <span class="type">long</span> hierarchical_mutex::_this_thread_hierarchy_value(ULONG_MAX);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_hierarchy_lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">hierarchical_mutex  <span class="title">hmtx1</span><span class="params">(<span class="number">1000</span>)</span></span>;</span><br><span class="line">    <span class="function">hierarchical_mutex  <span class="title">hmtx2</span><span class="params">(<span class="number">500</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;hmtx1, &amp;hmtx2]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        hmtx<span class="number">1.l</span>ock();</span></span></span><br><span class="line"><span class="params"><span class="function">        hmtx<span class="number">2.l</span>ock();</span></span></span><br><span class="line"><span class="params"><span class="function">        hmtx<span class="number">2.</span>unlock();</span></span></span><br><span class="line"><span class="params"><span class="function">        hmtx<span class="number">1.</span>unlock();</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([&amp;hmtx1, &amp;hmtx2]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        hmtx<span class="number">2.l</span>ock();</span></span></span><br><span class="line"><span class="params"><span class="function">        hmtx<span class="number">1.l</span>ock();</span></span></span><br><span class="line"><span class="params"><span class="function">        hmtx<span class="number">1.</span>unlock();</span></span></span><br><span class="line"><span class="params"><span class="function">        hmtx<span class="number">2.</span>unlock();</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>层级锁能保证我们每个线程加锁时，一定是先加权重高的锁。并且释放时也保证了顺序。主要原理就是将当前锁的权重保存在线程变量中，这样该线程再次加锁时判断线程变量的权重和锁的权重是否大于，如果满足条件则继续加锁。</li>
</ul>
<h2 id="C-unique-lock，共享锁和递归锁"><a href="#C-unique-lock，共享锁和递归锁" class="headerlink" title="C++unique_lock，共享锁和递归锁"></a>C++unique_lock，共享锁和递归锁</h2><h3 id="unique-lock"><a href="#unique-lock" class="headerlink" title="unique_lock"></a>unique_lock</h3><ul>
<li>unique_lock和lock_guard基本用法相同，构造时默认加锁，析构时默认解锁，但unique_lock有个好处就是可以<strong>手动解锁</strong>。这一点尤为重要，方便我们控制锁住区域的粒度(加锁的范围大小),也能支持和条件变量配套使用，至于条件变量我们之后再介绍，本文主要介绍锁的相关操作。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_unique</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx1)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;lock success&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    share_data++;</span><br><span class="line">    <span class="comment">//可以手动解锁</span></span><br><span class="line">    lock.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*som_big_object obj1(100);</span></span><br><span class="line"><span class="comment">    som_big_object obj2(100);</span></span><br><span class="line"><span class="comment">    obj2 = std::move(obj1);*/</span></span><br><span class="line">    <span class="comment">//test_lock();</span></span><br><span class="line">    <span class="comment">//test_threadsafe_stack1();</span></span><br><span class="line">    <span class="comment">//test_dead_lock();</span></span><br><span class="line">    <span class="comment">//test_hierarchy_lock();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="unique-lock的owns-lock判断是否持有锁"><a href="#unique-lock的owns-lock判断是否持有锁" class="headerlink" title="unique_lock的owns_lock判断是否持有锁"></a>unique_lock的owns_lock判断是否持有锁</h4><ul>
<li>我们可以通过unique_lock的owns_lock判断是否持有锁</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可判断是否占有锁</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">owns_lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//lock可自动解锁，也可手动解锁</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    shared_data++;</span><br><span class="line">    <span class="keyword">if</span> (lock.<span class="built_in">owns_lock</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;owns lock&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;doesn&#x27;t own lock&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    lock.<span class="built_in">unlock</span>();</span><br><span class="line">    <span class="keyword">if</span> (lock.<span class="built_in">owns_lock</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;owns lock&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;doesn&#x27;t own lock&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="unique-lock的延迟加锁defer-lock"><a href="#unique-lock的延迟加锁defer-lock" class="headerlink" title="unique_lock的延迟加锁defer_lock"></a>unique_lock的延迟加锁defer_lock</h4><ul>
<li>允许延迟加锁, <strong>std::defer_lock</strong> 表示延迟加锁的意思</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以延迟加锁</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">defer_lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//延迟加锁，锁正常初始化，但并没有自动加锁</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx, std::defer_lock)</span></span>;</span><br><span class="line">    <span class="comment">//可以加锁</span></span><br><span class="line">    lock.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="comment">//可以自动析构解锁，也可以手动解锁</span></span><br><span class="line">    lock.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="unique-lock的领养加锁"><a href="#unique-lock的领养加锁" class="headerlink" title="unique_lock的领养加锁"></a>unique_lock的领养加锁</h4><ul>
<li>和lock_guard一样，unique_lock也支持领养锁，尽管是领养的，但是打印还是会出现owns lock，因为不管如何锁被加上，就会输出owns lock。</li>
<li><strong>注意</strong>:领养一个锁前一定要加锁，否则就会报错，因为你领养前如果不加锁，后面他会自动解锁，而你本来没有加锁就会让一个没加锁的锁解锁就会报错</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_own_adopt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mtx<span class="number">1.l</span>ock();</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx1, std::adopt_lock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (lock.<span class="built_in">owns_lock</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;owns lock&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;dose not have the lock&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    lock.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>既然unique_lock支持领养操作也支持延迟加锁，那么可以用两种方式实现前文lock_guard实现的swap操作。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//之前的交换代码可以可以用如下方式等价实现</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">99</span>;</span><br><span class="line">std::mutex  mtx1;</span><br><span class="line">std::mutex  mtx2;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">safe_swap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">lock</span>(mtx1, mtx2);</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock1</span><span class="params">(mtx1, std::adopt_lock)</span></span>;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock2</span><span class="params">(mtx2, std::adopt_lock)</span></span>;</span><br><span class="line">    std::<span class="built_in">swap</span>(a, b);</span><br><span class="line">    <span class="comment">// 错误用法，因为此时mtx1已经没有所有权了</span></span><br><span class="line">    <span class="comment">//mtx1.unlock();</span></span><br><span class="line">    <span class="comment">//mtx2.unlock();</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">safe_swap2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock1</span><span class="params">(mtx1, std::defer_lock)</span></span>;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock2</span><span class="params">(mtx2, std::defer_lock)</span></span>;</span><br><span class="line">    <span class="comment">//需用lock1,lock2加锁</span></span><br><span class="line">    std::<span class="built_in">lock</span>(lock1, lock2);</span><br><span class="line">    <span class="comment">//错误用法</span></span><br><span class="line">    <span class="comment">//std::lock(mtx1, mtx2);</span></span><br><span class="line">    std::<span class="built_in">swap</span>(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>大家注意一旦mutex被unique_lock管理，加锁和释放的操作就交给unique_lock，不能调用mutex加锁和解锁，因为锁的使用权已经交给unique_lock了</li>
<li><p><strong>unique_lock</strong> 在底层实现了移动赋值函数以及移动构造函数，禁止了拷贝构造和拷贝复制函数</p>
</li>
<li><p>我们知道mutex是不支持移动和拷贝的，但是unique_lock支持移动，当一个mutex被转移给unique_lock后，可以通过unique_ptr转移其归属权.</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//转移互斥量所有权</span></span><br><span class="line"><span class="comment">//互斥量本身不支持move操作，但是unique_lock支持</span></span><br><span class="line">std::unique_lock &lt;std::mutex&gt;  <span class="built_in">get_lock</span>() &#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt;  <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    shared_data++;</span><br><span class="line">    <span class="keyword">return</span> lock;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_return</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(get_lock())</span></span>;</span><br><span class="line">    shared_data++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="锁的粒度"><a href="#锁的粒度" class="headerlink" title="锁的粒度"></a>锁的粒度</h4><ul>
<li>锁的粒度表示加锁（范围）的精细程度，一个锁的粒度足够大，保证可以锁住要访问的共享数据</li>
<li>同时一个锁的粒度足够小，保证非共享数据不被锁住影响效率而unique_lock则很好的支持手动解锁</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">precision_lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    shared_data++;</span><br><span class="line">    lock.<span class="built_in">unlock</span>();</span><br><span class="line">    <span class="comment">//不设计共享数据的耗时操作不要放在锁内执行</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    lock.<span class="built_in">lock</span>();</span><br><span class="line">    shared_data++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="共享锁shared-lock以及shared-mutex"><a href="#共享锁shared-lock以及shared-mutex" class="headerlink" title="共享锁shared_lock以及shared_mutex"></a>共享锁shared_lock以及shared_mutex</h3><ul>
<li>试想这样一个场景，对于一个DNS服务，我们可以根据域名查询服务对应的ip地址，它很久才更新一次，比如新增记录，删除记录或者更新记录等。平时大部分时间都是提供给外部查询，对于查询操作，即使多个线程并发查询不加锁也不会有问题，但是当有线程修改DNS服务的ip记录或者增减记录时，其他线程不能查询，需等待修改完再查询。或者等待查询完，线程才能修改。也就是说读操作并不是互斥的，同一时间可以有多个线程同时读，但是写和读是互斥的，写与写是互斥的，简而言之，写操作需要独占锁。而读操作需要共享锁。</li>
<li>要想使用共享锁，需使用<strong>共享互斥量std::shared_mutex</strong>,std::shared_mutex是<strong>C++17</strong>标准提出的。</li>
<li><strong>C++14标准</strong>可以使用<strong>std::shared_time_mutex</strong></li>
<li><strong>C++11</strong>的话可以使用boost</li>
<li>std::shared_mutex 和 std::shared_timed_mutex 都是用于实现多线程并发访问共享数据的互斥锁，但它们之间存在一些区别：<ol>
<li>std::shared_mutex：</li>
</ol>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 提供了 `lock()`, `try_lock()`, 和 `try_lock_for()` 以及 `try_lock_until()` 函数，这些函数都可以用于获取互斥锁。</span><br><span class="line">* 提供了 `try_lock_shared()` 和 `lock_shared()` 函数，这些函数可以用于获取共享锁。</span><br><span class="line">* 当 `<span class="built_in">std</span>::shared_mutex` 被锁定后，其他尝试获取该锁的线程将会被阻塞，直到该锁被解锁。</span><br></pre></td></tr></table></figure>
<ol>
<li>std::shared_timed_mutex：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 与 `<span class="built_in">std</span>::shared_mutex` 类似，也提供了 `lock()`, `try_lock()`, 和 `try_lock_for()` 以及  `try_lock_until()` 函数用于获取互斥锁。</span><br><span class="line">* 与 `<span class="built_in">std</span>::shared_mutex` 不同的是，它还提供了 `try_lock_shared()` 和 `lock_shared()` 函数用于获取共享锁，这些函数在尝试获取共享锁时具有超时机制。</span><br><span class="line">* 当 `<span class="built_in">std</span>::shared_timed_mutex` 被锁定后，其他尝试获取该锁的线程将会被阻塞，直到该锁被解锁，这与 `<span class="built_in">std</span>::shared_mutex` 相同。然而，当尝试获取共享锁时，如果不能立即获得锁，`<span class="built_in">std</span>::shared_timed_mutex` 会设置一个超时，超时过后如果仍然没有获取到锁，则操作将返回失败。</span><br></pre></td></tr></table></figure>
<ul>
<li><p>因此，std::shared_timed_mutex 提供了额外的超时机制，这使得它在某些情况下更适合于需要处理超时的并发控制。然而，如果不需要超时机制，可以使用更简单的 std::shared_mutex。</p>
</li>
<li><p>下面我们定义了一个DNS类，查询使用共享锁，写数据使用独占锁</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DNSserver</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DNSserver</span>()&#123;&#125;</span><br><span class="line">    <span class="function">std::string <span class="title">QueryDNS</span><span class="params">(<span class="type">const</span> std::string&amp; dnsname)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::shared_lock&lt;std::shared_mutex&gt; <span class="title">shared_locks</span><span class="params">(_shared_mtx)</span></span>;</span><br><span class="line">        <span class="keyword">auto</span> iter = _dns_info.<span class="built_in">find</span>(dnsname);</span><br><span class="line">        <span class="keyword">if</span> (iter != _dns_info.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> iter-&gt;second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span><span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddDNSInfo</span><span class="params">(<span class="type">const</span> std::string&amp; dnsname,<span class="type">const</span> std::string&amp; dnsentry)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::shared_mutex&gt; <span class="title">lock_guards</span><span class="params">(_shared_mtx)</span></span>;</span><br><span class="line">        <span class="keyword">auto</span> iter = _dns_info.<span class="built_in">find</span>(dnsname);</span><br><span class="line">        <span class="keyword">if</span> (iter != _dns_info.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            _dns_info[dnsname] = dnsentry;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> _dns_info.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(dnsname, dnsentry));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> std::shared_mutex _shared_mtx;</span><br><span class="line">    std::map&lt;std::string, std::string&gt; _dns_info;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="递归锁"><a href="#递归锁" class="headerlink" title="递归锁"></a>递归锁</h3><ul>
<li><p>有时候我们在实现接口的时候内部加锁，接口内部调用完结束自动解锁。会出现一个接口调用另一个接口的情况，如果用普通的std::mutex就会出现卡死，因为嵌套加锁导致卡死。但是我们可以使用递归锁。</p>
</li>
<li><p>但我个人并不推荐递归锁，可以从设计源头规避嵌套加锁的情况，我们可以将接口相同的功能抽象出来，统一加锁。下面的设计演示了如何使用递归锁</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RecursiveDemo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RecursiveDemo</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">QueryStudent</span><span class="params">(std::string name)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::recursive_mutex&gt;  <span class="title">recursive_lock</span><span class="params">(_recursive_mtx)</span></span>;</span><br><span class="line">        <span class="keyword">auto</span> iter_find = _students_info.<span class="built_in">find</span>(name);</span><br><span class="line">        <span class="keyword">if</span> (iter_find == _students_info.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddScore</span><span class="params">(std::string name, <span class="type">int</span> score)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::recursive_mutex&gt;  <span class="title">recursive_lock</span><span class="params">(_recursive_mtx)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">QueryStudent</span>(name)) &#123;</span><br><span class="line">            _students_info.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(name, score));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _students_info[name] = _students_info[name] + score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不推荐采用递归锁，使用递归锁说明设计思路并不理想，需优化设计</span></span><br><span class="line">    <span class="comment">//推荐拆分逻辑，将共有逻辑拆分为统一接口</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddScoreAtomic</span><span class="params">(std::string name, <span class="type">int</span> score)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::recursive_mutex&gt;  <span class="title">recursive_lock</span><span class="params">(_recursive_mtx)</span></span>;</span><br><span class="line">        <span class="keyword">auto</span> iter_find = _students_info.<span class="built_in">find</span>(name);</span><br><span class="line">        <span class="keyword">if</span> (iter_find == _students_info.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            _students_info.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(name, score));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _students_info[name] = _students_info[name] + score;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::map&lt;std::string, <span class="type">int</span>&gt; _students_info;</span><br><span class="line">    std::recursive_mutex   _recursive_mtx;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>我们可以看到AddScore函数内部调用了QueryStudent, 所以采用了递归锁。</li>
<li>但是我们同样可以改变设计，将两者公有的部分抽离出来生成一个新的接口AddScoreAtomic.</li>
<li>AddScoreAtomic可以不适用递归锁，照样能完成线程安全操作的目的。</li>
</ul>
<h2 id="C-线程安全单例模式的演变"><a href="#C-线程安全单例模式的演变" class="headerlink" title="C++线程安全单例模式的演变"></a>C++线程安全单例模式的演变</h2><h3 id="局部静态变量"><a href="#局部静态变量" class="headerlink" title="局部静态变量"></a>局部静态变量</h3><ul>
<li>C++11之后可以使用静态内部方法来实现，我们知道当一个函数中定义一个局部静态变量，那么这个局部静态变量只会初始化一次，就是在这个函数第一次调用的时候，以后无论调用几次这个函数，函数内的局部静态变量都不再初始化。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Single2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Single2&amp; <span class="title">GetInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> Single2 single;</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Single2</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Single2</span>(<span class="type">const</span> Single2&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Single2&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Single2&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="饿汉与懒汉式，详情看面试笔记"><a href="#饿汉与懒汉式，详情看面试笔记" class="headerlink" title="饿汉与懒汉式，详情看面试笔记"></a>饿汉与懒汉式，详情看面试笔记</h3><h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><ul>
<li>懒汉与饿汉式存在一个缺陷，存在多重释放或者不知道哪个指针释放的问题。</li>
<li>所以我们想到可以用智能指针来自动释放</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以利用智能指针完成自动回收</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleAuto</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">SingleAuto</span>()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">SingleAuto</span>(<span class="type">const</span> SingleAuto&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    SingleAuto&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SingleAuto&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">SingleAuto</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;single auto delete success &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> std::shared_ptr&lt;SingleAuto&gt; <span class="title">GetInst</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (single != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> single;</span><br><span class="line">        &#125;</span><br><span class="line">        s_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span> (single != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">return</span> single;</span><br><span class="line">        &#125;</span><br><span class="line">        single = std::<span class="built_in">shared_ptr</span>&lt;SingleAuto&gt;(<span class="keyword">new</span> SingleAuto);</span><br><span class="line">        s_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> std::shared_ptr&lt;SingleAuto&gt; single;</span><br><span class="line">    <span class="type">static</span> std::mutex s_mutex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::shared_ptr&lt;SingleAuto&gt; SingleAuto::single = <span class="literal">nullptr</span>;</span><br><span class="line">std::mutex SingleAuto::s_mutex;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_singleauto</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> sp1 = SingleAuto::<span class="built_in">GetInst</span>();</span><br><span class="line">    <span class="keyword">auto</span> sp2 = SingleAuto::<span class="built_in">GetInst</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sp1  is  &quot;</span> &lt;&lt; sp1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sp2  is  &quot;</span> &lt;&lt; sp2 &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">//此时存在隐患，可以手动删除裸指针，造成崩溃</span></span><br><span class="line">    <span class="comment">// delete sp1.get();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这样开辟的资源交给智能指针管理免去了回收资源的麻烦。但是有些人觉得虽然智能指针能自动回收内存，如果有开发人员手动delete指针怎么办？</li>
<li>可以直接把<strong>析构函数设为私有</strong>吗？ 不行，因为析构的时候会调用智能指针的析构函数，在智能指针的析构函数里会调用单例模式的析构，而单例模式的析构是私有无法析构</li>
<li>所以有人提出了利用<strong>辅助类帮助智能指针释放资源，将智能指针的析构设置为私有</strong>。</li>
</ul>
<h4 id="改进方案"><a href="#改进方案" class="headerlink" title="改进方案"></a>改进方案</h4><ul>
<li><strong>辅助类帮助智能指针释放资源，将智能指针的析构设置为私有</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为了规避用户手动释放内存，可以提供一个辅助类帮忙回收内存</span></span><br><span class="line"><span class="comment">//并将单例类的析构函数写为私有</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleAutoSafe</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SafeDeletor</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(SingleAutoSafe* sf)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;this is safe deleter operator()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">delete</span> sf;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleAutoSafe</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">SingleAutoSafe</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">SingleAutoSafe</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;this is single auto safe deletor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">SingleAutoSafe</span>(<span class="type">const</span> SingleAutoSafe&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    SingleAutoSafe&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SingleAutoSafe&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="comment">//定义友元类，通过友元类调用该类析构函数</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">SafeDeletor</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> std::shared_ptr&lt;SingleAutoSafe&gt; <span class="title">GetInst</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//1处</span></span><br><span class="line">        <span class="keyword">if</span> (single != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> single;</span><br><span class="line">        &#125;</span><br><span class="line">        s_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="comment">//2处</span></span><br><span class="line">        <span class="keyword">if</span> (single != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">return</span> single;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//额外指定删除器  </span></span><br><span class="line">        <span class="comment">//3 处</span></span><br><span class="line">        single = std::<span class="built_in">shared_ptr</span>&lt;SingleAutoSafe&gt;(<span class="keyword">new</span> SingleAutoSafe, <span class="built_in">SafeDeletor</span>());</span><br><span class="line">        <span class="comment">//也可以指定删除函数</span></span><br><span class="line">        <span class="comment">// single = std::shared_ptr&lt;SingleAutoSafe&gt;(new SingleAutoSafe, SafeDelFunc);</span></span><br><span class="line">        s_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> std::shared_ptr&lt;SingleAutoSafe&gt; single;</span><br><span class="line">    <span class="type">static</span> std::mutex s_mutex;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>SafeDeletor就是删除的辅助类，实现了仿函数。构造智能指针时指定了SafeDeletor对象，这样就能帮助智能指针释放了。</p>
</li>
<li><p>但是上面的代码存在危险，比如懒汉式的使用方式，当多个线程调用单例时，有一个线程加锁进入3处的逻辑。</p>
</li>
<li><p>其他的线程有的在1处，判断指针非空则跳过初始化直接使用单例的内存会存在问题。<br>主要原因在于SingleAutoSafe * temp = new SingleAutoSafe() 这个操作是由三部分组成的</p>
<ol>
<li>调用allocate开辟内存</li>
<li>调用construct执行SingleAutoSafe的构造函数</li>
<li>调用赋值操作将地址赋值给temp</li>
</ol>
</li>
<li><p>而现实中2和3的步骤可能颠倒，所以有可能在一些编译器中通过优化是1，3，2的调用顺序，<br>其他线程取到的指针就是非空，还没来的及调用构造函数就交给外部使用造成不可预知错误。<br>为解决这个问题，<strong>C++11 推出了std::call_once函数保证多个线程只执行一次</strong></p>
</li>
</ul>
<h3 id="call-once"><a href="#call-once" class="headerlink" title="call_once"></a>call_once</h3><ul>
<li>C++11 提出了call_once函数，我们可以配合一个局部的静态变量once_flag实现线程安全的初始化。</li>
<li>多线程调用call_once函数时，会判断once_flag是否被初始化，如没被初始化则进入初始化流程，调用我们提供的初始化函数。但是同一时刻只有一个线程能进入这个初始化函数。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingletonOnce</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">SingletonOnce</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">SingletonOnce</span>(<span class="type">const</span> SingletonOnce&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    SingletonOnce&amp; <span class="keyword">operator</span> = (<span class="type">const</span> SingletonOnce&amp; st) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="type">static</span> std::shared_ptr&lt;SingletonOnce&gt; _instance;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="function"><span class="type">static</span> std::shared_ptr&lt;SingletonOnce&gt; <span class="title">GetInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> std::once_flag s_flag;</span><br><span class="line">        std::<span class="built_in">call_once</span>(s_flag, [&amp;]() &#123;</span><br><span class="line">            _instance = std::<span class="built_in">shared_ptr</span>&lt;SingletonOnce&gt;(<span class="keyword">new</span> SingletonOnce);</span><br><span class="line">            &#125;);</span><br><span class="line">        <span class="keyword">return</span> _instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PrintAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; _instance.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">SingletonOnce</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;this is singleton destruct&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">std::shared_ptr&lt;SingletonOnce&gt; SingletonOnce::_instance = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestSingle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::this_thread::sleep_for(std::chrono::seconds(<span class="number">1</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">            SingletonOnce::GetInstance()-&gt;PrintAddress();    </span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::this_thread::sleep_for(std::chrono::seconds(<span class="number">1</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">            SingletonOnce::GetInstance()-&gt;PrintAddress();</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>为了使用单例类更通用，比如项目中使用多个单例类，可以通过继承实现多个单例类</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为了让单例更加通用，可以做成模板类</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&lt;T&gt;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&lt;T&gt;&amp; st) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="type">static</span> std::shared_ptr&lt;T&gt; _instance;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> std::shared_ptr&lt;T&gt; <span class="title">GetInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> std::once_flag s_flag;</span><br><span class="line">        std::<span class="built_in">call_once</span>(s_flag, [&amp;]() &#123;</span><br><span class="line">            _instance = std::<span class="built_in">shared_ptr</span>&lt;T&gt;(<span class="keyword">new</span> T);</span><br><span class="line">            &#125;);</span><br><span class="line">        <span class="keyword">return</span> _instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PrintAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; _instance.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Singleton</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;this is singleton destruct&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::shared_ptr&lt;T&gt; Singleton&lt;T&gt;::_instance = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//想使用单例类，可以继承上面的模板，我们在网络编程中逻辑单例类用的就是这种方式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LogicSystem</span> :<span class="keyword">public</span> Singleton&lt;LogicSystem&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&lt;LogicSystem&gt;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">LogicSystem</span>()&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">LogicSystem</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="总结1"><a href="#总结1" class="headerlink" title="总结1"></a>总结1</h3><ul>
<li>如果你只是实现一个简单的单例类推荐使用返回局部静态变量的方式</li>
<li>如果想大规模实现多个单例类可以用call_once实现的模板类。</li>
</ul>
<h2 id="C-11多线程同步"><a href="#C-11多线程同步" class="headerlink" title="C++11多线程同步"></a>C++11多线程同步</h2><ul>
<li>在多线程编程中，有许多情况需要线程之间的同步，比如你得先登录才能执行其他操作等情况，这可以通过<strong>std::future</strong>和<strong>std::promise</strong>来实现</li>
</ul>
<h3 id="使用future与promise"><a href="#使用future与promise" class="headerlink" title="使用future与promise"></a>使用future与promise</h3><ul>
<li><strong>std::future</strong>是一个对象，可以从某个对象或函数获取值，并在不同线程之间提供恰当的同步访问。</li>
<li><p><strong>std::promise</strong>是可以存储类型T的值的对象，该值可以被另一线程的std::future对象获取，并提供了同步机制。</p>
</li>
<li><p>简单来说就是，promise存储了一个在未来会改变其值（类型为T）的对象，并且在未来会改变该值，而future则存储一个已知其值在将来会改变的值，并且在该值改变后可以线程安全地读取。</p>
</li>
<li>这两一般配合使用,以下为<strong>线程间共享一个需要另一个线程设置变量时的代码</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(std::promise&lt;<span class="type">int</span>&gt; * pro)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread B&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">3</span>));</span><br><span class="line">    pro-&gt;<span class="built_in">set_value</span>(<span class="number">23</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_future</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::promise&lt;<span class="type">int</span>&gt; promObj;</span><br><span class="line">    <span class="comment">// 将promise&lt;T&gt;转成future&lt;T&gt;</span></span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; futObj = promObj.<span class="built_in">get_future</span>();</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(init, &amp;promObj)</span></span>;</span><br><span class="line">    <span class="comment">// 只有在promise被设置值的时候这个才不会被阻塞，否则就会一直阻塞直到设置值为止</span></span><br><span class="line">    std::cout &lt;&lt; futObj.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>future与promise的关系</strong>：promise就相当于生产者生成的一个东西，消费者通过把它转换为future来读取这个东西，也就是说生产者线程可以使用 std::promise 设置异步任务的结果，而消费者线程可以通过 std::future 等待异步任务的完成并获取结果</p>
</li>
<li><p>实现线程间的同步操作</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">loginSrv</span><span class="params">(std::promise&lt;<span class="type">bool</span>&gt; * promObj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread B&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 模拟登录操作，假设登录成功</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">3</span>));</span><br><span class="line">    promObj-&gt;<span class="built_in">set_value</span>(<span class="literal">true</span>); <span class="comment">// 设置登录结果为 true</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::promise&lt;<span class="type">bool</span>&gt; promiseObj;</span><br><span class="line">    std::future&lt;<span class="type">bool</span>&gt; futureObj = promiseObj.<span class="built_in">get_future</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::thread <span class="title">th</span><span class="params">(loginSrv, &amp;promiseObj)</span></span>; <span class="comment">// 启动线程B</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 等待登录结果，最多等待10秒</span></span><br><span class="line">    <span class="keyword">auto</span> status = futureObj.<span class="built_in">wait_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">10</span>));</span><br><span class="line">    <span class="keyword">if</span> (status == std::future_status::ready) &#123;</span><br><span class="line">        <span class="comment">// 异步操作已完成</span></span><br><span class="line">        <span class="keyword">if</span> (futureObj.<span class="built_in">get</span>()) &#123;</span><br><span class="line">            <span class="comment">// 登录成功</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Login succeeded!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="comment">// 进行登录成功后的操作</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 登录失败</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Login failed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="comment">// 进行登录失败后的操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == std::future_status::timeout) &#123;</span><br><span class="line">        <span class="comment">// 超时未登录成功</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Timeout! Login failed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 进行超时后的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    th.<span class="built_in">join</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>future对象的<strong>wait_for函数</strong>会<strong>阻塞</strong>等待结果变得可用，可用的标志为以下两种情况之一：</p>
</li>
<li><p>设置的时间超时</p>
</li>
<li><p>共享对象的状态变为ready</p>
</li>
<li><p>原型如下:</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Rep, <span class="keyword">class</span> Period &gt;</span></span><br><span class="line"><span class="function">std::future_status <span class="title">wait_for</span><span class="params">( <span class="type">const</span> std::chrono::duration&lt;Rep,Period&gt;&amp; timeout_duration )</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>返回值标识了结果的状态，为：</p>
<ol>
<li>future_status::deferred ：计算结果的函数未启动</li>
<li>future_status::ready：结果ready</li>
<li>future_status::timeout：超时</li>
</ol>
</li>
</ul>
<h3 id="使用条件变量来实现同步"><a href="#使用条件变量来实现同步" class="headerlink" title="使用条件变量来实现同步"></a>使用条件变量来实现同步</h3><ul>
<li>当某个线程的执行需要另一个线程完成后才能进行，可以使用条件变量(condition_variable)。</li>
<li><p>也可以把它理解为信号通知机制，一个线程负责发送信号，其他线程等待该信号的触发,condition_variable 存在一些问题，如虚假唤醒</p>
</li>
<li><p><strong>通知方</strong></p>
</li>
<li><p>获取 std::mutex, 通常是 std::lock_guard</p>
</li>
<li>修改共享变量（即使共享变量是原子变量，也需要在互斥对象内进行修改，以保证正确地将修改发布到等待线程）</li>
<li><p>在 condition_variable 上执行 notify_one/notify_all 通知条件变量（该操作不需要锁）</p>
</li>
<li><p><strong>等待方</strong></p>
</li>
<li><p>获取相同的std::mutex，使用std::unique_lock</p>
</li>
<li>执行wait，wait_for或wait_until(该操作会自动释放锁并阻塞)</li>
<li><p>接收到条件变量通知、超时或者发生虚假唤醒时，线程被唤醒，并自动获取锁。唤醒的线程负责检查共享变量，如果是虚假唤醒，则应继续等待</p>
</li>
<li><p><strong>注意：</strong> </p>
<ol>
<li>std :: condition_variable仅适用于 std::unique_lock, 此限制允许在某些平台上获得最大效率。 </li>
<li>std :: condition_variable_any提供可与任何BasicLockable对象一起使用的条件变量，例如std :: shared_lock。</li>
</ol>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">std::mutex mtx_num;</span><br><span class="line">std::condition_variable cvA;</span><br><span class="line">std::condition_variable cvB;</span><br><span class="line"><span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ResonableImplemention</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span> (; ;) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::unique_lock&lt;std::mutex&gt; lock(mtx_num);</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="comment">//方法一</span></span></span></span><br><span class="line"><span class="params"><span class="function">            cvA.wait(lock, []() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">return</span> num == <span class="number">1</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">                &#125;);</span></span></span><br><span class="line"><span class="params"><span class="function">            num++;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::cout &lt;&lt; <span class="string">&quot;thread A point 1......&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">            cvB.notify_one();</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">     &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span> (;;) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::unique_lock&lt;std::mutex&gt; lock(mtx_num);</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="comment">//方法二</span></span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">while</span> (num != <span class="number">2</span>) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                cvB.wait(lock);</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">            num--;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::cout &lt;&lt; <span class="string">&quot;thread B point 2.......&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">            cvA.notify_one();</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="利用条件变量实现线程安全队列"><a href="#利用条件变量实现线程安全队列" class="headerlink" title="利用条件变量实现线程安全队列"></a>利用条件变量实现线程安全队列</h2><ul>
<li>如何让线程按一定顺序执行，也就是说如何控制并发的同步操作？可以用一个变量num 当num为1，执行线程A，当num为2执行线程B, 如果当num为1时碰到了线程B 就直接让线程b睡一会，实现大概如下：</li>
</ul>
<h3 id="不良实现"><a href="#不良实现" class="headerlink" title="不良实现"></a>不良实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PoorImpleman</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span> (;;) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                std::lock_guard&lt;std::mutex&gt; lock(mtx_num);</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">if</span> (num == <span class="number">1</span>) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                    std::cout &lt;&lt; <span class="string">&quot;thread A print 1.....&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">                    num++;</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">continue</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">                &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::this_thread::sleep_for(std::chrono::milliseconds(<span class="number">500</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">     &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span> (;;) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                std::lock_guard&lt;std::mutex&gt; lock(mtx_num);</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">if</span> (num == <span class="number">2</span>) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                    std::cout &lt;&lt; <span class="string">&quot;thread B print 2.....&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">                    num--;</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">continue</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">                &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::this_thread::sleep_for(std::chrono::milliseconds(<span class="number">500</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>PoorImpleman虽然能实现我们交替打印的功能，会造成消息处理的不及时，因为线程A要循环检测num值，如果num不为1，则线程A就睡眠了，在线程A睡眠这段时间很可能B已经处理完打印了，此时A还在睡眠，是对资源的浪费，也错过了最佳的处理时机。</li>
</ul>
<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">std::mutex mtx_num;</span><br><span class="line">std::condition_variable cvA;</span><br><span class="line">std::condition_variable cvB;</span><br><span class="line"><span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ResonableImplemention</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span> (; ;) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::unique_lock&lt;std::mutex&gt; lock(mtx_num);</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="comment">//方法一</span></span></span></span><br><span class="line"><span class="params"><span class="function">            cvA.wait(lock, []() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">return</span> num == <span class="number">1</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">                &#125;);</span></span></span><br><span class="line"><span class="params"><span class="function">            num++;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::cout &lt;&lt; <span class="string">&quot;thread A point 1......&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">            cvB.notify_one();</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">     &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span> (;;) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::unique_lock&lt;std::mutex&gt; lock(mtx_num);</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="comment">//方法二</span></span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">while</span> (num != <span class="number">2</span>) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                cvB.wait(lock);</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">            num--;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::cout &lt;&lt; <span class="string">&quot;thread B point 2.......&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">            cvA.notify_one();</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>当条件不满足时(num 不等于1 时)cvA.wait就会挂起，等待线程B通知通知线程A唤醒，线程B采用的是cvA.notifyone。</li>
<li>这么做的好处就是线程交替处理非常及时。比起sleep的方式，我们可以从控制台上看出差异效果，sleep的方式看出日志基本是每隔1秒才打印一次，效率不高。</li>
</ul>
<h3 id="实现安全队列"><a href="#实现安全队列" class="headerlink" title="实现安全队列"></a>实现安全队列</h3><ul>
<li>之前我们实现过线程安全的栈，对于pop操作，我们如果在线程中调用empty判断是否为空，如果不为空，则pop，因为empty和pop内部分别加锁，是两个原子操作，导致pop时可能会因为其他线程提前pop导致队列为空，从而引发崩溃。我们当时的处理方式是实现了两个版本的pop，一种是返回智能指针类型，一种通过参数为引用的方式返回。对于智能指针版本我们发现队列为空则返回空指针，对于引用版本，发现队列为空则抛出异常，这么做并不是很友好，所以我们可以通过条件变量完善之前的程序，不过这次我们重新实现一个线程安全队列。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadsafe_queue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">threadsafe_queue</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">threadsafe_queue</span>(<span class="type">const</span> threadsafe_queue&amp; q) &#123;</span><br><span class="line">        <span class="comment">//防止拷贝构造的时候被拷贝对象执行了其他操作</span></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(q.mtx)</span></span>;</span><br><span class="line">        tq = q.tq;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">threadsafe_queue</span>(<span class="type">const</span> threadsafe_queue&amp;&amp; q) &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(q.mtx)</span></span>;</span><br><span class="line">        tq = std::<span class="built_in">move</span>(q.tq);</span><br><span class="line">    &#125;</span><br><span class="line">    threadsafe_queue&lt;T&gt;&amp; <span class="keyword">operator</span> = (<span class="type">const</span> threadsafe_queue &amp; q)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;q) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(q.mtx)</span></span>;</span><br><span class="line">        tq = q.tq;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    threadsafe_queue&lt;T&gt;&amp; <span class="keyword">operator</span> = (<span class="type">const</span> threadsafe_queue&amp;&amp; q) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;q) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(q.mtx)</span></span>;</span><br><span class="line">        tq = std::<span class="built_in">move</span>(q.tq);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T value)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        tq.<span class="built_in">push</span>(value);</span><br><span class="line">        <span class="comment">//加入这条语句是为了让其他因为队列为空而挂起的线程继续执行</span></span><br><span class="line">        cvA.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wait_and_pop</span><span class="params">(T&amp; value)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        <span class="comment">//[this] 就是捕获这个类 使得lambda表达式可以使用该类的所有函数</span></span><br><span class="line">        cvA.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]() &#123;<span class="keyword">return</span> !tq.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line">        <span class="comment">// 只有一次拷贝</span></span><br><span class="line">        value = tq.<span class="built_in">front</span>();</span><br><span class="line">        tq.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">wait_and_pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        cvA.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]() &#123;<span class="keyword">return</span> !tq.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line">        std::shared_ptr&lt;T&gt; res = std::<span class="built_in">make_shared</span>&lt;T&gt;(tq.<span class="built_in">front</span>());</span><br><span class="line">        tq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">try_pop</span><span class="params">(T&amp; value)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (tq.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        value = tq.<span class="built_in">front</span>();</span><br><span class="line">        tq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">try_pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (tq.<span class="built_in">empty</span>()) <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;T&gt;();</span><br><span class="line">        std::shared_ptr&lt;T&gt; res = std::<span class="built_in">make_shared</span>&lt;T&gt;(tq.<span class="built_in">front</span>());</span><br><span class="line">        tq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span><span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> tq.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> std::mutex mtx;</span><br><span class="line">    std::condition_variable cvA;</span><br><span class="line">    std::queue&lt;T&gt; tq;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_safe_que</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    threadsafe_queue&lt;<span class="type">int</span>&gt;  safe_que;</span><br><span class="line">    std::mutex  mtx_print;</span><br><span class="line">    <span class="function">std::thread <span class="title">producer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        [&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; ; i++) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                safe_que.push(i);</span></span></span><br><span class="line"><span class="params"><span class="function">                &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="comment">// 为了打印完整一行</span></span></span></span><br><span class="line"><span class="params"><span class="function">                    std::lock_guard&lt;std::mutex&gt; printlk(mtx_print);</span></span></span><br><span class="line"><span class="params"><span class="function">                    std::cout &lt;&lt; <span class="string">&quot;producer push data is &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">                &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">                std::this_thread::sleep_for(std::chrono::milliseconds(<span class="number">200</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">consumer1</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        [&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">for</span> (;;) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">auto</span> data = safe_que.wait_and_pop();</span></span></span><br><span class="line"><span class="params"><span class="function">                &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                    std::lock_guard&lt;std::mutex&gt; printlk(mtx_print);</span></span></span><br><span class="line"><span class="params"><span class="function">                    std::cout &lt;&lt; <span class="string">&quot;consumer1 wait and pop data is &quot;</span> &lt;&lt; *data &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">                &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">                std::this_thread::sleep_for(std::chrono::milliseconds(<span class="number">500</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">consumer2</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        [&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">for</span> (;;) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">auto</span> data = safe_que.try_pop();</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">if</span> (data != <span class="literal">nullptr</span>) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                    &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                        std::lock_guard&lt;std::mutex&gt; printlk(mtx_print);</span></span></span><br><span class="line"><span class="params"><span class="function">                        std::cout &lt;&lt; <span class="string">&quot;consumer2 try_pop data is &quot;</span> &lt;&lt; *data &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">                    &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">                &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">                std::this_thread::sleep_for(std::chrono::milliseconds(<span class="number">500</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line">    producer.<span class="built_in">join</span>();</span><br><span class="line">    consumer<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    consumer<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>我们可以启动三个线程，一个producer线程用来向队列中放入数据。一个consumer1线程用来阻塞等待pop队列中的元素。</p>
</li>
<li><p>另一个consumer2尝试从队列中pop元素，如果队列为空则直接返回，如果非空则pop元素。</p>
</li>
<li><p>打印时为了保证线程输出在屏幕上不会乱掉，所以加了锁保证互斥输出</p>
</li>
</ul>
<h2 id="并发三剑客async-promise-future"><a href="#并发三剑客async-promise-future" class="headerlink" title="并发三剑客async,promise,future"></a>并发三剑客async,promise,future</h2><h3 id="async用法"><a href="#async用法" class="headerlink" title="async用法"></a>async用法</h3><ul>
<li>std::async 是一个用于异步执行函数的模板函数，它返回一个 std::future 对象，该对象用于获取函数的返回值。</li>
<li>以下是一个使用 std::async 的示例：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="comment">// 定义一个异步任务</span></span><br><span class="line"><span class="function">std::string <span class="title">fetchDataFromDB</span><span class="params">(std::string query)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 模拟一个异步任务，比如从数据库中获取数据</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Data: &quot;</span> + query;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 std::async 异步调用 fetchDataFromDB</span></span><br><span class="line">    std::future&lt;std::string&gt; resultFromDB = std::<span class="built_in">async</span>(std::launch::async, fetchDataFromDB, <span class="string">&quot;Data&quot;</span>);</span><br><span class="line">    <span class="comment">// 在主线程中做其他事情</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Doing something else...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 从 future 对象中获取数据</span></span><br><span class="line">    std::string dbData = resultFromDB.<span class="built_in">get</span>();</span><br><span class="line">    std::cout &lt;&lt; dbData &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在这个示例中，<strong>std::async</strong> 创建了一个新的线程（或从内部线程池中挑选一个线程）并自动与一个 <strong>std::promise</strong>对象相关联。<strong>std::promise</strong> 对象被传递给 <strong>fetchDataFromDB</strong> 函数，函数的返回值被存储在 <strong>std::future</strong> 对象中。在主线程中，我们可以使用 <strong>std::future::get</strong> 方法从 <strong>std::future</strong> 对象中获取数据。<strong><em>注意</em></strong>，在使用 <strong>std::async</strong> 的情况下，我们必须使用 <strong>std::launch::async</strong> 标志来明确表明我们希望函数异步执行</li>
</ul>
<h4 id="async的启动策略"><a href="#async的启动策略" class="headerlink" title="async的启动策略"></a>async的启动策略</h4><ul>
<li><p>std::async函数可以接受几个不同的启动策略，这些策略在std::launch枚举中定义。除了std::launch::async之外，还有以下启动策略：</p>
<ol>
<li>std::launch::deferred：这种策略意味着任务将在调用std::future::get()或std::future::wait()函数时延迟执行。换句话说，任务将在需要结果时同步执行。</li>
<li>std::launch::async | std::launch::deferred：这种策略是上面两个策略的组合。任务可以在一个单独的线程上异步执行，也可以延迟执行，具体取决于实现。</li>
</ol>
</li>
<li>默认情况下，std::async使用std::launch::async | std::launch::deferred策略。这意味着任务可能异步执行，也可能延迟执行，具体取决于实现。需要注意的是，不同的编译器和操作系统可能会有不同的默认行为。</li>
</ul>
<h3 id="future的wait和get"><a href="#future的wait和get" class="headerlink" title="future的wait和get"></a>future的wait和get</h3><ul>
<li>std::future::get() 和 std::future::wait() 是 C++ 中用于处理异步任务的两个方法，它们的功能和用法有一些重要的区别。</li>
</ul>
<ol>
<li>std::future::get():<ul>
<li>std::future::get() 是一个阻塞调用，用于获取 std::future 对象表示的值或异常。如果异步任务还没有完成，get() 会阻塞当前线程，直到任务完成。如果任务已经完成，get() 会立即返回任务的结果。重要的是，get() 只能调用一次，因为它会移动或消耗掉 std::future 对象的状态。一旦 get() 被调用，std::future 对象就不能再被用来获取结果。</li>
</ul>
</li>
<li>std::future::wait():<ul>
<li>std::future::wait() 也是一个阻塞调用，但它与 get() 的主要区别在于 wait() 不会返回任务的结果。它只是等待异步任务完成。如果任务已经完成，wait() 会立即返回。如果任务还没有完成，wait() 会阻塞当前线程，直到任务完成。与 get() 不同，wait() 可以被多次调用，它不会消耗掉 std::future 对象的状态。</li>
</ul>
</li>
</ol>
<ul>
<li>总结下这两个方法的主要区别：<ol>
<li>std::future::get() 用于获取并返回任务的结果，而 std::future::wait() 只是等待任务完成</li>
<li>get() 只能调用一次，而 wait() 可以被多次调用。</li>
<li>如果任务还没有完成，get() 和 wait() 都会阻塞当前线程，但 get() 会一直阻塞直到任务完成并返回结果，而 wait() 只是在等待任务完成。</li>
</ol>
</li>
<li>可以使用std::future的wait_for()或wait_until()方法来检查异步操作是否已完成。这些方法返回一个表示操作状态的std::future_status值。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(fut.<span class="built_in">wait_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>)) == std::future_status::ready)&#123;</span><br><span class="line">    <span class="comment">//操作已完成</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//操作失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="将任务和future关联（paskaged-task）"><a href="#将任务和future关联（paskaged-task）" class="headerlink" title="将任务和future关联（paskaged_task）"></a>将任务和future关联（paskaged_task）</h3><ul>
<li>std::packaged_task和std::future是C++11中引入的两个类，它们用于处理异步任务的结果。</li>
<li>std::packaged_task是一个可调用目标，它包装了一个任务，该任务可以在另一个线程上运行。它可以捕获任务的返回值或异常，并将其存储在std::future对象中，以便以后使用。</li>
<li>std::future代表一个异步操作的结果。它可以用于从异步任务中获取返回值或异常。</li>
<li>以下是使用std::packaged_task和std::future的基本步骤：<ol>
<li>创建一个std::packaged_task对象，该对象包装了要执行的任务。</li>
<li>调用std::packaged_task对象的get_future()方法，该方法返回一个与任务关联的std::future对象。</li>
<li>在另一个线程上调用std::packaged_task对象的operator()，以执行任务。</li>
<li>在需要任务结果的地方，调用与任务关联的std::future对象的get()方法，以获取任务的返回值或异常</li>
</ol>
</li>
<li>以下是一个简单的示例代码</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">my_task</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;my task run 5 s&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_package</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个包装了任务的 std::packaged_task 对象  </span></span><br><span class="line">    <span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">()</span>&gt; <span class="title">task</span><span class="params">(my_task)</span></span>;</span><br><span class="line">    <span class="comment">// 获取与任务关联的 std::future 对象  </span></span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; result = task.<span class="built_in">get_future</span>();</span><br><span class="line">    <span class="comment">// 在另一个线程上执行任务  </span></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(std::move(task))</span></span>;</span><br><span class="line">    t.<span class="built_in">detach</span>(); <span class="comment">// 将线程与主线程分离，以便主线程可以等待任务完成  </span></span><br><span class="line">    <span class="comment">// 等待任务完成并获取结果  </span></span><br><span class="line">    <span class="type">int</span> value = result.<span class="built_in">get</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The result is: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>在上面的示例中，我们创建了一个包装了任务的std::packaged_task对象，并获取了与任务关联的std::future对象。然后，我们在另一个线程上执行任务，并等待任务完成并获取结果。最后，我们输出结果。</p>
</li>
<li><p>我们可以使用 std::function 和 std::package_task 来包装带参数的函数。std::package_task 是一个模板类，它包装了一个可调用对象，并允许我们将其作为异步任务传递。</p>
</li>
<li><p><strong>注意</strong>在传入package_task对象给线程的时候，一定要使用<strong>std::move</strong>函数</p>
</li>
</ul>
<h3 id="promise的用法"><a href="#promise的用法" class="headerlink" title="promise的用法"></a>promise的用法</h3><ul>
<li>C++11引入了std::promise和std::future两个类，用于实现异步编程。std::promise用于在某一线程中设置某个值或异常，而std::future则用于在另一线程中获取这个值或异常。</li>
<li>下面是std::promise的基本用法：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_value</span><span class="params">(std::promise&lt;<span class="type">int</span>&gt; prom)</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">3</span>));</span><br><span class="line">    <span class="comment">// 设置 promise 的值</span></span><br><span class="line">    prom.<span class="built_in">set_value</span>(<span class="number">10</span>);</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;value set success&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;子线程执行完毕&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_promise</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 promise 对象</span></span><br><span class="line">    std::promise&lt;<span class="type">int</span>&gt; prom;</span><br><span class="line">    <span class="comment">// 获取与 promise 相关联的 future 对象</span></span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; fut = prom.<span class="built_in">get_future</span>();</span><br><span class="line">    <span class="comment">// 在新线程中设置 promise 的值,传入参数的时候一定要使用move</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(set_value, std::move(prom))</span></span>;</span><br><span class="line">    <span class="comment">//在主线程中获取future的值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Waiting for the thread to set the value...\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value set by the thread: &quot;</span> &lt;&lt; fut.<span class="built_in">get</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>程序输出</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Waiting <span class="keyword">for</span> the thread to set the value...</span><br><span class="line">Value set by the thread: <span class="number">10</span></span><br><span class="line">value set success</span><br><span class="line">子线程执行完毕</span><br></pre></td></tr></table></figure>
<ul>
<li>在上面的代码中，我们首先创建了一个std::promise<int>对象，然后通过调用get_future()方法获取与之相关联的std::future<int>对象。然后，我们在新线程中通过调用set_value()方法设置promise的值，并在主线程中通过调用fut.get()方法获取这个值。注意，在调用fut.get()方法时，如果promise的值还没有被设置，则该方法会阻塞当前线程，直到值被设置为止。</li>
<li><p><strong>注意</strong>promise的值被设置后就可以被get，而不需要等待子线程执行完成才能get，这个就是和前面package_task的区别之一</p>
</li>
<li><p>除了set_value()方法外，std::promise还有一个set_exception()方法，用于设置异常。该方法接受一个std::exception_ptr参数，该参数可以通过调用std::current_exception()方法获取。</p>
</li>
<li>下面是一个例子：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_exception</span><span class="params">(std::promise&lt;<span class="type">void</span>&gt; prom)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//抛出一个异常</span></span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;An error occurred!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">        <span class="comment">//设置 promise的异常</span></span><br><span class="line">        prom.<span class="built_in">set_exception</span>(std::<span class="built_in">current_exception</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_promise_exception</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::promise&lt;<span class="type">void</span>&gt; prom;</span><br><span class="line">    std::future&lt;<span class="type">void</span>&gt; fut = prom.<span class="built_in">get_future</span>();</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(set_exception, std::move(prom))</span></span>;</span><br><span class="line">    <span class="comment">// 在主线程中获取 future 的异常</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Waiting for the thread to set the exception...\n&quot;</span>;</span><br><span class="line">        fut.<span class="built_in">get</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Exception set by the thread: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;hello world!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>子线程抛出了异常一定要在主线程里也捕获异常</p>
</li>
<li><p>当然我们使用promise时要注意一点，如果promise被释放了，而其他的线程还未使用与promise关联的future，当其使用这个future时会报错。</p>
</li>
</ul>
<h3 id="共享类型的future"><a href="#共享类型的future" class="headerlink" title="共享类型的future"></a>共享类型的future</h3><ul>
<li>当我们需要多个线程等待同一个执行结果时，需要使用std::shared_future</li>
<li>以下是一个适合使用std::shared_future的场景，多个线程等待同一个异步操作的结果：</li>
<li>假设你有一个异步任务，需要多个线程等待其完成，然后这些线程需要访问任务的结果。在这种情况下，你可以使用std::shared_future来共享异步任务的结果。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">(std::promise&lt;<span class="type">int</span>&gt;&amp;&amp; promise)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 模拟一些工作</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    promise.<span class="built_in">set_value</span>(<span class="number">42</span>); <span class="comment">// 设置 promise 的值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">(std::shared_future&lt;<span class="type">int</span>&gt; future)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> result = future.<span class="built_in">get</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> std::future_error&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Future error: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_shared_future</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::promise&lt;<span class="type">int</span>&gt; promise;</span><br><span class="line">    std::shared_future&lt;<span class="type">int</span>&gt; future = promise.<span class="built_in">get_future</span>();</span><br><span class="line">    <span class="function">std::thread <span class="title">myThread1</span><span class="params">(myFunction, std::move(promise))</span></span>; <span class="comment">// 将 promise 移动到线程中</span></span><br><span class="line">    <span class="comment">// 使用 share() 方法获取新的 shared_future 对象  </span></span><br><span class="line">    <span class="function">std::thread <span class="title">myThread2</span><span class="params">(threadFunction, future)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">myThread3</span><span class="params">(threadFunction, future)</span></span>;</span><br><span class="line">    myThread<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    myThread<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    myThread<span class="number">3.</span><span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在这个示例中，我们创建了一个std::promise<int>对象promise和一个与之关联的std::shared_future<int>对象future。然后，我们将promise对象移动到另一个线程myThread1中，该线程将执行myFunction函数，并在完成后设置promise的值。我们还创建了两个线程myThread2和myThread3，它们将等待future对象的结果。如果myThread1成功地设置了promise的值，那么future.get()将返回该值。这些线程可以同时访问和等待future对象的结果，而不会相互干扰。</li>
<li>但是大家要注意，如果一个future被移动给两个shared_future是错误的。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_shared_future_error</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::promise&lt;<span class="type">int</span>&gt; promise;</span><br><span class="line">    std::shared_future&lt;<span class="type">int</span>&gt; future = promise.<span class="built_in">get_future</span>();</span><br><span class="line">    <span class="function">std::thread <span class="title">myThread1</span><span class="params">(myFunction, std::move(promise))</span></span>; <span class="comment">// 将 promise 移动到线程中</span></span><br><span class="line">    <span class="function">std::thread <span class="title">myThread2</span><span class="params">(threadFunction, std::move(future))</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">myThread3</span><span class="params">(threadFunction, std::move(future))</span></span>;</span><br><span class="line">    myThread<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    myThread<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    myThread<span class="number">3.</span><span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这种用法是错误的，一个future通过隐式构造传递给shared_future之后，这个shared_future被移动传递给两个线程是不合理的，因为第一次移动后shared_future的生命周期被转移了，接下来myThread3构造时用的std::move(future)future已经失效了，会报错，一般都是no state 之类的错误。</li>
</ul>
<h3 id="异常处理1"><a href="#异常处理1" class="headerlink" title="异常处理1"></a>异常处理1</h3><ul>
<li>std::future 是C++的一个模板类，它用于表示一个可能还没有准备好的异步操作的结果。你可以通过调用 std::future::get 方法来获取这个结果。如果在获取结果时发生了异常，那么 std::future::get 会重新抛出这个异常。</li>
</ul>
<p>以下是一个例子，演示了如何在 std::future 中获取异常：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">may_throw</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这里我们抛出一个异常。在实际的程序中，这可能在任何地方发生。</span></span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Oops, something went wrong!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个异步任务</span></span><br><span class="line">    <span class="function">std::future&lt;<span class="type">void</span>&gt; <span class="title">result</span><span class="params">(std::async(std::launch::async, may_throw))</span></span>;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取结果（如果在获取结果时发生了异常，那么会重新抛出这个异常）</span></span><br><span class="line">        result.<span class="built_in">get</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> std::exception &amp;e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 捕获并打印异常</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Caught exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在这个例子中，我们创建了一个异步任务 may_throw，这个任务会抛出一个异常。然后，我们创建一个 std::future 对象 result 来表示这个任务的结果。在 main 函数中，我们调用 result.get() 来获取任务的结果。如果在获取结果时发生了异常，那么 result.get() 会重新抛出这个异常，然后我们在 catch 块中捕获并打印这个异常。</li>
</ul>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><ul>
<li><p>我们可以利用上面提到的std::packaged_task和std::promise构建线程池，提高程序的并发能力。<br>先了解什么是线程池：</p>
</li>
<li><p><strong>线程池</strong>是一种多线程处理形式，它处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。线程池线程都是后台线程。每个线程都使用默认的堆栈大小，以默认的优先级运行，并处于多线程单元中。如果某个线程在托管代码中空闲（如正在等待某个事件）,则线程池将插入另一个辅助线程来使所有处理器保持繁忙。如果所有线程池线程都始终保持繁忙，但队列中包含挂起的工作，则线程池将在一段时间后创建另一个辅助线程但线程的数目永远不会超过最大值。超过最大值的线程可以排队，但他们要等到其他线程完成后才启动。</p>
</li>
</ul>
<p>-<strong>线程池</strong>可以避免在处理短时间任务时创建与销毁线程的代价，它维护着多个线程，等待着监督管理者分配可并发执行的任务，从而提高了整体性能。</p>
<ul>
<li><strong>线程池注意事项</strong></li>
<li>保证并发，且执行时无序的（可以用线程池）</li>
<li>互斥性很大，强关联（不能用线程池）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Task = std::packaged_task&lt;<span class="built_in">void</span>()&gt;;</span><br><span class="line">    ~<span class="built_in">ThreadPool</span>() &#123;</span><br><span class="line">        <span class="built_in">stop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> ThreadPool&amp; <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> ThreadPool ins;</span><br><span class="line">        <span class="keyword">return</span> ins;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回一个future，将一个可调用函数封装成无参数无返回值类型</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">F</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">commit</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span> -&gt; std::future&lt;<span class="title">decltype</span><span class="params">(f(args...))</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> RetType = <span class="keyword">decltype</span>(<span class="built_in">f</span>(args...));</span><br><span class="line">        <span class="keyword">if</span> (stop_.<span class="built_in">load</span>()) <span class="keyword">return</span> std::future&lt;RetType&gt;&#123;&#125;;</span><br><span class="line">        <span class="comment">// 打包一个无参数的可调用函数</span></span><br><span class="line">        <span class="keyword">auto</span> task = std::make_shared&lt;std::packaged_task&lt;<span class="built_in">RetType</span>()&gt;&gt;(</span><br><span class="line">            <span class="comment">//重新绑定可调用函数，让有参形式变得无参</span></span><br><span class="line">            std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...));</span><br><span class="line">        <span class="comment">/*auto task = std::make_shared&lt;std::packaged_task&lt;RetType()&gt;&gt;(</span></span><br><span class="line"><span class="comment">            std::bind(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...));*/</span></span><br><span class="line">        std::future&lt;RetType&gt; ret = task-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//由于队列被多线程共享所以需要互斥添加</span></span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">cv_mt</span><span class="params">(cv_mt_)</span></span>;</span><br><span class="line">            <span class="comment">//调用packaged_task的operator()让有返回值函数变为无返回值</span></span><br><span class="line">            tasks_.<span class="built_in">emplace</span>([task] &#123;(*task)(); &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//通知被阻塞的线程</span></span><br><span class="line">        cv_lock_.<span class="built_in">notify_one</span>();</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">idleThreadCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> thread_nums_;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="type">const</span> ThreadPool&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    ThreadPool&amp; <span class="keyword">operator</span>=(<span class="type">const</span> ThreadPool&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="type">unsigned</span> <span class="type">int</span> num = <span class="number">5</span>): <span class="built_in">stop_</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">1</span>) thread_nums_ = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> thread_nums_ = num;</span><br><span class="line">        <span class="built_in">start</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建num个线程</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; thread_nums_; i++) &#123;</span><br><span class="line">            pool_.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>]() &#123;</span><br><span class="line">                <span class="keyword">while</span> (!stop_.<span class="built_in">load</span>()) &#123;</span><br><span class="line">                    Task task;</span><br><span class="line">                    &#123;</span><br><span class="line">                        std::unique_lock&lt;std::mutex&gt; <span class="built_in">cv_mt</span>(cv_mt_);</span><br><span class="line">                        <span class="keyword">this</span>-&gt;cv_lock_.<span class="built_in">wait</span>(cv_mt, [<span class="keyword">this</span>] &#123;<span class="keyword">return</span> <span class="keyword">this</span>-&gt;stop_.<span class="built_in">load</span>() || !<span class="keyword">this</span>-&gt;tasks_.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line">                        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;tasks_.<span class="built_in">empty</span>()) <span class="keyword">return</span>;</span><br><span class="line">                        <span class="comment">//因为package_task里需要右值</span></span><br><span class="line">                        task = std::<span class="built_in">move</span>(<span class="keyword">this</span>-&gt;tasks_.<span class="built_in">front</span>());</span><br><span class="line">                        <span class="comment">//首先++,--操作是原子操作其次它是在构造函数里进行的，不存在创建线程的时候thread_nums_变化</span></span><br><span class="line">                        <span class="keyword">this</span>-&gt;tasks_.<span class="built_in">pop</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">this</span>-&gt;thread_nums_--;</span><br><span class="line">                    <span class="built_in">task</span>();</span><br><span class="line">                    <span class="keyword">this</span>-&gt;thread_nums_++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stop_.<span class="built_in">store</span>(<span class="literal">true</span>);</span><br><span class="line">        cv_lock_.<span class="built_in">notify_all</span>();</span><br><span class="line">        <span class="comment">// 当线程还没执行完任务时让他先执行完</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; td : pool_) &#123;</span><br><span class="line">            <span class="keyword">if</span> (td.<span class="built_in">joinable</span>()) &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;join thread &quot;</span> &lt;&lt; td.<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">                td.<span class="built_in">join</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::mutex cv_mt_;</span><br><span class="line">    std::condition_variable cv_lock_;</span><br><span class="line">    <span class="comment">//表示线程池的启动状态,false表示启动</span></span><br><span class="line">    std::atomic_bool stop_;</span><br><span class="line">    <span class="comment">//表示线程池的线程数量</span></span><br><span class="line">    std::atomic_int thread_nums_;</span><br><span class="line">    <span class="comment">//任务队列</span></span><br><span class="line">    std::queue&lt;Task&gt; tasks_;</span><br><span class="line">    <span class="comment">//存放预先创建好的线程</span></span><br><span class="line">    std::vector&lt;std::thread&gt; pool_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; tp = ThreadPool::<span class="built_in">getInstance</span>();</span><br><span class="line">    <span class="type">int</span> m = <span class="number">0</span>;</span><br><span class="line">    tp.<span class="built_in">commit</span>([](<span class="type">int</span>&amp; m) &#123;</span><br><span class="line">        m = <span class="number">1024</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;inner set m is &quot;</span> &lt;&lt; m &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;m address is &quot;</span> &lt;&lt; &amp;m &lt;&lt; std::endl;</span><br><span class="line">     &#125;, m);</span><br><span class="line">    tp.<span class="built_in">commit</span>([](<span class="type">int</span>&amp; m) &#123;</span><br><span class="line">        m = <span class="number">1024</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;inner set m is &quot;</span> &lt;&lt; m &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;m address is &quot;</span> &lt;&lt; &amp;m &lt;&lt; std::endl;</span><br><span class="line">    &#125;, std::<span class="built_in">ref</span>(m));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="两种并发设计模式"><a href="#两种并发设计模式" class="headerlink" title="两种并发设计模式"></a>两种并发设计模式</h2><h3 id="Actor设计模式"><a href="#Actor设计模式" class="headerlink" title="Actor设计模式"></a>Actor设计模式</h3><ul>
<li>简单点说，actor通过消息传递的方式与外界通信。消息传递是异步的。每个actor都有一个邮箱，该邮箱接收并缓存其他actor发过来的消息，actor一次只能同步处理一个消息，处理消息过程中，除了可以接收消息，不能做任何其他操作。<br>每一个类独立在一个线程里称作Actor，Actor之间通过队列通信，比如Actor1 发消息给Actor2， Actor2 发消息给Actor1都是投递到对方的队列中。好像给对方发邮件，对方从邮箱中取出一样。如下图：</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/并发编程/image.png" alt="示例图片" style="zoom:100%;" /></p>
<ul>
<li>Actor模型的另一个好处就是可以消除共享状态，因为它每次只能处理一条消息，所以actor内部可以安全的处理状态，而不用考虑锁机制。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/并发编程/image-1.png" alt="示例图片" style="zoom:100%;" /></p>
<ul>
<li><p>我们在网络编程中对于逻辑层的处理就采用了将要处理的逻辑消息封装成包投递给逻辑队列，逻辑类从队列中消费的思想，其实就是一种Actor设计模式。Erlang是天然支持Actor的语言。</p>
</li>
<li><p><strong>应用场景</strong>：<br>一个游戏有很多地图，每个地图都由一个独立的线程管理，在每个地图上都能购物，如果只有一个购物类给其他线程提供购物接口，其他线程调用找个接口，为了考虑线程安全性就得考虑频繁加锁，并且如果购物类崩了，就会导致用到这个接口的所有线程都会崩，所以可以采用Actor设计模式，将一个购物类安排在一个线程里，并且它有一个线程安全队列来接受购物请求，其他线程需要购物的时往这个队列加入请求，购物类消费请求，这样就可以做到解耦，并且如果购物类崩了很容易排查</p>
</li>
</ul>
<h3 id="CSP模式"><a href="#CSP模式" class="headerlink" title="CSP模式"></a>CSP模式</h3><ul>
<li><p>SP 是 Communicating Sequential Process 的简称，中文可以叫做通信顺序进程，是一种并发编程模型，是一个很强大的并发数据模型，是上个世纪七十年代提出的，用于描述两个独立的并发实体通过共享的通讯 channel(管道)进行通信的并发模型。相对于Actor模型，CSP中channel是第一类对象，它不关注发送消息的实体，而关注与发送消息时使用的channel。go是天然支持csp模式的语言。</p>
</li>
<li><p>CSP和Actor类似，只不过CSP将消息投递给channel，至于谁从channel中取数据，发送的一方是不关注的。简单的说Actor在发送消息前是直到接收方是谁，而接受方收到消息后也知道发送方是谁，更像是邮件的通信模式。而csp是完全解耦合的。</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/并发编程/image-2.png" alt="示例图片" style="zoom:100%;" /></p>
<ul>
<li>C++ 风格CSP</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">channel</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">channel</span>(<span class="type">size_t</span> capacity = <span class="number">0</span>):<span class="built_in">close_</span>(<span class="literal">false</span>), <span class="built_in">capacity_</span>(capacity)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">send</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">        cv_producer_.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]() &#123;</span><br><span class="line">            <span class="built_in">return</span> (capacity_ == <span class="number">0</span> &amp;&amp; queue_.<span class="built_in">empty</span>()) || close_ || queue_.<span class="built_in">size</span>() &lt; capacity_;</span><br><span class="line">            &#125;);</span><br><span class="line">        <span class="keyword">if</span> (close_) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        queue_.<span class="built_in">push</span>(value);</span><br><span class="line">        cv_consumer_.<span class="built_in">notify_one</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">receive</span><span class="params">(T&amp; value)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">        cv_consumer_.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]() &#123;</span><br><span class="line">            <span class="keyword">return</span> !queue_.<span class="built_in">empty</span>() || close_;</span><br><span class="line">            &#125;);</span><br><span class="line">        <span class="keyword">if</span> (close_ &amp;&amp; queue_.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        value = queue_.<span class="built_in">front</span>();</span><br><span class="line">        queue_.<span class="built_in">pop</span>();</span><br><span class="line">        cv_producer_.<span class="built_in">notify_one</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">        close_ = <span class="literal">true</span>;</span><br><span class="line">        cv_consumer_.<span class="built_in">notify_all</span>();</span><br><span class="line">        cv_producer_.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::queue&lt;<span class="type">int</span>&gt; queue_;</span><br><span class="line">    std::mutex mtx_;</span><br><span class="line">    std::condition_variable cv_producer_;</span><br><span class="line">    std::condition_variable cv_consumer_;</span><br><span class="line">    <span class="type">size_t</span> capacity_;</span><br><span class="line">    <span class="type">bool</span> close_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_channel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">channel&lt;<span class="type">int</span>&gt; <span class="title">ch</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">producer</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            ch.send(i);</span></span></span><br><span class="line"><span class="params"><span class="function">            std::cout &lt;&lt; <span class="string">&quot;Sent: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        ch.close();</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">consumer</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::this_thread::sleep_for(std::chrono::milliseconds(<span class="number">500</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int</span> val;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span> (ch.receive(val)) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::cout &lt;&lt; <span class="string">&quot;Received: &quot;</span> &lt;&lt; val &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    producer.<span class="built_in">join</span>();</span><br><span class="line">    consumer.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>消息队列：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">﻿<span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> messaging</span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">//①消息基类。队列中存储的项目</span></span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">message_base</span>   </span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">message_base</span>()</span><br><span class="line">  &#123;&#125;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//②每种消息都具有特化类型</span></span><br><span class="line"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Msg&gt;</span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">wrapped_message</span> : </span><br><span class="line">  message_base</span><br><span class="line"> &#123;</span><br><span class="line">  Msg contents;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">wrapped_message</span><span class="params">(Msg <span class="type">const</span>&amp; contents_)</span> :</span></span><br><span class="line"><span class="function">   contents(contents_)</span></span><br><span class="line"><span class="function">  &#123;</span>&#125;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//③消息队列</span></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">queue</span>   </span><br><span class="line"> &#123;</span><br><span class="line">  std::mutex m;</span><br><span class="line">  std::condition_variable c;</span><br><span class="line">  <span class="comment">//④以内部队列存储message_base型共享指针</span></span><br><span class="line">  std::queue&lt;std::shared_ptr&lt;message_base&gt; &gt; q;    </span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">  <span class="type">void</span> <span class="title">push</span><span class="params">(T <span class="type">const</span>&amp; msg)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">   <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;</span><br><span class="line">   <span class="comment">//⑤包装发布的消息，并存储相关的指针</span></span><br><span class="line">   q.<span class="built_in">push</span>(std::make_shared&lt;wrapped_message&lt;T&gt; &gt;(msg));     </span><br><span class="line">   c.<span class="built_in">notify_all</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">std::shared_ptr&lt;message_base&gt; <span class="title">wait_and_pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">   <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;</span><br><span class="line">   <span class="comment">//⑥如果队列为空，就发生阻塞</span></span><br><span class="line">   c.<span class="built_in">wait</span>(lk,[&amp;] &#123;<span class="keyword">return</span> !q.<span class="built_in">empty</span>(); &#125;);   </span><br><span class="line">   <span class="keyword">auto</span> res = q.<span class="built_in">front</span>();</span><br><span class="line">   q.<span class="built_in">pop</span>();</span><br><span class="line">   <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="thread-源码解读及一些常见问题"><a href="#thread-源码解读及一些常见问题" class="headerlink" title="thread 源码解读及一些常见问题"></a>thread 源码解读及一些常见问题</h2><h3 id="默认移动构造"><a href="#默认移动构造" class="headerlink" title="默认移动构造"></a>默认移动构造</h3><ul>
<li>关于局部变量返回值的问题我曾在视频中说会通过构造函数返回一个局部变量给调用者，编译器会先执行拷贝构造，如果没有拷贝构造再寻找移动构造。这么说是有问题的。<br>有热心的粉丝查询了chatgpt，当函数返回一个类类型的局部变量时会先调用移动构造，如果没有移动构造再调用拷贝构造。</li>
<li>所以对于一些没有拷贝构造但是实现了移动构造的类类型也支持通过函数返回局部变量。</li>
<li>在 C++11 之后，编译器会默认使用移动语义（move semantics）来提高性能</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestCopy</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TestCopy</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">TestCopy</span>(<span class="type">const</span> TestCopy&amp; tp) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Test Copy Copy &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">TestCopy</span>(TestCopy&amp;&amp; cp) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Test Copy Move &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">TestCopy <span class="title">TestCp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TestCopy tp;</span><br><span class="line">    <span class="keyword">return</span> tp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">TestCp</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>发现打印的是”Test Copy Move” .这说明优先调用的是移动构造，这也提醒我们，如果我们自定义的类实现了拷贝构造和移动构造，而这个类的移动给构造和拷贝构造实现方式不同时，要注意通过函数内部局部变量返回该类时调用移动构造是否会存在一些逻辑或安全的问题。</p>
</li>
<li><p>优先按照移动构造的方式返回局部的类对象，有一个好处就是可以返回一些只支持移动构造的类型</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ReturnUniquePtr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt;  uq_ptr = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">return</span>  uq_ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::thread <span class="title">ReturnThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">([]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int</span> i = <span class="number">0</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::cout &lt;&lt; <span class="string">&quot;i is &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">            i++;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">break</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::this_thread::sleep_for(std::chrono::seconds(<span class="number">1</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> rt_ptr = <span class="built_in">ReturnUniquePtr</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;rt_ptr value is &quot;</span> &lt;&lt; *rt_ptr &lt;&lt; std::endl;</span><br><span class="line">    std::thread rt_thread = <span class="built_in">ReturnThread</span>();</span><br><span class="line">    rt_thread.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线程归属权问题"><a href="#线程归属权问题" class="headerlink" title="线程归属权问题"></a>线程归属权问题</h3><ul>
<li><strong>我们不能将一个线程的归属权转移给一个已经绑定线程的变量。</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadOp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int</span> i = <span class="number">0</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span> (i &lt; <span class="number">5</span>) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::this_thread::sleep_for(std::chrono::seconds(<span class="number">1</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">            i++;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int</span> i = <span class="number">0</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::this_thread::sleep_for(std::chrono::seconds(<span class="number">1</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">            i++;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    <span class="comment">//不能将一个线程归属权绑定给一个已经绑定线程的变量，否则会触发terminate导致崩溃</span></span><br><span class="line">    t1 = std::<span class="built_in">move</span>(t2);</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这样就会发生崩溃</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/并发编程/image-3.png" alt="示例图片" style="zoom:100%;" /></p>
<ul>
<li><p>t1已经绑定了一个线程执行循环操作直到i&lt;5。如果在t1没运行完的情况下将t2的归属权给t1，则会引发terminate崩溃错误。</p>
</li>
<li><p>所以综上所述，std::thread向回调函数传递值是以副本的方式,回调函数参数是引用类型，可以将传递的实参用std::ref包装达到修改的效果。<br>因为std::ref其实是构造了reference_wrapper类对象，这个类实现了仿函数</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">_CONSTEXPR20 <span class="keyword">operator</span> _Ty&amp;() <span class="type">const</span> <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> *_Ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>所以当线程接收std::ref包裹的参数时会调用仿函数通过指针解引用的方式获取外部实参，以_Ty&amp;返回，从而达到修改的效果。</li>
</ul>
<h3 id="future-析构的细节"><a href="#future-析构的细节" class="headerlink" title="future 析构的细节"></a>future 析构的细节</h3><ul>
<li>future在析构之前会等待任务结束才会正确析构，否则会阻塞，它内部会有一个引用计数，只有当引用计数为0的时候future才会析构</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BlockAsync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;begin block async&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#123;</span><br><span class="line">        std::<span class="built_in">async</span>(std::launch::async, []() &#123;</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">3</span>));</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;std::async called &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;end block async&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>输出如下：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">begin block async</span><br><span class="line">std::async called</span><br><span class="line">end block async</span><br></pre></td></tr></table></figure>
<ul>
<li><p>我们发现并没有并行运行，因为会在async局部作用域的时候阻塞，等待任务执行完主线程才会继续执行</p>
</li>
<li><p><strong>需求</strong></p>
</li>
<li>你的需求是func1 中要异步执行asyncFunc函数。</li>
<li>func2中先收集asyncFunc函数运行的结果，只有结果正确才执行</li>
<li>func1启动异步任务后继续执行，执行完直接退出不用等到asyncFunc运行完</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">asyncFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">3</span>));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;this is asyncFunc&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(std::future&lt;<span class="type">int</span>&gt;&amp; future_ref)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;this is func1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    future_ref = std::<span class="built_in">async</span>(std::launch::async, asyncFunc);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(std::future&lt;<span class="type">int</span>&gt;&amp; future_ref)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;this is func2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">auto</span> future_res = future_ref.<span class="built_in">get</span>();</span><br><span class="line">    <span class="keyword">if</span> (future_res == <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;get asyncFunc result success !&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;get asyncFunc result failed !&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//提供多种思路，这是第一种</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">first_method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; future_tmp;</span><br><span class="line">    <span class="built_in">func1</span>(future_tmp);</span><br><span class="line">    <span class="built_in">func2</span>(future_tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>上面的例子我们保证在func1和func2使用的是future的引用即可。这样func1内不会因为启动async而阻塞，因为future_ref不是shared state最后持有者。</p>
</li>
<li><p>纯异步代码</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Func, <span class="keyword">typename</span>... Args  &gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span>  <span class="title">ParallenExe</span><span class="params">(Func&amp;&amp; func, Args &amp;&amp; ... args)</span> -&gt; std::future&lt;<span class="title">decltype</span><span class="params">(func(args...))</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span>    <span class="title">decltype</span><span class="params">(func(args...))</span>  RetType</span>;</span><br><span class="line">    std::function&lt;RetType()&gt;  bind_func = std::<span class="built_in">bind</span>(std::forward&lt;Func&gt;(func), std::forward&lt;Args&gt;(args)...);</span><br><span class="line">    <span class="function">std::packaged_task&lt;<span class="title">RetType</span><span class="params">()</span>&gt; <span class="title">task</span><span class="params">(bind_func)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> rt_future = task.<span class="built_in">get_future</span>();</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(std::move(task))</span></span>;</span><br><span class="line">    t.<span class="built_in">detach</span>();</span><br><span class="line">    <span class="keyword">return</span> rt_future;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="原子操作和内存模型"><a href="#原子操作和内存模型" class="headerlink" title="原子操作和内存模型"></a>原子操作和内存模型</h2><h3 id="改动序列"><a href="#改动序列" class="headerlink" title="改动序列"></a>改动序列</h3><ul>
<li>在一个C++程序中，每个对象都具有一个改动序列，它由所有线程在对象上的全部写操作构成，其中第一个写操作即为对象的初始化。</li>
<li>大部分情况下，这个序列会随程序的多次运行而发生变化，但是在程序的任意一次运行过程中，所含的全部线程都必须形成相同的改动序列。</li>
</ul>
<p>改动序列基本要求如下：</p>
<ol>
<li>只要某线程看到过某个对象，则该线程的后续读操作必须获得相对新近的值，并且，该线程就同一对象的后续写操作，必然出现在改动序列后方。（也就是说只有在修改后才能继续修改或读取）</li>
<li>如果某线程先向一个对象写数据，过后再读取它，那么必须读取前面写的值。</li>
<li>若在改动序列中，上述读写操作之间还有别的写操作，则必须读取最后写的值。</li>
<li>在程序内部，对于同一个对象，全部线程都必须就其形成相同的改动序列，并且在所有对象上都要求如此.（多个线程作用在一个对象上需要井然有序）</li>
<li>多个对象上的改动序列只是相对关系，线程之间不必达成一致</li>
</ol>
<h3 id="原子类型"><a href="#原子类型" class="headerlink" title="原子类型"></a>原子类型</h3><ul>
<li><p>标准原子类型的定义位于头文件<atomic>内。我们可以通过atomic&lt;&gt;定义一些原子类型的变量，如atomic<bool>,atomic<int> 这些类型的操作全是原子化的。</p>
</li>
<li><p>从C++17开始，所有的原子类型都包含一个静态常量表达式成员变量，<strong>std::atomic::is_always_lock_free（判断是否天生原子性）</strong>。这个成员变量的值表示在任意给定的目标硬件上，原子类型X是否始终以无锁结构形式实现。如果在所有支持该程序运行的硬件上，原子类型X都以无锁结构形式实现，那么这个成员变量的值就为true；否则为false。</p>
</li>
<li><p>只有一个原子类型不提供is_lock_free()成员函数：std::atomic_flag 。类型<strong>std::atomic_flag的对象在初始化时清零</strong>，随后即可通过成员函数<strong>test_and_set()</strong>查值并设置成立，或者由<strong>clear()清零</strong>。整个过程只有这两个操作。其他的atomic&lt;&gt;的原子类型都可以基于其实现。</p>
</li>
<li><p><strong>std::atomic_flag的test_and_set成员函数是一个原子操作</strong>，他会先检查std::atomic_flag当前的状态是否被设置过，</p>
</li>
</ul>
<p>test_ans_set的作用:</p>
<ol>
<li><p>如果没被设置过(比如初始状态或者清除后)，将<strong>std::atomic_flag</strong>当前的状态设置为true，并返回false。</p>
</li>
<li><p>如果被设置过则直接返回ture。</p>
</li>
</ol>
<p>对于std::atomic<T>类型的原子变量，还支持load()（读操作）和store()（写操作）、exchange()、compare_exchange_weak()（比较期望值，不相等交换）和compare_exchange_strong()等操作。</p>
<h3 id="内存次序"><a href="#内存次序" class="headerlink" title="内存次序"></a>内存次序</h3><ul>
<li>对于原子类型上的每一种操作，我们都可以提供额外的参数，从枚举类std::memory_order取值，用于设定所需的内存次序语义（memory-ordering semantics）。</li>
<li>枚举类std::memory_order具有6个可能的值，分别是：std::memory_order_relaxed、std::memory_order_consume、std::memory_order_acquire、std::memory_order_release、std::memory_order_acq_rel或std::memory_order_seq_cst。</li>
</ul>
<ol>
<li>包括std::memory_order_relaxed、std:: memory_order_acquire、std::memory_order_consume、</li>
</ol>
<p>std::memory_order_acq_rel、std::memory_order_release和 std::memory_order_seq_cst。</p>
<ol>
<li><p>存储（store）操作，可选用的内存次序有std::memory_order_relaxed、std::memory_order_release或std::memory_order_seq_cst（全局一致性）。</p>
</li>
<li><p>载入（load）操作，可选用的内存次序有std::memory_order_relaxed、std::memory_order_consume、std::memory_order_acquire或std::memory_order_seq_cst。</p>
</li>
<li><p>“读-改-写”（read-modify-write）操作，可选用的内存次序有std::memory_order_relaxed、std::memory_order_consume、std::memory_order_acquire、std::memory_order_release、std::memory_order_acq_rel或std::memory_order_seq_cst。</p>
</li>
<li><p>原子操作默认使用的是std::memory_order_seq_cst次序。</p>
</li>
</ol>
<p>这六种内存顺序相互组合可以实现三种顺序模型 (ordering model)</p>
<ol>
<li>Sequencial consistent ordering. 实现同步, 且保证全局顺序一致 (single total order) 的模型. 是一致性最强的模型, 也是默认的顺序模型.</li>
<li>Acquire-release ordering. 实现同步, 但不保证保证全局顺序一致的模型.</li>
<li>Relaxed ordering. 不能实现同步, 只保证原子性的模型.</li>
</ol>
<h3 id="实现自旋锁"><a href="#实现自旋锁" class="headerlink" title="实现自旋锁"></a>实现自旋锁</h3><ul>
<li>自旋锁是一种在多线程环境下保护共享资源的同步机制。它的基本思想是，当一个线程尝试获取锁时，如果锁已经被其他线程持有，那么该线程就会不断地循环检查锁的状态，直到成功获取到锁为止。</li>
<li>我们可以用std::atomic_flag来实现自旋锁</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SpinLock</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//自旋等待直到可获取锁</span></span><br><span class="line">        <span class="keyword">while</span> (flag.<span class="built_in">test_and_set</span>(std::memory_order_acquire));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//释放锁</span></span><br><span class="line">        flag.<span class="built_in">clear</span>(std::memory_order_release);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//初始化为0</span></span><br><span class="line">    std::atomic_flag flag = ATOMIC_FLAG_INIT;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestSpinLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SpinLock spinlock;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;spinlock]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        spinlock.lock();</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::cout &lt;&lt; <span class="string">&quot;*&quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::cout &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">        spinlock.unlock();</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([&amp;spinlock]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        spinlock.lock();</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::cout &lt;&lt; <span class="string">&quot;?&quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::cout &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">        spinlock.unlock();</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>在多线程调用时，仅有一个线程在同一时刻进入test_and_set，因为atomic_flag初始状态为false,所以test_and_set将atomic_flag设置为true，并且返回false。</p>
</li>
<li><p>比如线程A调用了test_and_set返回false，这样lock函数返回，线程A继续执行加锁区域的逻辑。此时线程B调用test_and_set，test_and_set会返回true,导致线程B在while循环中循环等待，达到自旋检测标记的效果。当线程A直行至2处调用clear操作后，atomic_flag被设置为清空状态，线程B调用test_and_set会将状态设为成立并返回false，B线程执行加锁区域的逻辑。</p>
</li>
</ul>
<h3 id="宽松内存序"><a href="#宽松内存序" class="headerlink" title="宽松内存序"></a>宽松内存序</h3><ul>
<li>为了给大家介绍不同的字节序，我们先从最简单的字节序std::memory_order_relaxed(宽松字节序)介绍。</li>
<li>因为字节序是为了实现改动序列的，所以为了理解字节序还要结合改动序列讲起。</li>
<li>我们先看一个CPU和内存结构图：</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/并发编程/image-4.png" alt="示例图片" style="zoom:100%;" /></p>
<ul>
<li><p>其中StoreBuffer就是一级Cache， Catche是二级Cache，Memory是三级Cache。</p>
</li>
<li><p>每个标识CPU的块就是core，上图画的就是4核结构。每两个core构成一个bank，共享一个cache。四个core共享memory。</p>
</li>
<li><p>每个CPU所作的store均会写到store buffer中，每个CPU会在任何时刻将store buffer中结果写入到cache或者memory中。</p>
</li>
<li><p>那该如何保证数据一致性？这就要提及<strong>MESI一致性协议</strong>。</p>
</li>
<li><strong>MESI 协议</strong>，是一种叫作<strong>写失效（Write Invalidate）的协议</strong>。在写失效协议里，<strong>只有一个 CPU 核心负责写入数据，其他的核心，只是同步读取到这个写入</strong>。在这个 CPU 核心写入 cache 之后，它会去<strong>广播一个“失效”请求告诉所有其他的 CPU 核心</strong>。</li>
<li>MESI 协议对应的四个不同的标记，分别是：</li>
</ul>
<ol>
<li><p><strong>M：代表已修改（Modified）</strong>：“已修改”用来告诉其他cpu已经修改完成，其他cpu可以向cache中写入数据</p>
</li>
<li><p><strong>I：代表已失效（Invalidated）</strong></p>
</li>
<li><p><strong>E：代表独占（Exclusive）</strong>：“独占”表示数据只是加载到当前 CPU核 的store buffer中，其他的 CPU 核，并没有加载对应的数据到自己的 store buffer 里。，这个时候，如果要向独占的 store buffer 写入数据，我们可以自由地写入数据，而不需要告知其他 CPU 核。</p>
</li>
<li><p><strong>S：代表共享（Shared）</strong>：共享状态就是在多核中<strong>同时加载了同一份数据</strong>。所以在共享状态下想要修改数据要<strong>先向所有的其他 CPU 核心广播一个请求</strong>，要求先把其他 CPU 核心里面的 cache ，都变成无效的状态，然后再更新当前 cache 里面的数据，我们可以这么理解，如果变量a此刻在各个cpu的StoreBuffer中，那么CPU1核修改这个a的值，放入cache时通知其他CPU核写失效，因为同一时刻仅有一个CPU核可以写数据，但是其他CPU核是可以读数据的，那么其他核读到的数据可能是CPU1核修改之前的。这就涉及我们提到的改动序列了。</p>
</li>
</ol>
<p>这里给大家简单介绍两个改动序列的术语</p>
<ol>
<li><p><strong><em>“synchronizes-with“ : 同步, “A synchronizes-with B” 的意思就是 A和B同步，简单来说如果多线程环境下，有一个线程先修改了变量m，我们将这个操作叫做A，之后有另一个线程读取变量m，我们将这个操作叫做B，如果A先修改了，那么B一定读取A修改m之后的最新值。也可以称作 A “happens-before“ B，即A操作的结果对B操作可见。</em></strong></p>
</li>
<li><p>“happens-before“ : 先行，”A happens-before B” 的意思是如果A操作先于B操作，那么A操作的结果对B操作可见。”happens-before“包含很多种境况，不仅仅是我们上面提到的”synchronizes-with“,之后给大家一个脑图详细说明”happens-before“的几种情况。</p>
</li>
</ol>
<ul>
<li><p>我的理解是先行关系多数情况下描述对同一变量的先后操作，只有变量之间存在依赖关系才会有对不同变量的先后操作存在先行关系</p>
</li>
<li><p>我们接下来谈谈<strong>std::memory_order_relaxed</strong>。</p>
</li>
<li><p>关于std::memory_order_relaxed具备如下几个功能：</p>
<ol>
<li>作用于原子变量(写的时候是完整的，不会发生写一半而被终止)</li>
<li>不具有synchronizes-with关系(同步)（<strong>也就是说在多线程里不能保证读操作能读到写操作后的值</strong>）</li>
<li>对于同一个原子变量，在同一个线程中具有happens-before关系, <strong>在同一线程中不同的原子变量不具有happens-before关系，可以乱序执行。</strong></li>
<li>多线程情况下不具有happens-before关系。</li>
</ol>
</li>
<li><p>由上述可知，如果采用最松散的内存顺序模型，在一个线程中，如果某个表达式已经看到原子变量的某个值a，则该表达式的后续表达式只能看到a或者比a更新的值。</p>
</li>
<li>我们看下面的代码：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; x, y;</span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; z;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_x_then_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    x.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_relaxed);  <span class="comment">// 1</span></span><br><span class="line">    y.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_relaxed);  <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_y_then_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!y.<span class="built_in">load</span>(std::memory_order_relaxed)) &#123; <span class="comment">// 3</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;y load false&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x.<span class="built_in">load</span>(std::memory_order_relaxed)) &#123; <span class="comment">//4</span></span><br><span class="line">        ++z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestOrderRelaxed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(write_x_then_y)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(read_y_then_x)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    <span class="built_in">assert</span>(z.<span class="built_in">load</span>() != <span class="number">0</span>); <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>我们从两个角度分析</li>
</ul>
<ol>
<li>从cpu架构分析</li>
</ol>
<p>假设线程t1运行在CPU1上，t2运行在CPU3上，那么t1对x和y的操作，t2是看不到的。</p>
<p>比如当线程t1运行至1处将x设置为true，t1运行至2处将y设置为true。这些操作仅在CPU1的store buffer中，还未放入cache和memory中，CPU2自然不知道。</p>
<p>如果CPU1先将y放入memory，那么CPU2就会读取y的值为true。那么t2就会运行至3处从while循环退出，进而运行至4处，此时CPU1还未将x的值写入memory，</p>
<p>t2读取的x值为false，进而线程t2运行结束，然后CPU1将x写入true, t1结束运行，最后主线程运行至5处，因为z为0,所以触发断言。</p>
<ol>
<li>从宽松内存序分析</li>
</ol>
<p>因为memory_order_relaxed是宽松的内存序列，它只保证操作的原子性，并不能保证多个变量之间的顺序性，也不能保证同一个变量在不同线程之间的可见顺序。</p>
<p>比如t1可能先运行2处代码再运行1处代码，因为我们的代码会被编排成指令执行，编译器在不破坏语义的情况下(2处和1处代码无耦合，可调整顺序)，2可能先于1执行。如果这样，t2运行至3处退出while循环，继续运行4处，此时t1还未执行1初代码，则t2运行4处条件不成立不会对z做增加，t2结束。这样也会导致z为0引发断言。</p>
<p>如图：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/并发编程/image-5.png" alt="示例图片" style="zoom:100%;" /></p>
<ul>
<li>我们在看一个例子</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestOderRelaxed2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::atomic&lt;<span class="type">int</span>&gt; a&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v3, v4;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;a]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i += <span class="number">2</span>) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            a.store(i, std::memory_order_relaxed);</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([&amp;a]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i += <span class="number">2</span>)</span></span></span><br><span class="line"><span class="params"><span class="function">            a.store(i, std::memory_order_relaxed);</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t3</span><span class="params">([&amp;v3, &amp;a]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span></span></span><br><span class="line"><span class="params"><span class="function">            v<span class="number">3.</span>push_back(a.load(std::memory_order_relaxed));</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t4</span><span class="params">([&amp;v4, &amp;a]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span></span></span><br><span class="line"><span class="params"><span class="function">            v<span class="number">4.</span>push_back(a.load(std::memory_order_relaxed));</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">3.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">4.</span><span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : v3) &#123;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : v4) &#123;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>可能的输出</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span></span><br><span class="line"><span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span></span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line"><span class="number">0</span> <span class="number">8</span> <span class="number">8</span> <span class="number">8</span> <span class="number">8</span> <span class="number">8</span> <span class="number">8</span> <span class="number">8</span> <span class="number">8</span> <span class="number">8</span></span><br><span class="line"><span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>由此可见，std::memory_order_relaxed对于多个线程它是乱序执行的，因为多个线程仅操作了a变量，通过memory_order_relaxed的方式仅能保证对a的操作是原子的(同一时刻仅有一个线程写a的值，但是可能多个线程读取a的值)。</p>
</li>
<li><p>但是多个线程之间操作不具备同步关系，也就是线程t1将a改为7，那么线程t3不知道a改动的最新值为7，它读到a的值为1。只是要过一阵子可能会读到7或者a变为7之后又改动的其他值。</p>
</li>
<li><p>但是t3,t4两个线程读取a的次序是一致的，比如t3和t4都读取了7和9，t3读到7在9之前，那么t4也读取到7在9之前。</p>
</li>
<li><p>因为我们memory_order_relaxed保证了多线程对同一个变量的原子操作的安全性，只是可见性会有延迟罢了。</p>
</li>
</ul>
<h3 id="先行"><a href="#先行" class="headerlink" title="先行"></a>先行</h3><ul>
<li>Happens-before 是一个非常重要的概念. 如前文我们提及：</li>
<li>如果操作 a “happens-before” 操作 b, 则操作 a 的结果对于操作 b 可见. happens-before 的关系可以建立在用一个线程的两个操作之间, 也可以建立在不同的线程的两个操作之间。</li>
</ul>
<h4 id="顺序先行"><a href="#顺序先行" class="headerlink" title="顺序先行"></a>顺序先行</h4><ul>
<li>单线程情况下前面的语句先执行，后面的语句后执行。操作a先于操作b，那么操作b可以看到操作a的结果。我们称操作a顺序先行于操作b。也就是”a sequenced-before b”。</li>
</ul>
<p>这种情况下”a happens before b</p>
<ul>
<li>sequencde-before”具备传递性，比如操作 a “sequenced-before” 操作 b, 且操作 b “sequenced-before” 操作 m, 则操作 a “sequenced-before” 操作 m.</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/并发编程/image-6.png" alt="示例图片" style="zoom:100%;" /></p>
<h4 id="线程间先行"><a href="#线程间先行" class="headerlink" title="线程间先行"></a>线程间先行</h4><ul>
<li><p>线程间先行又叫做”inter-thread-happens-before”，这是多线程情况的”happens-before”.</p>
</li>
<li><p>我们前面提到的”synchronizes-with” 可以构成 “happens-before”。</p>
</li>
<li><p>如果线程 1 中的操作 a “synchronizes-with” 线程 2 中的操作 b, 则操作 a “inter-thread happens-before” 操作 b.</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/并发编程/image-7.png" alt="示例图片" style="zoom:100%;" /></p>
<ul>
<li><p>此外 synchronizes-with 还可以 “后接” 一个 sequenced-before 关系组合成 inter-thread happens-before 的关系:</p>
</li>
<li><p>比如操作 a “synchronizes-with” 操作 b, 且操作 b “sequenced-before” 操作 m, 则操作 a “inter-thread happens-before” 操作 m.</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/并发编程/image-8.png" alt="示例图片" style="zoom:100%;" /></p>
<ul>
<li>那同样的道理， Inter-thread happens-before 关系则可以 “前接” 一个 sequenced-before 关系以延伸它的范围; 而且 inter-thread happens-before 关系具有传递性:</li>
</ul>
<ol>
<li>如果操作 a “sequenced-before” 操作 k, 且操作 k “inter-thread happens-before” 操作 b, 则操作 a “inter-thread happens-before” 操作 b.</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/并发编程/image-9.png" alt="示例图片" style="zoom:100%;" /></p>
<ol>
<li>如果操作 a “inter-thread happens-before” 操作 k, 且操作 k “inter-thread happens-before” 操作 b, 则操作 a “inter-thread happens-before” 操作 b.</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/并发编程/image-10.png" alt="示例图片" style="zoom:100%;" /></p>
<h3 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h3><ul>
<li><p>依赖关系有 carries dependency 和 dependency-ordered before.</p>
</li>
<li><p>单线程情况下a “sequenced-before” b, 且 b 依赖 a 的数据, 则 a “carries a dependency into” b. 称作 a 将依赖关系带给 b, 也理解为b依赖于a。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestDependency</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1 处</span></span><br><span class="line">    std::string str = <span class="string">&quot;hello world!&quot;</span>;</span><br><span class="line">    <span class="comment">// 2 处</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 3 处</span></span><br><span class="line">    std::cout &lt;&lt; str[i] &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>函数TestDependency内部打印str[i]的值。3处代码需要依赖1处和2处两个变量的值，所以达成依赖关系。</p>
</li>
<li><p>我们看单线程情况下按顺序执行1，2，3处代码，1 “sequenced-before” 3，且3 依赖 1的数据，则 1 “carries a dependency into” 3</p>
</li>
<li><p>同样的道理 2 “sequenced-before” 3, 且3依赖2 的数据，则2 “carries a dependency into” 3.</p>
</li>
</ul>
<p>“carries a dependency into” 也被归为”happens-before”。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/并发编程/image-11.png" alt="示例图片" style="zoom:100%;" /></p>
<ul>
<li><strong><em>多线程情况下</em></strong></li>
<li>线程1执行操作A(比如对i自增)，线程2执行操作B(比如根据i访问字符串下表的元素), 如果线程1先于线程2执行，且操作A的结果对操作B可见，我们将这种叫做<br>A “dependency-ordered before” B. 有人会说这不是前面说到的A “synchronizes with “ B吗？你可以这么理解。就当作他们达到的效果是一致的，只不过A “dependency-ordered before” B 更细化一点，表述了一种依赖，比如操作A仅仅对i增加，而没有对字符串修改。而操作B需要通过i访问字符串数据。那操作B实际上是依赖于A的。</li>
</ul>
<h3 id="Happens-before不代表指令执行顺序"><a href="#Happens-before不代表指令执行顺序" class="headerlink" title="Happens-before不代表指令执行顺序"></a>Happens-before不代表指令执行顺序</h3><ul>
<li><strong>Happens-before不代表指令实际执行顺序，C++编译器可以对不相关的指令任意编排达到优化效果，Happens-before仅是C++语义层面的描述，表示 a “Happens-before” b仅能说明a操作的结果对b操作可见。</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>  <span class="title">Add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//1 处</span></span><br><span class="line">    a++; </span><br><span class="line">    <span class="comment">// 2 处</span></span><br><span class="line">    b++;</span><br><span class="line">    <span class="comment">// 3 处</span></span><br><span class="line">    <span class="keyword">return</span>  a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>单线程执行上述代码，操作1一定是happens-before 操作2 的(a “sequenced-before” b)，就是我们理解的 a++ 先于 b++。</p>
</li>
<li><p>但是计算机的指令可能不是这样，一条C++语句对于多条计算机指令。</p>
</li>
<li><p>有可能是先将b值放入寄存器eax做加1，再将a的值放入寄存器edx做加1，然后再将eax寄存器的值写回a，将edx写回b。</p>
</li>
<li><p>因为对于计算机来说1处操作和2处操作的顺序对于3处来说并无影响。只要3处返回a+b之前能保证a和b的值是增加过的即可。</p>
</li>
<li><p>那我们语义上的”Happens-before”有意义吗？ 是有意义的，因为如果 a “sequenced-before” b, 那么无论指令如何编排，最终写入内存的顺序一定是a先于b。</p>
</li>
<li><p>只不过C++编译器不断优化尽可能不造成指令编排和语义理解的差异，上面C++的代码转换为汇编指令如下</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line"><span class="number">00</span>A1C8F5  mov         dword ptr [a],<span class="number">0</span>  </span><br><span class="line"><span class="number">00</span>A1C8FC  mov         dword ptr [b],<span class="number">0</span>  </span><br><span class="line">    <span class="comment">//1 处</span></span><br><span class="line">    a++; </span><br><span class="line"><span class="number">00</span>A1C903  mov         eax,dword ptr [a]  </span><br><span class="line"><span class="number">00</span>A1C906  add         eax,<span class="number">1</span>  </span><br><span class="line"><span class="number">00</span>A1C909  mov         dword ptr [a],eax  </span><br><span class="line">    <span class="comment">// 2 处</span></span><br><span class="line">    b++;</span><br><span class="line"><span class="number">00</span>A1C90C  mov         eax,dword ptr [b]  </span><br><span class="line"><span class="number">00</span>A1C90F  add         eax,<span class="number">1</span>  </span><br><span class="line"><span class="number">00</span>A1C912  mov         dword ptr [b],eax  </span><br><span class="line">    <span class="keyword">return</span>  a + b;</span><br><span class="line"><span class="number">00</span>A1C915  mov         eax,dword ptr [a]  </span><br><span class="line"><span class="number">00</span>A1C918  add         eax,dword ptr [b]</span><br></pre></td></tr></table></figure>
<h3 id="脑图"><a href="#脑图" class="headerlink" title="脑图"></a>脑图</h3><ul>
<li>我们将”happens-before” 的几种情况做成脑图，方便理解</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/并发编程/image-12.png" alt="示例图片" style="zoom:100%;" /></p>
<ul>
<li>我们画一个框将”happens-before” 的几种情况框起来</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/并发编程/image-13.png" alt="示例图片" style="zoom:100%;" /></p>
<h2 id="用内存顺序实现内存模型"><a href="#用内存顺序实现内存模型" class="headerlink" title="用内存顺序实现内存模型"></a>用内存顺序实现内存模型</h2><h3 id="memory-order-seq-cst"><a href="#memory-order-seq-cst" class="headerlink" title="memory_order_seq_cst"></a>memory_order_seq_cst</h3><ul>
<li>memory_order_seq_cst代表全局一致性顺序，可以用于 store, load 和 read-modify-write 操作, 实现 sequencial consistent 的顺序模型. 在这个模型下, 所有线程看到的所有操作都有一个一致的顺序, 即使这些操作可能针对不同的变量, 运行在不同的线程.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_x_then_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    x.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_seq_cst);  <span class="comment">// 1</span></span><br><span class="line">    y.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_seq_cst);  <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_y_then_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!y.<span class="built_in">load</span>(std::memory_order_seq_cst)) &#123; <span class="comment">// 3</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;y load false&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x.<span class="built_in">load</span>(std::memory_order_seq_cst)) &#123; <span class="comment">//4</span></span><br><span class="line">        ++z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestOrderSeqCst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(write_x_then_y)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(read_y_then_x)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    <span class="built_in">assert</span>(z.<span class="built_in">load</span>() != <span class="number">0</span>); <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>上面的代码x和y采用的是memory_order_seq_cst, 所以当线程t2执行到3处并退出循环时我们可以断定y为true，因为是全局一致性顺序，所以线程t1已经执行完2处将y设置为true，那么线程t1也一定执行完1处代码并对t2可见，所以当t2执行至4处时x为true，那么会执行z++保证z不为零，从而不会触发断言。</p>
</li>
<li><p><strong>实现 sequencial consistent 模型有一定的开销</strong>. 现代 CPU 通常有多核, 每个核心还有自己的缓存. <strong>为了做到全局顺序一致, 每次写入操作都必须同步给其他核心</strong>. 为了减少性能开销, 如果不需要全局顺序一致, 我们应该考虑使用更加宽松的顺序模型.</p>
</li>
<li><p><strong>为了保持全局一致性，当CPU执行写操作的时候不仅会给别的cpu发送写失效，还会发送不让读的指令，这样就保住了全局一致性</strong></p>
</li>
</ul>
<h3 id="memory-order-relaxed"><a href="#memory-order-relaxed" class="headerlink" title="memory_order_relaxed"></a>memory_order_relaxed</h3><ul>
<li><p>memory_order_relaxed 可以用于 store, load 和 read-modify-write 操作, 实现 relaxed 的顺序模型.<br>前文我们介绍过这种模型下, 只能保证操作的原子性和修改顺序 (modification order) 一致性, 无法实现 synchronizes-with 的关系。</p>
</li>
<li><p>详见上一段笔记</p>
</li>
</ul>
<h3 id="Acquire-Release"><a href="#Acquire-Release" class="headerlink" title="Acquire-Release"></a>Acquire-Release</h3><ul>
<li><p>在 acquire-release 模型中, 会使用 memory_order_acquire, memory_order_release 和 memory_order_acq_rel 这三种内存顺序. 它们的用法具体是这样的:</p>
<ol>
<li>对原子变量的 load 可以使用 memory_order_acquire 内存顺序. 这称为 acquire 操作</li>
<li>对原子变量的 store 可以使用 memory_order_release 内存顺序. 这称为 release 操作.(发布操作)</li>
<li>read-modify-write 操作即读 (load) 又写 (store), 它可以使用 memory_order_acquire, memory_order_release 和 memory_order_acq_rel:<ol>
<li>如果使用 memory_order_acquire, 则作为 acquire 操作;</li>
<li>如果使用 memory_order_release, 则作为 release 操作;</li>
<li>如果使用 memory_order_acq_rel, 则同时为两者.</li>
</ol>
</li>
</ol>
</li>
<li><p>Acquire-release 可以实现 synchronizes-with 的关系. 如果一个 acquire 操作在同一个原子变量上读取到了一个 release 操作写入的值, 则这个 release 操作 “synchronizes-with” 这个 acquire 操作.（就是说对于一个原子变量，如果store relase先发生，则会保证 load acuire读取到的是操作后的值）</p>
</li>
<li>不要想太复杂，release给变量store时加上了一个标记，另一个线程acquire读到该变量时看到该标记就知道要先进行同步，就是同步更新了各自缓冲区的数据（比如线程1告诉线程2我的x更新了，线程2刷新缓冲区），保证数据的一致性，而不是说加上了release标记的就必须得先执行。</li>
<li>我们可以通过Acquire-release 修正 TestOrderRelaxed函数以达到同步的效果</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestReleaseAcquire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::atomic&lt;<span class="type">bool</span>&gt; rx, ry;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        rx.store(<span class="literal">true</span>, std::memory_order_relaxed); <span class="comment">// 1</span></span></span></span><br><span class="line"><span class="params"><span class="function">        ry.store(<span class="literal">true</span>, std::memory_order_release); <span class="comment">// 2</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span> (!ry.load(std::memory_order_acquire)); <span class="comment">//3</span></span></span></span><br><span class="line"><span class="params"><span class="function">        assert(rx.load(std::memory_order_relaxed)); <span class="comment">//4</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>上面的例子中我们看到ry.store使用的是std::memory_order_release, ry.load使用的是std::memory_order_relaxed.</p>
</li>
<li><p>对于ry.store(true, std::memory_order_release);，它确保在存储操作之前的所有操作都发生在存储操作之前，并且不会被重排序到存储操作之后。对于ry.load(std::memory_order_acquire);，它确保在加载操作之后的所有操作都发生在加载操作之后，并且不会被重排序到加载操作之前。”，然后又问了synchronizes with相关的：“具体来说，如果一个原子操作A与另一个原子操作B具有“synchronizes-with”关系，那么：</p>
<ol>
<li>所有在A之前的操作都在B之前发生。</li>
<li>所有在B之后的操作都在A之后发生。</li>
</ol>
</li>
<li><p>可以断定4 不会触发断言。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestReleaseAcquire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::atomic&lt;<span class="type">bool</span>&gt; rx, ry;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        ry.store(<span class="literal">true</span>, std::memory_order_release); <span class="comment">// 1</span></span></span></span><br><span class="line"><span class="params"><span class="function">        rx.store(<span class="literal">true</span>, std::memory_order_relaxed); <span class="comment">// 2</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span> (!ry.load(std::memory_order_acquire)); <span class="comment">//3</span></span></span></span><br><span class="line"><span class="params"><span class="function">        assert(rx.load(std::memory_order_relaxed)); <span class="comment">//4</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>这就又可能发生断言，因为rx.store(true, std::memory_order_relaxed);在1之后操作不会保证同步性</p>
</li>
<li><p>我们从cpu结构图理解这一情景</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/并发编程/image-14.png" alt="示例图片" style="zoom:100%;" /></p>
<ul>
<li><p>到此大家一定要记住仅 Acquire-release能配合达到 synchronizes-with效果，再就是memory_order_seq_cst可以保证全局顺序唯一，其他情况的内存顺序都能保证顺序，使用时需注意。</p>
</li>
<li><p>Acquire-release 的开销比 sequencial consistent 小. 在 x86 架构下, memory_order_acquire 和 memory_order_release 的操作不会产生任何其他的指令, 只会影响编译器的优化: 任何指令都不能重排到 acquire 操作的前面, 且不能重排到 release 操作的后面; 否则会违反 acquire-release 的语义. 因此很多需要实现 synchronizes-with 关系的场景都会使用 acquire-release.</p>
</li>
</ul>
<h3 id="Release-sequences"><a href="#Release-sequences" class="headerlink" title="Release sequences"></a>Release sequences</h3><ul>
<li><p>我们再考虑一种情况，多个线程对同一个变量release操作，另一个线程对这个变量acquire，那么只有一个线程的release操作和这个acquire线程构成同步关系。</p>
</li>
<li><p>以下为危险示例</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ReleasAcquireDanger2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::atomic&lt;<span class="type">int</span>&gt; xd&#123;<span class="number">0</span>&#125;, yd&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    std::atomic&lt;<span class="type">int</span>&gt; zd;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        xd.store(<span class="number">1</span>, std::memory_order_release);  <span class="comment">// (1)</span></span></span></span><br><span class="line"><span class="params"><span class="function">        yd.store(<span class="number">1</span>, std::memory_order_release); <span class="comment">//  (2)</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        yd.store(<span class="number">2</span>, std::memory_order_release);  <span class="comment">// (3)</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t3</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span> (!yd.load(std::memory_order_acquire)); <span class="comment">//（4）</span></span></span></span><br><span class="line"><span class="params"><span class="function">        assert(xd.load(std::memory_order_acquire) == <span class="number">1</span>); <span class="comment">// (5)</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">3.</span><span class="built_in">join</span>();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<ul>
<li>当3被当作4的同步操作的时候，可能会发生断言(xd != 1)</li>
<li><p>当2被当作4的同步操作的时候，不会发生断言</p>
</li>
<li><p>并不是只有在 acquire 操作读取到 release 操作写入的值时才能构成 synchronizes-with 关系. 为了说这种情况, 我们需要引入 release sequence 这个概念.</p>
</li>
<li><p>针对一个原子变量 M 的 release 操作 A 完成后, 接下来 M 上可能还会有一连串的其他操作. 如果这一连串操作是由</p>
<ol>
<li>同一线程上的写操作</li>
<li>任意线程上的 read-modify-write 操作，这两种构成的, 则称这一连串的操作为以 release 操作 A 为首的 release sequence. 这里的写操作和 read-modify-write 操作可以使用任意内存顺序.</li>
</ol>
</li>
<li>如果一个 acquire 操作在同一个原子变量上读到了一个 release 操作写入的值, 或者读到了以这个 release 操作为首的 release sequence 写入的值, 那么这个 release 操作 “synchronizes-with” 这个 acquire 操作.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ReleaseSequence</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; data;</span><br><span class="line">    std::atomic&lt;<span class="type">int</span>&gt; flag&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        data.push_back(<span class="number">42</span>);  <span class="comment">//(1)</span></span></span></span><br><span class="line"><span class="params"><span class="function">        flag.store(<span class="number">1</span>, std::memory_order_release); <span class="comment">//(2)</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int</span> expected = <span class="number">1</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span> (!flag.compare_exchange_strong(expected, <span class="number">2</span>, std::memory_order_relaxed)) <span class="comment">// (3)</span></span></span></span><br><span class="line"><span class="params"><span class="function">            expected = <span class="number">1</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t3</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span> (flag.load(std::memory_order_acquire) &lt; <span class="number">2</span>); <span class="comment">// (4)</span></span></span></span><br><span class="line"><span class="params"><span class="function">        assert(data.at(<span class="number">0</span>) == <span class="number">42</span>); <span class="comment">// (5)</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">3.</span><span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>我们考虑t3要想退出首先flag要等于2，那么就要等到t2将flag设置为2，而flag设置为2又要等到t1将flag设置为1. 所以我们捋一下顺序 2-&gt;3-&gt;4</p>
</li>
<li><p>t1中操作2是release操作，以2为开始，其他线程(t2)的读改写在release操作之后，我们称之为release sequence， t3要读取release sequence写入的值，所以我们称t1的release操作 “synchronizes with “ t3的 acquire 操作。</p>
</li>
</ul>
<h3 id="memory-order-consume"><a href="#memory-order-consume" class="headerlink" title="memory_order_consume"></a>memory_order_consume</h3><ul>
<li>memory_order_consume 其实是 acquire-release 模型的一部分, 但是它比较特殊, 它涉及到数据间相互依赖的关系. 就是前文我们提及的 carries dependency和 dependency-ordered before.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p++;   <span class="comment">// (1)</span></span><br><span class="line">i++;   <span class="comment">// (2)</span></span><br><span class="line">p[i]   <span class="comment">// (3)</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>(1) “sequenced-before” (2), (2) “sequenced-before” (3), 而(1)和(2)的值作为(3)的下表运算符[]的操作数。</p>
</li>
<li><p>我们可以称(1) “carries a dependency into “ (3), (2) “carries a dependency into “ (3), 但是(1)和(2)不是依赖关系。</p>
</li>
<li><p>memory_order_consume 可以用于 load 操作. 使用 memory_order_consume 的 load 称为 consume 操作. 如果一个 consume 操作在同一个原子变量上读到了一个 release 操作写入的值, 或以其为首的 release sequence 写入的值, 则这个 release 操作 “dependency-ordered before” 这个 consume 操作.</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConsumeDependency</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::atomic&lt;std::string*&gt; ptr;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::string* p = <span class="keyword">new</span> std::string(<span class="string">&quot;Hello World&quot;</span>); <span class="comment">// (1)</span></span></span></span><br><span class="line"><span class="params"><span class="function">        data = <span class="number">42</span>; <span class="comment">// (2)</span></span></span></span><br><span class="line"><span class="params"><span class="function">        ptr.store(p, std::memory_order_release); <span class="comment">// (3)</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::string* p2;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span> (!(p2 = ptr.load(std::memory_order_consume))); <span class="comment">// (4)</span></span></span></span><br><span class="line"><span class="params"><span class="function">        assert(*p2 == <span class="string">&quot;Hello World&quot;</span>); <span class="comment">// (5)</span></span></span></span><br><span class="line"><span class="params"><span class="function">        assert(data == <span class="number">42</span>); <span class="comment">// (6)</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>t2执行到(4)处时，需要等到ptr非空才能退出循环，这就依赖t1执行完(3)操作。</li>
</ul>
<p>-因此(3) “dependency-ordered before” (4), 根据前文我们介绍了dependency等同于synchronizes ，所以(3) “inter-thread happens-before”. （4）</p>
<p>-因为(1) “sequenced before” (3), 所以(1) “happens-before “ (4)</p>
<p>-因为(4) “sequenced before” (5), 所以(1) “happens-before “ (5)</p>
<p>-所以(5)处断言也不会触发。</p>
<p>-因为(2) 和(3)不构成先行关系，所以(6)处断言可能触发。</p>
<ul>
<li>release只能保证其他线程可见，并不能保证其他线程能够正确读到，正因为如此才引入acquire。 而consumer只能保证相关原子能够读到</li>
</ul>
<h3 id="单例模型改良"><a href="#单例模型改良" class="headerlink" title="单例模型改良"></a>单例模型改良</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用智能指针解决释放问题</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleMemoryModel</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">SingleMemoryModel</span>()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">SingleMemoryModel</span>(<span class="type">const</span> SingleMemoryModel&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    SingleMemoryModel&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SingleMemoryModel&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">SingleMemoryModel</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;single auto delete success &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> std::shared_ptr&lt;SingleMemoryModel&gt; <span class="title">GetInst</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 1 处</span></span><br><span class="line">        <span class="keyword">if</span> (_b_init.<span class="built_in">load</span>(std::memory_order_acquire))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> single;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2 处</span></span><br><span class="line">        s_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="comment">// 3 处</span></span><br><span class="line">        <span class="keyword">if</span> (_b_init.<span class="built_in">load</span>(std::memory_order_relaxed))</span><br><span class="line">        &#123;</span><br><span class="line">            s_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">return</span> single;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4处</span></span><br><span class="line">        single = std::<span class="built_in">shared_ptr</span>&lt;SingleMemoryModel&gt;(<span class="keyword">new</span> SingleMemoryModel);</span><br><span class="line">        _b_init.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_release);</span><br><span class="line">        s_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> std::shared_ptr&lt;SingleMemoryModel&gt; single;</span><br><span class="line">    <span class="type">static</span> std::mutex s_mutex;</span><br><span class="line">    <span class="type">static</span> std::atomic&lt;<span class="type">bool</span>&gt; _b_init ;</span><br><span class="line">&#125;;</span><br><span class="line">std::shared_ptr&lt;SingleMemoryModel&gt; SingleMemoryModel::single = <span class="literal">nullptr</span>;</span><br><span class="line">std::mutex SingleMemoryModel::s_mutex;</span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; SingleMemoryModel::_b_init = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>锁要求全局一致性,所以在3处可以用relaxed</li>
</ul>
<h2 id="用内存顺序和原子变量实现无锁队列"><a href="#用内存顺序和原子变量实现无锁队列" class="headerlink" title="用内存顺序和原子变量实现无锁队列"></a>用内存顺序和原子变量实现无锁队列</h2><h3 id="环形队列"><a href="#环形队列" class="headerlink" title="环形队列"></a>环形队列</h3><ul>
<li>我们要实现<strong>无锁并发</strong>，经常会用到<strong>一种结构无锁队列</strong>，而<strong>无锁队列</strong>和我们经常使用的队列颇有不同，它采用的是<strong>环状的队列结构</strong>，为什么成环呢？主要有两个好处，一个是成<strong>环的队列大小是固定</strong>的，另外一个我们通过移动<strong>头和尾就能实现数据的插入和取出</strong>。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/并发编程/image-15.png" alt="示例图片" style="zoom:100%;" /></p>
<ul>
<li><p>图1表示队列为空的时候，头节点和尾节点交会在一起，指向同一个扇区。</p>
</li>
<li><p>图2表示当我们你插入一个数字1后，队列大小为1，此时tail指针移动到下一个扇区，head指向头部，1被存储在头部了。</p>
</li>
<li><p>图3表示当我们将数字1出队后，head指针向后移动一个扇区，此时head和tail指向同一个扇区，表示队列又为空了。那有人会问队列中数字1为什么不清空呢？其实不用清空，因为当我们插入新数据时就可以覆盖掉1这个无效的数据。</p>
</li>
</ul>
<p>比如我们继续3图，连续插入几个数字，将队列填满。</p>
<ul>
<li>当tail + 1 == head的时候队列就满了，所以如果你想存储10个数你得开辟11个空间最后一个空间用来判断满</li>
</ul>
<h3 id="用锁实现环形队列"><a href="#用锁实现环形队列" class="headerlink" title="用锁实现环形队列"></a>用锁实现环形队列</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">size_t</span> Cap&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CircularQueLk</span> :<span class="keyword">private</span> std::allocator&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CircularQueLk</span>() :_max_size(Cap + <span class="number">1</span>),_data(std::allocator&lt;T&gt;::<span class="built_in">allocate</span>(_max_size)), _head(<span class="number">0</span>), _tail(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">CircularQueLk</span>(<span class="type">const</span> CircularQueLk&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    CircularQueLk&amp; <span class="keyword">operator</span> = (<span class="type">const</span> CircularQueLk&amp;) <span class="keyword">volatile</span> = <span class="keyword">delete</span>;</span><br><span class="line">    CircularQueLk&amp; <span class="keyword">operator</span> = (<span class="type">const</span> CircularQueLk&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    ~<span class="built_in">CircularQueLk</span>() &#123;</span><br><span class="line">        <span class="comment">//循环销毁</span></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt;  <span class="title">lock</span><span class="params">(_mtx)</span></span>;</span><br><span class="line">        <span class="comment">//调用内部元素的析构函数</span></span><br><span class="line">        <span class="keyword">while</span> (_head != _tail) &#123;</span><br><span class="line">            std::allocator&lt;T&gt;::<span class="built_in">destroy</span>(_data + _head);</span><br><span class="line">            _head = (_head<span class="number">+1</span>)%_max_size;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调用回收操作</span></span><br><span class="line">        std::allocator&lt;T&gt;::<span class="built_in">deallocate</span>(_data, _max_size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//先实现一个可变参数列表版本的插入函数最为基准函数</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...Args&gt;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">emplace</span><span class="params">(Args &amp;&amp; ... args)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_mtx)</span></span>;</span><br><span class="line">        <span class="comment">//判断队列是否满了</span></span><br><span class="line">        <span class="keyword">if</span> ((_tail + <span class="number">1</span>) % _max_size == _head) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;circular que full ! &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在尾部位置构造一个T类型的对象，构造参数为args...</span></span><br><span class="line">        std::allocator&lt;T&gt;::<span class="built_in">construct</span>(_data + _tail, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">        <span class="comment">//更新尾部元素位置</span></span><br><span class="line">        _tail = (_tail + <span class="number">1</span>) % _max_size;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//push 实现两个版本，一个接受左值引用，一个接受右值引用</span></span><br><span class="line">    <span class="comment">//接受左值引用版本</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp; val)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;called push const T&amp; version&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">emplace</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//接受右值引用版本，当然也可以接受左值引用，T&amp;&amp;为万能引用</span></span><br><span class="line">    <span class="comment">// 但是因为我们实现了const T&amp;</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(T&amp;&amp; val)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;called push T&amp;&amp; version&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">emplace</span>(std::<span class="built_in">move</span>(val));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//出队函数</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(T&amp; val)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_mtx)</span></span>;</span><br><span class="line">        <span class="comment">//判断头部和尾部指针是否重合，如果重合则队列为空</span></span><br><span class="line">        <span class="keyword">if</span> (_head == _tail) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;circular que empty ! &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//取出头部指针指向的数据</span></span><br><span class="line">        val = std::<span class="built_in">move</span>(_data[_head]);</span><br><span class="line">        <span class="comment">//更新头部指针</span></span><br><span class="line">        _head = (_head + <span class="number">1</span>) % _max_size;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">size_t</span> _max_size;</span><br><span class="line">    T* _data;</span><br><span class="line">    std::mutex _mtx;</span><br><span class="line">    <span class="type">size_t</span> _head = <span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> _tail = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestCircularQue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//最大容量为10</span></span><br><span class="line">    CircularQueLk&lt;MyClass, <span class="number">5</span>&gt; cq_lk;</span><br><span class="line">    <span class="function">MyClass <span class="title">mc1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">MyClass <span class="title">mc2</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    cq_lk.<span class="built_in">push</span>(mc1);</span><br><span class="line">    cq_lk.<span class="built_in">push</span>(std::<span class="built_in">move</span>(mc2));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="function">MyClass <span class="title">mc</span><span class="params">(i)</span></span>;</span><br><span class="line">        <span class="keyword">auto</span> res = cq_lk.<span class="built_in">push</span>(mc);</span><br><span class="line">        <span class="keyword">if</span> (res == <span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cq_lk.<span class="built_in">push</span>(mc2);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        MyClass mc1;</span><br><span class="line">        <span class="keyword">auto</span> res = cq_lk.<span class="built_in">pop</span>(mc1);</span><br><span class="line">        <span class="keyword">if</span> (!res) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;pop success, &quot;</span> &lt;&lt; mc1 &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> res = cq_lk.<span class="built_in">pop</span>(mc1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="无锁队列"><a href="#无锁队列" class="headerlink" title="无锁队列"></a>无锁队列</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> std::atomic&lt;T&gt;::<span class="built_in">compare_exchange_weak</span>(T &amp;expected, T desired);</span><br><span class="line"><span class="type">bool</span> std::atomic&lt;T&gt;::<span class="built_in">compare_exchange_strong</span>(T &amp;expected, T desired);</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>compare_exchange_strong</strong>会比较原子变量atomic<T>的值和expected的值是否相等，如果相等则执行交换操作，将atomic<T>的值换为desired并且返回true,否则将expected的值修改为T变量的值，并且返回false.</li>
<li>其伪代码可以这么理解</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> atomic&lt;T&gt;::<span class="built_in">compare_exchange_strong</span>(T &amp;expected, T desired) &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(m_lock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (m_val == expected)</span><br><span class="line">        <span class="keyword">return</span> m_val = desired, <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> expected = m_val, <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>compare_exchange_weak功能比compare_exchange_strong弱一些，他不能保证atomic<T>的值和expected的值相等时也会做交换，很可能原子变量和预期值相等也会返回false，所以使用要多次循环使用。</li>
<li>我们们定义一个类CircularQueSeq, 其内容和之前我们定义的类CircularQueLk差不多，只不过将类的成员变量mutex换成atomic类型的原子变量, 我们可以利用自旋锁的思路将锁替换为原子变量循环检测的方式，进而达到锁住互斥逻辑的效果。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">size_t</span> Cap&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CircularQueSeq</span> :<span class="keyword">private</span> std::allocator&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CircularQueSeq</span>() :_max_size(Cap + <span class="number">1</span>), _data(std::allocator&lt;T&gt;::<span class="built_in">allocate</span>(_max_size)), _atomic_using(<span class="literal">false</span>),_head(<span class="number">0</span>), _tail(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">CircularQueSeq</span>(<span class="type">const</span> CircularQueSeq&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    CircularQueSeq&amp; <span class="keyword">operator</span> = (<span class="type">const</span> CircularQueSeq&amp;) <span class="keyword">volatile</span> = <span class="keyword">delete</span>;</span><br><span class="line">    CircularQueSeq&amp; <span class="keyword">operator</span> = (<span class="type">const</span> CircularQueSeq&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    ~<span class="built_in">CircularQueSeq</span>() &#123;</span><br><span class="line">        <span class="comment">//循环销毁</span></span><br><span class="line">        <span class="type">bool</span> use_expected = <span class="literal">false</span>;</span><br><span class="line">        <span class="type">bool</span> use_desired = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            use_expected = <span class="literal">false</span>;</span><br><span class="line">            use_desired = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!_atomic_using.<span class="built_in">compare_exchange_strong</span>(use_expected, use_desired));</span><br><span class="line">        <span class="comment">//调用内部元素的析构函数</span></span><br><span class="line">        <span class="keyword">while</span> (_head != _tail) &#123;</span><br><span class="line">            std::allocator&lt;T&gt;::<span class="built_in">destroy</span>(_data + _head);</span><br><span class="line">            _head = （_head<span class="number">+1</span>）% _max_size;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调用回收操作</span></span><br><span class="line">        std::allocator&lt;T&gt;::<span class="built_in">deallocate</span>(_data, _max_size);</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            use_expected = <span class="literal">true</span>;</span><br><span class="line">            use_desired = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!_atomic_using.<span class="built_in">compare_exchange_strong</span>(use_expected, use_desired));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//先实现一个可变参数列表版本的插入函数最为基准函数</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...Args&gt;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">emplace</span><span class="params">(Args &amp;&amp; ... args)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> use_expected = <span class="literal">false</span>;</span><br><span class="line">        <span class="type">bool</span> use_desired = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            use_expected = <span class="literal">false</span>;</span><br><span class="line">            use_desired = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!_atomic_using.<span class="built_in">compare_exchange_strong</span>(use_expected, use_desired));</span><br><span class="line">        <span class="comment">//判断队列是否满了</span></span><br><span class="line">        <span class="keyword">if</span> ((_tail + <span class="number">1</span>) % _max_size == _head) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;circular que full ! &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">                use_expected = <span class="literal">true</span>;</span><br><span class="line">                use_desired = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!_atomic_using.<span class="built_in">compare_exchange_strong</span>(use_expected, use_desired));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在尾部位置构造一个T类型的对象，构造参数为args...</span></span><br><span class="line">        std::allocator&lt;T&gt;::<span class="built_in">construct</span>(_data + _tail, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">        <span class="comment">//更新尾部元素位置</span></span><br><span class="line">        _tail = (_tail + <span class="number">1</span>) % _max_size;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            use_expected = <span class="literal">true</span>;</span><br><span class="line">            use_desired = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!_atomic_using.<span class="built_in">compare_exchange_strong</span>(use_expected, use_desired));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//push 实现两个版本，一个接受左值引用，一个接受右值引用</span></span><br><span class="line">    <span class="comment">//接受左值引用版本</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp; val)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;called push const T&amp; version&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">emplace</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//接受右值引用版本，当然也可以接受左值引用，T&amp;&amp;为万能引用</span></span><br><span class="line">    <span class="comment">// 但是因为我们实现了const T&amp;</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(T&amp;&amp; val)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;called push T&amp;&amp; version&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">emplace</span>(std::<span class="built_in">move</span>(val));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//出队函数</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(T&amp; val)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> use_expected = <span class="literal">false</span>;</span><br><span class="line">        <span class="type">bool</span> use_desired = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            use_desired = <span class="literal">true</span>;</span><br><span class="line">            use_expected = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!_atomic_using.<span class="built_in">compare_exchange_strong</span>(use_expected, use_desired));</span><br><span class="line">        <span class="comment">//判断头部和尾部指针是否重合，如果重合则队列为空</span></span><br><span class="line">        <span class="keyword">if</span> (_head == _tail) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;circular que empty ! &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">                use_expected = <span class="literal">true</span>;</span><br><span class="line">                use_desired = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!_atomic_using.<span class="built_in">compare_exchange_strong</span>(use_expected, use_desired));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//取出头部指针指向的数据</span></span><br><span class="line">        val = std::<span class="built_in">move</span>(_data[_head]);</span><br><span class="line">        <span class="comment">//更新头部指针</span></span><br><span class="line">        _head = (_head + <span class="number">1</span>) % _max_size;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            use_expected = <span class="literal">true</span>;</span><br><span class="line">            use_desired = <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">while</span> (!_atomic_using.<span class="built_in">compare_exchange_strong</span>(use_expected, use_desired));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">size_t</span> _max_size;</span><br><span class="line">    T* _data;</span><br><span class="line">    std::atomic&lt;<span class="type">bool</span>&gt; _atomic_using;</span><br><span class="line">    <span class="type">size_t</span> _head = <span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> _tail = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>原子变量为false 才能进函数执行逻辑</li>
<li>多线程情况下也能保证安全是因为原子变量循环检测保证有且只有一个线程修改成功。读取也是这样。</li>
</ul>
<h4 id="单一原子变量的弊端"><a href="#单一原子变量的弊端" class="headerlink" title="单一原子变量的弊端"></a>单一原子变量的弊端</h4><ul>
<li><p>我们考虑上述单一原子变量的弊端</p>
</li>
<li><p>多个线程push和pop操作耦合读太高，同一时刻仅有一个线程pop或者push，而且互斥逻辑的精度不够。影响效率。</p>
</li>
<li><p>我们需要考虑将pop和push操作解耦，我们采用的是环形队列，将tail和head作为原子变量可以实现精细控制。</p>
</li>
<li><p>比如我们做push操作的时候，一个线程更新完tail标签和数据后，其他线程就可以pop或者push了，精细控制的好处就是效率提升。</p>
</li>
<li><p>我们定义一个新的类CircularQueLight，类的基本数据结构和CircularQueSeq差不多。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">size_t</span> Cap&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CircularQueLight</span>: <span class="keyword">private</span> std::allocator&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CircularQueLight</span>():_max_size(Cap + <span class="number">1</span>),</span><br><span class="line">    _data(std::allocator&lt;T&gt;::<span class="built_in">allocate</span>(_max_size))</span><br><span class="line">    , _head(<span class="number">0</span>), _tail(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">CircularQueLight</span>(<span class="type">const</span> CircularQueLight&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    CircularQueLight&amp; <span class="keyword">operator</span> = (<span class="type">const</span> CircularQueLight&amp;) <span class="keyword">volatile</span> = <span class="keyword">delete</span>;</span><br><span class="line">    CircularQueLight&amp; <span class="keyword">operator</span> = (<span class="type">const</span> CircularQueLight&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(T&amp; val)</span> </span>&#123;</span><br><span class="line">            <span class="type">size_t</span> h;</span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">                h = _head.<span class="built_in">load</span>();  <span class="comment">//1 处</span></span><br><span class="line">                <span class="comment">//判断头部和尾部指针是否重合，如果重合则队列为空</span></span><br><span class="line">                <span class="keyword">if</span>(h == _tail.<span class="built_in">load</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                val = _data[h]; <span class="comment">// 2处</span></span><br><span class="line">            &#125; <span class="keyword">while</span> (!_head.<span class="built_in">compare_exchange_strong</span>(h, </span><br><span class="line">                (h<span class="number">+1</span>)% _max_size)); <span class="comment">//3 处</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">size_t</span> _max_size;</span><br><span class="line">    T* _data;</span><br><span class="line">    std::atomic&lt;<span class="type">size_t</span>&gt;  _head;</span><br><span class="line">    std::atomic&lt;<span class="type">size_t</span>&gt; _tail;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>在pop逻辑里我们在1处load获取头部head的值，在2处采用了复制的方式将头部元素取出赋值给val，而不是通过std::move，因为多个线程同时pop最后只有一个线程成功执行3处代码退出，而失败的则需要继续循环，从更新后的head处pop元素。所以不能用std::move，否则会破坏原有的队列数据。</p>
</li>
<li><p>接下来看看push的逻辑</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(T&amp; val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">size_t</span> t;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            t = _tail.<span class="built_in">load</span>(); <span class="comment">//1</span></span><br><span class="line">            <span class="comment">//判断队列是否满</span></span><br><span class="line">            <span class="keyword">if</span>( (t<span class="number">+1</span>)%_max_size == _head.<span class="built_in">load</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            _data[t] = val; <span class="comment">//2</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (!_tail.<span class="built_in">compare_exchange_strong</span>(t,</span><br><span class="line">            (t + <span class="number">1</span>) % _max_size)); <span class="comment">//3</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>这样会存在危险，push函数的逻辑乍一看和pop一样，但是我们会发现多线程push的情况存在线程安全问题。</p>
</li>
<li><p>比如我们线程1 push(1) 而线程2 push(2). 很有可能的顺序是</p>
</li>
<li><p>1.1 -&gt; 1.2 -&gt; 2.1 -&gt; 2.2 -&gt; 1.3</p>
</li>
<li><p>这样我们看到的效果就是_data[t]被存储为2了，而实际情况应该是被存储为1，因为线程1的原子变量生效，而线程2的原子变量不满足需继续循环。所以_data[t]必须修改为1.</p>
</li>
<li><p>那我们改进一下push的函数</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(T&amp; val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">size_t</span> t;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            t = _tail.<span class="built_in">load</span>();  <span class="comment">//1</span></span><br><span class="line">            <span class="comment">//判断队列是否满</span></span><br><span class="line">            <span class="keyword">if</span>( (t<span class="number">+1</span>)%_max_size == _head.<span class="built_in">load</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!_tail.<span class="built_in">compare_exchange_strong</span>(t,</span><br><span class="line">            (t + <span class="number">1</span>) % _max_size));  <span class="comment">//3</span></span><br><span class="line">        _data[t] = val; <span class="comment">//2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这样可能还会有安全问题，因为你可能一个线程执行到2处，还没来得及更新，另一个线程就开始执行pop操作了，会使得pop出一个未更新的值</li>
<li>为了解决这个问题，我们可以增加另一个原子变量<strong>_tail_update</strong>来标记尾部数据是否修改完成，如果尾部数据没有修改完成，此时其他线程pop时获取的数据就是不安全的，所以pop要返回false。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp; val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">size_t</span> t;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            t = _tail.<span class="built_in">load</span>();  <span class="comment">//1</span></span><br><span class="line">            <span class="comment">//判断队列是否满</span></span><br><span class="line">            <span class="keyword">if</span>( (t<span class="number">+1</span>)%_max_size == _head.<span class="built_in">load</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!_tail.<span class="built_in">compare_exchange_strong</span>(t,</span><br><span class="line">            (t + <span class="number">1</span>) % _max_size));  <span class="comment">//3</span></span><br><span class="line">        _data[t] = val; <span class="comment">//2</span></span><br><span class="line">        <span class="type">size_t</span> tailup;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            tailup = t;</span><br><span class="line">        &#125; <span class="keyword">while</span> (_tail_update.<span class="built_in">compare_exchange_strong</span>(tailup, </span><br><span class="line">            (tailup + <span class="number">1</span>) % _max_size));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(T&amp; val)</span> </span>&#123;</span><br><span class="line">        <span class="type">size_t</span> h;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            h = _head.<span class="built_in">load</span>();  <span class="comment">//1 处</span></span><br><span class="line">            <span class="comment">//判断头部和尾部指针是否重合，如果重合则队列为空</span></span><br><span class="line">            <span class="keyword">if</span>(h == _tail.<span class="built_in">load</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断如果此时要读取的数据和tail_update是否一致，如果一致说明尾部数据未更新完</span></span><br><span class="line">            <span class="keyword">if</span>(h == _tail_update.<span class="built_in">load</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            val = _data[h]; <span class="comment">// 2处</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (!_head.<span class="built_in">compare_exchange_strong</span>(h, </span><br><span class="line">            (h<span class="number">+1</span>)% _max_size)); <span class="comment">//3 处</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>pop版本也是，先判断队列是否为空，再判断h是否和_tail_update的值相等，如果相等说明有写数据的没更新完，直接返回false或者循环等待也行，为了方便我们直接返回false即可。</p>
</li>
<li><p>因为我们知道原子操作默认采用的是memory_order_seq_cst内存顺序，性能上不是最优的，我们可以用acquire和release的内存顺序实现同步的效果。</p>
</li>
<li>**这样的改动就相当于使用了3个指针，一个指针指向头，一个指向尾，另一个为修改数据后的下一个位置，（也就是说在这个指针之前的位置都是修改好的，这个指针指向的位置是正在被修改）如果一个线程想要读取一个未被修改的值，会被卡住</li>
</ul>
<h4 id="优化性能"><a href="#优化性能" class="headerlink" title="优化性能"></a>优化性能</h4><ul>
<li>我们用acquire和release模型优化上述代码，实现同步。</li>
<li><p>最简单的方式就是将load的地方变为memory_order_relaxed，compare_exchange_strong的地方变为memory_order_release</p>
</li>
<li><p>我们先看pop操作</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(T&amp; val)</span> </span>&#123;</span><br><span class="line">      <span class="type">size_t</span> h;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">          h = _head.<span class="built_in">load</span>(std::memory_order_relaxed);  <span class="comment">//1 处</span></span><br><span class="line">          <span class="comment">//判断头部和尾部指针是否重合，如果重合则队列为空</span></span><br><span class="line">          <span class="keyword">if</span> (h == _tail.<span class="built_in">load</span>(std::memory_order_acquire)) <span class="comment">//2处</span></span><br><span class="line">          &#123;</span><br><span class="line">              std::cout &lt;&lt; <span class="string">&quot;circular que empty ! &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//判断如果此时要读取的数据和tail_update是否一致，如果一致说明尾部数据未更新完</span></span><br><span class="line">          <span class="keyword">if</span> (h == _tail_update.<span class="built_in">load</span>(std::memory_order_acquire)) <span class="comment">//3处</span></span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          val = _data[h]; <span class="comment">// 2处</span></span><br><span class="line">      &#125; <span class="keyword">while</span> (!_head.<span class="built_in">compare_exchange_strong</span>(h,</span><br><span class="line">          (h + <span class="number">1</span>) % _max_size, std::memory_order_release, std::memory_order_relaxed)); <span class="comment">//4 处</span></span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;pop data success, data is &quot;</span> &lt;&lt; val &lt;&lt; std::endl;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>1 处为memory_order_relaxed是因为即使多个线程pop，每个线程获取的head可能不及时，这个没关系，因为我们有4处的while来重试。</p>
</li>
<li><p>2 compare_exchange_strong操作，在期望的条件匹配时采用memory_order_release, 期望的条件不匹配时memory_order_relaxed可以提升效率，毕竟还是要重试的。</p>
</li>
<li><p>再看push操作</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">size_t</span> t;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        t = _tail.<span class="built_in">load</span>(std::memory_order_relaxed);  <span class="comment">//5</span></span><br><span class="line">        <span class="comment">//判断队列是否满</span></span><br><span class="line">        <span class="keyword">if</span> ((t + <span class="number">1</span>) % _max_size == _head.<span class="built_in">load</span>(std::memory_order_acquire))</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;circular que full ! &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!_tail.<span class="built_in">compare_exchange_strong</span>(t,</span><br><span class="line">        (t + <span class="number">1</span>) % _max_size, std::memory_order_release, std::memory_order_relaxed));  <span class="comment">//6</span></span><br><span class="line">    _data[t] = val; </span><br><span class="line">    <span class="type">size_t</span> tailup;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        tailup = t;</span><br><span class="line">    &#125; <span class="keyword">while</span> (_tail_update.<span class="built_in">compare_exchange_strong</span>(tailup,</span><br><span class="line">        (tailup + <span class="number">1</span>) % _max_size, std::memory_order_release, std::memory_order_relaxed)); <span class="comment">//7</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;called push data success &quot;</span> &lt;&lt; val &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>两个线程协同工作，一个线程先push，另一个线程后pop，那么对于tail部分和_tail_update，我们要保证push的结果_data[t] = val;先于pop的结果val = _data[h];</p>
</li>
<li><p>所以push线程中对于_tail_update的compare_exchange_strong操作采用memory_order_release方式。</p>
</li>
<li><p>pop线程对于_tail_update的load操作采用memory_order_acquire。</p>
</li>
<li><p>如果一个线程先pop，另一个线程先push，那么对于head部分，我们要保证pop的结果val = _data[h];先于pop的结果_data[t] = val;。</p>
</li>
</ul>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><ul>
<li><p>优势</p>
</li>
<li><p>无锁高并发. 虽然存在循环重试, 但是这只会在相同操作并发的时候出现. push 不会因为与 pop 并发而重试, 反之亦然.</p>
</li>
<li><p>缺陷</p>
</li>
<li><p>这样队列只应该存储标量, 如果存储类对象时，多个push线程只有一个线程push成功，而拷贝复制的开销很大，其他线程会循环重试，每次重试都会有开销。</p>
</li>
</ul>
<h2 id="利用栅栏实现同步模型"><a href="#利用栅栏实现同步模型" class="headerlink" title="利用栅栏实现同步模型"></a>利用栅栏实现同步模型</h2><h3 id="线程可见顺序"><a href="#线程可见顺序" class="headerlink" title="线程可见顺序"></a>线程可见顺序</h3><ul>
<li><p>我们提到过除了memory_order_seq_cst顺序，其他的顺序都不能保证原子变量修改的值在其他多线程中看到的顺序是一致的。</p>
</li>
<li><p>但是可以通过同步机制保证一个线程对原子变量的修改对另一个原子变量可见。通过“Syncronizes With” 的方式达到先行的效果。</p>
</li>
<li><p>但是我们说的先行是指 “A Syncronizes With B ”， 如果A 的结果被B读取，则A 先行于B。</p>
</li>
<li><p>有时候我们线程1对A的store操作采用release内存序，而线程2对B的load采用acquire内存序，并不能保证A 一定比 B先执行。因为两个线程并行执行无法确定先后顺序，我们指的先行不过是说如果B读取了A操作的结果，则称A先行于B</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; x, y;</span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; z;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_x</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_release); <span class="comment">//1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_y</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    y.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_release); <span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_x_then_y</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!x.<span class="built_in">load</span>(std::memory_order_acquire));</span><br><span class="line">    <span class="keyword">if</span> (y.<span class="built_in">load</span>(std::memory_order_acquire))   <span class="comment">//3</span></span><br><span class="line">        ++z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_y_then_x</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!y.<span class="built_in">load</span>(std::memory_order_acquire));</span><br><span class="line">    <span class="keyword">if</span> (x.<span class="built_in">load</span>(std::memory_order_acquire))   <span class="comment">//4</span></span><br><span class="line">        ++z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>我们写一个函数测试，函数TestAR中初始化x和y为false， 启动4个线程a,b,c,d，分别执行write_x, write_y, read_x_then_y, read_y_then_x.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestAR</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x = <span class="literal">false</span>;</span><br><span class="line">    y = <span class="literal">false</span>;</span><br><span class="line">    z = <span class="number">0</span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">a</span><span class="params">(write_x)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">b</span><span class="params">(write_y)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">c</span><span class="params">(read_x_then_y)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">d</span><span class="params">(read_y_then_x)</span></span>;</span><br><span class="line">    a.<span class="built_in">join</span>();</span><br><span class="line">    b.<span class="built_in">join</span>();</span><br><span class="line">    c.<span class="built_in">join</span>();</span><br><span class="line">    d.<span class="built_in">join</span>();</span><br><span class="line">    <span class="built_in">assert</span>(z.<span class="built_in">load</span>() != <span class="number">0</span>); <span class="comment">//5</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;z value is &quot;</span> &lt;&lt; z.<span class="built_in">load</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>有的读者可能会觉5处的断言不会被触发，他们认为c和d肯定会有一个线程对z执行++操作。他们的思路是这样的。 1 如果c线程执行read_x_then_y没有对z执行加加操作，那么说明c线程读取的x值为true, y值为false。 2 之后d线程读取时，如果保证执行到4处说明y为true，等d线程执行4处代码时x必然为true。 3 他们的理解是如果x先被store为true，y后被store为true，c线程看到y为false时x已经为true了，那么d线程y为true时x也早就为true了，所以z一定会执行加加操作。</p>
</li>
<li><p>上述理解是不正确的，我们提到过即便是releas和acquire顺序也不能保证多个线程看到的一个变量的值是一致的，更不能保证看到的多个变量的值是一致的。</p>
</li>
<li><p>变量x和y的载入操作3和4有可能都读取false值（与宽松次序的情况一样），因此有可能令断言触发错误。变量x和y分别由不同线程写出，所以两个释放操作都不会影响到对方线程。</p>
</li>
<li><p>看下图</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/并发编程/image-17.png" alt="示例图片" style="zoom:100%;" /></p>
<ul>
<li><p>无论x和y的store顺序谁先谁后，线程c和线程d读取的x和y顺序都不一定一致。</p>
</li>
<li><p>从CPU的角度我们可以这么理解</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/并发编程/image-18.png" alt="示例图片" style="zoom:100%;" /></p>
<ul>
<li><p>在一个4核CPU结构的主机上，a,b,c,d分别运行在不同的CPU内核上。</p>
</li>
<li><p>a执行x.store(true)先被线程c读取，而此时线程b对y的store还没有被c读取到新的值，所以此时c读取的x为true，y为false。</p>
</li>
<li><p>同样的道理，d可以读取b修改y的最新值，但是没来的及读取x的最新值，那么读取到y为true，x为false。</p>
</li>
<li><p>即使我们采用release和acquire方式也不能保证全局顺序一致。如果一个线程对变量执行release内存序的store操作，另一个线程不一定会马上读取到。这个大家要理解。</p>
</li>
</ul>
<h2 id="栅栏"><a href="#栅栏" class="headerlink" title="栅栏"></a>栅栏</h2><ul>
<li><p>有时候我们可以通过栅栏保证指令编排顺序。</p>
</li>
<li><p>看下面一段代码</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; x,y;</span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; z;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_x_then_y</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x.<span class="built_in">store</span>(<span class="literal">true</span>,std::memory_order_relaxed); <span class="comment">// 1</span></span><br><span class="line">    y.<span class="built_in">store</span>(<span class="literal">true</span>,std::memory_order_relaxed);   <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_y_then_x</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!y.<span class="built_in">load</span>(std::memory_order_relaxed));  <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">if</span>(x.<span class="built_in">load</span>(std::memory_order_relaxed))  <span class="comment">// 4</span></span><br><span class="line">        ++z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="literal">false</span>;</span><br><span class="line">    y=<span class="literal">false</span>;</span><br><span class="line">    z=<span class="number">0</span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">a</span><span class="params">(write_x_then_y)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">b</span><span class="params">(read_y_then_x)</span></span>;</span><br><span class="line">    a.<span class="built_in">join</span>();</span><br><span class="line">    b.<span class="built_in">join</span>();</span><br><span class="line">    <span class="built_in">assert</span>(z.<span class="built_in">load</span>()!=<span class="number">0</span>);  <span class="comment">//5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>上面的代码我们都采用的是memory_order_relaxed, 所以无法保证a线程将x,y修改后b线程看到的也是先修改x，再修改y的值。b线程可能先看到y被修改为true，x后被修改为true，那么b线程执行到4处时x可能为false导致z不会加加，5处断言会被触发。</p>
</li>
<li><p>那我们之前做法可以解决这个问题</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_x_then_y3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_relaxed); <span class="comment">// 1</span></span><br><span class="line">    y.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_release);   <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_y_then_x3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!y.<span class="built_in">load</span>(std::memory_order_acquire));  <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">if</span> (x.<span class="built_in">load</span>(std::memory_order_relaxed))  <span class="comment">// 4</span></span><br><span class="line">        ++z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>可以通过std::memory_order_release和std::memory_order_acquire形成同步关系。</p>
</li>
<li><p>线程a执行write_x_then_y3，线程b执行read_y_then_x3，如果线程b执行到4处，说明y已经被线程a设置为true。</p>
</li>
<li><p>线程a执行到2，也必然执行了1，因为是memory_order_release的内存顺序，所以线程a能2操作之前的指令在2之前被写入内存。</p>
</li>
<li><p>同样的道理，线程b在3处执行的是memory_order_acquire的内存顺序，所以能保证4不会先于3写入内存，这样我们能知道1一定先行于4.</p>
</li>
<li><p>进而推断出z会加加，所以不会触发assert(z.load() != 0);的断言。</p>
</li>
<li><p>其实我们可以通过栅栏机制保证指令的写入顺序。栅栏的机制和memory_order_release类似。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_x_then_y_fence</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_relaxed);  <span class="comment">//1</span></span><br><span class="line">    std::<span class="built_in">atomic_thread_fence</span>(std::memory_order_release);  <span class="comment">//2</span></span><br><span class="line">    y.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_relaxed);  <span class="comment">//3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_y_then_x_fence</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!y.<span class="built_in">load</span>(std::memory_order_relaxed));  <span class="comment">//4</span></span><br><span class="line">    std::<span class="built_in">atomic_thread_fence</span>(std::memory_order_acquire); <span class="comment">//5</span></span><br><span class="line">    <span class="keyword">if</span> (x.<span class="built_in">load</span>(std::memory_order_relaxed))  <span class="comment">//6</span></span><br><span class="line">        ++z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>测试</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestFence</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x = <span class="literal">false</span>;</span><br><span class="line">    y = <span class="literal">false</span>;</span><br><span class="line">    z = <span class="number">0</span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">a</span><span class="params">(write_x_then_y_fence)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">b</span><span class="params">(read_y_then_x_fence)</span></span>;</span><br><span class="line">    a.<span class="built_in">join</span>();</span><br><span class="line">    b.<span class="built_in">join</span>();</span><br><span class="line">    <span class="built_in">assert</span>(z.<span class="built_in">load</span>() != <span class="number">0</span>);   <span class="comment">//7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>处的断言也不会触发。我们可以分析一下，</p>
</li>
<li><p>线程a运行write_x_then_y_fence，线程b运行read_y_then_x_fence.</p>
</li>
<li><p>当线程b执行到5处时说明4已经结束，此时线程a看到y为true，那么线程a必然已经执行完3.</p>
</li>
<li><p>尽管4和3我们采用的是std::memory_order_relaxed顺序，但是通过逻辑关系保证了3的结果同步给4，进而”3 happens-before 4”</p>
</li>
<li><p>因为我们采用了栅栏std::atomic_fence所以，5处能保证6不会先于5写入内存，(memory_order_acquire保证其后的指令不会先于其写入内存)</p>
</li>
<li><p>2处能保证1处的指令先于2写入内存，进而”1 happens-before 6”, 1的结果会同步给 6</p>
</li>
<li><p>所以”atomic_thread_fence”其实和”release-acquire”相似，都是保证memory_order_release之前的指令不会排到其后，memory_order_acquire之后的指令不会排到其之前。</p>
</li>
</ul>
<h2 id="基于锁是新鲜线程安全队列与栈"><a href="#基于锁是新鲜线程安全队列与栈" class="headerlink" title="基于锁是新鲜线程安全队列与栈"></a>基于锁是新鲜线程安全队列与栈</h2><h3 id="线程安全的栈"><a href="#线程安全的栈" class="headerlink" title="线程安全的栈"></a>线程安全的栈</h3><ul>
<li>实现一个线程安全的栈，我们能想到的是基于锁控制push和pop操作，比如下面的逻辑</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">empty_stack</span> : std::exception</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">what</span><span class="params">()</span> <span class="type">const</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadsafe_stack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::stack&lt;T&gt; data;</span><br><span class="line">    <span class="keyword">mutable</span> std::mutex m;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">threadsafe_stack</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">threadsafe_stack</span>(<span class="type">const</span> threadsafe_stack&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(other.m)</span></span>;</span><br><span class="line">        data = other.data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    threadsafe_stack&amp; <span class="keyword">operator</span>=(<span class="type">const</span> threadsafe_stack&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        data.<span class="built_in">push</span>(std::<span class="built_in">move</span>(new_value));    <span class="comment">// ⇽-- - 1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (data.<span class="built_in">empty</span>()) <span class="keyword">throw</span> <span class="built_in">empty_stack</span>();  <span class="comment">//  ⇽-- - 2</span></span><br><span class="line">            <span class="function">std::shared_ptr&lt;T&gt; <span class="type">const</span> <span class="title">res</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">                std::make_shared&lt;T&gt;(std::move(data.top())))</span></span>;   <span class="comment">// ⇽-- - 3</span></span><br><span class="line">            data.<span class="built_in">pop</span>();   <span class="comment">// ⇽-- - 4</span></span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(T&amp; value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (data.<span class="built_in">empty</span>()) <span class="keyword">throw</span> <span class="built_in">empty_stack</span>();</span><br><span class="line">        value = std::<span class="built_in">move</span>(data.<span class="built_in">top</span>());   <span class="comment">// ⇽-- - 5</span></span><br><span class="line">            data.<span class="built_in">pop</span>();   <span class="comment">// ⇽-- - 6</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> data.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>我们实现了push操作和pop操作</p>
</li>
<li><p>push操作里加锁，然后将数据通过std::move的方式移动放入stack中。我们思考如果1处因为机器内存不足push导致异常，此种情况并不会对栈已有的数据产生危险。<br>但是vector容器大家要考虑，因为vector存在内存不足时将数据拷贝转移到新空间的过程。那么对于vector这种动态扩容的容器该如何保证容器内数据在移动过程中出现了异常仍能不丢失呢？</p>
</li>
<li><p>我想到的一个方式就是管理vector的capacity，每次push的时候要判断一下vector的size和capacity是否相等，如果相等则手动扩容并将数据转移到新的vector，再释放旧有的vector。</p>
</li>
<li><p>但是同样会存在一个问题就是会造成内存溢出，因为vector的capacity会随着数据增加而增加，当vector中没有数据的时候capacity仍然很大。这种方式也可以通过swap的方式将当前大容量的vector和一个空的vector做交换，快速清空内存。这些操作和思路需结合实际开发情况而定。</p>
</li>
<li><p>pop提供了两个版本，一个是返回智能指针一个是返回bool类型，这两种我们分析，比如3处和4处也很可能因为内存不足导致构造智能指针失败，或者5处赋值失败，这种情况下抛出异常并不会影响栈内数据，因为程序没走到4和6处就抛出异常了。</p>
</li>
<li><p>pop函数内部判断栈是否空，如果为空则抛出异常，这种情况我们不能接受，异常是用来处理和预判突发情况的，对于一个栈为空这种常见现象，仅需根据返回之后判断为空再做尝试或放弃出栈即可。</p>
</li>
<li><p>为了解决栈为空就抛出异常的问题，我们可以做如下优化</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>  T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadsafe_stack_waitable</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::stack&lt;T&gt; data;</span><br><span class="line">    <span class="keyword">mutable</span> std::mutex m;</span><br><span class="line">    std::condition_variable cv;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">threadsafe_stack_waitable</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">threadsafe_stack_waitable</span>(<span class="type">const</span> threadsafe_stack_waitable&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(other.m)</span></span>;</span><br><span class="line">        data = other.data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    threadsafe_stack_waitable&amp; <span class="keyword">operator</span>=(<span class="type">const</span> threadsafe_stack_waitable&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        data.<span class="built_in">push</span>(std::<span class="built_in">move</span>(new_value));    <span class="comment">// ⇽-- - 1</span></span><br><span class="line">        cv.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">wait_and_pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]()   </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(data.<span class="built_in">empty</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;); <span class="comment">//  ⇽-- - 2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function">std::shared_ptr&lt;T&gt; <span class="type">const</span> <span class="title">res</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            std::make_shared&lt;T&gt;(std::move(data.top())))</span></span>;   <span class="comment">// ⇽-- - 3</span></span><br><span class="line">        data.<span class="built_in">pop</span>();   <span class="comment">// ⇽-- - 4</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wait_and_pop</span><span class="params">(T&amp; value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]()</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (data.<span class="built_in">empty</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        value = std::<span class="built_in">move</span>(data.<span class="built_in">top</span>());   <span class="comment">// ⇽-- - 5</span></span><br><span class="line">        data.<span class="built_in">pop</span>();   <span class="comment">// ⇽-- - 6</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> data.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">try_pop</span><span class="params">(T&amp; value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(data.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        value = std::<span class="built_in">move</span>(data.<span class="built_in">top</span>());</span><br><span class="line">        data.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">try_pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(data.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;T&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::shared_ptr&lt;T&gt; <span class="title">res</span><span class="params">(std::make_shared&lt;T&gt;(std::move(data.top())))</span></span>;</span><br><span class="line">        data.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>我们将pop优化为四个版本，四个版本又可以分为两个大类，两个大类分别为try_pop版本和wait_and_pop版本。</p>
</li>
<li><p>try_pop版本不阻塞等待队列有数据才返回，而是直接返回，try_pop又有两个版本，分别返回bool值和指针值。如果队列为空返回false或者空指针。</p>
</li>
<li><p>wait_and_pop版本阻塞等待队列有数据才返回，同样有两个版本，分别返回bool值和指针值。</p>
</li>
<li><p>但是上面的代码我们分析，假设此时栈为空，有一个线程A从队列中消费数据，调用wait_and_pop挂起, 此时另一个线程B向栈中放入数据调用push操作，notify一个线程消费队列中的数据。</p>
</li>
<li><p>此时A从wait_and_pop唤醒，但是在执行3或者5处时，因为内存不足引发了异常，我们之前分析过，即使引发异常也不会影响到栈内数据，所以对于栈的数据来说是安全的，但是线程A异常后，其他线程无法从队列中消费数据，除非线程B再执行一次push。因为我们采用的是notify_one的方式，所以仅有一个线程被激活，如果被激活的线程异常了，就不能保证该数据被其他线程消费了，解决这个问题，可以采用几个方案。</p>
<ol>
<li>wai_and_pop失败的线程修复后再次取一次数据。</li>
<li>将notify_one改为notify_all，这样能保证通知所有线程。但是notify_all将导致所有线程竞争，并不可取。</li>
<li>我们可以通过栈存储智能指针的方式进行，因为智能指针在赋值的时候不会引发异常。</li>
</ol>
</li>
<li><p>稍后我们提供的线程安全队列的版本使用的就是第三种优化。</p>
</li>
</ul>
<h3 id="线程安全队列"><a href="#线程安全队列" class="headerlink" title="线程安全队列"></a>线程安全队列</h3><ul>
<li>队列和栈最大的不同就是队列为先入先出，有了线程安全的栈的开发思路，我们很快实现一个支持线程安全的队列</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadsafe_queue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mutable</span> std::mutex mut;</span><br><span class="line">    std::queue&lt;T&gt; data_queue;</span><br><span class="line">    std::condition_variable data_cond;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">threadsafe_queue</span>()</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">        data_queue.<span class="built_in">push</span>(std::<span class="built_in">move</span>(new_value));</span><br><span class="line">        data_cond.<span class="built_in">notify_one</span>();    <span class="comment">//⇽-- - ①</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wait_and_pop</span><span class="params">(T&amp; value)</span>    <span class="comment">//⇽-- - ②</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">        data_cond.<span class="built_in">wait</span>(lk, [<span class="keyword">this</span>] &#123;<span class="keyword">return</span> !data_queue.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line">        value = std::<span class="built_in">move</span>(data_queue.<span class="built_in">front</span>());</span><br><span class="line">        data_queue.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">wait_and_pop</span><span class="params">()</span>   <span class="comment">// ⇽-- - ③</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">        data_cond.<span class="built_in">wait</span>(lk, [<span class="keyword">this</span>] &#123;<span class="keyword">return</span> !data_queue.<span class="built_in">empty</span>(); &#125;);   <span class="comment">// ⇽-- - ④</span></span><br><span class="line">        <span class="function">std::shared_ptr&lt;T&gt; <span class="title">res</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            std::make_shared&lt;T&gt;(std::move(data_queue.front())))</span></span>;</span><br><span class="line">        data_queue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">try_pop</span><span class="params">(T&amp; value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (data_queue.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        value = std::<span class="built_in">move</span>(data_queue.<span class="built_in">front</span>());</span><br><span class="line">        data_queue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">try_pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (data_queue.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;T&gt;();    <span class="comment">//⇽-- - ⑤</span></span><br><span class="line">        <span class="function">std::shared_ptr&lt;T&gt; <span class="title">res</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            std::make_shared&lt;T&gt;(std::move(data_queue.front())))</span></span>;</span><br><span class="line">        data_queue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> data_queue.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>关于异常情况的分析和栈一样，上面的队列版本不存在异常导致数据丢失的问题。但是同样面临线程执行wait_and_pop时如果出现了异常，导致数据被滞留在队列中，其他线程也无法被唤醒的情况。</p>
</li>
<li><p>为了解决这种情况，我们前文提到了采用智能指针的方式，重新实现一下线程安全队列</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadsafe_queue_ptr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> std::mutex mut;</span><br><span class="line">    std::queue&lt;std::shared_ptr&lt;T&gt;&gt; data_queue;</span><br><span class="line">    std::condition_variable data_cond;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">threadsafe_queue_ptr</span>()</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wait_and_pop</span><span class="params">(T&amp; value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">        data_cond.<span class="built_in">wait</span>(lk, [<span class="keyword">this</span>] &#123;<span class="keyword">return</span> !data_queue.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line">        value = std::<span class="built_in">move</span>(*data_queue.<span class="built_in">front</span>());    <span class="comment">//⇽-- - 1</span></span><br><span class="line">            data_queue.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">try_pop</span><span class="params">(T&amp; value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (data_queue.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        value = std::<span class="built_in">move</span>(*data_queue.<span class="built_in">front</span>());   <span class="comment">// ⇽-- - 2</span></span><br><span class="line">            data_queue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">wait_and_pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">        data_cond.<span class="built_in">wait</span>(lk, [<span class="keyword">this</span>] &#123;<span class="keyword">return</span> !data_queue.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line">        std::shared_ptr&lt;T&gt; res = data_queue.<span class="built_in">front</span>();   <span class="comment">// ⇽-- - 3</span></span><br><span class="line">            data_queue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">try_pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (data_queue.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;T&gt;();</span><br><span class="line">        std::shared_ptr&lt;T&gt; res = data_queue.<span class="built_in">front</span>();   <span class="comment">// ⇽-- - 4</span></span><br><span class="line">            data_queue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::shared_ptr&lt;T&gt; <span class="title">data</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            std::make_shared&lt;T&gt;(std::move(new_value)))</span></span>;   <span class="comment">// ⇽-- - 5</span></span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">        data_queue.<span class="built_in">push</span>(data);</span><br><span class="line">        data_cond.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> data_queue.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>在5处，我们push数据时需要先构造智能指针，如果构造的过程失败了也就不会push到队列中，不会污染队列中的数据。</p>
</li>
<li><p>2，3处和4，5处我们仅仅时将智能指针取出来赋值给一个新的智能指针并返回。关于智能指针的赋值不会引发异常这一点在C++并发编程中提及，这一点我觉得有些存疑，我觉得书中表述的意思应该是指针在64位机器占用8个字节，所有智能指针共享引用计数所以在复制时仅为8字节开销，降低了内存消耗。</p>
</li>
<li><p>所以推荐大家存储数据放入容器中时尽量用智能指针，这样能保证复制和移动过程中开销较小，也可以实现一定意义的数据共享。</p>
</li>
<li><p>但是我们分析上面的代码，队列push和pop时采用的是一个mutex，导致push和pop等操作串行化，我们要考虑的是优化锁的精度，提高并发，那有什么办法吗？</p>
</li>
<li><p>我们分析，队列和栈最本质的区别是队列是首尾操作。我们可以考虑将push和pop操作分化为分别对尾和对首部的操作。对首和尾分别用不同的互斥量管理就可以实现真正意义的并发了。</p>
</li>
<li><p>我们引入虚位节点的概念，表示一个空的节点，没有数据，是一个无效的节点，初始情况下，队列为空，head和tail节点都指向这个虚位节点。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadsafe_queue_ht</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;T&gt; data;</span><br><span class="line">        std::unique_ptr&lt;node&gt; next;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::mutex head_mutex;</span><br><span class="line">    std::unique_ptr&lt;node&gt; head;</span><br><span class="line">    std::mutex tail_mutex;</span><br><span class="line">    node* tail;</span><br><span class="line">    std::condition_variable data_cond;</span><br><span class="line"></span><br><span class="line">    <span class="function">node* <span class="title">get_tail</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">tail_lock</span><span class="params">(tail_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> tail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;node&gt; <span class="title">pop_head</span><span class="params">()</span>   </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::unique_ptr&lt;node&gt; old_head = std::<span class="built_in">move</span>(head);</span><br><span class="line">        head = std::<span class="built_in">move</span>(old_head-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> old_head;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">wait_for_data</span><span class="params">()</span>   </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">head_lock</span><span class="params">(head_mutex)</span></span>;</span><br><span class="line">        data_cond.<span class="built_in">wait</span>(head_lock,[&amp;] &#123;<span class="keyword">return</span> head.<span class="built_in">get</span>() != <span class="built_in">get_tail</span>(); &#125;); <span class="comment">//5</span></span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">move</span>(head_lock);   </span><br><span class="line">    &#125;</span><br><span class="line">        <span class="function">std::unique_ptr&lt;node&gt; <span class="title">wait_pop_head</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">head_lock</span><span class="params">(wait_for_data())</span></span>;   </span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">pop_head</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">std::unique_ptr&lt;node&gt; <span class="title">wait_pop_head</span><span class="params">(T&amp; value)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">head_lock</span><span class="params">(wait_for_data())</span></span>;  </span><br><span class="line">                value = std::<span class="built_in">move</span>(*head-&gt;data);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">pop_head</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function">std::unique_ptr&lt;node&gt; <span class="title">try_pop_head</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">head_lock</span><span class="params">(head_mutex)</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (head.<span class="built_in">get</span>() == <span class="built_in">get_tail</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> std::<span class="built_in">unique_ptr</span>&lt;node&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">pop_head</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">std::unique_ptr&lt;node&gt; <span class="title">try_pop_head</span><span class="params">(T&amp; value)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">head_lock</span><span class="params">(head_mutex)</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (head.<span class="built_in">get</span>() == <span class="built_in">get_tail</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> std::<span class="built_in">unique_ptr</span>&lt;node&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            value = std::<span class="built_in">move</span>(*head-&gt;data);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">pop_head</span>();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">threadsafe_queue_ht</span>() :  <span class="comment">// ⇽-- - 1</span></span><br><span class="line">        <span class="built_in">head</span>(<span class="keyword">new</span> node), <span class="built_in">tail</span>(head.<span class="built_in">get</span>())</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">threadsafe_queue_ht</span>(<span class="type">const</span> threadsafe_queue_ht&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    threadsafe_queue_ht&amp; <span class="keyword">operator</span>=(<span class="type">const</span> threadsafe_queue_ht&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">wait_and_pop</span><span class="params">()</span> <span class="comment">//  &lt;------3</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::unique_ptr&lt;node&gt; <span class="type">const</span> old_head = <span class="built_in">wait_pop_head</span>();</span><br><span class="line">        <span class="keyword">return</span> old_head-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wait_and_pop</span><span class="params">(T&amp; value)</span>  <span class="comment">//  &lt;------4</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::unique_ptr&lt;node&gt; <span class="type">const</span> old_head = <span class="built_in">wait_pop_head</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">try_pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::unique_ptr&lt;node&gt; old_head = <span class="built_in">try_pop_head</span>();</span><br><span class="line">        <span class="keyword">return</span> old_head ? old_head-&gt;data : std::<span class="built_in">shared_ptr</span>&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">try_pop</span><span class="params">(T&amp; value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::unique_ptr&lt;node&gt; <span class="type">const</span> old_head = <span class="built_in">try_pop_head</span>(value);</span><br><span class="line">        <span class="keyword">return</span> old_head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">head_lock</span><span class="params">(head_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> (head.<span class="built_in">get</span>() == <span class="built_in">get_tail</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T new_value)</span>  <span class="comment">//&lt;------2</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::shared_ptr&lt;T&gt; <span class="title">new_data</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            std::make_shared&lt;T&gt;(std::move(new_value)))</span></span>;</span><br><span class="line">        <span class="function">std::unique_ptr&lt;node&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> node)</span></span>;</span><br><span class="line">        node* <span class="type">const</span> new_tail = p.<span class="built_in">get</span>();</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">tail_lock</span><span class="params">(tail_mutex)</span></span>;</span><br><span class="line">        tail-&gt;data = new_data;</span><br><span class="line">        tail-&gt;next = std::<span class="built_in">move</span>(p);</span><br><span class="line">        tail = new_tail;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>node为节点类型，包含data和next两个成员。 data为智能指针类型存储T类型的数据。next为指向下一个节点的智能指针，以此形成链表。</p>
</li>
<li><p>上述代码我们的head是一个node类型的智能指针。而tail为node类型的普通指针，读者也可以用智能指针。</p>
</li>
<li><p>在1处构造函数那里，我们将head和tail初始指向的位置设置为虚位节点。</p>
</li>
<li><p>在2 处我们push数据的时候先构造T类型的智能指针存储数据new_data，然后我们构造了一个新的智能指针p, p取出裸指针就是新的虚位节点new_tail，我们将new_data赋值给现在的尾节点，并且让尾节点的next指针指向p, 然后将tail更新为我们新的虚位节点。</p>
</li>
<li><p>3，4处都是wait_and_pop的不同版本，内部调用了wait_pop_head，wait_pop_head内部先调用wait_for_data判断队列是否为空，这里判断是否为空主要是判断head是否指向虚位节点。如果不为空则返回unique_lock，我们显示的调用了move操作，返回unique_lock仍保留对互斥量的锁住状态。</p>
</li>
<li><p>回到wait_pop_head中，接下来执行pop_head将数据pop出来。</p>
</li>
<li><p>值得注意的是get_tail()返回tail节点，那么我们思考如果此时有多个线程push数据，tail节点已经变化了，我们此时在5处的判断可能是基于push之前的tail信息，但是不影响逻辑，因为如果head和tail相等则线程挂起，等待通知，如果不等则继续执行，push操作只会将tail向后移动不会导致逻辑问题。</p>
</li>
<li><p>pop_head中我们将head节点移动给一个old_head变量，然后将old_head的next节点更新为新的head。这里我觉得可以简化写为head=head-&gt;next.</p>
</li>
</ul>
<h2 id="实现线程安全的查找表"><a href="#实现线程安全的查找表" class="headerlink" title="实现线程安全的查找表"></a>实现线程安全的查找表</h2><h3 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h3><p>散列表（Hash table，也叫哈希表），是根据键（Key）而直接访问在存储器存储位置的数据结构。 也就是说，它通过计算出一个键值的函数，将所需查询的数据映射到表中一个位置来让人访问，这加快了查找速度。 这个映射函数称做散列函数，存放记录的数组称做散列表。</p>
<h3 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h3><ul>
<li><p>我们要实现上述逻辑，可以考虑将11，12，13等hash值放入一个vector中。多线程根据key计算得出hash值的过程并不需要加锁，可以实现并行计算。</p>
</li>
<li><p>但是对于链表的增删改查需要加锁。</p>
</li>
<li><p>所以我们考虑将链表封装为一个类bucket_type,支持数据的增删改查。</p>
</li>
<li><p>我们将整体的查找表封装为threadsafe_lookup_table类，实现散列规则和调度bucket_type类。</p>
</li>
</ul>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><ul>
<li>我们先实现内部的bucket_type类. 为了threadsafe_lookup_table可以访问他，所以将threadsafe_lookup_table设置为其友元类</li>
<li>接下来我们设计threadsafe_lookup_table类。我们用一个vector存储上面的bucket_type类型。 因为我们要计算hash值，key可能是多种类型string, int等，所以我们采用std的hash算法作为散列函数即可.</li>
<li><p>get_bucket函数不需要加锁，各个线程可以并行计算哈希值，取出key对应的桶。如果多线程调用同一个bucket的增删改查，就通过bucket内部的互斥解决线程安全问题。 接下来我们完善threadsafe_lookup_table的对外接口</p>
</li>
<li><p>查找表头文件</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;shared_mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value, <span class="keyword">typename</span> Hash = std::hash&lt;Key&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> threadsafe_lockup_table &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">class</span> bucket_type &#123;</span><br><span class="line">		<span class="keyword">friend</span> <span class="keyword">class</span> threadsafe_lockup_table;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">typedef</span> std::pair&lt;Key, Value&gt; bucket_value;</span><br><span class="line">		<span class="keyword">typedef</span> std::list&lt;bucket_value&gt; bucket_data;</span><br><span class="line">		<span class="comment">// 在模板中指定类型的时候要加typename</span></span><br><span class="line">		<span class="keyword">typedef</span> <span class="keyword">typename</span> bucket_data::iterator bucket_iterator;</span><br><span class="line">		bucket_data data;</span><br><span class="line">		<span class="keyword">mutable</span> std::shared_mutex mutex;</span><br><span class="line"></span><br><span class="line">		<span class="function">bucket_iterator <span class="title">find_entry_for</span><span class="params">(<span class="type">const</span> Key&amp; key)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> std::<span class="built_in">find_if</span>(data.<span class="built_in">begin</span>(), data.<span class="built_in">end</span>(), [&amp;](<span class="type">const</span> bucket_value&amp; item) &#123;</span><br><span class="line">				<span class="keyword">return</span> item.first == key;</span><br><span class="line">				&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="comment">//查找key值，找到返回对应的value，没有找到返回提供的默认值</span></span><br><span class="line">		<span class="function">Value <span class="title">value_for</span><span class="params">(<span class="type">const</span> Key&amp; key, <span class="type">const</span> Value&amp; default_value)</span> </span>&#123;</span><br><span class="line">			<span class="function">std::shared_lock&lt;std::shared_mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line">			bucket_iterator <span class="type">const</span> found_entry = <span class="built_in">find_entry_for</span>(key);</span><br><span class="line">			<span class="keyword">return</span> (found_entry == data.<span class="built_in">end</span>()) ? default_value: found_entry-&gt;second;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//添加key和value，找到更新，没找到就添加</span></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">add_or_update_mapping</span><span class="params">(<span class="type">const</span> Key&amp; key, <span class="type">const</span> Value&amp; value)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">auto</span> found_entry = <span class="built_in">find_entry_for</span>(key);</span><br><span class="line">			<span class="keyword">if</span> (found_entry == data.<span class="built_in">end</span>()) &#123;</span><br><span class="line">				data.<span class="built_in">push_back</span>(<span class="built_in">bucket_value</span>(key, value));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				found_entry-&gt;second = value;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//删除对应的key</span></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">remove_mapping</span><span class="params">(Key <span class="type">const</span>&amp; key)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="function">std::unique_lock&lt;std::shared_mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line">			bucket_iterator <span class="type">const</span> found_entry = <span class="built_in">find_entry_for</span>(key);</span><br><span class="line">			<span class="keyword">if</span> (found_entry != data.<span class="built_in">end</span>())</span><br><span class="line">			&#123;</span><br><span class="line">				data.<span class="built_in">erase</span>(found_entry);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//用vector存储桶类型</span></span><br><span class="line">	std::vector&lt;std::unique_ptr&lt;bucket_type&gt;&gt; buckets;</span><br><span class="line">	<span class="comment">//hash&lt;Key&gt; 哈希表 用来根据key生成哈希值</span></span><br><span class="line">	Hash hasher;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//根据key生成数字，并对桶的大小取余得到下标，根据下标返回对应的桶智能指针</span></span><br><span class="line">	<span class="function">bucket_type&amp; <span class="title">get_bucket</span><span class="params">(Key <span class="type">const</span>&amp; key)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::<span class="type">size_t</span> <span class="type">const</span> bucket_index = <span class="built_in">hasher</span>(key) % buckets.<span class="built_in">size</span>();</span><br><span class="line">		<span class="keyword">return</span> *buckets[bucket_index];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">threadsafe_lockup_table</span>(<span class="type">unsigned</span> num_buckets = <span class="number">19</span>, Hash <span class="type">const</span>&amp; hasher_ = <span class="built_in">Hash</span>()) :</span><br><span class="line">		<span class="built_in">buckets</span>(num_buckets), <span class="built_in">hasher</span>(hasher_)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; num_buckets; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//让智能指针转绑定</span></span><br><span class="line">			buckets[i].<span class="built_in">reset</span>(<span class="keyword">new</span> bucket_type);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">threadsafe_lockup_table</span>(threadsafe_lockup_table <span class="type">const</span>&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">	threadsafe_lockup_table&amp; <span class="keyword">operator</span>=(threadsafe_lockup_table <span class="type">const</span>&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Value() 就是用构造函数构造一个默认值，这是查找算法</span></span><br><span class="line">	<span class="function">Value <span class="title">value_for</span><span class="params">(Key <span class="type">const</span>&amp; key,Value <span class="type">const</span>&amp; default_value = Value())</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">get_bucket</span>(key).<span class="built_in">value_for</span>(key, default_value);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">add_or_update_mapping</span><span class="params">(Key <span class="type">const</span>&amp; key, Value <span class="type">const</span>&amp; value)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">get_bucket</span>(key).<span class="built_in">add_or_update_mapping</span>(key, value);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">remove_mapping</span><span class="params">(Key <span class="type">const</span>&amp; key)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">get_bucket</span>(key).<span class="built_in">remove_mapping</span>(key);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">std::map&lt;Key, Value&gt; <span class="title">get_map</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//对所有的桶都加锁</span></span><br><span class="line">		std::vector&lt;std::unique_lock&lt;std::shared_mutex&gt;&gt; locks;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; buckets.<span class="built_in">size</span>(); ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			locks.<span class="built_in">push_back</span>(std::<span class="built_in">unique_lock</span>&lt;std::shared_mutex&gt;(buckets[i]-&gt;mutex));</span><br><span class="line">		&#125;</span><br><span class="line">		std::map&lt;Key, Value&gt; res;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; buckets.<span class="built_in">size</span>(); ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//需用typename告诉编译器bucket_type::bucket_iterator是一个类型，以后再实例化</span></span><br><span class="line">			<span class="comment">//当然此处可简写成auto it = buckets[i]-&gt;data.begin();</span></span><br><span class="line">			<span class="keyword">typename</span> bucket_type::bucket_iterator it = buckets[i]-&gt;data.<span class="built_in">begin</span>();</span><br><span class="line">			<span class="keyword">for</span> (; it != buckets[i]-&gt;data.<span class="built_in">end</span>(); ++it)</span><br><span class="line">			&#123;</span><br><span class="line">				res.<span class="built_in">insert</span>(*it);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>自定义类型</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> i):_data(i)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span> &lt;&lt; (std::ostream&amp; os, <span class="type">const</span> MyClass&amp; mc)&#123;</span><br><span class="line">        os &lt;&lt; mc._data;</span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>测试函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyClass.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ThreadSafeLockupTable.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestThreadSafeHash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; removeSet;</span><br><span class="line">    threadsafe_lockup_table&lt;<span class="type">int</span>, std::shared_ptr&lt;MyClass&gt;&gt; table;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span></span></span><br><span class="line"><span class="params"><span class="function">        &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">auto</span> class_ptr = std::make_shared&lt;MyClass&gt;(i);</span></span></span><br><span class="line"><span class="params"><span class="function">            table.add_or_update_mapping(i, class_ptr);</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; )</span></span></span><br><span class="line"><span class="params"><span class="function">        &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">auto</span> find_res = table.value_for(i, <span class="literal">nullptr</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">if</span> (find_res)</span></span></span><br><span class="line"><span class="params"><span class="function">            &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                table.remove_mapping(i);</span></span></span><br><span class="line"><span class="params"><span class="function">                removeSet.insert(i);</span></span></span><br><span class="line"><span class="params"><span class="function">                i++;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">            std::this_thread::sleep_for(std::chrono::milliseconds(<span class="number">10</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t3</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">100</span>; i &lt; <span class="number">200</span>; i++)</span></span></span><br><span class="line"><span class="params"><span class="function">        &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">auto</span> class_ptr = std::make_shared&lt;MyClass&gt;(i);</span></span></span><br><span class="line"><span class="params"><span class="function">            table.add_or_update_mapping(i, class_ptr);</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">3.</span><span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : removeSet)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;remove data is &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> copy_map = table.<span class="built_in">get_map</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : copy_map)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;copy data is &quot;</span> &lt;&lt; *(i.second) &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">TestThreadSafeHash</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现线程安全链表"><a href="#实现线程安全链表" class="headerlink" title="实现线程安全链表"></a>实现线程安全链表</h2><ul>
<li><p>如果做一个支持多线程并发访问的链表，我们首先想到的是用一个互斥量控制整个链表，达到多线程访问时串行的效果。但是这么做精度不够，需要分化互斥量的功能。我们想到的一个办法就是每个节点都维护一个互斥量，这样能保证多个线程操作不同节点时加不同的锁，减少耦合性。</p>
</li>
<li><p>另外我们将head独立为一个虚节点，所谓虚节点就是不存储数据，只做头部标记。我们每次从头部插入只需要修将新的节点的next指针指向原来head的next指向的节点，再将head的next指针指向新的节点</p>
</li>
</ul>
<h2 id="线程间切分任务的方法"><a href="#线程间切分任务的方法" class="headerlink" title="线程间切分任务的方法"></a>线程间切分任务的方法</h2><h3 id="按数量切分"><a href="#按数量切分" class="headerlink" title="按数量切分"></a>按数量切分</h3><ul>
<li>对于大量处理的数据，可以按照任务数量区分，简单来说如果我们要处理n个任务，总计有m个线程，那么我们可以简单的规划每个线程处理n/m个任务。</li>
</ul>
<h2 id="线程池原理和实现"><a href="#线程池原理和实现" class="headerlink" title="线程池原理和实现"></a>线程池原理和实现</h2></article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>C++并发编程</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://pigcanstudy.github.io/posts/e8e79e61.html">https://pigcanstudy.github.io/posts/e8e79e61.html</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>PigCanStudy</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2024-07-18</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2024-07-18</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/"><div class="tags-punctuation"><svg class="faa-tada icon" style="height:1.1em;width:1.1em;fill:currentColor;position:relative;top:2px;margin-right:3px" aria-hidden="true"><use xlink:href="#icon-sekuaibiaoqian"></use></svg></div>C++</a><a class="post-meta__tags" href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"><div class="tags-punctuation"><svg class="faa-tada icon" style="height:1.1em;width:1.1em;fill:currentColor;position:relative;top:2px;margin-right:3px" aria-hidden="true"><use xlink:href="#icon-sekuaibiaoqian"></use></svg></div>并发编程</a></div></div><link rel="stylesheet" href="/css/coin.css" media="defer" onload="this.media='all'"/><div class="post-reward"><button class="tip-button reward-button"><span class="tip-button__text">投喂作者</span><div class="coin-wrapper"><div class="coin"><div class="coin__middle"></div><div class="coin__back"></div><div class="coin__front"></div></div></div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://tuchuang.voooe.cn/images/2023/01/04/2.webp" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://tuchuang.voooe.cn/images/2023/01/04/2.webp" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://tuchuang.voooe.cn/images/2023/01/04/20f8e49805975b8f8.webp" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://tuchuang.voooe.cn/images/2023/01/04/20f8e49805975b8f8.webp" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></button></div><audio id="coinAudio" src="https://npm.elemecdn.com/akilar-candyassets@1.0.36/audio/aowu.m4a"></audio><script defer="defer" src="/js/coin.js"></script><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/6e928d8a.html"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_14.webp" onerror="onerror=null;src='/assets/r2.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">C++Qt</div></div></a></div><div class="next-post pull-right"><a href="/posts/2f7ff9a3.html"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_14.webp" onerror="onerror=null;src='/assets/r2.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">C++面试笔记</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/9724705.html" title="C++asio网络编程"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_14.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-07-18</div><div class="title">C++asio网络编程</div></div></a></div><div><a href="/posts/6e928d8a.html" title="C++Qt"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_14.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-07-18</div><div class="title">C++Qt</div></div></a></div><div><a href="/posts/2f7ff9a3.html" title="C++面试笔记"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_14.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-07-18</div><div class="title">C++面试笔记</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><svg class="meta_icon" style="width:22px;height:22px;position:relative;top:5px"><use xlink:href="#icon-mulu1"></use></svg><span style="font-weight:bold">目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95"><span class="toc-text">目录</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-text">线程基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8F%91%E8%B5%B7"><span class="toc-text">线程的发起</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%BE%85"><span class="toc-text">线程等待</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%8F%AF%E4%BB%A5%E8%B0%83%E7%94%A8%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-text">线程可以调用的参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="toc-text">调用函数对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BD%93%E4%BD%9C%E5%85%B6%E5%8F%82%E6%95%B0"><span class="toc-text">使用lambda表达式当作其参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E6%9D%A5%E5%BD%93%E4%BD%9C%E5%8F%82%E6%95%B0"><span class="toc-text">使用成员函数指针来当作参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E5%BD%93%E5%85%B6%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E5%9C%A8%E5%90%8E%E9%9D%A2%E5%8A%A0%E5%85%A5%E5%AF%B9%E5%BA%94%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-text">注意当其调用函数有参数的时候需要在后面加入对应的参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8Bdetach"><span class="toc-text">线程detach</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95"><span class="toc-text">解决办法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-text">异常处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%85%8E%E7%94%A8%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="toc-text">慎用隐式转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0"><span class="toc-text">引用参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFstd-ref%EF%BC%9F"><span class="toc-text">什么是std::ref？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#std-ref-%E5%92%8C%E4%B8%8D%E5%90%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">std::ref 和不同引用的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8move%E6%93%8D%E4%BD%9C"><span class="toc-text">使用move操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%BA%95%E5%B1%82%E5%81%9A%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-text">线程底层做的处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E7%BA%BF%E7%A8%8B%E7%AE%A1%E6%8E%A7"><span class="toc-text">C++线程管控</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%BD%92%E5%B1%9E%E6%9D%83"><span class="toc-text">线程归属权</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#joining-thread"><span class="toc-text">joining_thread</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%AD%98%E5%82%A8"><span class="toc-text">容器存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E8%BF%90%E8%A1%8C%E6%95%B0%E9%87%8F"><span class="toc-text">选择运行数量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%86%E5%88%AB%E7%BA%BF%E7%A8%8B"><span class="toc-text">识别线程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E5%92%8C%E6%AD%BB%E9%94%81"><span class="toc-text">互斥和死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">锁的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lock-guard%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">lock_guard的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8"><span class="toc-text">如何保证数据安全</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E7%9A%84%E5%8A%9E%E6%B3%95"><span class="toc-text">解决的办法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E6%98%AF%E6%80%8E%E4%B9%88%E9%80%A0%E6%88%90%E7%9A%84"><span class="toc-text">死锁是怎么造成的</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95"><span class="toc-text">死锁解决办法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%97%B6%E5%8A%A0%E9%94%81"><span class="toc-text">同时加锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#thread-local"><span class="toc-text">thread_local</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%82%E7%BA%A7%E5%8A%A0%E9%94%81"><span class="toc-text">层级加锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-unique-lock%EF%BC%8C%E5%85%B1%E4%BA%AB%E9%94%81%E5%92%8C%E9%80%92%E5%BD%92%E9%94%81"><span class="toc-text">C++unique_lock，共享锁和递归锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#unique-lock"><span class="toc-text">unique_lock</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#unique-lock%E7%9A%84owns-lock%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%8C%81%E6%9C%89%E9%94%81"><span class="toc-text">unique_lock的owns_lock判断是否持有锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unique-lock%E7%9A%84%E5%BB%B6%E8%BF%9F%E5%8A%A0%E9%94%81defer-lock"><span class="toc-text">unique_lock的延迟加锁defer_lock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unique-lock%E7%9A%84%E9%A2%86%E5%85%BB%E5%8A%A0%E9%94%81"><span class="toc-text">unique_lock的领养加锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E7%B2%92%E5%BA%A6"><span class="toc-text">锁的粒度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E9%94%81shared-lock%E4%BB%A5%E5%8F%8Ashared-mutex"><span class="toc-text">共享锁shared_lock以及shared_mutex</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E9%94%81"><span class="toc-text">递归锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%BC%94%E5%8F%98"><span class="toc-text">C++线程安全单例模式的演变</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="toc-text">局部静态变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A5%BF%E6%B1%89%E4%B8%8E%E6%87%92%E6%B1%89%E5%BC%8F%EF%BC%8C%E8%AF%A6%E6%83%85%E7%9C%8B%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0"><span class="toc-text">饿汉与懒汉式，详情看面试笔记</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-text">智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B9%E8%BF%9B%E6%96%B9%E6%A1%88"><span class="toc-text">改进方案</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#call-once"><span class="toc-text">call_once</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%931"><span class="toc-text">总结1</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-11%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-text">C++11多线程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8future%E4%B8%8Epromise"><span class="toc-text">使用future与promise</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E6%9D%A5%E5%AE%9E%E7%8E%B0%E5%90%8C%E6%AD%A5"><span class="toc-text">使用条件变量来实现同步</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%98%9F%E5%88%97"><span class="toc-text">利用条件变量实现线程安全队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E8%89%AF%E5%AE%9E%E7%8E%B0"><span class="toc-text">不良实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-text">条件变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%AE%89%E5%85%A8%E9%98%9F%E5%88%97"><span class="toc-text">实现安全队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%B8%89%E5%89%91%E5%AE%A2async-promise-future"><span class="toc-text">并发三剑客async,promise,future</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#async%E7%94%A8%E6%B3%95"><span class="toc-text">async用法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#async%E7%9A%84%E5%90%AF%E5%8A%A8%E7%AD%96%E7%95%A5"><span class="toc-text">async的启动策略</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#future%E7%9A%84wait%E5%92%8Cget"><span class="toc-text">future的wait和get</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86%E4%BB%BB%E5%8A%A1%E5%92%8Cfuture%E5%85%B3%E8%81%94%EF%BC%88paskaged-task%EF%BC%89"><span class="toc-text">将任务和future关联（paskaged_task）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#promise%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-text">promise的用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E7%B1%BB%E5%9E%8B%E7%9A%84future"><span class="toc-text">共享类型的future</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%861"><span class="toc-text">异常处理1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">线程池</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E5%B9%B6%E5%8F%91%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">两种并发设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Actor%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">Actor设计模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSP%E6%A8%A1%E5%BC%8F"><span class="toc-text">CSP模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#thread-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E5%8F%8A%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="toc-text">thread 源码解读及一些常见问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0"><span class="toc-text">默认移动构造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%BD%92%E5%B1%9E%E6%9D%83%E9%97%AE%E9%A2%98"><span class="toc-text">线程归属权问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#future-%E6%9E%90%E6%9E%84%E7%9A%84%E7%BB%86%E8%8A%82"><span class="toc-text">future 析构的细节</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E5%92%8C%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-text">原子操作和内存模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%B9%E5%8A%A8%E5%BA%8F%E5%88%97"><span class="toc-text">改动序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E7%B1%BB%E5%9E%8B"><span class="toc-text">原子类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%AC%A1%E5%BA%8F"><span class="toc-text">内存次序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-text">实现自旋锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%BD%E6%9D%BE%E5%86%85%E5%AD%98%E5%BA%8F"><span class="toc-text">宽松内存序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%88%E8%A1%8C"><span class="toc-text">先行</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%85%88%E8%A1%8C"><span class="toc-text">顺序先行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%85%88%E8%A1%8C"><span class="toc-text">线程间先行</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB"><span class="toc-text">依赖关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Happens-before%E4%B8%8D%E4%BB%A3%E8%A1%A8%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-text">Happens-before不代表指令执行顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%84%91%E5%9B%BE"><span class="toc-text">脑图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E5%86%85%E5%AD%98%E9%A1%BA%E5%BA%8F%E5%AE%9E%E7%8E%B0%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-text">用内存顺序实现内存模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#memory-order-seq-cst"><span class="toc-text">memory_order_seq_cst</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#memory-order-relaxed"><span class="toc-text">memory_order_relaxed</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Acquire-Release"><span class="toc-text">Acquire-Release</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Release-sequences"><span class="toc-text">Release sequences</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#memory-order-consume"><span class="toc-text">memory_order_consume</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%9E%8B%E6%94%B9%E8%89%AF"><span class="toc-text">单例模型改良</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E5%86%85%E5%AD%98%E9%A1%BA%E5%BA%8F%E5%92%8C%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F%E5%AE%9E%E7%8E%B0%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97"><span class="toc-text">用内存顺序和原子变量实现无锁队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97"><span class="toc-text">环形队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E9%94%81%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97"><span class="toc-text">用锁实现环形队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97"><span class="toc-text">无锁队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%B8%80%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F%E7%9A%84%E5%BC%8A%E7%AB%AF"><span class="toc-text">单一原子变量的弊端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E6%80%A7%E8%83%BD"><span class="toc-text">优化性能</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%80%83"><span class="toc-text">思考</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%A0%85%E6%A0%8F%E5%AE%9E%E7%8E%B0%E5%90%8C%E6%AD%A5%E6%A8%A1%E5%9E%8B"><span class="toc-text">利用栅栏实现同步模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%8F%AF%E8%A7%81%E9%A1%BA%E5%BA%8F"><span class="toc-text">线程可见顺序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%85%E6%A0%8F"><span class="toc-text">栅栏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E9%94%81%E6%98%AF%E6%96%B0%E9%B2%9C%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%98%9F%E5%88%97%E4%B8%8E%E6%A0%88"><span class="toc-text">基于锁是新鲜线程安全队列与栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E6%A0%88"><span class="toc-text">线程安全的栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%98%9F%E5%88%97"><span class="toc-text">线程安全队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E6%9F%A5%E6%89%BE%E8%A1%A8"><span class="toc-text">实现线程安全的查找表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%A3%E5%88%97%E8%A1%A8"><span class="toc-text">散列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF"><span class="toc-text">设计思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%93%BE%E8%A1%A8"><span class="toc-text">实现线程安全链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%88%87%E5%88%86%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">线程间切分任务的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E6%95%B0%E9%87%8F%E5%88%87%E5%88%86"><span class="toc-text">按数量切分</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="toc-text">线程池原理和实现</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-color: transparent;"><div id="footer-wrap"><div id="ft"><div class="ft-item-1"><div class="t-top"><div class="t-t-l"><p class="ft-t t-l-t">格言🧬</p><div class="bg-ad"><div>再看看那个光点，它就在这里，这是家园，这是我们 —— 你所爱的每一个人，你认识的一个人，你听说过的每一个人，曾经有过的每一个人，都在它上面度过他们的一生✨</div><div class="btn-xz-box"><a class="btn-xz" target="_blank" rel="noopener" href="https://stellarium.org/">点击开启星辰之旅</a></div></div></div><div class="t-t-r"><p class="ft-t t-l-t">猜你想看💡</p><ul class="ft-links"><li><a href="/posts/eec9786.html">魔改指南</a><a href="/box/nav/">网址导航</a></li><li><a href="/social/link/">我的朋友</a><a href="/comments/">留点什么</a></li><li><a href="/personal/about/">关于作者</a><a href="/archives/">文章归档</a></li><li><a href="/categories/">文章分类</a><a href="/tags/">文章标签</a></li><li><a href="/box/Gallery/">我的画廊</a><a href="/personal/bb/">我的唠叨</a></li><li><a href="/site/time/">建设进程</a><a href="/site/census/">网站统计</a></li></ul></div></div></div><div class="ft-item-2"><p class="ft-t">推荐友链⌛</p><div class="ft-img-group"><div class="img-group-item"><a target="_blank" rel="noopener" href="https://www.fomal.cc/" title="Fomalhaut🥝"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/60e5d4e39da7c077.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div></div></div></div><div class="copyright"><span><b>&copy;2022-2024</b></span><span><b>&nbsp;&nbsp;By PigCanStudy</b></span></div><div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" title="博客框架为Hexo_v6.3.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Frame-Hexo-blue.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" title="主题版本Butterfly_v4.3.1"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Theme-Butterfly-6513df.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" title="本站采用多线部署，主线路托管于Vercel"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Hosted-Vercel-brightgreen.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://user.51.la/" style="margin-inline:5px" title="本站数据分析得益于51la技术支持"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Analytics-51la-3db1eb.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://icp.gov.moe/?keyword=20226665" style="margin-inline:5px" title="本站已加入萌ICP豪华套餐，萌ICP备20226665号"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/萌ICP备-20226665-fe1384.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://bitiful.dogecast.com/buckets" style="margin-inline:5px" title="本网站经Service Worker分流至缤纷云对象存储"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src=" https://sourcebucket.s3.ladydaily.com/badge/Bucket-缤纷云-9c62da.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://www.netdun.net/" style="margin-inline:5px" title="本站使用网盾星球提供CDN加速与防护"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/CDN-网盾星球-fff2cc.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" title="本网站源码由Github提供存储仓库"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src=" https://sourcebucket.s3.ladydaily.com/badge/Source-Github-d021d6.svg" alt=""/></a></p></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button class="share" type="button" title="右键模式" onclick="changeMouseMode()"><i class="fas fa-mouse"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog right_side"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button class="share" type="button" title="分享链接" onclick="share()"><i class="fas fa-share-nodes"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i><span id="percent">0<span>%</span></span></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();"><i class="fa fa-copy"></i><span>复制</span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.baidu.com/s?wd=&quot;+window.getSelection().toString());window.location.reload();"><i class="fa fa-search"></i><span>百度搜索</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();"><i class="fa fa-link"></i><span>转到链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()"><i class="fa fa-copy"></i><span>粘贴</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-post"><a class="rightMenu-item" href="#post-comment"><i class="fas fa-comment"></i><span>空降评论</span></a><a class="rightMenu-item" href="javascript:rmf.copyWordsLink()"><i class="fa fa-link"></i><span>复制本文地址</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>新窗口打开</span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()"><i class="fa fa-link"></i><span>转到链接</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()"><i class="fa fa-download"></i><span>保存图片</span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>在新窗口打开</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制图片链接</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:randomPost()"><i class="fa fa-paper-plane"></i><span>随便逛逛</span></a><a class="rightMenu-item" href="javascript:switchNightMode();"><i class="fa fa-moon"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="/personal/about/"><i class="fa fa-info-circle"></i><span>关于博客</span></a><a class="rightMenu-item" href="javascript:toggleWinbox();"><i class="fas fa-cog"></i><span>美化设置</span></a><a class="rightMenu-item" href="javascript:rmf.fullScreen();"><i class="fas fa-expand"></i><span>切换全屏</span></a><a class="rightMenu-item" href="javascript:window.print();"><i class="fa-solid fa-print"></i><span>打印页面</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.umd.min.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/instant.page/5.1.0/instantpage.min.js" type="module"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/vanilla-lazyload/17.3.1/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><script async="async">var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())
setTimeout(function(){preloader.endLoading();}, 5000);
document.getElementById('loading-box').addEventListener('click',()=> {preloader.endLoading()})</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: '',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: '',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.staticfile.org/twikoo/1.6.8/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script src="https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js"></script><script async src="https://cdn1.tianli0.top/npm/vue@2.6.14/dist/vue.min.js"></script><script async src="https://cdn1.tianli0.top/npm/element-ui@2.15.6/lib/index.js"></script><script async src="https://cdn.bootcdn.net/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script><script defer type="text/javascript" src="https://cdn1.tianli0.top/npm/sweetalert2@8.19.0/dist/sweetalert2.all.js"></script><script async src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><script defer src="https://cdn1.tianli0.top/gh/nextapps-de/winbox/dist/winbox.bundle.min.js"></script><script async src="//at.alicdn.com/t/c/font_3586335_hsivh70x0fm.js"></script><script async src="//at.alicdn.com/t/c/font_3636804_gr02jmjr3y9.js"></script><script async src="//at.alicdn.com/t/c/font_3612150_kfv55xn3u2g.js"></script><script async src="https://cdn.wpon.cn/2022-sucai/Gold-ingot.js"></script><canvas id="universe"></canvas><canvas id="snow"></canvas><script defer src="/js/fomal.js"></script><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.js"></script><script src="https://cdn1.tianli0.top/npm/js-heo@1.0.12/metingjs/Meting.min.js"></script><script src="https://lib.baomitu.com/pjax/0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show","#web_bg",".js-pjax","#bibi","body > title","#app","#tag-echarts","#posts-echart","#categories-echarts"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><a class="magnet_link_more"  href="https://pigcanstudy.github.io/categories/" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(33.333333333333336% - 5px);background: #e9e9e9;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: var(--text-bg-hover)}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/95787e92.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-07-16</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/95787e92.html&quot;);" href="javascript:void(0);" alt="">网络编程教程</a><div class="blog-slider__text">🥧本文介绍了linux基础的系统编程和基础的Linux网络编程</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/95787e92.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/2f7ff9a3.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-07-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/2f7ff9a3.html&quot;);" href="javascript:void(0);" alt="">C++面试笔记</a><div class="blog-slider__text">本文介绍了C++面试笔记的相关知识</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/2f7ff9a3.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/e8e79e61.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-07-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/e8e79e61.html&quot;);" href="javascript:void(0);" alt="">C++并发编程</a><div class="blog-slider__text">本文介绍了C++并发编程的相关知识</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/e8e79e61.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/6e928d8a.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-07-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/6e928d8a.html&quot;);" href="javascript:void(0);" alt="">C++Qt</a><div class="blog-slider__text">本文介绍了C++Qt的相关知识</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/6e928d8a.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/9724705.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-07-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/9724705.html&quot;);" href="javascript:void(0);" alt="">C++asio网络编程</a><div class="blog-slider__text">本文介绍了C++运用asio进行网络编程的相关知识</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/9724705.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><script data-pjax src="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.js"></script><script data-pjax>
  function gitcalendar_injector_config(){
      var parent_div_git = document.getElementById('gitZone');
      var item_html = '<div class="recent-post-item" id="gitcalendarBar" style="width:100%;height:auto;padding:10px;"><style>#git_container{min-height: 320px}@media screen and (max-width:650px) {#git_container{min-height: 0px}}</style><div id="git_loading" style="width:10%;height:100%;margin:0 auto;display: block;"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animatetransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animatetransform></path></svg><style>#git_container{display: none;}</style></div><div id="git_container"></div></div>';
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      console.log('已挂载gitcalendar')
      }

    if( document.getElementById('gitZone') && (location.pathname ==='/site/census/'|| '/site/census/' ==='all')){
        gitcalendar_injector_config()
        GitCalendarInit("/api?null",['#d9e0df', '#c6e0dc', '#a8dcd4', '#9adcd2', '#89ded1', '#77e0d0', '#5fdecb', '#47dcc6', '#39dcc3', '#1fdabe', '#00dab9'],'null')
    }
  </script><!-- hexo injector body_end end --></body></html>