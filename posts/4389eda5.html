<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><div id="myscoll"></div><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>muduo网络库学习 | PigCanStudy</title><meta name="keywords" content="C++,MySQL,算法,代码,博客,Butterfly,Hexo,PigCanStudy"><meta name="author" content="PigCanStudy"><meta name="copyright" content="PigCanStudy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="剖析muduo网络库核心部分、设计思想">
<meta property="og:type" content="article">
<meta property="og:title" content="muduo网络库学习">
<meta property="og:url" content="https://pigcanstudy.github.io/posts/4389eda5.html">
<meta property="og:site_name" content="PigCanStudy">
<meta property="og:description" content="剖析muduo网络库核心部分、设计思想">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://source.fomal.cc/img/default_cover_14.webp">
<meta property="article:published_time" content="2024-07-25T01:43:31.000Z">
<meta property="article:modified_time" content="2024-11-29T09:14:30.740Z">
<meta property="article:author" content="PigCanStudy">
<meta property="article:tag" content="C++,MySQL,算法,代码,博客,Butterfly,Hexo,PigCanStudy">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://source.fomal.cc/img/default_cover_14.webp"><link rel="shortcut icon" href="/"><link rel="canonical" href="https://pigcanstudy.github.io/posts/4389eda5"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/6.0.0/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.js',
      css: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'muduo网络库学习',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-11-29 17:14:30'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/element-ui@2.15.6/packages/theme-chalk/lib/index.css"><style id="themeColor"></style><style id="rightSide"></style><style id="transPercent"></style><style id="blurNum"></style><style id="settingStyle"></style><span id="fps"></span><style id="defineBg"></style><style id="menu_shadow"></style><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="PigCanStudy" type="application/atom+xml">
</head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://tuchuang.voooe.cn/images/2023/01/02/avatar.webp" onerror="onerror=null;src='/assets/r1.jpg'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-home"></use></svg><span class="menu_word" style="font-size:17px"> 首页</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--article"></use></svg><span class="menu_word" style="font-size:17px"> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-guidang1">                   </use></svg><span class="menu_word" style="font-size:17px"> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-sekuaibiaoqian">                   </use></svg><span class="menu_word" style="font-size:17px"> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-fenlei">                   </use></svg><span class="menu_word" style="font-size:17px"> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pinweishenghuo"></use></svg><span class="menu_word" style="font-size:17px"> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/life/music/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-yinle">                   </use></svg><span class="menu_word" style="font-size:17px"> 八音盒</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/movies/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-dianying1">                   </use></svg><span class="menu_word" style="font-size:17px"> 影院</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/games/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-youxishoubing">                   </use></svg><span class="menu_word" style="font-size:17px"> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xiangzi"></use></svg><span class="menu_word" style="font-size:17px"> 八宝箱</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/box/gallery/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-tubiaozhizuomoban">                   </use></svg><span class="menu_word" style="font-size:17px"> 画廊</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/animation/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-nvwumao">                   </use></svg><span class="menu_word" style="font-size:17px"> 动画</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/nav/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-zhifengche">                   </use></svg><span class="menu_word" style="font-size:17px"> 网址导航</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shejiaoxinxi"></use></svg><span class="menu_word" style="font-size:17px"> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/social/fcircle/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pengyouquan">                   </use></svg><span class="menu_word" style="font-size:17px"> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-liuyan">                   </use></svg><span class="menu_word" style="font-size:17px"> 留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/social/link/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-lianjie">                   </use></svg><span class="menu_word" style="font-size:17px"> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-wangye"></use></svg><span class="menu_word" style="font-size:17px"> 网站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/site/census/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--tongjibiao">                   </use></svg><span class="menu_word" style="font-size:17px"> 网站统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/echarts/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shujutongji1">                   </use></svg><span class="menu_word" style="font-size:17px"> 文章统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/time/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xianxingshalou">                   </use></svg><span class="menu_word" style="font-size:17px"> 旧时光</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-maoliang"></use></svg><span class="menu_word" style="font-size:17px"> 个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/personal/bb/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-qunliaotian">                   </use></svg><span class="menu_word" style="font-size:17px"> 唠叨</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/love/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-love-sign">                   </use></svg><span class="menu_word" style="font-size:17px"> 恋爱小屋</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/about/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-paperplane">                   </use></svg><span class="menu_word" style="font-size:17px"> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">PigCanStudy</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-home"></use></svg><span class="menu_word" style="font-size:17px"> 首页</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--article"></use></svg><span class="menu_word" style="font-size:17px"> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-guidang1">                   </use></svg><span class="menu_word" style="font-size:17px"> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-sekuaibiaoqian">                   </use></svg><span class="menu_word" style="font-size:17px"> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-fenlei">                   </use></svg><span class="menu_word" style="font-size:17px"> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pinweishenghuo"></use></svg><span class="menu_word" style="font-size:17px"> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/life/music/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-yinle">                   </use></svg><span class="menu_word" style="font-size:17px"> 八音盒</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/movies/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-dianying1">                   </use></svg><span class="menu_word" style="font-size:17px"> 影院</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/games/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-youxishoubing">                   </use></svg><span class="menu_word" style="font-size:17px"> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xiangzi"></use></svg><span class="menu_word" style="font-size:17px"> 八宝箱</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/box/gallery/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-tubiaozhizuomoban">                   </use></svg><span class="menu_word" style="font-size:17px"> 画廊</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/animation/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-nvwumao">                   </use></svg><span class="menu_word" style="font-size:17px"> 动画</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/nav/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-zhifengche">                   </use></svg><span class="menu_word" style="font-size:17px"> 网址导航</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shejiaoxinxi"></use></svg><span class="menu_word" style="font-size:17px"> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/social/fcircle/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pengyouquan">                   </use></svg><span class="menu_word" style="font-size:17px"> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-liuyan">                   </use></svg><span class="menu_word" style="font-size:17px"> 留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/social/link/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-lianjie">                   </use></svg><span class="menu_word" style="font-size:17px"> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-wangye"></use></svg><span class="menu_word" style="font-size:17px"> 网站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/site/census/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--tongjibiao">                   </use></svg><span class="menu_word" style="font-size:17px"> 网站统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/echarts/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shujutongji1">                   </use></svg><span class="menu_word" style="font-size:17px"> 文章统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/time/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xianxingshalou">                   </use></svg><span class="menu_word" style="font-size:17px"> 旧时光</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-maoliang"></use></svg><span class="menu_word" style="font-size:17px"> 个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/personal/bb/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-qunliaotian">                   </use></svg><span class="menu_word" style="font-size:17px"> 唠叨</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/love/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-love-sign">                   </use></svg><span class="menu_word" style="font-size:17px"> 恋爱小屋</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/about/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-paperplane">                   </use></svg><span class="menu_word" style="font-size:17px"> 关于</span></a></li></ul></div></div><center id="name-container"><a id="page-name" href="javascript:scrollToTop()">PAGE_NAME</a></center><div id="nav-right"><div id="search-button"><a class="search faa-parent animated-hover" title="检索站内任何你想要的信息"><svg class="faa-tada icon" style="height:24px;width:24px;fill:currentColor;position:relative;top:6px" aria-hidden="true"><use xlink:href="#icon-valentine_-search-love-find-heart"></use></svg><span> 搜索</span></a></div><a class="meihua faa-parent animated-hover" onclick="toggleWinbox()" title="美化设置-自定义你的风格" id="meihua-button"><svg class="faa-tada icon" style="height:26px;width:26px;fill:currentColor;position:relative;top:8px" aria-hidden="true"><use xlink:href="#icon-tupian1"></use></svg></a><a class="sun_moon faa-parent animated-hover" onclick="switchNightMode()" title="浅色和深色模式转换" id="nightmode-button"><svg class="faa-tada" style="height:25px;width:25px;fill:currentColor;position:relative;top:7px" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon">       </use></svg></a><div id="toggle-menu"><a><i class="fas fa-bars fa-fw"></i></a></div></div></div></nav><div id="post-info"><h1 class="post-title">muduo网络库学习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><svg class="meta_icon post-meta-icon" style="width:30px;height:30px;position:relative;top:10px"><use xlink:href="#icon-rili"></use></svg><span class="post-meta-label">发表于 </span><time class="post-meta-date-created" datetime="2024-07-25T01:43:31.000Z" title="发表于 2024-07-25 09:43:31">2024-07-25</time><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:18px;height:18px;position:relative;top:5px"><use xlink:href="#icon-gengxin1"></use></svg><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-29T09:14:30.740Z" title="更新于 2024-11-29 17:14:30">2024-11-29</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><svg class="meta_icon post-meta-icon" style="width:25px;height:25px;position:relative;top:8px"><use xlink:href="#icon-charuword"></use></svg><span class="post-meta-label">字数总计:</span><span class="word-count">2w</span><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:20px;height:20px;position:relative;top:5px"><use xlink:href="#icon-shizhong"></use></svg><span class="post-meta-label">阅读时长:</span><span>80分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="muduo网络库学习"><svg class="meta_icon post-meta-icon" style="width:25px;height:25px;position:relative;top:5px"><use xlink:href="#icon-eye"></use></svg><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><ul>
<li><p><a href="#目录">目录</a></p>
<ul>
<li><a href="#Reactor">Reactor</a></li>
<li><p><a href="#muduo库三大核心组件之Channel类">muduo库三大核心组件之Channel类</a></p>
<ul>
<li><a href="#Channel头文件">Channel头文件</a></li>
<li><a href="#Channel实现">Channel实现</a></li>
<li><a href="#重要设计">重要设计</a></li>
</ul>
</li>
<li><a href="#muduo库三大核心组件之EventLoop类">muduo库三大核心组件之EventLoop类</a><ul>
<li><a href="#重要成员变量">重要成员变量</a></li>
<li><a href="#重要成员函数">重要成员函数</a></li>
<li><a href="#其中的巧妙设计">其中的巧妙设计</a></li>
</ul>
</li>
<li><p><a href="#muduo库三大核心组件之 Poller/EpollPoller类">muduo库三大核心组件之 Poller/EpollPoller类</a></p>
<ul>
<li><a href="#重要成员变量">poller/Epollpoller重要成员变量</a></li>
<li><a href="#重要成员函数">poller/Epollpoller重要成员函数</a></li>
</ul>
</li>
<li><a href="#muduo库Acceptor类">muduo库Acceptor类</a><ul>
<li><a href="#Acceptor重要成员变量">Acceptor重要成员变量</a></li>
<li><a href="#Acceptor重要成员函数">Acceptor重要成员函数</a></li>
<li><a href="#比较好的设计">比较好的设计</a></li>
</ul>
</li>
<li><a href="#muduo库Buffer类">muduo库Buffer类</a><ul>
<li><a href="#为什么需要buffer类">为什么需要buffer类?</a></li>
<li><a href="#Buffer设计思想">Buffer设计思想</a></li>
<li><a href="#Buffer重要成员变量">Buffer重要成员变量</a></li>
<li><a href="#Buffer重要成员函数">Buffer重要成员函数</a></li>
<li><a href="#iovec结构体定义">iovec结构体定义</a></li>
</ul>
</li>
<li><p><a href="#muduo库TcpConnection类">muduo库TcpConnection类</a></p>
<ul>
<li><p><a href="#设计思想以及一些感悟">设计思想以及一些感悟</a></p>
</li>
<li><p><a href="#TcpConnection重要成员变量">TcpConnection重要成员变量</a></p>
</li>
<li><a href="#TcpConnection重要成员函数">TcpConnection重要成员函数</a></li>
</ul>
</li>
<li><p><a href="#muduo库TcpServer">muduo库TcpServer</a></p>
<ul>
<li><a href="#TcpServer重要成员变量">TcpServer重要成员变量</a></li>
<li><a href="#TcpServer重要成员函数">TcpServer重要成员函数</a></li>
</ul>
</li>
<li><p><a href="#muduo库Thread类]">muduo库Thread类</a></p>
<ul>
<li><a href="#Thread重要成员变量">Thread重要成员变量</a></li>
<li><a href="#Thread重要成员函数">Thread重要成员函数</a></li>
</ul>
</li>
<li><p><a href="#muduo库EventLoopThread类">muduo库EventLoopThread类</a></p>
<ul>
<li><a href="#EventLoopThread重要成员变量">EventLoopThread重要成员变量</a></li>
<li><a href="#EventLoopThread重要成员函数">EventLoopThread重要成员函数</a></li>
</ul>
</li>
<li><p><a href="#muduo库EventLoopThreadPool类">muduo库EventLoopThreadPool类</a></p>
<ul>
<li><a href="#EventLoopThreadPool重要成员变量">EventLoopThreadPool重要成员变量</a></li>
<li><a href="#EventLoopThreadPool重要成员函数">EventLoopThreadPool重要成员函数</a></li>
</ul>
</li>
<li><a href="#EchoServer之建立">利用muduo库建立一个简单的EchoServer</a></li>
<li><a href="#muduo库中的定时器类">muduo库中的定时器类</a><ul>
<li><a href="#Timer类">Timer类</a><ul>
<li><a href="#Timer重要成员变量">Timer重要成员变量</a></li>
<li><a href="#Timer重要成员函数">Timer重要成员函数</a></li>
<li><a href="#Timer设计思想">Timer设计思想</a></li>
</ul>
</li>
<li><a href="#TimerId类">TimerId类</a><ul>
<li><a href="#TimerId重要成员变量">TimerId重要成员变量</a></li>
</ul>
</li>
<li><a href="#TimerQueue类">TimerQueue类</a><ul>
<li><a href="#TimerQueue重要成员变量">TimerQueue重要成员变量</a></li>
<li><a href="#TimerQueue重要成员函数">TimerQueue重要成员函数</a><ul>
<li><a href="#取消定时器逻辑">取消定时器逻辑</a></li>
<li><a href="#加入定时器逻辑">加入定时器逻辑</a></li>
<li><a href="#处理定时器过期逻辑">处理定时器过期逻辑</a></li>
<li><a href="#"></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="Reactor"><a href="#Reactor" class="headerlink" title="Reactor"></a>Reactor</h1><ul>
<li><p>Muduo库是基于Reactor模式实现的TCP网络编程库。其中的重要组件是由<strong>Event(事件)、Reactor(反应堆)、Demultiplex(事件分发器)和Evanthandler(事件处理器)</strong>四部分构成的，其相互关系如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/2024-07-25-muduo网络库学习/20240725-180441.jpg" alt="image-20240725100624027"></p>
<ul>
<li>首先，将事件Event注册到反应堆Reactor上，即将应用程序感兴趣的事件注册到反应堆上，请求反应堆帮助监听，若事件发生，反应堆调用应用程序预制的回调(handler)，一个event对应一个handler；</li>
<li>反应堆Reactor相当于是一个事件以及事件处理的集合，通过相应的方法在事件分发器Demultiplex里做一个相应的调整（add/mod/del event），然后启动事件循环（epoll_wait），服务器处于阻塞状态等待新用户的连接，或者已连接用户的读写事件；</li>
<li>如果epoll_wait监听到有新事件产生，分发器返回事件给反应堆，反应堆调用相应的事件处理器eventhandler；</li>
<li>eventhandler中读取用户的请求，解码，处理，打包，发送。</li>
</ul>
</li>
<li><p>在muduo库的Reactor模型上：</p>
<ul>
<li>Poller和EPollPoller就是Demultiplex</li>
<li>Channel封装了Event，里面存在fd，events，revents，以及相应的回调函数callbacks，其中有两种channel，acceptorChannel以及connectionChannel分别对应listenfd以及connfd</li>
<li>EventLoop就是Reactor</li>
</ul>
</li>
<li><p>这也就看出<strong>muduo库的三个核心组件是：Channel类、Poller/EpollPoller类以及EventLoop类</strong>这三个组件之间的关系如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/2024-07-25-muduo网络库学习/20240725-180505.jpg" alt="image-20240725101825823"></p>
</li>
</ul>
<h1 id="muduo库三大核心组件之Channel类"><a href="#muduo库三大核心组件之Channel类" class="headerlink" title="muduo库三大核心组件之Channel类"></a>muduo库三大核心组件之Channel类</h1><ul>
<li><strong>Channel</strong>类封装了一个 fd 、fd感兴趣事件events、该fd实际发生的事件revents。同时Channel类还提供了设置该fd的感兴趣事件，以及相应的回调函数。</li>
</ul>
<h2 id="channel头文件"><a href="#channel头文件" class="headerlink" title="channel头文件"></a>channel头文件</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Socket.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">理清楚 EventLoop Channel，Poller之间的关系 他们在Reactor上面对应的Demultiplex</span></span><br><span class="line"><span class="comment">Channel 理解为通道，封装了sockfd和其感兴趣的event，如EPOLLIN  EPOLLOUT事件</span></span><br><span class="line"><span class="comment">还绑定了poller返回的具体事件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EventLoop</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TimeStamp</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个监听端口和一个epoll即为一个channel</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Channel</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> EventCallback = std::function&lt;<span class="built_in">void</span>()&gt;;</span><br><span class="line">    <span class="keyword">using</span> ReadEventCallback = std::function&lt;<span class="built_in">void</span>(TimeStamp)&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Channel</span>(<span class="type">int</span> fd, EventLoop* event_loop);</span><br><span class="line">    <span class="built_in">Channel</span>(<span class="type">const</span> Channel&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Channel&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Channel&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    ~<span class="built_in">Channel</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="comment">//返回fd_</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fd</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 采用边缘触发</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">usetET</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置inepoll成员为true</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setinepoll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置revents成员的值为参数ev</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setrevents</span><span class="params">(<span class="type">uint32_t</span> ev)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 eventsl成员</span></span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">events</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 inepoll成员</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">inepoll</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 revents成员</span></span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">revents</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理epoll_wait返回的事件</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleevent</span><span class="params">(TimeStamp receiveTime)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止当channel被手动remove掉，channel还在执行回调操作时失效</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">tie</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;<span class="type">void</span>&gt;&amp; obj)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置fd相应的状态 update()相当于调用epoll_ctl</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">enableReading</span><span class="params">()</span> </span>&#123; events_ |= kReadEvent; <span class="built_in">update</span>();&#125; <span class="comment">//相当于把读事件给events相应的位置位了</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">disableReading</span><span class="params">()</span> </span>&#123; events_ &amp;= ~kReadEvent; <span class="built_in">update</span>();&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">enableWriting</span><span class="params">()</span> </span>&#123; events_ |= kWriteEvent; <span class="built_in">update</span>();&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">disableWriting</span><span class="params">()</span> </span>&#123; events_ &amp;= ~kWriteEvent; <span class="built_in">update</span>();&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">disableAll</span><span class="params">()</span> </span>&#123; events_ = kNoneEvent; <span class="built_in">update</span>();&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回fd当前的事件状态</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isNoneEvent</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> events_ == kNoneEvent;&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isReadEvent</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> events_ &amp; kReadEvent;&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isWriteEvent</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> events_ &amp; kWriteEvent;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// one loop per thread</span></span><br><span class="line">    <span class="function">EventLoop* <span class="title">onwerLoop</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> event_loop_;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置写事件回调函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setWriteCallBack</span><span class="params">(EventCallback wcb)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置读事件回调函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setReadCallBack</span><span class="params">(ReadEventCallback rcb)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置连接断开回调函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setCloseCallBack</span><span class="params">(EventCallback rcb)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置连接错误回调函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setErrorCallBack</span><span class="params">(EventCallback rcb)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示没有感兴趣的事件</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> kNoneEvent;</span><br><span class="line">    <span class="comment">// 表示感兴趣的是读事件</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> kReadEvent;</span><br><span class="line">    <span class="comment">// 表示感兴趣的是写事件</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> kWriteEvent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleEventWithGuard</span><span class="params">(TimeStamp receiveTime)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// channel拥有的fd，Channel和fd是一一对应的关系</span></span><br><span class="line">    <span class="type">int</span> fd_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// channel对应的红黑树，channel与EpollLoop是多对一的关系，一个Channel只对应一个EpollLoop</span></span><br><span class="line">    <span class="comment">// 一个EpollLoop可以对应多个Channel</span></span><br><span class="line">    EventLoop* event_loop_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Channel是已经添加到对应的epoll树中，false为未添加，true表示已经添加</span></span><br><span class="line">    <span class="comment">// 如果已经添加用EPOLL_CTL_MOD 否则用 EPOLL_CTL_ADD</span></span><br><span class="line">    <span class="type">bool</span> inepoll_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当客户端正常断开TCP连接，IO事件会触发Channel中的设置的CloseCallback回调</span></span><br><span class="line">    <span class="comment">// 但是用户代码在onClose()中有可能析构Channel对象，导致回调执行到一半的时候，其所属的Channel对象本身被销毁了</span></span><br><span class="line">    <span class="comment">// 为了解决这个问题 考虑延长生命周期，怎么延长？</span></span><br><span class="line">    <span class="comment">// 如果直接在另一个类声明一个强引用，但是这会出现循环引用问题</span></span><br><span class="line">    <span class="comment">// 所以想着使用弱引用，那弱引用该如何延长生命周期呢?</span></span><br><span class="line">    <span class="comment">// 可以在调用函数之前 将它提升为强引用赋值给一个强引用 从而增加引用计数</span></span><br><span class="line">    <span class="comment">// 在调用完某函数之前都不会引用计数变为0，执行完后出作用域，引用计数-1</span></span><br><span class="line"></span><br><span class="line">    std::weak_ptr&lt;<span class="type">void</span>&gt; tie_; <span class="comment">// 一方面这个若引用可以做到避免循环引用的现象，另一方面可以增加引用计数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示当前的 Channel对象 是否和一个生命周期受控的对象（如 `TcpServer` 或 `EventLoop`）关联。</span></span><br><span class="line">    <span class="comment">// 如果 `tied_` 为 `true`，则表示需要检查关联对象的生命周期。</span></span><br><span class="line">    <span class="type">bool</span> tied_;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// fd需要监听的事件，listenfd和clientfd需要监听EPOLLIN，</span></span><br><span class="line">    <span class="comment">// clientfd还可能监听EPOLLOUT事件</span></span><br><span class="line">    <span class="type">uint32_t</span> events_;</span><br><span class="line">    <span class="comment">// fd_中已发生的事件</span></span><br><span class="line">    <span class="type">uint32_t</span> revents_;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为channel可以获得fd最终发生的具体事件revent，所以他负责回调</span></span><br><span class="line">    <span class="comment">// 读事件回调函数</span></span><br><span class="line">    ReadEventCallback readcallback_;</span><br><span class="line">    <span class="comment">// 连接错误回调函数</span></span><br><span class="line">    EventCallback errorcallback_;</span><br><span class="line">    <span class="comment">// 连接断开回调函数</span></span><br><span class="line">    EventCallback closecallback_;</span><br><span class="line">    <span class="comment">// 写事件回调函数</span></span><br><span class="line">    EventCallback writecallback_;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="channel实现"><a href="#channel实现" class="headerlink" title="channel实现"></a>channel实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;TcpServer.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;EPollPoller.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Channel.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;InetAddress.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;logger.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TimeStamp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Channel::kNoneEvent = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Channel::kReadEvent = EPOLLIN | EPOLLPRI;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Channel::kWriteEvent = EPOLLOUT;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Channel::<span class="built_in">Channel</span>(<span class="type">int</span> fd, EventLoop* event_loop)</span><br><span class="line">        : <span class="built_in">fd_</span>(fd)</span><br><span class="line">        , <span class="built_in">event_loop_</span>(event_loop)</span><br><span class="line">        , <span class="built_in">inepoll_</span>(<span class="literal">false</span>)</span><br><span class="line">        , <span class="built_in">tied_</span>(<span class="literal">false</span>)</span><br><span class="line">        , <span class="built_in">events_</span>(<span class="number">0</span>)</span><br><span class="line">        , <span class="built_in">revents_</span>(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Channel::fd</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fd_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Channel::usetET</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    events_ = events_|EPOLLET;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Channel::setinepoll</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    inepoll_ = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Channel::setrevents</span><span class="params">(<span class="type">uint32_t</span> ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    revents_ = ev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">Channel::events</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> events_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Channel::inepoll</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> inepoll_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">Channel::revents</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> revents_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Channel::setReadCallBack</span><span class="params">(ReadEventCallback rcb)</span></span>&#123;</span><br><span class="line">    readcallback_ = std::<span class="built_in">move</span>(rcb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Channel::setCloseCallBack</span><span class="params">(EventCallback rcb)</span> </span>&#123;</span><br><span class="line">    closecallback_ = std::<span class="built_in">move</span>(rcb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Channel::setErrorCallBack</span><span class="params">(EventCallback rcb)</span> </span>&#123;</span><br><span class="line">    errorcallback_ = std::<span class="built_in">move</span>(rcb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Channel::setWriteCallBack</span><span class="params">(EventCallback wcb)</span> </span>&#123;</span><br><span class="line">    writecallback_ = std::<span class="built_in">move</span>(wcb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Channel::handleevent</span><span class="params">(TimeStamp receiveTime)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tied_) &#123;</span><br><span class="line">        std::shared_ptr&lt;<span class="type">void</span>&gt; guard = tie_.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span>(guard) &#123;</span><br><span class="line">            <span class="built_in">handleEventWithGuard</span>(receiveTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">handleEventWithGuard</span>(receiveTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Channel::handleEventWithGuard</span><span class="params">(TimeStamp receiveTime)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;channel handleEvent revents:%d\n&quot;</span>,revents_);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// EPOLLRDHUP 表示对方已经关闭</span></span><br><span class="line">    <span class="keyword">if</span>((revents_ &amp; EPOLLRDHUP) &amp;&amp; !(revents_ &amp; EPOLLIN))&#123;</span><br><span class="line">        <span class="keyword">if</span> (closecallback_) &#123;</span><br><span class="line">            <span class="built_in">closecallback_</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// EPOLLPRI 表示外带数据</span></span><br><span class="line">    <span class="keyword">if</span>(revents_ &amp; (EPOLLIN | EPOLLPRI) ) &#123;</span><br><span class="line">       <span class="keyword">if</span> (readcallback_) &#123;</span><br><span class="line">            <span class="built_in">readcallback_</span>(receiveTime);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;Read callback not set for fd= %d\n&quot;</span>, fd_);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(revents_ &amp; EPOLLOUT)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(writecallback_)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">writecallback_</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(errorcallback_) <span class="built_in">errorcallback_</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Channel::update</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过channel所属的EventLoop，把当前的channel删除掉</span></span><br><span class="line">    event_loop_-&gt;<span class="built_in">updatechannel</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Channel::remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//通过channel所属的EventLoop，调用Poller相应的方法，移除fd的events事件</span></span><br><span class="line">    event_loop_-&gt;<span class="built_in">removechannel</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Channel::tie</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;<span class="type">void</span>&gt; &amp;obj)</span> </span>&#123;</span><br><span class="line">    tie_ = obj;</span><br><span class="line">    tied_ = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="重要设计"><a href="#重要设计" class="headerlink" title="重要设计"></a>重要设计</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="comment">// 当客户端正常断开TCP连接，IO事件会触发Channel中的设置的CloseCallback回调</span></span><br><span class="line">    <span class="comment">// 但是用户代码在onClose()中有可能析构Channel对象，导致回调执行到一半的时候，其所属的Channel对象本身被销毁了</span></span><br><span class="line">    <span class="comment">// 为了解决这个问题 考虑延长生命周期，怎么延长？</span></span><br><span class="line">    <span class="comment">// 如果直接在另一个类声明一个强引用，但是这会出现循环引用问题</span></span><br><span class="line">    <span class="comment">// 所以想着使用弱引用，那弱引用该如何延长生命周期呢?</span></span><br><span class="line">    <span class="comment">// 可以在调用函数之前 将它提升为强引用赋值给一个强引用 从而增加引用计数</span></span><br><span class="line">    <span class="comment">// 在调用完某函数之前都不会引用计数变为0，执行完后出作用域，引用计数-1</span></span><br><span class="line"></span><br><span class="line">    std::weak_ptr&lt;<span class="type">void</span>&gt; tie_; <span class="comment">// 一方面这个若引用可以做到避免循环引用的现象，另一方面可以增加引用计数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示当前的 Channel对象 是否和一个生命周期受控的对象（如 `TcpServer` 或 `EventLoop`）关联。</span></span><br><span class="line">    <span class="comment">// 如果 `tied_` 为 `true`，则表示需要检查关联对象的生命周期。</span></span><br><span class="line">    <span class="type">bool</span> tied_;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Channel::tie</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;<span class="type">void</span>&gt; &amp;obj)</span> </span>&#123;</span><br><span class="line">        tie_ = obj;</span><br><span class="line">        tied_ = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Channel::handleEvent</span><span class="params">(TimeStamp receiveTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(tied_)</span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;<span class="type">void</span>&gt; guard;</span><br><span class="line">        guard = tie_.<span class="built_in">lock</span>(); <span class="comment">//提升</span></span><br><span class="line">        <span class="keyword">if</span>(guard)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">handleEventWithGuard</span>(receiveTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">handleEventWithGuard</span>(receiveTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Channel::handleEventWithGuard</span><span class="params">(TimeStamp receiveTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;channel handleEvent revents:%d\n&quot;</span>,revents_);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接断开，并且fd上没有可读数据（默认水平触发）</span></span><br><span class="line">    <span class="keyword">if</span>((revents_ &amp; EPOLLHUP) &amp;&amp; !(revents_ &amp; EPOLLIN))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(closeCallback_)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">closeCallback_</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(revents_ &amp; EPOLLERR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (errorCallback_)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">errorCallback_</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(revents_ &amp; (EPOLLIN | EPOLLPRI))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(readCallback_)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">readCallback_</span>(receiveTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(revents_ &amp; EPOLLOUT)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(writeCallback_)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">writeCallback_</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><strong><em>tie</em></strong>这个成员变量的设计：<ol>
<li>当客户端正常断开TCP连接，IO事件会触发Channel中的设置的CloseCallback回调，但是用户代码在onClose()中有可能析构Channel对象，导致回调执行到一半的时候，其所属的Channel对象本身被销毁了</li>
<li>为了解决这个问题 考虑延长生命周期，怎么延长？<ol>
<li>如果直接在另一个类声明一个强引用，但是这会出现循环引用问题</li>
<li>所以想着使用弱引用，那弱引用该如何延长生命周期呢?</li>
<li>可以在调用函数之前 将它提升为强引用赋值给一个强引用 从而增加引用计数</li>
<li>在调用完某函数之前都不会引用计数变为0，执行完后出作用域，引用计数-1</li>
</ol>
</li>
</ol>
</li>
</ul>
<p>​           3. 我们可以看出handleEvent中tie实际上这是一个弱指针，绑定到TcpConnection的共享指针 ，如果可以原来的弱指针，变成了强指针，这时候tie()的作用     就表明了，延长了TcpConnection的生命周期，使之长过Channel::handleEvent()，保证了TcpConnection不被销毁</p>
<h1 id="muduo库三大核心组件之EventLoop类"><a href="#muduo库三大核心组件之EventLoop类" class="headerlink" title="muduo库三大核心组件之EventLoop类"></a>muduo库三大核心组件之EventLoop类</h1><ul>
<li>Poller封装了和事件监听有关的方法和成员，调用Poller派生类EpollPoller::poll方法，我们就可以获得发生事件的fd 及其 发生的事件。EventLoop是网络服务器中负责 循环 的重要模块，从而做到持续监听、持续获取监听结果、持续处理监听结果对应的事件。</li>
<li>也就是说： EventLoop起到一个驱动循环的功能，Poller负责从事件监听器上获取监听结果，Channel类将fd及其相关属性封装，并将fd及其感兴趣事件和发生的事件以及不同事件对应的回调函数封装在一起，这样在各个模块中传递更加方便。接着被EventLoop调用。</li>
<li>可能上面我画的图不能充分表达三者在muduo库中的角色，下面借用我在地铁站里吃闸机博主的图，可能会让大家看的更加直观。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/direct/99d171403b4e4e6fafd2ab726ab7d102.png" alt="img"></p>
<h2 id="重要成员变量"><a href="#重要成员变量" class="headerlink" title="重要成员变量"></a>重要成员变量</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用来存放活跃的channels</span></span><br><span class="line">   ChannelList activeChannels_;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 指向poller 来调用他的API</span></span><br><span class="line">   std::unique_ptr&lt;Poller&gt; poller_;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 标志事件循环是否在执行</span></span><br><span class="line">   std::atomic_bool looping_;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 标志事件循环是否停止</span></span><br><span class="line">   std::atomic_bool quit_;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// poller返回发生事件的channels的时间点</span></span><br><span class="line">   TimeStamp pollReturnTime_;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 用来记录事件循环线程的tid</span></span><br><span class="line">   <span class="type">const</span> <span class="type">pid_t</span> threadId_;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** 这是用来唤醒事件循环线程（就是执行EventLoop.loop()的线程）</span></span><br><span class="line"><span class="comment">   // 其设计思想是当另外一个线程，调用了此EventLoop并往里面加入回调函数的时候，唤醒事件循环线程</span></span><br><span class="line"><span class="comment">   // 会有两种唤醒情况</span></span><br><span class="line"><span class="comment">       * 1. 会唤醒被poller_-&gt;poll(kPollTimeMs,&amp;activeChannels_);阻塞的事件循环线程</span></span><br><span class="line"><span class="comment">       * 2. 事件循环线程正在执行回调函数，当他执行完后，再次调用poller_-&gt;poll(kPollTimeMs,&amp;activeChannels_);</span></span><br><span class="line"><span class="comment">       * 由于有新的事件发生了（eventfd也就是wakeupChannel_有读事件）</span></span><br><span class="line"><span class="comment">       * 就不会被阻塞而继续执行doPendingFunctors();</span></span><br><span class="line"><span class="comment">   **/</span></span><br><span class="line">   <span class="type">int</span> wakeupFd_;</span><br><span class="line">   std::unique_ptr&lt;Channel&gt; wakeupChannel_;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 存放回调函数的所有集合</span></span><br><span class="line">   std::vector&lt;Functor&gt; pendingFunctors_;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 用来标志是否正在处理回调函数</span></span><br><span class="line">   std::atomic_bool pcallingPendingFunctors_;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 用来实现共享数据的互斥访问</span></span><br><span class="line">   std::mutex mutex_;</span><br></pre></td></tr></table></figure>
<ul>
<li>poller<em>就不用在多说什么了，通过它会返回给EventLoop发生的事件。</em></li>
<li><em>wakeupFd</em>是非常重要的一个成员，与之对应的wakeupChannel<em>,起到了一个唤醒loop所在的线程的作用，因为当前线程主要阻塞在poll函数上，唤醒的方法是手动激活这个wakeupChannel</em>， 写入几个字节让Channel变为可读， 当然这个Channel也注册到Pooll中，在下面的成员函数会详细介绍它的实现。</li>
<li>threadId<em>创建时要保存当前时间循环所在的线程，用于之后运行时判断使用EventLoop的线程是否时EventLoop所属的线程.</em></li>
<li><em>pollReturnTime</em>保存poll返回的时间，用于计算从激活到调用回调函数的延迟</li>
<li>activeChannels<em>就是poller返回的所有发生事件的channel列表。</em></li>
<li><em>callingPendingFunctors</em>标识当前loop是否有需要执行的回调操作</li>
<li>pendingFunctors<em>存储loop需要执行的所有回调操作，避免本来属于当前线程的回调函数被其他线程调用，应该把这个回调函数添加到属于它所属的线程，等待它属于的线程被唤醒后调用，满足线程安全</em></li>
<li><em>mutex</em>互斥锁，用来保护vector容器的线程安全操作</li>
</ul>
<h2 id="重要成员函数"><a href="#重要成员函数" class="headerlink" title="重要成员函数"></a>重要成员函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Functor = std::function&lt;<span class="built_in">void</span>()&gt;;</span><br><span class="line">    <span class="keyword">using</span> ChannelList = std::vector&lt;Channel*&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">EventLoop</span>();</span><br><span class="line">    ~<span class="built_in">EventLoop</span>();</span><br><span class="line">    <span class="built_in">EventLoop</span>(<span class="type">const</span> EventLoop&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    EventLoop&amp; <span class="keyword">operator</span>=(<span class="type">const</span> EventLoop&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开启事件循环</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//退出事件循环</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">quit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回处理的时间辍</span></span><br><span class="line">    <span class="function">TimeStamp <span class="title">pollReturnTime</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> pollReturnTime_; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//EventLoop的方法=&gt; poller的方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">updatechannel</span><span class="params">(Channel* channel)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removechannel</span><span class="params">(Channel* channel)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasChannel</span><span class="params">(Channel* channel)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往存放回调函数的所有集合加数据</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">queueInLoop</span><span class="params">(<span class="type">const</span> Functor&amp; cb)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">runInLoop</span><span class="params">(<span class="type">const</span> Functor&amp; cb)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用来唤醒事件循环线程</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wakeup</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 证明EventLoop创建时的线程id与当前线程id是否相等</span></span><br><span class="line">    <span class="comment">// 相等表示EventLoop就在所创建他的loop线程里面，可以执行回调</span></span><br><span class="line">    <span class="comment">// 不相等就需要queueInLoop，等待唤醒它自己的线程时，在执行回调</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isInLoopThread</span><span class="params">()</span> <span class="type">const</span></span>&#123; <span class="keyword">return</span> threadId_ == CurrentThread::<span class="built_in">tid</span>();&#125;</span><br><span class="line">    <span class="comment">//[[nodiscard]] EPollPoller* ReturnEPollPoller() const;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//唤醒用的 wake up</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleRead</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行回调函数用</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doPendingFunctors</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>其实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by ubuntu on 24-7-19.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;EventLoop.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Channel.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;logger.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/eventfd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//防止一个线程创建多个EventLoop</span></span><br><span class="line"><span class="comment">//当创建了一个EventLoop对象时，*t_loopInThisThread就指向这个对象</span></span><br><span class="line"><span class="comment">//在一个线程里面在创建EventLoop时，指针不为空就不会创建了</span></span><br><span class="line"><span class="comment">//从而控制了一个线程里面只有一个EventLoop</span></span><br><span class="line">__thread EventLoop *t_loopInThisThread = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义默认的Poller IO复用接口的超时时间</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kPollTimeMs = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建wakeupfd 用来notify唤醒subReactor处理新来的channel</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">createEventfd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//eventfd 计数不为零表示有可读事件发生，read 之后计数会清零，write 则会递增计数器。</span></span><br><span class="line">    <span class="type">int</span> evtfd = ::<span class="built_in">eventfd</span>(<span class="number">0</span>, EFD_NONBLOCK | EFD_CLOEXEC);</span><br><span class="line">    <span class="keyword">if</span> (evtfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_FATAL</span>(<span class="string">&quot;eventfd error:%d \n&quot;</span>,errno);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> evtfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventLoop::<span class="built_in">EventLoop</span>()</span><br><span class="line">    : <span class="built_in">activeChannels_</span>(<span class="number">0</span>)</span><br><span class="line">    , <span class="built_in">poller_</span>(Poller::<span class="built_in">newDefaultPoller</span>(<span class="keyword">this</span>))</span><br><span class="line">    , <span class="built_in">looping_</span>(<span class="literal">false</span>)</span><br><span class="line">    , <span class="built_in">quit_</span>(<span class="literal">false</span>)</span><br><span class="line">    , <span class="built_in">pollReturnTime_</span>(<span class="number">0</span>)</span><br><span class="line">    , <span class="built_in">threadId_</span>(CurrentThread::<span class="built_in">tid</span>())</span><br><span class="line">    , <span class="built_in">wakeupFd_</span>(<span class="built_in">createEventfd</span>())</span><br><span class="line">    , <span class="built_in">wakeupChannel_</span>(std::<span class="built_in">make_unique</span>&lt;Channel&gt;(wakeupFd_, <span class="keyword">this</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;EventLoop created %p in thread %d \n&quot;</span>,<span class="keyword">this</span> threadId_);</span><br><span class="line">    <span class="keyword">if</span>(t_loopInThisThread)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_FATAL</span>(<span class="string">&quot;Another EvnetLoop %p exists in this thread %d \n&quot;</span>,t_loopInThisThread, threadId_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        t_loopInThisThread = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置wakeupfd的事件类型以及发生事件后的回调操作</span></span><br><span class="line">    wakeupChannel_-&gt;<span class="built_in">setReadCallBack</span>(std::<span class="built_in">bind</span>(&amp;EventLoop::handleRead, <span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每一个eventloop都将监听wakeupchannel的EPOLLIN读事件了</span></span><br><span class="line">    <span class="comment">//minreactor通过给subreactor写东西，通知其苏醒</span></span><br><span class="line">    wakeupChannel_-&gt;<span class="built_in">enableReading</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventLoop::~<span class="built_in">EventLoop</span>() &#123;</span><br><span class="line">    wakeupChannel_-&gt;<span class="built_in">disableAll</span>();</span><br><span class="line">    wakeupChannel_-&gt;<span class="built_in">remove</span>();</span><br><span class="line">    <span class="built_in">close</span>(wakeupFd_);</span><br><span class="line">    t_loopInThisThread = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    looping_.<span class="built_in">store</span>(<span class="literal">true</span>);</span><br><span class="line">    quit_.<span class="built_in">store</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;EventLoop %p start looping \n&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!quit_) &#123;</span><br><span class="line">        activeChannels_.<span class="built_in">clear</span>();</span><br><span class="line">        pollReturnTime_ = poller_-&gt;<span class="built_in">poll</span>(kPollTimeMs, activeChannels_);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> activeChannel: activeChannels_) &#123;</span><br><span class="line">            <span class="comment">//poller监听哪些channel发生事件了，然后上报给EventLoop，通知channel处理相应的事件</span></span><br><span class="line">            activeChannel-&gt;<span class="built_in">handleevent</span>(pollReturnTime_);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * IO线程 mainloop accept fd &lt;= channel  subloop</span></span><br><span class="line"><span class="comment">         * mainloop事先注册一个回调cb，需要subloop执行</span></span><br><span class="line"><span class="comment">         * wakeup subloop后执行下面的方法 执行之前mainloop注册的cb回调</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//执行当前EventLoop事件循环需要处理的回调操作</span></span><br><span class="line">        <span class="built_in">doPendingFunctors</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;EventLoop %p stop looping,\n&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">    looping_ = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//退出事件循环</span></span><br><span class="line"><span class="comment">//1. loop在自己的线程中调用quit</span></span><br><span class="line"><span class="comment">//2. 在其他线程中调用的quit（在一个subloop（woker）中，调用了mainloop（IO）的quit）</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">                mainloop</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ****************************** 生产者-消费者的线程安全的队列（no）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    subloop1     subloop2     subloop3</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::quit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    quit_.<span class="built_in">store</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是在其它线程中，调用的quit 在一个subloop(woker)中，调用了mainLoop(IO)的quit</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">isInLoopThread</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">wakeup</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::wakeup</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> one = <span class="number">1</span>;</span><br><span class="line">    <span class="type">ssize_t</span> evnums = <span class="built_in">write</span>(wakeupFd_, &amp;one, <span class="keyword">sizeof</span> one);</span><br><span class="line">    <span class="keyword">if</span>(evnums != <span class="keyword">sizeof</span> one) &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;EventLoop::wakeup() writes %lu bytes instead of 8 \n&quot;</span>,evnums);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::handleRead</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> one&#123;&#125;;</span><br><span class="line">    <span class="type">ssize_t</span> n = <span class="built_in">read</span>(wakeupFd_, &amp;one, <span class="keyword">sizeof</span> one);</span><br><span class="line">    <span class="keyword">if</span>(n != <span class="keyword">sizeof</span> one)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;EventLoop::handleRead() reads %d bytes instead of 8&quot;</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::removechannel</span><span class="params">(Channel* channel)</span> </span>&#123;</span><br><span class="line">    poller_-&gt;<span class="built_in">removeChannel</span>(channel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::updatechannel</span><span class="params">(Channel* channel)</span> </span>&#123;</span><br><span class="line">    poller_-&gt;<span class="built_in">updateChannel</span>(channel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">EventLoop::hasChannel</span><span class="params">(Channel* channel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> poller_-&gt;<span class="built_in">hasChannel</span>(channel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::doPendingFunctors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用一个局部的vector和pendingFunctors_的交换，有两种好处</span></span><br><span class="line">    <span class="comment">// 1. 可以缩小pendingFunctors_的容量, 因为如果只是resize</span></span><br><span class="line">    <span class="comment">// 它只会重新设定大小（size）而不会重新设定容量</span></span><br><span class="line">    <span class="comment">// 2. 最重要的原因：可以最大的减小占用互斥锁的时间，使得其只在swap加锁</span></span><br><span class="line">    <span class="comment">// 在执行回调函数的时候不加锁，可能还能预防在执行回调函数的时候获取锁而死锁</span></span><br><span class="line">    <span class="comment">// 也能在确保执行回调函数的时候，能够往pendingFunctors_里加数据</span></span><br><span class="line">    std::vector&lt;Functor&gt; functors;</span><br><span class="line">    pcallingPendingFunctors_.<span class="built_in">store</span>(<span class="literal">true</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        functors.<span class="built_in">swap</span>(pendingFunctors_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处可以优化，将处理回调函数单独交给一个逻辑系统（线程池）来处理</span></span><br><span class="line">    <span class="comment">// 实现解耦</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> Functor&amp; func: functors) &#123;</span><br><span class="line">        <span class="built_in">func</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pcallingPendingFunctors_.<span class="built_in">store</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来与上处设计比较</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void EventLoop::doPendingFunctors() &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    pcallingPendingFunctors_.store(true);</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        std::lock_guard&lt;std::mutex&gt; lock(mutex_);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        // 此处可以优化，将处理回调函数单独交给一个逻辑系统（线程池）来处理</span></span><br><span class="line"><span class="comment">        // 实现解耦</span></span><br><span class="line"><span class="comment">        for(const Functor&amp; func: functors) &#123;</span></span><br><span class="line"><span class="comment">            func();</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    pcallingPendingFunctors_.store(false);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::runInLoop</span><span class="params">(<span class="type">const</span> Functor &amp;cb)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果调用的线程是事件循环线程直接调用回调函数</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isInLoopThread</span>()) &#123;</span><br><span class="line">        <span class="built_in">cb</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">queueInLoop</span>(cb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::queueInLoop</span><span class="params">(<span class="type">const</span> Functor &amp;cb)</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        pendingFunctors_.<span class="built_in">emplace_back</span>(cb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当出现以下两种情况的时候进行唤醒</span></span><br><span class="line">    <span class="comment">/** 这是用来唤醒事件循环线程（就是执行EventLoop.loop()的线程）</span></span><br><span class="line"><span class="comment">   // 其设计思想是当另外一个线程，调用了此EventLoop并往里面加入回调函数的时候，唤醒事件循环线程</span></span><br><span class="line"><span class="comment">   // 会有两种唤醒情况</span></span><br><span class="line"><span class="comment">       * 1. 会唤醒被poller_-&gt;poll(kPollTimeMs,&amp;activeChannels_);阻塞的事件循环线程</span></span><br><span class="line"><span class="comment">       * 2. 事件循环线程正在执行回调函数，当他执行完后，再次调用poller_-&gt;poll(kPollTimeMs,&amp;activeChannels_);</span></span><br><span class="line"><span class="comment">       * 由于有新的事件发生了（eventfd也就是wakeupChannel_有读事件）</span></span><br><span class="line"><span class="comment">       * 就不会被阻塞而继续执行doPendingFunctors();</span></span><br><span class="line"><span class="comment">   **/</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">isInLoopThread</span>() || pcallingPendingFunctors_.<span class="built_in">load</span>()) &#123;</span><br><span class="line">        <span class="built_in">wakeup</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="其中的巧妙设计"><a href="#其中的巧妙设计" class="headerlink" title="其中的巧妙设计"></a>其中的巧妙设计</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::doPendingFunctors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用一个局部的vector和pendingFunctors_的交换，有两种好处</span></span><br><span class="line">    <span class="comment">// 1. 可以缩小pendingFunctors_的容量, 因为如果只是resize</span></span><br><span class="line">    <span class="comment">// 它只会重新设定大小（size）而不会重新设定容量</span></span><br><span class="line">    <span class="comment">// 2. 最重要的原因：可以最大的减小占用互斥锁的时间，使得其只在swap加锁</span></span><br><span class="line">    <span class="comment">// 在执行回调函数的时候不加锁，可能还能预防在执行回调函数的时候获取锁而死锁</span></span><br><span class="line">    <span class="comment">// 也能在确保执行回调函数的时候，能够往pendingFunctors_里加数据</span></span><br><span class="line">    std::vector&lt;Functor&gt; functors;</span><br><span class="line">    pcallingPendingFunctors_.<span class="built_in">store</span>(<span class="literal">true</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        functors.<span class="built_in">swap</span>(pendingFunctors_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处可以优化，将处理回调函数单独交给一个逻辑系统（线程池）来处理</span></span><br><span class="line">    <span class="comment">// 实现解耦</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> Functor&amp; func: functors) &#123;</span><br><span class="line">        <span class="built_in">func</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pcallingPendingFunctors_.<span class="built_in">store</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个与上面比较</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::doPendingFunctors</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    pcallingPendingFunctors_.<span class="built_in">store</span>(<span class="literal">true</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此处可以优化，将处理回调函数单独交给一个逻辑系统（线程池）来处理</span></span><br><span class="line">        <span class="comment">// 实现解耦</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">const</span> Functor&amp; func: functors) &#123;</span><br><span class="line">            <span class="built_in">func</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pcallingPendingFunctors_.<span class="built_in">store</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><em>第一个比较巧妙的思想就是，使用一个局部的<code>vector</code>和<code>pendingFunctors_</code>的交换:</em></strong><ul>
<li><strong>可以缩小pendingFunctors_的容量, 因为如果只是resize, 它只会重新设定大小（size）而不会重新设定容量</strong></li>
<li><strong>最重要的原因：可以最大的减小占用互斥锁的时间，使得其只在swap加锁, 在执行回调函数的时候不加锁，可能还能预防在执行回调函数的时候获取锁而死锁,也能在确保执行回调函数的时候，能够往pendingFunctors_里加数据</strong></li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::wakeup</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> one = <span class="number">1</span>;</span><br><span class="line">    <span class="type">ssize_t</span> evnums = <span class="built_in">write</span>(wakeupFd_, &amp;one, <span class="keyword">sizeof</span> one);</span><br><span class="line">    <span class="keyword">if</span>(evnums != <span class="keyword">sizeof</span> one) &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;EventLoop::wakeup() writes %lu bytes instead of 8 \n&quot;</span>,evnums);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::handleRead</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> one&#123;&#125;;</span><br><span class="line">    <span class="type">ssize_t</span> n = <span class="built_in">read</span>(wakeupFd_, &amp;one, <span class="keyword">sizeof</span> one);</span><br><span class="line">    <span class="keyword">if</span>(n != <span class="keyword">sizeof</span> one)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;EventLoop::handleRead() reads %d bytes instead of 8&quot;</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::runInLoop</span><span class="params">(<span class="type">const</span> Functor &amp;cb)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果调用的线程是事件循环线程直接调用回调函数</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isInLoopThread</span>()) &#123;</span><br><span class="line">        <span class="built_in">cb</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">queueInLoop</span>(cb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::queueInLoop</span><span class="params">(<span class="type">const</span> Functor &amp;cb)</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        pendingFunctors_.<span class="built_in">emplace_back</span>(cb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当出现以下两种情况的时候进行唤醒</span></span><br><span class="line">    <span class="comment">/** 这是用来唤醒事件循环线程（就是执行EventLoop.loop()的线程）</span></span><br><span class="line"><span class="comment">   // 其设计思想是当另外一个线程，调用了此EventLoop并往里面加入回调函数的时候，唤醒事件循环线程</span></span><br><span class="line"><span class="comment">   // 会有两种唤醒情况</span></span><br><span class="line"><span class="comment">       * 1. 会唤醒被poller_-&gt;poll(kPollTimeMs,&amp;activeChannels_);阻塞的事件循环线程</span></span><br><span class="line"><span class="comment">       * 2. 事件循环线程正在执行回调函数，当他执行完后，再次调用poller_-&gt;poll(kPollTimeMs,&amp;activeChannels_);</span></span><br><span class="line"><span class="comment">       * 由于有新的事件发生了（eventfd也就是wakeupChannel_有读事件）</span></span><br><span class="line"><span class="comment">       * 就不会被阻塞而继续执行doPendingFunctors();</span></span><br><span class="line"><span class="comment">   **/</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">isInLoopThread</span>() || pcallingPendingFunctors_.<span class="built_in">load</span>()) &#123;</span><br><span class="line">        <span class="built_in">wakeup</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><em>第二个比较巧妙的设计就是，使用<code>wakeupFd_</code>，这是最巧妙的</em></strong><ul>
<li>传统的进程/线程间唤醒办法是用pipe或者socketpair，IO线程始终监视管道上的可读事件，在需要唤醒的时候，其他线程向管道中写一个字节，这样IO线程就从IO multiplexing阻塞调用中返回。pipe和socketpair都需要一对文件描述符，且pipe只能单向通信，socketpair可以双向通信。一方面它比 pipe 少用一个 fd，节省了资源；另一方面，wakeupFd<em>的缓冲区管理也简单得多，全部buffer只有定长8 bytes，不像 pipe 那样可能有不定长的真正 buffer。muduo库也没有采用生产者消费者的模型，采用了wakeupFd</em>这种巧妙的思想，在今后的学习中，我们也可以进一步的使用它。</li>
<li>什么是<strong>eventfd</strong>，他是用来记录有多少的事件可读，其有两个函数read 清空计数，write类加技术（具体请参考:<a target="_blank" rel="noopener" href="https://blog.csdn.net/EDDYCJY/article/details/118980819）">https://blog.csdn.net/EDDYCJY/article/details/118980819）</a></li>
<li>他可以用来跨线程通知</li>
<li>会有两种唤醒情况<pre><code>1. 会唤醒被poller_-&gt;poll(kPollTimeMs,&amp;activeChannels_);阻塞的事件循环线程
1.  事件循环线程正在执行回调函数，当他执行完后，再次调用&#39;poller_-&gt;poll(kPollTimeMs,&amp;activeChannels_);&#39;由于有新的事件发生了（eventfd也就是wakeupChannel_有读事件），就不会被阻塞而继续执行doPendingFunctors();
</code></pre></li>
</ul>
</li>
</ul>
<h1 id="muduo库三大核心组件之-Poller-EpollPoller类"><a href="#muduo库三大核心组件之-Poller-EpollPoller类" class="headerlink" title="muduo库三大核心组件之 Poller/EpollPoller类"></a>muduo库三大核心组件之 Poller/EpollPoller类</h1><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/2024-07-25-muduo网络库学习/20240725-180512.jpg" alt="image-20240725101825823"></p>
<p><strong>Poller</strong>负责监听<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=文件描述符&amp;spm=1001.2101.3001.7020">文件描述符</a>事件是否触发以及返回发生事件的文件描述符以及具体事件。在 muduo 中，使用抽象基类 Poller ，并由EpollPoller和PollPoller派生基类中继承实现 epoll 和 poll</p>
<h2 id="重要成员变量-1"><a href="#重要成员变量-1" class="headerlink" title="重要成员变量"></a>重要成员变量</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//poller.h</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">//map的key表示 sockfd  value表示所属的channel通道类型</span></span><br><span class="line">    <span class="keyword">using</span> ChannelMap = std::unordered_map&lt;<span class="type">int</span>, Channel*&gt;;</span><br><span class="line">    ChannelMap channels_;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 定义Poller所属的事件循环EventLoop</span></span><br><span class="line">    EventLoop* owernLoop_;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// EpollPoller</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">using</span> EventList = std::vector&lt;epoll_event&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//epoll_event初始的长度</span></span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> kInitEventListSize = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//epoll 的句柄</span></span><br><span class="line">    <span class="type">int</span> epollfd_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存放epoll返回的事件的容器</span></span><br><span class="line">    EventList events_;</span><br></pre></td></tr></table></figure>
<ul>
<li>详情见注释</li>
</ul>
<h2 id="重要成员函数-1"><a href="#重要成员函数-1" class="headerlink" title="重要成员函数"></a>重要成员函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Poller.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Channel.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">Poller::<span class="built_in">Poller</span>(EventLoop* loop):<span class="built_in">owernLoop_</span>(loop) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Poller::hasChannel</span><span class="params">(Channel* channel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = channels_.<span class="built_in">find</span>(channel-&gt;<span class="built_in">fd</span>());</span><br><span class="line">    <span class="keyword">return</span> it != channels_.<span class="built_in">end</span>() &amp;&amp; it-&gt;second == channel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//============== EpollPoller==============</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;EPollPoller.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;logger.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TimeStamp.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Channel.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">EPollPoller::<span class="built_in">EPollPoller</span>(EventLoop* loop)</span><br><span class="line">    : <span class="built_in">Poller</span>(loop)</span><br><span class="line">    , <span class="built_in">epollfd_</span>(<span class="built_in">epoll_create1</span>(EPOLL_CLOEXEC))</span><br><span class="line">    , <span class="built_in">events_</span>(kInitEventListSize)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (epollfd_ == <span class="number">-1</span>) &#123;</span><br><span class="line">       <span class="built_in">LOG_FATAL</span>(<span class="string">&quot;epoll_create error:%d \n&quot;</span>, errno);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="built_in">LOG_INFO</span>(<span class="string">&quot;epoll_create() successed&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EPollPoller::~<span class="built_in">EPollPoller</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">close</span>(epollfd_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过epoll_wait将发生事件的channel通过activeChannels告知给EventLoop</span></span><br><span class="line"><span class="function">TimeStamp <span class="title">EPollPoller::poll</span><span class="params">(<span class="type">int</span> timeoutMs, ChannelList &amp;activeChannels)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;func=%s =&gt; fd total count:%lu \n&quot;</span>,__FUNCTION__, channels_.<span class="built_in">size</span>());</span><br><span class="line">    <span class="comment">//events_是vector类型，</span></span><br><span class="line">    <span class="comment">//events_.begin()返回首元素的地址，</span></span><br><span class="line">    <span class="comment">//*events_.begin()为首元素的值</span></span><br><span class="line">    <span class="comment">//&amp;*events_.begin()存放首元素的地址</span></span><br><span class="line">    <span class="comment">//这就得到了vector底层首元素的起始地址</span></span><br><span class="line">    <span class="type">int</span> EventNums = <span class="built_in">epoll_wait</span>(epollfd_, &amp;*events_.<span class="built_in">begin</span>(), <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(events_.<span class="built_in">size</span>()), timeoutMs);</span><br><span class="line">    <span class="comment">//记录最开始poll里面的错误值</span></span><br><span class="line">    <span class="type">int</span> saveErrno = errno;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取发生事件的时间</span></span><br><span class="line">    <span class="function">TimeStamp <span class="title">now</span><span class="params">(TimeStamp::now())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(EventNums &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">&quot;%d events happended!\n&quot;</span>, EventNums);</span><br><span class="line">        <span class="built_in">fillActiveChannels</span>(EventNums, activeChannels);</span><br><span class="line">        <span class="comment">// 为了防止频繁开辟空间，选择提前开辟</span></span><br><span class="line">        <span class="keyword">if</span>(EventNums == events_.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            events_.<span class="built_in">resize</span>(events_.<span class="built_in">size</span>() * <span class="number">2</span>);</span><br><span class="line">            <span class="comment">//说明当前发生的事件可能多于vector能存放的 ，需要扩容，等待下一轮处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(EventNums == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;%s timeout! \n&quot;</span>,__FUNCTION__);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(saveErrno != EINTR) <span class="comment">//不是外部中断引起的</span></span><br><span class="line">        &#123;</span><br><span class="line">            errno = saveErrno;</span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;EPollPoller::poll() errno!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EPollPoller::fillActiveChannels</span><span class="params">(<span class="type">int</span> numEvents, ChannelList &amp;activeChannels)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; numEvents; i ++) &#123;</span><br><span class="line">        Channel *channel = <span class="built_in">static_cast</span>&lt;Channel*&gt;(events_[i].data.ptr);</span><br><span class="line">        <span class="comment">// 设置channel的返回事件</span></span><br><span class="line">        channel-&gt;<span class="built_in">setrevents</span>(events_[i].events);</span><br><span class="line">        <span class="comment">// EventLoop就拿到了他的poller给他返回的所有发生事件的channel列表了</span></span><br><span class="line">        activeChannels.<span class="built_in">push_back</span>(channel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//channel update remove =&gt; EventLoop updateChannel removeChannel =&gt;Poller updateChannel removeChannel</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *             EventLoop =&gt; poller.poll</span></span><br><span class="line"><span class="comment"> *   ChannelList          Poller</span></span><br><span class="line"><span class="comment"> *                     ChannelMap &lt;fd,channel*&gt;   epollfd</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EPollPoller::updateChannel</span><span class="params">(Channel* channel)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;func=%s =&gt; fd=%d  events=%d\n&quot;</span>,__FUNCTION__, channel-&gt;<span class="built_in">fd</span>(),channel-&gt;<span class="built_in">events</span>());</span><br><span class="line">    <span class="comment">// false 表示不再epoll的红黑树中</span></span><br><span class="line">    <span class="keyword">if</span>(!channel-&gt;<span class="built_in">inepoll</span>()) &#123;</span><br><span class="line">        <span class="built_in">update</span>(EPOLL_CTL_ADD, channel);</span><br><span class="line">        channels_[channel-&gt;<span class="built_in">fd</span>()] = channel;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(channel-&gt;<span class="built_in">isNoneEvent</span>()) &#123;</span><br><span class="line">            <span class="built_in">update</span>(EPOLL_CTL_DEL, channel);</span><br><span class="line">            channels_.<span class="built_in">erase</span>(channel-&gt;<span class="built_in">fd</span>());</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">update</span>(EPOLL_CTL_MOD,channel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EPollPoller::removeChannel</span><span class="params">(Channel* channel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!channel-&gt;<span class="built_in">inepoll</span>()) &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;channel not in epoll&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        channels_.<span class="built_in">erase</span>(channel-&gt;<span class="built_in">fd</span>());</span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">&quot;func=%s =&gt; fd=%d  \n&quot;</span>,__FUNCTION__, channel-&gt;<span class="built_in">fd</span>());</span><br><span class="line">        <span class="built_in">update</span>(EPOLL_CTL_DEL, channel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// operation分别是epoll_(ADD/MOD/DEL)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EPollPoller::update</span><span class="params">(<span class="type">int</span> operation, Channel* channel)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    epoll_event event&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    event.data.ptr = channel;</span><br><span class="line">    <span class="comment">// 把感兴趣的事件加入到events中</span></span><br><span class="line">    event.events = channel-&gt;<span class="built_in">events</span>();</span><br><span class="line">    event.data.fd = channel-&gt;<span class="built_in">fd</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">epoll_ctl</span>(epollfd_, operation, channel-&gt;<span class="built_in">fd</span>(), &amp;event) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(operation == EPOLL_CTL_DEL)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;epoll_ctl del error:%d\n&quot;</span>,errno);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">LOG_FATAL</span>(<span class="string">&quot;epoll_ctl add/mod error:%d\n&quot;</span>,errno);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="muduo库Acceptor类"><a href="#muduo库Acceptor类" class="headerlink" title="muduo库Acceptor类"></a>muduo库Acceptor类</h1><h2 id="Acceptor重要成员变量"><a href="#Acceptor重要成员变量" class="headerlink" title="Acceptor重要成员变量"></a>Acceptor重要成员变量</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Socket acceptSocket_;</span><br><span class="line">Channel acceptChannel_;</span><br><span class="line">std::shared_ptr&lt;EventLoop&gt; event_loop_;</span><br><span class="line">NewConnectionCallBack connectionCallBack_;</span><br><span class="line"><span class="type">bool</span> listening_;</span><br><span class="line"><span class="type">int</span> idlefd_;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>event<em>loop__监听套接字的fd由哪个EventLoop负责循环监听以及处理相应事件，其实这个EventLoop就是main EventLoop。</em></p>
</li>
<li><p><em>acceptSocket</em> 服务器监听套接字的文件描述符</p>
</li>
<li><p>acceptChannel<em>把acceptSocket</em>及其感兴趣事件和事件对应的处理函数进行封装。</p>
</li>
<li><p>newConnetionCallback<em>这个是最重要的一个成员了，它的类型是using NewConnectionCallback = std::function<void(int sockfd, const InetAddress&)>;，在TcpServer构造函数中通过acceptor</em>-&gt;setNewConnetionCallback(std::bind(&amp;TcpServer::newConnection, this, std::placeholders::<em>1,std::placeholders::_2));将 TcpServer::newConnection函数注册给了这个成员变量。这个 TcpServer::newConnection函数的功能是通过轮询EventLoop *ioLoop = threadPool</em>-&gt;getNextLoop();选择一个subEventLoop，并把已经接受的连接分发给这个subEventLoop。_</p>
</li>
<li><p><em>listenning</em>是一个标志位</p>
</li>
<li><p>idlefd_是用来防止底层一直通知有事件以及为了优雅地处理文件描述符耗尽的情况，确保系统在高负载下仍能稳定工作</p>
<h2 id="Acceptor重要成员函数"><a href="#Acceptor重要成员函数" class="headerlink" title="Acceptor重要成员函数"></a>Acceptor重要成员函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by ubuntu on 24-7-19.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Acceptor.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Connection.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;logger.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/fcntl-linux.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">createNonblocking</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sockfd = ::<span class="built_in">socket</span>(AF_INET, SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sockfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_FATAL</span>(<span class="string">&quot;%s:%s:%d listen socket create err:%d \n&quot;</span>, __FILE__,__FUNCTION__,__LINE__,errno);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Acceptor::<span class="built_in">Acceptor</span>(std::shared_ptr&lt;EventLoop&gt; event_loop, <span class="type">const</span> InetAddress&amp; address, <span class="type">bool</span> resuseport)</span><br><span class="line">    : <span class="built_in">acceptSocket_</span>(<span class="built_in">createNonblocking</span>())</span><br><span class="line">    , <span class="built_in">acceptChannel_</span>(acceptSocket_.<span class="built_in">fd</span>(),event_loop)</span><br><span class="line">    , <span class="built_in">event_loop_</span>(event_loop)</span><br><span class="line">    , <span class="built_in">listening_</span>(<span class="literal">false</span>)</span><br><span class="line">    , <span class="built_in">idlefd_</span>(::<span class="built_in">open</span>(<span class="string">&quot;/dev/null&quot;</span>, O_RDONLY | O_CLOEXEC)) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(idlefd_ &gt;= <span class="number">0</span>);</span><br><span class="line">    acceptSocket_.<span class="built_in">SetReuseaddr</span>(<span class="literal">true</span>);</span><br><span class="line">    acceptSocket_.<span class="built_in">SetReuseport</span>(resuseport);</span><br><span class="line">    acceptSocket_.<span class="built_in">bind</span>(address);</span><br><span class="line">    <span class="built_in">setNewConnectionCallBack</span>(std::<span class="built_in">bind</span>(&amp;Acceptor::handleread, <span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Acceptor::~<span class="built_in">Acceptor</span>() &#123;</span><br><span class="line">    acceptChannel_.<span class="built_in">disableAll</span>();</span><br><span class="line">    acceptChannel_.<span class="built_in">remove</span>();</span><br><span class="line">    <span class="built_in">close</span>(idlefd_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Acceptor::listen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    acceptChannel_.<span class="built_in">enableReading</span>();</span><br><span class="line">    listening_ = <span class="literal">true</span>;</span><br><span class="line">    acceptSocket_.<span class="built_in">listen</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Acceptor::handleread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    InetAddress clientAddress&#123;&#125;;</span><br><span class="line">    <span class="type">int</span> connfd = acceptSocket_.<span class="built_in">accept</span>(clientAddress);</span><br><span class="line">    <span class="keyword">if</span>(connfd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(connectionCallBack_) &#123;</span><br><span class="line">            <span class="built_in">connectionCallBack_</span>(connfd, clientAddress);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">close</span>(connfd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;in Acceptor::handleRead&quot;</span>);</span><br><span class="line">        <span class="comment">// 由于采用了LT，为了防止一直通知，使用idlefd_来接受读事件</span></span><br><span class="line">        <span class="comment">//`idleFd_`的设计是为了优雅地处理文件描述符耗尽的情况，确保系统在高负载下仍能稳定工作。</span></span><br><span class="line">        <span class="comment">//通过预先打开一个文件描述符（`/dev/null`），在文件描述符耗尽时释放它来接受新连接，</span></span><br><span class="line">        <span class="comment">//然后再重新打开`/dev/null`，这种机制可以有效避免程序因无法分配文件描述符而崩溃。</span></span><br><span class="line">        <span class="keyword">if</span> (errno == EMFILE)</span><br><span class="line">        &#123;</span><br><span class="line">            ::<span class="built_in">close</span>(idlefd_);</span><br><span class="line">            idlefd_ = ::<span class="built_in">accept</span>(acceptSocket_.<span class="built_in">fd</span>(), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">            ::<span class="built_in">close</span>(idlefd_);</span><br><span class="line">            idlefd_ = ::<span class="built_in">open</span>(<span class="string">&quot;/dev/null&quot;</span>, O_RDONLY | O_CLOEXEC);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>其中值得一提的是handleread的实现:</p>
<p>这里主要是建立连接，通过调用Socket的accept函数，底层调用系统的accept函数，返回一个已连接的socket描述字，这样连接就建立了。同时内部还调用了成员变量newConnectionCallback<em>保存的函数，当mainLoop监听到acceptChannel</em>上发生了可读事件时（新用户连接事件），就是调用这个handleRead( )方法,内部调用newConnetionCallback_，也就是TcpServer设置的一个回调函数setNewConnetionCallback，绑定了TcpServer::newConnection，通过 轮询算法，选择一个subloop，分发当前的新客户端的Channel，并且绑定了一些回调。</p>
</li>
</ul>
<h2 id="比较好的设计"><a href="#比较好的设计" class="headerlink" title="比较好的设计"></a>比较好的设计</h2><ul>
<li>idlefd：</li>
<li>这个思想也是很巧妙的，在调用accept的过程中，如果已用文件描述符过多，accept会返回-1，构造函数中注册的idleFd<em>就派上用场了。当前文件描述符过多，无法接收新的连接。但是由于我们采用LT模式，如果无法接收，可读事件会一直触发。那么在这个地方的处理机制就是，关掉之前创建的空的idleFd</em>，然后去accept，这样进行了连接，让这个事件不会一直触发，然后再关掉该文件描述符，重新将它设置为空文件描述符。这样就优雅的解决 EMFIFE 问题，也就是为了优雅地处理文件描述符耗尽的情况，确保系统在高负载下仍能稳定工作。</li>
</ul>
<h1 id="muduo库Buffer类"><a href="#muduo库Buffer类" class="headerlink" title="muduo库Buffer类"></a>muduo库Buffer类</h1><p>(本文参考链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_73537205/article/details/138665904">https://blog.csdn.net/m0_73537205/article/details/138665904</a>)</p>
<h2 id="为什么需要buffer类？"><a href="#为什么需要buffer类？" class="headerlink" title="为什么需要buffer类？"></a>为什么需要buffer类？</h2><ul>
<li>首先是为什么要有 <code>Buffer</code>？为什么不能直接接收和发送呢，如果直接使用 read()、write() 系统调用进行操作，就可以直接将应用层数据发送出去或者将内核数据读取到应用层，加上 <code>Buffer</code> 以后，相当于在应用层数据和内核缓冲区之间又多了一层，会不会造成负面影响呢？[2] 中明确，应用层的缓冲区是必要的，因为非阻塞 IO 的核心就是避免阻塞以在 read() 和 write() 为代表的系统调用上。 </li>
<li>对于发送来说，假设应用程序需要发送 40KB 数据，但是操作系统的 TCP 发送缓冲区只有 25KB  剩余空间，如果等待内核缓冲区可用，就会阻塞当前线程，因为不知道对方什么时候收到并读取数据。因此网络库应该把这 15KB 数据先缓存起来，等 fd 变得可写的时候立刻发送数据，这样操作才不会造成阻塞。需要注意，如果应用程序随后又要发送 50KB  数据，而此时发送缓冲区中尚有未发送的数据，那么网络库应该将这 50KB 数据追加到发送缓冲区的末尾，而不能立刻尝试  write()，因为这样有可能打乱数据的顺序。对于接收来说，假设一次读到的数据不够一个完整的数据包，那么这些已经读到的数据应该先暂存在某个地方，等剩余的数据收到之后再一并处理。所以说，发送缓冲区和接收缓冲区的存在都是必要的。 </li>
</ul>
<h2 id="Buffer设计思想"><a href="#Buffer设计思想" class="headerlink" title="Buffer设计思想"></a>Buffer设计思想</h2><ul>
<li>muduo的Buffer的定义如下，其内部是 一个 std::vector，且还存在两个size<em>t类型的readerIndex</em>，writerIndex_标识来表示读写的位置。结构图如下：</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/2024-07-25-muduo网络库学习/f8c9c09e6a1b48aea757f936f931ae64.png" alt="img"></p>
<ul>
<li><p>readIndex、writeIndex把整个vector内容分为3块：prependable、readable、writable，各块大小关系：</p>
<ul>
<li>prependable = readIndex</li>
<li>readable = writeIndex - readIndex</li>
<li>writable = buffer.size() - writeIndex</li>
</ul>
</li>
<li><p>Buffer类是可以动态扩容的，在下面的成员函数中，会详细介绍。</p>
</li>
</ul>
<h2 id="Buffer重要成员变量"><a href="#Buffer重要成员变量" class="headerlink" title="Buffer重要成员变量"></a>Buffer重要成员变量</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//缓冲区头部</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">size_t</span> kCheapPrepend = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//缓冲区读写初始大小</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">size_t</span> kInitialSize = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">char</span>&gt; buffer_;</span><br><span class="line"><span class="type">size_t</span> readerIndex_;</span><br><span class="line"><span class="type">size_t</span> writerIndex_;</span><br></pre></td></tr></table></figure>
<ul>
<li>其中readerIndex_指向的可读地区的起始地址</li>
<li>writerIndec_指向的是可写位置的起始地址</li>
</ul>
<h2 id="Buffer重要成员函数"><a href="#Buffer重要成员函数" class="headerlink" title="Buffer重要成员函数"></a>Buffer重要成员函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回可读的缓冲区大小</span></span><br><span class="line">    [[nodiscard]] <span class="function"><span class="type">size_t</span> <span class="title">readAbleBytes</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> writerIndex_ - readerIndex_;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回可写的缓冲区大小</span></span><br><span class="line">    [[nodiscard]] <span class="function"><span class="type">size_t</span> <span class="title">writeAbleBytes</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> buffer_.<span class="built_in">size</span>() - writerIndex_;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回缓冲区头部大小</span></span><br><span class="line">    [[nodiscard]] <span class="function"><span class="type">size_t</span> <span class="title">prependAbleBytes</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> readerIndex_;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回缓冲区中可读数据的起始地址</span></span><br><span class="line">    [[nodiscard]] <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">peek</span><span class="params">()</span> <span class="type">const</span></span>&#123; <span class="keyword">return</span> <span class="built_in">begin</span>() + readerIndex_;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回缓冲区可以写的起始地址</span></span><br><span class="line">    [[nodiscard]] <span class="function"><span class="type">char</span>* <span class="title">beginWrite</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">begin</span>() + writerIndex_; &#125;</span><br><span class="line"></span><br><span class="line">    [[nodiscard]] <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">beginWrite</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">begin</span>() + writerIndex_; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回数据的首地址</span></span><br><span class="line">    [[nodiscard]] <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">//it.operator*() 首元素  it.operator*().operator&amp;() 首元素的地址</span></span><br><span class="line">        <span class="keyword">return</span> &amp;*buffer_.<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [[nodiscard]] <span class="function"><span class="type">char</span>* <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//it.operator*() 首元素  it.operator*().operator&amp;() 首元素的地址</span></span><br><span class="line">        <span class="keyword">return</span> &amp;*buffer_.<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这几个代码功能如注释所示</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="comment">// 把[data ,data+len]内存上的数据，添加到writeable缓冲区当中</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">append</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* data, <span class="type">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确定是否可以写入</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ensureWriterableBytes</span><span class="params">(<span class="type">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容操作</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">makespace</span><span class="params">(<span class="type">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//===================================以下为对应实现============================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 考虑两种扩容情况</span></span><br><span class="line"><span class="comment">// 1. 预留空间 加上 可写空间不足的的话 就直接扩容</span></span><br><span class="line"><span class="comment">// 2. 否则 就不直接扩容，而是重新分配下 内部结构</span></span><br><span class="line"><span class="comment">// 这样可以避免内存空间的浪费</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::makespace</span><span class="params">(<span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">prependAbleBytes</span>() + <span class="built_in">writeAbleBytes</span>() &lt; len + kCheapPrepend) &#123;</span><br><span class="line">        buffer_.<span class="built_in">resize</span>(writerIndex_ + len);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">size_t</span> readable = <span class="built_in">readAbleBytes</span>();</span><br><span class="line">        std::<span class="built_in">copy</span>(<span class="built_in">begin</span>() + readerIndex_, <span class="built_in">begin</span>() + writerIndex_, <span class="built_in">begin</span>() + kCheapPrepend);</span><br><span class="line">        readerIndex_ = kCheapPrepend;</span><br><span class="line">        writerIndex_ = readerIndex_ + readable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::ensureWriterableBytes</span><span class="params">(<span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不够写就扩容</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">writeAbleBytes</span>() &lt; len) &#123;</span><br><span class="line">        <span class="built_in">makespace</span>(len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::append</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *data, <span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ensureWriterableBytes</span>(len);</span><br><span class="line">    std::<span class="built_in">copy</span>(data, data + len, <span class="built_in">beginWrite</span>());</span><br><span class="line">    writerIndex_ += len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong><em>比较巧妙的思想是:</em></strong>在进行扩容的时候考虑两种扩容情况</p>
<ol>
<li>预留空间 加上 可写空间（prependableBytes() + writerableBytes()）不足的的话 就直接扩容</li>
<li>否则 就不直接扩容，而是重新分配下 内部结构</li>
</ol>
<p>这样可以避免内存空间的浪费（<strong>因为更新可读与可写地区的时候是通过移动两个Index实现的，可能readerIndex会一直往右移，导致空间预留空间越来越大，如果直接扩容会导致内存空间的浪费</strong>）</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/2024-07-25-muduo网络库学习/buffer扩容演示.jpg" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/2024-07-25-muduo网络库学习/扩容演示.png" alt="在这里插入图片描述"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 读len长的数据，并进行移动位置</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">retrieve</span><span class="params">(<span class="type">size_t</span> len)</span></span>; <span class="comment">//len表示已经读了的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果都读完了</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">retrieveAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把onMessage函数上报的Buffer数据，转成string类型的数据返回</span></span><br><span class="line">    <span class="function">std::string <span class="title">retrieveAllAsString</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从起始位置读len长</span></span><br><span class="line">    <span class="function">std::string <span class="title">retrieveAsString</span><span class="params">(<span class="type">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//===================================以下为对应实现============================================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::retrieve</span><span class="params">(<span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(len &lt; <span class="built_in">readAbleBytes</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//已经读的小于可读的，只读了一部分len</span></span><br><span class="line">        <span class="comment">//还剩readerIndex_ += len 到 writerIndex_</span></span><br><span class="line">        readerIndex_ += len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//len == readableBytes()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">retrieveAll</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::retrieveAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    readerIndex_ = writerIndex_ = kCheapPrepend;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">Buffer::retrieveAllAsString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">retrieveAsString</span>(<span class="built_in">readAbleBytes</span>());<span class="comment">//应用可读取数据的长度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">Buffer::retrieveAsString</span><span class="params">(<span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从起始位置读len长</span></span><br><span class="line">    std::string result&#123;<span class="built_in">peek</span>(), len&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上面一句吧缓冲区可读的数据读出来，这里对缓冲区进行复位操作</span></span><br><span class="line">    <span class="built_in">retrieve</span>(len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这部分函数是对读数据操作的函数，其功能见注释</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//从fd上读取数据</span></span><br><span class="line">    <span class="function"><span class="type">ssize_t</span> <span class="title">readFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span>* saveErrno)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过fd发送数据</span></span><br><span class="line">    <span class="function"><span class="type">ssize_t</span> <span class="title">writeFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span>* saveErrno)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// ===========================其对应实现===================================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">Buffer::readFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> *saveErrno)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 栈上的临时空间，分配64K</span></span><br><span class="line">    <span class="type">char</span> extrabuf[<span class="number">65536</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">iovec</span> vec[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// buffer底层缓冲区剩余可以写的空间</span></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> writable = <span class="built_in">writeAbleBytes</span>();</span><br><span class="line">    vec[<span class="number">0</span>].iov_base = <span class="built_in">begin</span>() + writerIndex_;</span><br><span class="line">    vec[<span class="number">0</span>].iov_len = writable;</span><br><span class="line"></span><br><span class="line">    vec[<span class="number">1</span>].iov_base = extrabuf;</span><br><span class="line">    vec[<span class="number">1</span>].iov_len = <span class="keyword">sizeof</span> extrabuf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// writable &lt; sizeof extrabuf就选2块，否则一块就够用</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> iovcnt = (writable &lt; <span class="keyword">sizeof</span> extrabuf)? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">ssize_t</span> n = <span class="built_in">readv</span>(fd, vec, iovcnt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *saveErrno = errno;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n &lt;= writable) <span class="comment">//buffer可写的缓冲区已经够存储读取出来的数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        writerIndex_ += n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//extrabufl里面也写入了数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        writerIndex_ = buffer_.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//writerIndex_ 开始写n-writable的数据</span></span><br><span class="line">        <span class="built_in">append</span>(extrabuf,n-writable);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">Buffer::writeFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> *saveErrno)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">ssize_t</span> n = <span class="built_in">write</span>(fd, <span class="built_in">peek</span>(), <span class="built_in">readAbleBytes</span>());</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *saveErrno = errno;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><em>读数据的设计思想:</em></strong><ul>
<li>我们在读数据的时候，不知道数据的最终大小是多少，所以采用了如下的方法：<ol>
<li>首先会在栈区开一个64k的空间，利用栈的好处是可以自动的释放，并计算出目前剩余可写的空间大小；</li>
<li>利用结构体 iovec 指定了两块缓冲区，一块是目前剩余的可写的Buffer，一个是临时的缓冲区，指定了起始位置以及缓冲区的大小；</li>
<li>const int iovcnt = (writable &lt; sizeof extrabuf) ? 2 : 1; 如果writable &lt; sizeof extrabuf就选2块内存readv，否则一块就够用；</li>
<li>读数据const ssize_t n = ::readv(fd, vec, iovcnt);</li>
<li>若读取的数据超过现有内部buffer<em>的writable空间大小时, 启用备用的extrabuf 64KB空间, 并将这些数据添加到内部buffer</em>的末尾。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="iovec结构体定义"><a href="#iovec结构体定义" class="headerlink" title="iovec结构体定义"></a>iovec结构体定义</h3><p>​    </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iovec</span> &#123;</span><br><span class="line">    <span class="type">ptr_t</span> iov_base; <span class="comment">/* Starting address */</span></span><br><span class="line">    <span class="type">size_t</span> iov_len; <span class="comment">/* Length in bytes */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>struct iovec定义了一个向量元素。通常，这个结构用作一个多元素的数组。对于每一个传输的元素，指针成员iov_base指向一个缓冲区，这个缓冲区是存放的是readv所接收的数据或是writev将要发送的数据。成员iov_len在各种情况下分别确定了接收的最大长度以及实际写入的长度。</li>
<li>其中<strong>readv函数</strong>可以一次性向多个缓冲区读数据，而不用挨个调用，减少系统调用次数，writev同理</li>
</ul>
<h1 id="muduo库TcpConnection类"><a href="#muduo库TcpConnection类" class="headerlink" title="muduo库TcpConnection类"></a>muduo库TcpConnection类</h1><h2 id="设计思想以及一些感悟"><a href="#设计思想以及一些感悟" class="headerlink" title="设计思想以及一些感悟"></a>设计思想以及一些感悟</h2><ul>
<li><p><strong><em>在学习此网络库之前我并不知道到底什么时候该用智能指针，什么时候不该用，在一些情况下使用智能指针会带来额外的性能开销，所以不能无脑梭哈，所以不知道该如何权衡使用它们，但是学习之后我得到了一些启发</em></strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******** Callbacks.h  ********/</span></span><br><span class="line"><span class="keyword">using</span> TcpConnectionPtr = std::shared_ptr&lt;TcpConnection&gt;;</span><br><span class="line"><span class="comment">/******** TcpServer.cc ********/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpServer::newConnection</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> InetAddress &amp;peerAddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    代码省略</span><br><span class="line">	<span class="function">TcpConnectionPtr <span class="title">conn</span><span class="params">(<span class="keyword">new</span> TcpConnection(ioLoop, connName, sockfd, localAddr, peerAddr))</span></span>;</span><br><span class="line">    connections_[connName] = conn;</span><br><span class="line">    代码省略</span><br><span class="line">    ioLoop-&gt;<span class="built_in">runInLoop</span>(<span class="built_in">bind</span>(&amp;TcpConnection::connectEstablished, conn));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>在TcpServer::newConnection()函数中，当接受了一个新用户连接，就要把这个Tcp连接封装成一个TcpConnection对象，也就是上面代码中的new TcpConnection(…)。然后用一个共享型智能指针来管理这个对象。<strong>所以为什么这里要把TcpConnection用智能指针来管理？</strong></p>
</li>
<li><p>这里使用智能指针管理TcpConnetion的最重要原因<strong>在于防止指针悬空</strong>，而指针悬空可能会来自以下这三个方面：</p>
<ul>
<li><p>考虑一种情况，如果在通信的时候，用户手贱将TcpConnection给删除了，删除了之后，程序内部还要好几处地方都在使用TcpConnection对象。结果这个对象的内存突然消失了，服务器访问非法内存崩溃。我们不能防止用户做这些事情，所以<strong>编程设计不可以依赖用户行为，一定要尽可能地封死用户的误操作。所以这里用了共享智能指针。</strong></p>
</li>
<li><p>但是单单只使用一个shared_ptr还不足以解决上述问题，还需要配合weak_ptr来实现生命周期的延长，在muduo中就有这样的设计，这个设计非常的好，值得学习，以下为具体内容</p>
</li>
</ul>
</li>
</ul>
<pre><code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TcpConnection</span> : noncopyable,<span class="keyword">public</span> std::enable_shared_from_this&lt;TcpConnection&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">TcpConnection</span>(EventLoop *loop,</span><br><span class="line">            <span class="type">const</span> std::string &amp;name,</span><br><span class="line">            <span class="type">int</span> sockfd,</span><br><span class="line">            <span class="type">const</span> InetAddress &amp;localAddr,</span><br><span class="line">            <span class="type">const</span> InetAddress &amp;peerAddr);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/***** TcpConnection.cpp *****/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::connectEstablished</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">setState</span>(kConnected);</span><br><span class="line">    channel_-&gt;<span class="built_in">tie</span>(<span class="built_in">shared_from_this</span>());</span><br><span class="line">    channel_-&gt;<span class="built_in">enableReading</span>(); <span class="comment">//向poller注册channel的epollin事件</span></span><br><span class="line">    <span class="comment">//新连接建立，执行回调</span></span><br><span class="line">    <span class="built_in">connectionCallback_</span>(<span class="built_in">shared_from_this</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



- Tcpconnection设计的时候继承了enable_shared_from_this，这使得能通过调用shared_from_this,获得一个共享指针

- 假如我们在TcpConnection对象（我们管这个对象叫TCA）中的成员函数中调用了shared_from_this()，该函数可以返回一个shared_ptr，并且这个shared_ptr指向的对象是TCA。
- 接着这个shared_ptr就作为channel_的Channel::tie()函数的函数参数。
- 再根据上述Channel专栏中讲的[重要设计](#重要设计)，可知使用智能指针的好处
</code></pre><ul>
<li><p>考虑第二种情况，<strong>TcpConnection对象的多线程安全问题：</strong></p>
<ul>
<li>假如服务器要关闭了这个时候MainEventLoop线程中的TcpServer::~TcpServer()函数开始把所有TcpConnection对象都删掉。那么其他线程还在使用这个TcpConnection对象，如果你把它的内存空间都释放了，其他线程访问了非法内存，会直接崩溃。</li>
<li>你可能会觉得，反正我都要把服务器给关了，崩就崩了吧。这种想法是错的！因为可能在你关闭服务器的时候，其他线程正在处理TcpConnection的发送消息任务，这个时候你应该等它发完才释放TcpConnection对象的内存才对！</li>
<li>使用智能指针就很好的解决了这个问题，即使在一个线程中删除一个TcpConnection，也只是删除了引用，而只要引用技术不为0就不会删除掉</li>
</ul>
</li>
</ul>
<h2 id="TcpConnection重要成员变量"><a href="#TcpConnection重要成员变量" class="headerlink" title="TcpConnection重要成员变量"></a>TcpConnection重要成员变量</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个subloop</span></span><br><span class="line">   EventLoop *loop_;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Connection的名字</span></span><br><span class="line">   <span class="type">const</span> std::string name_;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//Connection的状态</span></span><br><span class="line">   std::atomic_int state_;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 是否正在读</span></span><br><span class="line">   <span class="type">bool</span> reading_;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Connection对应的socket</span></span><br><span class="line">   std::unique_ptr&lt;Socket&gt; socket_;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Connection对应的channel</span></span><br><span class="line">   std::unique_ptr&lt;Channel&gt; channel_;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 本地的地址</span></span><br><span class="line">   InetAddress localAddr_;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 对端的地址</span></span><br><span class="line">   InetAddress peerAddr_;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下三个回调都是用户设置给TcpServer=&gt;（传给）TcpConnection=&gt;Channel=&gt;Poller=&gt;notify channel调用回调</span></span><br><span class="line">   ConnectionCallback connectionCallback_; <span class="comment">//有新连接时的回调</span></span><br><span class="line">   MessageCallback messageCallback_; <span class="comment">//有读写消息时的回调</span></span><br><span class="line">   WriteCompleteCallback writeCompleteCallback_; <span class="comment">//消息发送完成以后的回调</span></span><br><span class="line">   CloseCallback closeCallback_; <span class="comment">// 关闭回调</span></span><br><span class="line">   HighWaterMarkCallback highWaterMarkCallback_; <span class="comment">// 高水位回调</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 水位的阀值</span></span><br><span class="line">   <span class="type">size_t</span> highWaterMark_;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 接受数据的缓冲区</span></span><br><span class="line">   Buffer inputBuffer_;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 发送数据的缓冲区</span></span><br><span class="line">   Buffer outputBuffer_;</span><br></pre></td></tr></table></figure>
<ul>
<li>具体含义见注释</li>
<li>其中两个输入输出缓冲区，在输出缓冲区是用于暂存那些暂时发送不出去的待发送数据。因为Tcp发送缓冲区是有大小限制的，假如达到了高水位线，就没办法把发送的数据通过send()直接拷贝到Tcp发送缓冲区，而是暂存在这个outputBuffer<em>中，等TCP发送缓冲区有空间了，触发可写事件了，再把outputBuffer</em>中的数据拷贝到Tcp发送缓冲区中。</li>
</ul>
<h2 id="TcpConnection重要成员函数"><a href="#TcpConnection重要成员函数" class="headerlink" title="TcpConnection重要成员函数"></a>TcpConnection重要成员函数</h2><ul>
<li><p>首先来看下构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> EventLoop *<span class="title">CheckLoopNotNull</span><span class="params">(EventLoop* loop)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(loop == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_FATAL</span>(<span class="string">&quot;%s:%s:%d TcpConnection loop is null! \n&quot;</span>,__FILE__,__FUNCTION__,__LINE__);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> loop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TcpConnection::<span class="built_in">TcpConnection</span>(EventLoop *loop,</span><br><span class="line">            <span class="type">const</span> std::string &amp;nameArg,</span><br><span class="line">            <span class="type">int</span> sockfd,</span><br><span class="line">            <span class="type">const</span> InetAddress &amp;localAddr,</span><br><span class="line">            <span class="type">const</span> InetAddress &amp;peerAddr)</span><br><span class="line">        : <span class="built_in">loop_</span>(<span class="built_in">CheckLoopNotNull</span>(loop))</span><br><span class="line">        , <span class="built_in">name_</span>(nameArg)</span><br><span class="line">        , <span class="built_in">state_</span>(kConnecting)</span><br><span class="line">        , <span class="built_in">reading_</span>(<span class="literal">true</span>)</span><br><span class="line">        , <span class="built_in">socket_</span>(std::<span class="built_in">make_unique</span>&lt;Socket&gt;(sockfd))</span><br><span class="line">        , <span class="built_in">channel_</span>(std::<span class="built_in">make_unique</span>&lt;Channel&gt;(sockfd, loop))</span><br><span class="line">        , <span class="built_in">localAddr_</span>(localAddr)</span><br><span class="line">        , <span class="built_in">peerAddr_</span>(peerAddr)</span><br><span class="line">        , <span class="built_in">highWaterMark_</span>(<span class="number">64</span>*<span class="number">1024</span>*<span class="number">1024</span>) <span class="comment">//64M</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//下面给channel设置相应的回调函数</span></span><br><span class="line">            <span class="comment">//poller给channel通知感兴趣的事件发生了</span></span><br><span class="line">            <span class="comment">//channel会回调相应的操作函数</span></span><br><span class="line">            <span class="comment">//将TcpConnection自己的成员函数注册给当前accept返回的connfd对应的Channel对象上</span></span><br><span class="line">            channel_-&gt;<span class="built_in">setReadCallBack</span>(std::<span class="built_in">bind</span>(&amp;TcpConnection::handleRead,<span class="keyword">this</span>,std::placeholders::_1));</span><br><span class="line">            channel_-&gt;<span class="built_in">setWriteCallBack</span>(std::<span class="built_in">bind</span>(&amp;TcpConnection::handleWrite,<span class="keyword">this</span>));</span><br><span class="line">            channel_-&gt;<span class="built_in">setCloseCallBack</span>(std::<span class="built_in">bind</span>(&amp;TcpConnection::handleClose,<span class="keyword">this</span>));</span><br><span class="line">            channel_-&gt;<span class="built_in">setErrorCallBack</span>(std::<span class="built_in">bind</span>(&amp;TcpConnection::handleError,<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">            <span class="built_in">LOG_INFO</span>(<span class="string">&quot;TcpConnection::ctor[%s] at fd=%d\n&quot;</span>,name_.<span class="built_in">c_str</span>(),sockfd);</span><br><span class="line">            <span class="comment">//开启Tcp/Ip层的心跳包检测</span></span><br><span class="line">            socket_-&gt;<span class="built_in">SetKeepalive</span>(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>其功能是创建一个TcpConnection，初始化一些变量，并且设置一些回调函数以及开启心跳包检测</li>
</ul>
</li>
<li><p>接着我们看看发送数据相关的函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">/ 发送数据</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::send</span><span class="params">(<span class="type">const</span> std::string &amp;buf)</span> <span class="comment">//直接引用buffer</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 先检查是否处于连接状态</span></span><br><span class="line">    <span class="keyword">if</span>(state_ == kConnected)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 判断处理的线程是否是事件循环线程</span></span><br><span class="line">        <span class="keyword">if</span>(loop_-&gt;<span class="built_in">isInLoopThread</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//string.c_str是Borland封装的String类中的一个函数，它返回当前字符串的首字符地址。</span></span><br><span class="line">            <span class="built_in">sendInLoop</span>(buf.<span class="built_in">c_str</span>(),buf.<span class="built_in">size</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            loop_-&gt;<span class="built_in">runInLoop</span>(std::<span class="built_in">bind</span>(&amp;TcpConnection::sendInLoop</span><br><span class="line">                                , <span class="keyword">this</span></span><br><span class="line">                                , buf.<span class="built_in">c_str</span>()</span><br><span class="line">                                , buf.<span class="built_in">size</span>()</span><br><span class="line">            ));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送数据，应用写得快，内核发送数据慢，</span></span><br><span class="line"><span class="comment"> * 需要把待发送的数据写入缓冲区</span></span><br><span class="line"><span class="comment"> * 且设置了水位回调，防止发送太快</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::sendInLoop</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* data, <span class="type">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">ssize_t</span> nwrote = <span class="number">0</span>; <span class="comment">// 已经写了多少数据</span></span><br><span class="line">    <span class="type">size_t</span> remaining = len; <span class="comment">//未发送的数据</span></span><br><span class="line">    <span class="type">bool</span> faultError = <span class="literal">false</span>; <span class="comment">//记录是否产生错误</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//之前调用过connection的shutdown 不能在发送了</span></span><br><span class="line">    <span class="keyword">if</span>(state_ == kDisconnected)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;disconnected,give up writing!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//channel 第一次开始写数据，且缓冲区没有待发送数据</span></span><br><span class="line">    <span class="keyword">if</span>(!channel_-&gt;<span class="built_in">isWriteEvent</span>() &amp;&amp; outputBuffer_.<span class="built_in">readAbleBytes</span>() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        nwrote = ::<span class="built_in">write</span>(channel_-&gt;<span class="built_in">fd</span>(),data,len);</span><br><span class="line">        <span class="keyword">if</span>(nwrote &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 更新剩余数据</span></span><br><span class="line">            remaining = len - nwrote;</span><br><span class="line">            <span class="keyword">if</span>(remaining == <span class="number">0</span> &amp;&amp; writeCompleteCallback_)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//一次性数据全部发送完成，就不要再给channel设置epollout事件了</span></span><br><span class="line">                loop_-&gt;<span class="built_in">queueInLoop</span>(</span><br><span class="line">                    std::<span class="built_in">bind</span>(writeCompleteCallback_,<span class="built_in">shared_from_this</span>()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            nwrote = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(errno != EWOULDBLOCK) <span class="comment">//用于非阻塞模式，不需要重新读或者写</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;TcpConnection::sendInLoop&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span>(errno == EPIPE || errno == ECONNRESET) <span class="comment">//SIGPIPE RESET</span></span><br><span class="line">                &#123;</span><br><span class="line">                    faultError = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 说明当前这一次write ，并没有把数据全发送出去，剩余的数据</span></span><br><span class="line">    <span class="comment">// 需要保存到缓冲区当中，给channel注册epollout事件</span></span><br><span class="line">    <span class="comment">// poller发现tcp发送缓冲区有空间，会通知相应的socket-channel</span></span><br><span class="line">    <span class="comment">// 调用相应的writeCallback（）回调方法</span></span><br><span class="line">    <span class="comment">// 也就是调用TcpConnection::handleWrite，把发送缓冲区中数据全部发送出去</span></span><br><span class="line">    <span class="keyword">if</span>(!faultError &amp;&amp; remaining &gt; <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//目前发送缓冲区剩余的待发送数据的长度</span></span><br><span class="line">        <span class="type">size_t</span> oldlen = outputBuffer_.<span class="built_in">readAbleBytes</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(oldlen + remaining &gt;= highWaterMark_ </span><br><span class="line">            &amp;&amp; oldlen &lt; highWaterMark_</span><br><span class="line">            &amp;&amp; highWaterMark_)</span><br><span class="line">            &#123;</span><br><span class="line">                loop_-&gt;<span class="built_in">queueInLoop</span>(</span><br><span class="line">                    std::<span class="built_in">bind</span>(highWaterMarkCallback_,<span class="built_in">shared_from_this</span>(),oldlen + remaining)</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 把未发送的数据加入到发送缓冲区</span></span><br><span class="line">            outputBuffer_.<span class="built_in">append</span>((<span class="type">char</span>*)data + nwrote,remaining);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!channel_-&gt;<span class="built_in">isWriteEvent</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                channel_-&gt;<span class="built_in">enableWriting</span>(); <span class="comment">//注册channel写事件，否则poller不会向channel通知epollout</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>为了秉持一个线程占用一个eventloop所以我们要确保执行发送任务的时候是发生在事件循环线程中 所以要进行一次判断，如果不是得投放到任务容器里等待被唤醒</li>
<li>发送数据的时候，会有两种情况，一种是第一次发送直接全部发送完了，这时候将它放入事件循环的处理函数容器，并唤醒对应线程处理，第二种情况是第一次没发完，这时就需要将未发完的数据存入outputBuffer里，存入的时候需要进行比较oldlen + remaining &gt;= highWaterMark<em> &amp;&amp; oldlen &lt; highWaterMark</em>&amp;&amp; highWaterMark_，如果满足就进行高水位回调（这有助于防止发送方发送过多数据，导致接收方无法及时处理。）</li>
<li>剩余的数据保存到缓冲区当中，要给给channel注册epollout事件(切记，一定要注册channel的写事件，否则poller不会向channel通知epollout)，这样poller发现tcp发送缓冲区有空间，会通知相应的socket-channel调用相应的writeCallback（）回调方法，也就是调用TcpConnection::handleWrite，把发送缓冲区中数据全部发送出去。</li>
</ul>
</li>
<li><p>一系列的回调函数处理</p>
<ul>
<li>handleread</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::handleRead</span><span class="params">(TimeStamp receiveTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> savedErrno = <span class="number">0</span>;</span><br><span class="line">    <span class="type">ssize_t</span> n = inputBuffer_.<span class="built_in">readFd</span>(channel_-&gt;<span class="built_in">fd</span>(),&amp;savedErrno);</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 已建立连接的用户，有可读事件发生了，调用用户传入的回调操作onMessage</span></span><br><span class="line">        <span class="comment">// shared_from_this()获取了当前TcpConnection对象的智能指针</span></span><br><span class="line">        <span class="built_in">messageCallback_</span>(<span class="built_in">shared_from_this</span>(),&amp;inputBuffer_,receiveTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="comment">//客户端断开</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">handleClose</span>();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        errno = savedErrno;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;TcpConnection::hanleRead&quot;</span>);</span><br><span class="line">        <span class="built_in">handleError</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::handleWrite</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(channel_-&gt;<span class="built_in">isWriteEvent</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> savedErrno = <span class="number">0</span>;</span><br><span class="line">        <span class="type">ssize_t</span> n = outputBuffer_.<span class="built_in">writeFd</span>(channel_-&gt;<span class="built_in">fd</span>(),&amp;savedErrno);</span><br><span class="line">        <span class="keyword">if</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            outputBuffer_.<span class="built_in">retrieve</span>(n); <span class="comment">//处理了n个</span></span><br><span class="line">            <span class="keyword">if</span>(outputBuffer_.<span class="built_in">readAbleBytes</span>() == <span class="number">0</span>) <span class="comment">//发送完成</span></span><br><span class="line">            &#123;</span><br><span class="line">                channel_-&gt;<span class="built_in">disableWriting</span>(); <span class="comment">//不可写了</span></span><br><span class="line">                <span class="keyword">if</span>(writeCompleteCallback_)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//唤醒loop对应的thread线程，执行回调</span></span><br><span class="line">                    loop_-&gt;<span class="built_in">queueInLoop</span>(</span><br><span class="line">                        std::<span class="built_in">bind</span>(writeCompleteCallback_,<span class="built_in">shared_from_this</span>())</span><br><span class="line">                    );</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(state_ == kDisconnecting)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">shutdownInLoop</span>();<span class="comment">// 在当前loop中删除TcpConnection</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;TcpConnection::handleWrite&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;TcpConnection fd=%d is down, no more writing \n&quot;</span>,channel_-&gt;<span class="built_in">fd</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><ul>
<li>关于readFd在Buffer类中我们已经剖析过了<a href="#muduo库Buffer类">Buffer类</a>，接着已建立连接的用户，有可读事件发生了，调用用户传入的回调操作<code>onMessage</code>，<code>shared_from_this()</code>获取了当前TcpConnection对象的智能指针.</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>handlewirte</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::handleWrite</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(channel_-&gt;<span class="built_in">isWriteEvent</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> savedErrno = <span class="number">0</span>;</span><br><span class="line">        <span class="type">ssize_t</span> n = outputBuffer_.<span class="built_in">writeFd</span>(channel_-&gt;<span class="built_in">fd</span>(),&amp;savedErrno);</span><br><span class="line">        <span class="keyword">if</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            outputBuffer_.<span class="built_in">retrieve</span>(n); <span class="comment">//处理了n个</span></span><br><span class="line">            <span class="keyword">if</span>(outputBuffer_.<span class="built_in">readAbleBytes</span>() == <span class="number">0</span>) <span class="comment">//发送完成</span></span><br><span class="line">            &#123;</span><br><span class="line">                channel_-&gt;<span class="built_in">disableWriting</span>(); <span class="comment">//不可写了</span></span><br><span class="line">                <span class="keyword">if</span>(writeCompleteCallback_)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//唤醒loop对应的thread线程，执行回调</span></span><br><span class="line">                    loop_-&gt;<span class="built_in">queueInLoop</span>(</span><br><span class="line">                        std::<span class="built_in">bind</span>(writeCompleteCallback_,<span class="built_in">shared_from_this</span>())</span><br><span class="line">                    );</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(state_ == kDisconnecting)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">shutdownInLoop</span>();<span class="comment">// 在当前loop中删除TcpConnection</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;TcpConnection::handleWrite&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;TcpConnection fd=%d is down, no more writing \n&quot;</span>,channel_-&gt;<span class="built_in">fd</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果可写，通过fd发送数据，直到发送完成</p>
</li>
<li>设置不可写，如果writeCompleteCallback_，唤醒loop对应的thread线程，执行回调</li>
<li>当前TCP正在断开连接，调用<code>shutdownInLoop</code>，在当前loop中删除TcpConnection</li>
</ul>
<ul>
<li><p>handleclose</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Poller =&gt; Channel::closeCallback =&gt; TcpConnection::handlerClose</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::handleClose</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;TcpConnection::handleClose fd=%d state=%d \n&quot;</span>,channel_-&gt;<span class="built_in">fd</span>(),(<span class="type">int</span>)state_);</span><br><span class="line">    <span class="built_in">setState</span>(kDisconnected);</span><br><span class="line">    channel_-&gt;<span class="built_in">disableAll</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">TcpConnectionPtr <span class="title">connPtr</span><span class="params">(shared_from_this())</span></span>;</span><br><span class="line">    <span class="built_in">connectionCallback_</span>(connPtr); <span class="comment">//执行连接关闭的回调</span></span><br><span class="line">    <span class="built_in">closeCallback_</span>(connPtr); <span class="comment">//关闭连接的回调 TcpServer =&gt; TcpServer::removeConnection</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>处理逻辑就是将这个TcpConnection对象中的channel<em>从事件监听器中移除。然后调用connectionCallback</em>和closeCallback<em>保存的回调函数。closeCallback</em>在TcpServer::newConnection()为新连接新建TcpConnection时，已设为TcpServer::removeConnection()，而removeConnection()最终会调用TcpConnection::connectDestroyed()来销毁连接资源。</p>
</li>
</ul>
<ul>
<li><p>handleerror</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::handleError</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> optval;</span><br><span class="line">    <span class="type">socklen_t</span> optlen = <span class="keyword">sizeof</span> optval;</span><br><span class="line">    <span class="type">int</span> err = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(::<span class="built_in">getsockopt</span>(channel_-&gt;<span class="built_in">fd</span>(),SOL_SOCKET,SO_ERROR,&amp;optval,&amp;optlen) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        err = errno;        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        err = optval;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;TcpConnection::handleError name:%s - SO_ERROR:%d \n&quot;</span>,name_.<span class="built_in">c_str</span>(),err);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>关闭写端函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//关闭连接</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::shutdown</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(state_ == kConnected)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">setState</span>(kDisconnecting);</span><br><span class="line">        loop_-&gt;<span class="built_in">runInLoop</span>(</span><br><span class="line">            std::<span class="built_in">bind</span>(&amp;TcpConnection::shutdownInLoop,<span class="keyword">this</span>)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::shutdownInLoop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!channel_-&gt;<span class="built_in">isWriteEvent</span>()) <span class="comment">//说明当前outputBuffer中的数据已经全部发送完成</span></span><br><span class="line">    &#123;</span><br><span class="line">        socket_-&gt;<span class="built_in">shutDownWrite</span>(); <span class="comment">// 关闭写端</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>注意</strong>： 为什么是关闭了写端呢？在TcpConnection::shutdownInLoop()中，我们会发现它调用了Socket的shutdowmWrite，这里并没有使用close，<strong><em>陈硕大佬原话是这样的：Muduo TcpConnection 没有提供 close，而只提供 shutdown ，这么做是为了收发数据的完整性。因为TCP 是一个全双工协议，同一个文件描述符既可读又可写， shutdownWrite() 关闭了“写”方向的连接，保留了“读”方向，这称为 TCP half-close。如果直接 close(socket_fd)，那么 socket_fd 就不能读或写了。用 shutdown 而不用 close 的效果是，如果对方已经发送了数据，这些数据还“在路上”，那么 muduo 不会漏收这些数据。换句话说，muduo 在 TCP 这一层面解决了“当你打算关闭网络连接的时候，如何得知对方有没有发了一些数据而你还没有收到？”这一问题。当然，这个问题也可以在上面的协议层解决，双方商量好不再互发数据，就可以直接断开连接。等于说 muduo 把“主动关闭连接”这件事情分成两步来做，如果要主动关闭连接，它会先关本地“写”端，等对方关闭之后，再关本地“读”端。</em></strong></li>
<li>另外如果当前outputbuffer里面还有数据尚未发出的话，Muduo也不会立刻调用shutwownWrite，而是等到数据发送完毕再shutdown，可以避免对方漏收数据。</li>
<li><p>关闭连接事件很重要，涉及到TcpConnection和Channel的生命周期以及是否能合理销毁，用了智能指针来管理和控制生命周期。下面我们就来分析一下断开流程中<strong>TcpConnection的引用计数问题</strong>：</p>
<ol>
<li>首先连接到来创建TcpConnection，并存入容器。引用计数+1 总数：1</li>
<li>客户端断开连接，在Channel的handleEvent函数中会将Channel中的TcpConnection弱指针提升,引用计数+1 总数：2</li>
<li>触发HandleRead ，可读字节0，进而触发HandleClose,HandleClose函数中栈上的TcpConnectionPtr guardThis会继续将引用计数+1 总数：3</li>
<li>触发HandleClose的回调函数 在TcpServer::removeConnection结束后(回归主线程队列)，释放HandleClose的栈指针，以及Channel里提升的指针引用计数-2 总数：1</li>
<li>主线程执行回调removeConnectionInLoop，在函数内部将tcpconnection从TcpServer中保存连接容器中erase掉。但在removeConnectionInLoop结用conn为参数构造了bind。引用计数不变 总数：1</li>
<li>回归次线程处理connectDestroyed事件，结束完释放参数传递的最后一个shard_ptr，释放TcpConnection。引用计数-1 总数：0</li>
</ol>
</li>
<li><p>连接建立与删除函数</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//建立连接</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::connectEstablished</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">setState</span>(kConnected);</span><br><span class="line">    channel_-&gt;<span class="built_in">tie</span>(<span class="built_in">shared_from_this</span>());</span><br><span class="line">    channel_-&gt;<span class="built_in">enableReading</span>(); <span class="comment">//向poller注册channel的epollin事件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//新连接建立 执行回调</span></span><br><span class="line">    <span class="built_in">connectionCallback_</span>(<span class="built_in">shared_from_this</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁连接</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::connectDestroyed</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(state_ == kConnected)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">setState</span>(kDisconnected);</span><br><span class="line">        channel_-&gt;<span class="built_in">disableAll</span>(); <span class="comment">//把channel所有感兴趣的事件，从poller中del掉</span></span><br><span class="line">        <span class="built_in">connectionCallback_</span>(<span class="built_in">shared_from_this</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    channel_-&gt;<span class="built_in">remove</span>();<span class="comment">//把channel从poller中删除掉</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="muduo库TcpServer类"><a href="#muduo库TcpServer类" class="headerlink" title="muduo库TcpServer类"></a>muduo库TcpServer类</h1><ul>
<li>TcpServer与用户打交道，用户可以传入读回调函数，写完成回调等函数给TcpConnection</li>
<li>TcpServer 发送逻辑给Acceptor或者TcpConnection,进行相应处理</li>
</ul>
<h2 id="TcpServer重要成员变量"><a href="#TcpServer重要成员变量" class="headerlink" title="TcpServer重要成员变量"></a>TcpServer重要成员变量</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//baseloop_用户定义的loop</span></span><br><span class="line">    EventLoop *loop_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 本地ip端口</span></span><br><span class="line">    <span class="type">const</span> std::string ipPort_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 名称</span></span><br><span class="line">    std::string name_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用来连接新到的客户端</span></span><br><span class="line">    std::unique_ptr&lt;Acceptor&gt; acceptor_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向一个线程池</span></span><br><span class="line">    std::shared_ptr&lt;EventLoopThreadPool&gt; threadPool_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有新连接时的回调</span></span><br><span class="line">    ConnectionCallback connectionCallback_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有读写消息时的回调</span></span><br><span class="line">    MessageCallback messageCallback_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消息发送完成以后的回调</span></span><br><span class="line">    WriteCompleteCallback writeCompleteCallback_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//LOOP线程初始化的回调 std::function类型 调用者，调用回调函数</span></span><br><span class="line">    ThreadInitCallback threadInitCallback_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//防止一个TcpServer对象被start多次</span></span><br><span class="line">    std::atomic_int started_;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> nextConnId_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用来存储Connection的map</span></span><br><span class="line">    ConnectionMap connMap_;</span><br></pre></td></tr></table></figure>
<ul>
<li>详解见注释</li>
</ul>
<h2 id="TcpServer重要成员函数"><a href="#TcpServer重要成员函数" class="headerlink" title="TcpServer重要成员函数"></a>TcpServer重要成员函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TcpServer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;TcpConnection.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;logger.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> EventLoop* <span class="title">CheckLoopNotNull</span><span class="params">(EventLoop* loop)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(loop == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_FATAL</span>(<span class="string">&quot;%s:%s:%d mainloop is null! \n&quot;</span>,__FILE__,__FUNCTION__,__LINE__);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> loop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TcpServer::<span class="built_in">TcpServer</span>(EventLoop *loop, <span class="type">const</span> InetAddress &amp;listenAddr, <span class="type">const</span> std::string &amp;nameArg, Option option)</span><br><span class="line">    : <span class="built_in">loop_</span>(<span class="built_in">CheckLoopNotNull</span>(loop))</span><br><span class="line">    , <span class="built_in">ipPort_</span>(listenAddr.<span class="built_in">toIpPort</span>())</span><br><span class="line">    , <span class="built_in">name_</span>(nameArg)</span><br><span class="line">    , <span class="built_in">acceptor_</span>(std::<span class="built_in">make_unique</span>&lt;Acceptor&gt;(loop, listenAddr, option == kReusePort))</span><br><span class="line">    , <span class="built_in">threadPool_</span>(std::<span class="built_in">make_shared</span>&lt;EventLoopThreadPool&gt;(loop, nameArg))</span><br><span class="line">    , <span class="built_in">messageCallback_</span>()</span><br><span class="line">    , <span class="built_in">writeCompleteCallback_</span>()</span><br><span class="line">    , <span class="built_in">started_</span>(<span class="number">0</span>)</span><br><span class="line">    , <span class="built_in">nextConnId_</span>(<span class="number">0</span>)</span><br><span class="line">    , <span class="built_in">connMap_</span>()</span><br><span class="line">&#123;</span><br><span class="line">    acceptor_-&gt;<span class="built_in">setNewConnectionCallBack</span>(std::<span class="built_in">bind</span>(&amp;TcpServer::newConnection, <span class="keyword">this</span>,</span><br><span class="line">        std::placeholders::_1, std::placeholders::_2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历connMap_, 挨个删除map中的内容，并将TcpConnection::connectDestroyed投递到conn的loop中</span></span><br><span class="line">TcpServer::~<span class="built_in">TcpServer</span>() &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; item: connMap_) &#123;</span><br><span class="line">        <span class="comment">//这个局部的shared_ptr智能指针对象，出右括号</span></span><br><span class="line">        <span class="comment">//可以自动释放new出来的TcpConnetion对象资源</span></span><br><span class="line">        <span class="function">TcpConnectionPtr <span class="title">conn</span><span class="params">(item.second)</span></span>;</span><br><span class="line">        item.second.<span class="built_in">reset</span>();</span><br><span class="line">        <span class="comment">//销毁连接</span></span><br><span class="line">        conn-&gt;<span class="built_in">getLoop</span>()-&gt;<span class="built_in">runInLoop</span>(</span><br><span class="line">            std::<span class="built_in">bind</span>(&amp;TcpConnection::connectDestroyed,conn)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpServer::newConnection</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> InetAddress &amp;peerAddr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.先用轮询算法选出一个subloop</span></span><br><span class="line">    EventLoop* ioLoop = threadPool_-&gt;<span class="built_in">getNextLoop</span>();</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">64</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span> buf,<span class="string">&quot;-%s#%d&quot;</span>,ipPort_.<span class="built_in">c_str</span>(),nextConnId_);</span><br><span class="line">    ++nextConnId_;</span><br><span class="line">    std::string connName = name_ + buf;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;TcpServer::newConnection [%s] - new connection [%s] from %s \n&quot;</span>,</span><br><span class="line">                name_.<span class="built_in">c_str</span>(),connName.<span class="built_in">c_str</span>(),peerAddr.<span class="built_in">toIpPort</span>().<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.通过socket获取其绑定的本机的ip地址和端口信息</span></span><br><span class="line">    sockaddr_in local;</span><br><span class="line">    ::<span class="built_in">bzero</span>(&amp;local,<span class="keyword">sizeof</span> local);</span><br><span class="line">    <span class="type">socklen_t</span> addrlen = <span class="keyword">sizeof</span> local;</span><br><span class="line">    <span class="keyword">if</span>(::<span class="built_in">getsockname</span>(sockfd,(sockaddr*) &amp;local,&amp;addrlen) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;sockets::getLocalAddr&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">InetAddress <span class="title">localAddr</span><span class="params">(local)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.根据连接成功的sockfd，创建 TcpConnection连接对象conn</span></span><br><span class="line">    TcpConnectionPtr conn = std::<span class="built_in">make_shared</span>&lt;TcpConnection&gt;(</span><br><span class="line">        ioLoop, connName, sockfd, localAddr, peerAddr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.下面的回调都是用户设置给TcpServer=&gt;TcpConnection=&gt;Channel=&gt;Poller=&gt;notify channel调用回调</span></span><br><span class="line">    connMap_[connName] = conn;</span><br><span class="line">    conn-&gt;<span class="built_in">setConnectionCallback</span>(connectionCallback_);</span><br><span class="line">    conn-&gt;<span class="built_in">setMessageCallback</span>(messageCallback_);</span><br><span class="line">    conn-&gt;<span class="built_in">setWriteCompleteCallback</span>(writeCompleteCallback_);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.设置了如何关闭连接的回调 conn-&gt;shutdown</span></span><br><span class="line">    conn-&gt;<span class="built_in">setCloseCallback</span>(</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;TcpServer::removeConnection,<span class="keyword">this</span>,std::placeholders::_1)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.直接调用TcpConnection::connectEstablished</span></span><br><span class="line">    ioLoop-&gt;<span class="built_in">runInLoop</span>(std::<span class="built_in">bind</span>(&amp;TcpConnection::connectEstablished,conn));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动线程池，并把Acceptor监听加到事件循环中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpServer::start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//防止一个TcpServer对象被start多次</span></span><br><span class="line">    <span class="keyword">if</span>(started_++ == <span class="number">0</span>) &#123;</span><br><span class="line">        threadPool_-&gt;<span class="built_in">start</span>(threadInitCallback_);</span><br><span class="line">        loop_-&gt;<span class="built_in">runInLoop</span>(std::<span class="built_in">bind</span>(&amp;Acceptor::listen, acceptor_.<span class="built_in">get</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置threadPool_的线程数量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpServer::setThreadNums</span><span class="params">(<span class="type">const</span> <span class="type">int</span> threadNums)</span> </span>&#123;</span><br><span class="line">    threadPool_-&gt;<span class="built_in">setThreadNums</span>(threadNums);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将删除操作投递到事件循环中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpServer::removeConnection</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn)</span> </span>&#123;</span><br><span class="line">    loop_-&gt;<span class="built_in">runInLoop</span>(std::<span class="built_in">bind</span>(&amp;TcpServer::removeConnectionInLoop, <span class="keyword">this</span>, conn));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先将connMap里的删掉，在调用TcpConnection的删除函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpServer::removeConnectionInLoop</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;TcpServer::removeConnectionInLoop [%s] - connection \n&quot;</span>,</span><br><span class="line">    name_.<span class="built_in">c_str</span>(),conn-&gt;<span class="built_in">name</span>().<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    connMap_.<span class="built_in">erase</span>(conn-&gt;<span class="built_in">name</span>()); <span class="comment">//从map表中删除</span></span><br><span class="line">    EventLoop *ioLoop = conn-&gt;<span class="built_in">getLoop</span>();</span><br><span class="line">    ioLoop-&gt;<span class="built_in">queueInLoop</span>(</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;TcpConnection::connectDestroyed,conn)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>具体功能见注释</li>
</ul>
<h1 id="muduo库Thread类"><a href="#muduo库Thread类" class="headerlink" title="muduo库Thread类"></a>muduo库Thread类</h1><h2 id="Thread重要成员变量"><a href="#Thread重要成员变量" class="headerlink" title="Thread重要成员变量"></a>Thread重要成员变量</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">std::string name_;<span class="comment">//线程名字</span></span><br><span class="line">   <span class="type">bool</span> started_;<span class="comment">//线程是否启动</span></span><br><span class="line">   <span class="type">bool</span> joined_;<span class="comment">//是否被join回收</span></span><br><span class="line">   <span class="type">pid_t</span> tid_;<span class="comment">//是否被join回收</span></span><br><span class="line">   std::shared_ptr&lt;std::thread&gt; thread_; <span class="comment">//用智能指针管理</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 线程要执行的任务</span></span><br><span class="line">   ThreadFunc func_;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 记录线程开辟了多少用于编号</span></span><br><span class="line">   <span class="type">static</span> std::atomic_int numCreated_;</span><br></pre></td></tr></table></figure>
<ul>
<li>具体见注释</li>
</ul>
<h2 id="Thread重要成员函数"><a href="#Thread重要成员函数" class="headerlink" title="Thread重要成员函数"></a>Thread重要成员函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::atomic_int <span class="title">Thread::numCreated_</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="comment">//静态成员变量 要在类外单独进行初始化</span></span><br><span class="line"></span><br><span class="line">Thread::<span class="built_in">Thread</span>(ThreadFunc func, <span class="type">const</span> std::string &amp;name)</span><br><span class="line">    : <span class="built_in">name_</span>(name)</span><br><span class="line">    , <span class="built_in">started_</span>(<span class="literal">false</span>)</span><br><span class="line">    , <span class="built_in">joined_</span>(<span class="literal">false</span>)</span><br><span class="line">    , <span class="built_in">tid_</span>(<span class="number">0</span>)</span><br><span class="line">    , <span class="built_in">func_</span>(std::<span class="built_in">move</span>(func))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">setDefaultName</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Thread::~<span class="built_in">Thread</span>() &#123;</span><br><span class="line">    <span class="comment">//线程已经运行起来了，并且没有joined_</span></span><br><span class="line">    <span class="keyword">if</span> (started_ &amp;&amp; !joined_)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//thread类提供的分离线程的方法</span></span><br><span class="line">        thread_-&gt;<span class="built_in">detach</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Thread::setDefaultName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = ++numCreated_;</span><br><span class="line">    <span class="keyword">if</span>(name_.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">snprintf</span>(buf,<span class="keyword">sizeof</span> buf,<span class="string">&quot;Thread%d&quot;</span>,num);</span><br><span class="line">        name_=buf;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Thread::start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    started_ = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">sem_t</span> sem;</span><br><span class="line">    <span class="comment">// 初始化一个信号量</span></span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;sem, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    thread_ = std::<span class="built_in">make_shared</span>&lt;std::thread&gt;([<span class="keyword">this</span>, &amp;sem]() &#123;</span><br><span class="line">        ++numCreated_;</span><br><span class="line">        <span class="comment">// 得到当前线程的tid</span></span><br><span class="line">        tid_ = CurrentThread::<span class="built_in">tid</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 信号量 + 1，说明tid_已经有了</span></span><br><span class="line">        <span class="built_in">sem_post</span>(&amp;sem);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行线程任务</span></span><br><span class="line">        <span class="built_in">func_</span>();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待返回线程id</span></span><br><span class="line">    <span class="built_in">sem_wait</span>(&amp;sem);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Thread::join</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    joined_ = <span class="literal">true</span>;</span><br><span class="line">    thread_-&gt;<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>值得注意的是线程并不是在构造函数中创建的，并且必须得创建线程后得到id才能继续运行（因为其他逻辑实现的<strong>one loop per thread</strong>必须要得到tid）</li>
</ul>
<ul>
<li><p>补充一下sem_t变量类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sem_init（）<span class="comment">// sem为指向信号量结构的一个指针；pshared不为０时此信号量在进程间共享，否则只能为当前进程的所有线程共享；value给出了信号量的初始值。</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> sem_init __P ((<span class="type">sem_t</span> *__sem, <span class="type">int</span> __pshared, <span class="type">unsigned</span> <span class="type">int</span> __value));　</span><br><span class="line"></span><br><span class="line"><span class="built_in">sem_wait</span>( <span class="type">sem_t</span> *sem ) <span class="comment">//用来阻塞当前线程直到信号量sem的值大于0，解除阻塞后将sem的值减一，表明公共资源经使用后减少。函数sem_trywait ( sem_t *sem )是函数sem_wait（）的非阻塞版本，它直接将信号量sem的值减一。</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">sem_post</span>( <span class="type">sem_t</span> *sem )<span class="comment">//用来增加信号量的值。当有线程阻塞在这个信号量上时，调用这个函数会使其中的一个线程不在阻塞，选择机制同样是由线程的调度策略决定的。</span></span><br><span class="line"><span class="comment">//sem_post和sem_wait函数配合使用来达到线程同步</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">sem_destroy</span>(<span class="type">sem_t</span> *sem)<span class="comment">//用来释放信号量sem。</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="muduo库EventLoopThread类"><a href="#muduo库EventLoopThread类" class="headerlink" title="muduo库EventLoopThread类"></a>muduo库EventLoopThread类</h1><h2 id="EventLoopThread重要成员变量"><a href="#EventLoopThread重要成员变量" class="headerlink" title="EventLoopThread重要成员变量"></a>EventLoopThread重要成员变量</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EventLoop *loop_;  <span class="comment">//线程内部的eventloop*</span></span><br><span class="line"><span class="type">bool</span> exiting_;     <span class="comment">//线程是否退出</span></span><br><span class="line">Thread thread_;   <span class="comment">//线程</span></span><br><span class="line">std::mutex mutex_; <span class="comment">//互斥锁</span></span><br><span class="line">std::condition_variable cond_; <span class="comment">//条件变量</span></span><br><span class="line">ThreadInitCallBack callback_; <span class="comment">//线程初始化回调函数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>具体见注释</li>
</ul>
<h2 id="EventLoopThread重要成员函数"><a href="#EventLoopThread重要成员函数" class="headerlink" title="EventLoopThread重要成员函数"></a>EventLoopThread重要成员函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;EventLoopThread.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">EventLoopThread::<span class="built_in">EventLoopThread</span>(<span class="type">const</span> ThreadInitCallBack &amp;cb, <span class="type">const</span> std::string &amp;name)</span><br><span class="line">    : <span class="built_in">loop_</span>(<span class="literal">nullptr</span>)</span><br><span class="line">    , <span class="built_in">exiting_</span>(<span class="literal">false</span>)</span><br><span class="line">    , <span class="built_in">thread_</span>(std::<span class="built_in">bind</span>(&amp;EventLoopThread::threadFunc, <span class="keyword">this</span>))</span><br><span class="line">    , <span class="built_in">mutex_</span>()</span><br><span class="line">    , <span class="built_in">cond_</span>()</span><br><span class="line">    , <span class="built_in">callback_</span>(cb)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventLoopThread::~<span class="built_in">EventLoopThread</span>() &#123;</span><br><span class="line">    exiting_ = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(loop_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 退出循环</span></span><br><span class="line">        loop_-&gt;<span class="built_in">quit</span>();</span><br><span class="line">        thread_.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">EventLoop *<span class="title">EventLoopThread::startLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建线程, 执行任务</span></span><br><span class="line">    thread_.<span class="built_in">start</span>();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 会调用Thread::start()，然后执行func_(); func_(std::move(func))；</span></span><br><span class="line"><span class="comment">     * 而func就是&amp;EventLoopThread::threadFunc,this 传入的，所以会启动一个新线程</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    EventLoop* loop = <span class="literal">nullptr</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        cond_.<span class="built_in">wait</span>(lock,[<span class="keyword">this</span>]() &#123;</span><br><span class="line">            <span class="keyword">return</span> loop_ != <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        loop = loop_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> loop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoopThread::threadFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    EventLoop loop;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(callback_) &#123;</span><br><span class="line">        <span class="built_in">callback_</span>(&amp;loop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        loop_ = &amp;loop;</span><br><span class="line">        cond_.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    loop.<span class="built_in">loop</span>();</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    loop_=<span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>启动LOOP的过程</p>
<ol>
<li>首先，在startLoop中调用了Thread::start()，而这里的thread<em>的线程函数是threadFunc，在上一篇剖析Thread类时，我们在Thread::start()，看到了一个线程函数func</em>()，所以func就是构造函数中&amp;EventLoopThread::threadFunc,this 传入的，所以这里会创建线程调用threadFunc()函数，并且主线程阻塞等待EventLoop对象的创建</li>
<li>此时有两个线程在运行 一个是调用EventLoopThread::startLoop()的线程，一个是执行EventLoopThread::threadFunc()的线程 IO线程</li>
<li>threadFunc是在单独的新线程里面运行的，创建一个独立的Eventloop，和上面的线程是一一对应的 one loop per thread</li>
<li>将IO线程定义好的loop传入回调</li>
<li>创建好loop了唤醒主线程，并把loop<em>给主线程，主线程返回IO线程创建的EventLoop对象</em></li>
<li><em>注意开始执行 loop.loop();，也就是EventLoop loop =&gt; Poller.poll，开始一个循环，知道循环结束eventloop析构,把loop</em>设为空。</li>
</ol>
</li>
<li><h6 id="总体来说，EventLoopThread提供了对应eventloop和thread的封装，意为I-O线程类，EventLoopThread可以创建一个IO线程，通过startLoop返回一个IO线程的loop，threadFunc中开启loop循环。"><a href="#总体来说，EventLoopThread提供了对应eventloop和thread的封装，意为I-O线程类，EventLoopThread可以创建一个IO线程，通过startLoop返回一个IO线程的loop，threadFunc中开启loop循环。" class="headerlink" title="总体来说，EventLoopThread提供了对应eventloop和thread的封装，意为I/O线程类，EventLoopThread可以创建一个IO线程，通过startLoop返回一个IO线程的loop，threadFunc中开启loop循环。"></a><strong>总体来说，EventLoopThread提供了对应eventloop和thread的封装，意为I/O线程类，EventLoopThread可以创建一个IO线程，通过startLoop返回一个IO线程的loop，threadFunc中开启loop循环。</strong></h6></li>
</ul>
<h1 id="muduo库EventLoopThreadPool类"><a href="#muduo库EventLoopThreadPool类" class="headerlink" title="muduo库EventLoopThreadPool类"></a>muduo库EventLoopThreadPool类</h1><h2 id="EventLoopThreadPool重要成员变量"><a href="#EventLoopThreadPool重要成员变量" class="headerlink" title="EventLoopThreadPool重要成员变量"></a>EventLoopThreadPool重要成员变量</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EventLoop *baseLoop_;  <span class="comment">//主线程loop</span></span><br><span class="line">std::string name_;</span><br><span class="line"><span class="type">bool</span> started_; <span class="comment">//标记当前状态 即IO线程是否开始运行</span></span><br><span class="line"><span class="type">int</span> numThreads_; <span class="comment">//线程池中线程的数量</span></span><br><span class="line"><span class="type">int</span> next_;  <span class="comment">//负载均衡用</span></span><br><span class="line">std::vector&lt;std::unique_ptr&lt;EventLoopThread&gt;&gt; threads_;<span class="comment">//创建事件的线程</span></span><br><span class="line">std::vector&lt;EventLoop*&gt; loops_; <span class="comment">//事件线程里面EventLoop的指针，每个EventLoopThread线程对应的EventLoop保存在loops_中</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>具体含义见注释</li>
</ul>
<h2 id="EventLoopThreadPool重要成员函数"><a href="#EventLoopThreadPool重要成员函数" class="headerlink" title="EventLoopThreadPool重要成员函数"></a>EventLoopThreadPool重要成员函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">EventLoopThreadPool</span><span class="params">(EventLoop* baseloop, <span class="type">const</span> std::string&amp; nameArg = std::string&#123;&#125;)</span></span>;</span><br><span class="line">    ~<span class="built_in">EventLoopThreadPool</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线程池子的线程数量</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setThreadNums</span><span class="params">(<span class="type">const</span> <span class="type">signed</span> <span class="type">int</span> threadNums)</span> </span>&#123; threadNums_ = threadNums;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启事件循环线程</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">(<span class="type">const</span> ThreadInitCallBack &amp;cb = ThreadInitCallBack())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//若是多线程，baseLoop_默认以轮询的方式分配channel给subloop</span></span><br><span class="line">    <span class="function">EventLoop* <span class="title">getNextLoop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到所有的EventLoop</span></span><br><span class="line">    <span class="function">std::vector&lt;EventLoop*&gt; <span class="title">getAllLoops</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">started</span><span class="params">()</span> <span class="type">const</span></span>&#123; <span class="keyword">return</span> started_;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> name_;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//===================================对应实现=============================================</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;EventLoopThreadPool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">EventLoopThreadPool::<span class="built_in">EventLoopThreadPool</span>(EventLoop *baseloop, <span class="type">const</span> std::string &amp;nameArg)</span><br><span class="line">    : <span class="built_in">baseLoop_</span>(baseloop)</span><br><span class="line">    , <span class="built_in">started_</span>(<span class="literal">false</span>)</span><br><span class="line">    , <span class="built_in">name_</span>(nameArg)</span><br><span class="line">    , <span class="built_in">threadNums_</span>(std::thread::<span class="built_in">hardware_concurrency</span>())</span><br><span class="line">    , <span class="built_in">next_</span>(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventLoopThreadPool::~<span class="built_in">EventLoopThreadPool</span>() &#123;</span><br><span class="line">    <span class="comment">//  因为子线程的的loop 是栈中分配的所以不需要手动删除</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">EventLoop *<span class="title">EventLoopThreadPool::getNextLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EventLoop* loop = baseLoop_;</span><br><span class="line">    <span class="comment">// 通过轮询，获取下一个处理事件的loop</span></span><br><span class="line">    <span class="keyword">if</span>(!loops_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        loop = loops_[next_];</span><br><span class="line">        ++next_;</span><br><span class="line">        <span class="keyword">if</span>(next_ &gt;= loops_.<span class="built_in">size</span>()) next_ = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> loop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空的时候是单线程</span></span><br><span class="line"><span class="function">std::vector&lt;EventLoop *&gt; <span class="title">EventLoopThreadPool::getAllLoops</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(loops_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::vector&lt;EventLoop*&gt;&#123;baseLoop_&#125;;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> loops_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoopThreadPool::start</span><span class="params">(<span class="type">const</span> ThreadInitCallBack &amp;cb)</span> </span>&#123;</span><br><span class="line">    started_ = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; threadNums_; i ++) &#123;</span><br><span class="line">        <span class="type">char</span> buf[name_.<span class="built_in">size</span>() + <span class="number">32</span>];</span><br><span class="line">        <span class="built_in">snprintf</span>(buf,<span class="keyword">sizeof</span> buf,<span class="string">&quot;%s%d&quot;</span>,name_.<span class="built_in">c_str</span>(),i);</span><br><span class="line">        <span class="keyword">auto</span> t = std::<span class="built_in">make_unique</span>&lt;EventLoopThread&gt;(cb, buf);</span><br><span class="line">        <span class="comment">// 启动循环并创建线程</span></span><br><span class="line">        loops_.<span class="built_in">emplace_back</span>(t-&gt;<span class="built_in">startLoop</span>());</span><br><span class="line">        <span class="comment">// 放入threads</span></span><br><span class="line">        threads_.<span class="built_in">emplace_back</span>(std::<span class="built_in">move</span>(t));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果整个循环就只有一个线程，就让这个主线程来执行回调函数</span></span><br><span class="line">    <span class="keyword">if</span>(threadNums_ == <span class="number">0</span> &amp;&amp; cb) &#123;</span><br><span class="line">        <span class="built_in">cb</span>(baseLoop_);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>启动线程池,实际上创建numThreads个线程,并让每个eventloopthread调用startLoop()<ol>
<li>设置当前状态为true，根据需要的线程数numThreads<em>，创建线程</em></li>
<li>_在for循环中，先创建一个EventLoopThread对象，构造线程池内线程集合</li>
<li><em>调用EventLoopThread::startLoop()，创建线程，绑定一个新的EventLoop，并返回loop地址，放入loops</em>中，loops<em>是一个std::vector<EventLoop*>类型</em></li>
<li><em>把每个EventLoopThread线程对应的EventLoop保存在loops</em>中。</li>
<li>如果没有其他线程，只有主线程的话，直接调用callback</li>
</ol>
</li>
</ul>
<ul>
<li><p>muduo是支持单线程和多线程的  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EventLoop* loop = baseLoop_;， </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(threadNums_ == <span class="number">0</span> &amp;&amp; cb) &#123;</span><br><span class="line">        <span class="built_in">cb</span>(baseLoop_);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这两块就实现了单线程功能</p>
</li>
</ul>
<h1 id="EchoServer之建立"><a href="#EchoServer之建立" class="headerlink" title="EchoServer之建立"></a>EchoServer之建立</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/TimeStamp.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/InetAddress.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/TcpConnection.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/EventLoop.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/TcpServer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/logger.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EchoServer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">EchoServer</span>(EventLoop *loop, <span class="type">const</span> InetAddress &amp;listenAddr, <span class="type">const</span> std::string &amp;nameArg)</span><br><span class="line">        : <span class="built_in">loop_</span>(loop)</span><br><span class="line">        , <span class="built_in">tcpServer_</span>(loop, listenAddr, nameArg)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Start</span>();</span><br><span class="line">        <span class="comment">//注册回调函数</span></span><br><span class="line">        tcpServer_.<span class="built_in">setConnectionCallback</span>(</span><br><span class="line">            std::<span class="built_in">bind</span>(&amp;EchoServer::onConnection,<span class="keyword">this</span>,std::placeholders::_1)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        tcpServer_.<span class="built_in">setMessageCallback</span>(</span><br><span class="line">            std::<span class="built_in">bind</span>(&amp;EchoServer::onMessage,<span class="keyword">this</span>,</span><br><span class="line">                std::placeholders::_1, std::placeholders::_2, std::placeholders::_3)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置合适的loop线程数量 loopThread</span></span><br><span class="line">        tcpServer_.<span class="built_in">setThreadNums</span>(std::thread::<span class="built_in">hardware_concurrency</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        tcpServer_.<span class="built_in">start</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可读写事件回调</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onMessage</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn,</span></span></span><br><span class="line"><span class="params"><span class="function">                Buffer *buf,</span></span></span><br><span class="line"><span class="params"><span class="function">                TimeStamp time)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::string msg = buf-&gt;<span class="built_in">retrieveAllAsString</span>();</span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">&quot;%s recv %d bytes at &quot;</span>, conn-&gt;<span class="built_in">name</span>(), msg.<span class="built_in">size</span>(),time.<span class="built_in">to_string</span>());</span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="string">&quot;exit\n&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            conn-&gt;<span class="built_in">send</span>(<span class="string">&quot;bye\n&quot;</span>);</span><br><span class="line">            conn-&gt;<span class="built_in">shutdown</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="string">&quot;quit\n&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            loop_-&gt;<span class="built_in">quit</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        conn-&gt;<span class="built_in">send</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接建立或者断开的回调</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onConnection</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(conn-&gt;<span class="built_in">connected</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">LOG_INFO</span>(<span class="string">&quot;Connection UP : %s&quot;</span>,conn-&gt;<span class="built_in">peerAddress</span>().<span class="built_in">toIpPort</span>().<span class="built_in">c_str</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">LOG_INFO</span>(<span class="string">&quot;Connection DOWN : %s&quot;</span>,conn-&gt;<span class="built_in">peerAddress</span>().<span class="built_in">toIpPort</span>().<span class="built_in">c_str</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EventLoop* loop_;</span><br><span class="line">    TcpServer tcpServer_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    EventLoop loop;</span><br><span class="line">    <span class="function">InetAddress <span class="title">addr</span><span class="params">(<span class="number">8000</span>)</span></span>;</span><br><span class="line">    <span class="comment">//Acceptor non-blocking listenfd create bind</span></span><br><span class="line">    <span class="function">EchoServer <span class="title">server</span><span class="params">(&amp;loop,addr,<span class="string">&quot;EchoServer-01&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">//listen loopthread listenfd =&gt; acceptChannel =&gt; mainLoop =&gt; subloop</span></span><br><span class="line">    server.<span class="built_in">Start</span>();</span><br><span class="line">    loop.<span class="built_in">loop</span>(); <span class="comment">//启动mainloop的底层pooler</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>具体执行逻辑可以看代码或者访问<a target="_blank" rel="noopener" href="https://blog.csdn.net/T_Solotov/article/details/124044175这篇大佬的文章">https://blog.csdn.net/T_Solotov/article/details/124044175这篇大佬的文章</a></p>
<h1 id="muduo库中的定时器类"><a href="#muduo库中的定时器类" class="headerlink" title="muduo库中的定时器类"></a>muduo库中的定时器类</h1><h2 id="Timer类"><a href="#Timer类" class="headerlink" title="Timer类"></a>Timer类</h2><h3 id="Timer重要成员变量"><a href="#Timer重要成员变量" class="headerlink" title="Timer重要成员变量"></a>Timer重要成员变量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定时到期需要执行的任务</span></span><br><span class="line">   TimerCallback timerCaLLBack_;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 何时到期</span></span><br><span class="line">   TimeStamp expiration_;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 距离下次启动的时间间隔，如果不是重复定时器，其值为0</span></span><br><span class="line">   <span class="type">double</span> interval_;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 标志是否是重复定时器</span></span><br><span class="line">   <span class="type">bool</span> repeat_;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 定时器的唯一ID</span></span><br><span class="line">   std::<span class="type">int64_t</span> sequence_;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 定时器开辟的数量</span></span><br><span class="line">   <span class="type">static</span> std::<span class="type">atomic_int64_t</span> numCreated_;</span><br></pre></td></tr></table></figure>
<ul>
<li>具体逻辑见注释</li>
</ul>
<h3 id="Timer重要成员函数"><a href="#Timer重要成员函数" class="headerlink" title="Timer重要成员函数"></a>Timer重要成员函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">using</span> TimerCallback = std::function&lt;<span class="built_in">void</span>()&gt;;</span><br><span class="line">    <span class="built_in">Timer</span>(TimerCallback timercallback, TimeStamp when, <span class="type">double</span> interval);</span><br><span class="line">    ~<span class="built_in">Timer</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">TimeStamp <span class="title">expiration</span><span class="params">()</span> <span class="type">const</span>  </span>&#123; <span class="keyword">return</span> expiration_; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">repeat</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> repeat_; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int64_t</span> <span class="title">sequence</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> sequence_; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="built_in">timerCaLLBack_</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">restart</span><span class="params">(TimeStamp now)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int64_t</span> <span class="title">numCreated</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> numCreated_; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ================================其实现================================</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Timer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TimeStamp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">std::<span class="type">atomic_int64_t</span> Timer::numCreated_ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Timer::<span class="built_in">Timer</span>(TimerCallback timercallback, TimeStamp when, <span class="type">double</span> interval)</span><br><span class="line">    : <span class="built_in">timerCaLLBack_</span>(timercallback)</span><br><span class="line">    , <span class="built_in">expiration_</span>(when)</span><br><span class="line">    , <span class="built_in">interval_</span>(interval)</span><br><span class="line">    , <span class="built_in">repeat_</span>(interval &gt; <span class="number">0.0</span>)</span><br><span class="line">    , <span class="built_in">sequence_</span>(++ numCreated_)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Timer::restart</span><span class="params">(TimeStamp now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (repeat_)</span><br><span class="line">    &#123;</span><br><span class="line">        expiration_ = TimeStamp::<span class="built_in">addTime</span>(now, interval_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        expiration_ = TimeStamp::<span class="built_in">invaild</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>restart函数判断是否重复定时器构造到期时间,如果是重复就设置到期时间为设定的时间，否则为0</li>
</ul>
<h3 id="Timer设计思想"><a href="#Timer设计思想" class="headerlink" title="Timer设计思想"></a>Timer设计思想</h3><ul>
<li>首先需要到期时需要执行的任务，然后需要存储到期时间以及是否是重复定时器，以及定时器的唯一id</li>
</ul>
<h2 id="TimerId类"><a href="#TimerId类" class="headerlink" title="TimerId类"></a>TimerId类</h2><h3 id="TimerId重要成员变量"><a href="#TimerId重要成员变量" class="headerlink" title="TimerId重要成员变量"></a>TimerId重要成员变量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdint&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Timer</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TimerId</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TimerId</span>()</span><br><span class="line">      : <span class="built_in">timer_</span>(<span class="literal">NULL</span>),</span><br><span class="line">        <span class="built_in">sequence_</span>(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">TimerId</span>(Timer* timer, <span class="type">int64_t</span> seq)</span><br><span class="line">      : <span class="built_in">timer_</span>(timer),</span><br><span class="line">        <span class="built_in">sequence_</span>(seq)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">TimerId</span>(<span class="type">const</span> TimerId&amp; timerid) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    TimerId&amp; <span class="keyword">operator</span>=(<span class="type">const</span> TimerId&amp; timerid) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">TimerQueue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 指向一个定时器</span></span><br><span class="line">    Timer* timer_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该定时器对应编号</span></span><br><span class="line">    <span class="type">int64_t</span> sequence_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="TimerQueue类"><a href="#TimerQueue类" class="headerlink" title="TimerQueue类"></a>TimerQueue类</h2><h3 id="TimerQueue重要成员变量"><a href="#TimerQueue重要成员变量" class="headerlink" title="TimerQueue重要成员变量"></a>TimerQueue重要成员变量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">EventLoop* loop_;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// timerfd的描述符</span></span><br><span class="line">   <span class="type">int</span> timerfd_;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 与timer描述符相对应的channel</span></span><br><span class="line">   Channel timerfdChannel_;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 定时器任务列表，以触发时间排序，小的在前</span></span><br><span class="line">   TimerList timers_;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 待处理的定时器列表</span></span><br><span class="line">   ActiverTimerSet activeTimers_;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 标记是否正在执行要过期的定时器</span></span><br><span class="line">   std::atomic_bool callingExpiredTimers_;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 暂存正要过期的定时器列表</span></span><br><span class="line">   ActiverTimerSet cancleTimers_;</span><br></pre></td></tr></table></figure>
<ul>
<li>具体见注释</li>
</ul>
<h3 id="TimerQueue重要成员函数"><a href="#TimerQueue重要成员函数" class="headerlink" title="TimerQueue重要成员函数"></a>TimerQueue重要成员函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> TimerCallback = std::function&lt;<span class="built_in">void</span>()&gt;;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">TimerQueue</span><span class="params">(EventLoop* loop)</span></span>;</span><br><span class="line">    ~<span class="built_in">TimerQueue</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加定时器任务</span></span><br><span class="line">    <span class="function">TimerId <span class="title">addTimer</span><span class="params">(TimerCallback cb,</span></span></span><br><span class="line"><span class="params"><span class="function">                   TimeStamp when,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="type">double</span> interval)</span></span>;</span><br><span class="line">    <span class="comment">// 取消定时器任务</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">cancel</span><span class="params">(TimerId timerId)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">using</span> ActiverTimer = std::pair&lt;Timer *, <span class="type">int64_t</span>&gt;;</span><br><span class="line">    <span class="keyword">using</span> ActiverTimerSet = std::set&lt;ActiverTimer&gt;;</span><br><span class="line">    <span class="keyword">using</span> Entry = std::pair&lt;TimeStamp, Timer*&gt;;</span><br><span class="line">    <span class="keyword">using</span> TimerList = std::set&lt;Entry&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消定时器任务</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">cancelInLoop</span><span class="params">(TimerId timerid)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理readfd的读事件，得到过期的定时器，并且执行对应任务，并设置下一个要发生的定时器</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleRead</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把过期的定时器从timers_和activeTimer_中删掉 并返回所有过期的定时器集合</span></span><br><span class="line">    <span class="function">std::vector&lt;Entry&gt; <span class="title">getExpired</span><span class="params">(TimeStamp now)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加入到容器中，加入时候要注意是否更新了最早触发任务</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addTimerInLoop</span><span class="params">(Timer* timer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有重复的定时器就重新设置，否则就直接删除，获取过期时间最早的定时器的时间，并将它设置到timerfd中</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(<span class="type">const</span> std::vector&lt;Entry&gt;&amp; expired, TimeStamp now)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入到ActiveTimeSet和timers，同时注意是否会影响一个要发生的定时器时间</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(Timer* timer)</span></span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment">// =====================================其实现===============================</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TimerQueue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;logger.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/timerfd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">timespec <span class="title">howMuchTimeFromNow</span><span class="params">(TimeStamp when)</span> </span>&#123;</span><br><span class="line">    <span class="type">int64_t</span> microseconds = when.<span class="built_in">microSecondsSinceEpoch</span>()</span><br><span class="line">                         - TimeStamp::<span class="built_in">now</span>().<span class="built_in">microSecondsSinceEpoch</span>();</span><br><span class="line">    <span class="keyword">if</span> (microseconds &lt; <span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        microseconds = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timespec</span> ts;</span><br><span class="line">    ts.tv_sec = <span class="built_in">static_cast</span>&lt;<span class="type">time_t</span>&gt;(</span><br><span class="line">        microseconds / TimeStamp::kMicroSecondsPerSecond);</span><br><span class="line">    ts.tv_nsec = <span class="built_in">static_cast</span>&lt;<span class="type">long</span>&gt;(</span><br><span class="line">        (microseconds % TimeStamp::kMicroSecondsPerSecond) * <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> ts;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">createTimerfd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> timerfd = <span class="built_in">timerfd_create</span>(CLOCK_MONOTONIC, TFD_NONBLOCK | TFD_CLOEXEC);</span><br><span class="line">    <span class="keyword">if</span>(timerfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;timerfd_create failed!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> timerfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">resetTimerfd</span><span class="params">(<span class="type">int</span> timerfd, TimeStamp expiration)</span> </span>&#123;</span><br><span class="line">    itimerspec newValue&#123;&#125;;</span><br><span class="line">    itimerspec oldValue&#123;&#125;;</span><br><span class="line">    <span class="comment">// 定时的间隔时间</span></span><br><span class="line">    newValue.it_value =  <span class="built_in">howMuchTimeFromNow</span>(expiration);</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">timerfd_settime</span>(timerfd, <span class="number">0</span>, &amp;newValue, &amp;oldValue);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;timerfd_settime failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">readTimerfd</span><span class="params">(<span class="type">int</span> timerfd, TimeStamp now)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> howmany;</span><br><span class="line">    <span class="type">ssize_t</span> n = ::<span class="built_in">read</span>(timerfd, &amp;howmany, <span class="keyword">sizeof</span> howmany);</span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;TimerQueue::handleRead() %lu at %s&quot;</span>, howmany, now.<span class="built_in">to_string</span>().<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">if</span> (n != <span class="keyword">sizeof</span> howmany)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;TimerQueue::handleRead() reads %ld bytes instead of 8&quot;</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TimerQueue::<span class="built_in">TimerQueue</span>(EventLoop *loop)</span><br><span class="line">    : <span class="built_in">loop_</span>(loop)</span><br><span class="line">    , <span class="built_in">timerfd_</span>(<span class="built_in">createTimerfd</span>())</span><br><span class="line">    , <span class="built_in">timerfdChannel_</span>(timerfd_, loop)</span><br><span class="line">    , <span class="built_in">timers_</span>()</span><br><span class="line">    , <span class="built_in">activeTimers_</span>()</span><br><span class="line">    , <span class="built_in">callingExpiredTimers_</span>(<span class="literal">false</span>)</span><br><span class="line">    , <span class="built_in">cancleTimers_</span>()</span><br><span class="line">&#123;</span><br><span class="line">    timerfdChannel_.<span class="built_in">setReadCallBack</span>(std::<span class="built_in">bind</span>(&amp;TimerQueue::handleRead, <span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置可读 并且让loop监听读事件</span></span><br><span class="line">    timerfdChannel_.<span class="built_in">enableReading</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TimerQueue::~<span class="built_in">TimerQueue</span>() &#123;</span><br><span class="line">    timerfdChannel_.<span class="built_in">disableAll</span>();</span><br><span class="line">    timerfdChannel_.<span class="built_in">remove</span>();</span><br><span class="line">    <span class="built_in">close</span>(timerfd_);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; t: timers_) &#123;</span><br><span class="line">        <span class="keyword">delete</span> t.second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TimerId <span class="title">TimerQueue::addTimer</span><span class="params">(TimerCallback cb, TimeStamp when, <span class="type">double</span> interval)</span> </span>&#123;</span><br><span class="line">    Timer* timer = <span class="keyword">new</span> <span class="built_in">Timer</span>(std::<span class="built_in">move</span>(cb), when, interval);</span><br><span class="line">    loop_-&gt;<span class="built_in">runInLoop</span>(std::<span class="built_in">bind</span>(std::<span class="built_in">bind</span>(&amp;TimerQueue::addTimerInLoop, <span class="keyword">this</span>, timer)));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">TimerId</span>(timer, timer-&gt;<span class="built_in">sequence</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TimerQueue::addTimerInLoop</span><span class="params">(Timer *timer)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> earliestChanged = <span class="built_in">insert</span>(timer);</span><br><span class="line">    <span class="keyword">if</span>(earliestChanged) &#123;</span><br><span class="line">        <span class="built_in">resetTimerfd</span>(timerfd_, timer-&gt;<span class="built_in">expiration</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TimerQueue::insert</span><span class="params">(Timer *timer)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> earliestChanged = <span class="literal">false</span>;</span><br><span class="line">    TimeStamp when = timer-&gt;<span class="built_in">expiration</span>();</span><br><span class="line">    TimerList::iterator it = timers_.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">if</span>(it == timers_.<span class="built_in">end</span>() || when &lt; it-&gt;first) &#123;</span><br><span class="line">        earliestChanged = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        std::pair&lt;TimerList::iterator, <span class="type">bool</span>&gt; result</span><br><span class="line">          = timers_.<span class="built_in">insert</span>(<span class="built_in">Entry</span>(when, timer));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        std::pair&lt;ActiverTimerSet::iterator, <span class="type">bool</span>&gt; result</span><br><span class="line">          = activeTimers_.<span class="built_in">insert</span>(<span class="built_in">ActiverTimer</span>(timer, timer-&gt;<span class="built_in">sequence</span>()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> earliestChanged;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TimerQueue::cancel</span><span class="params">(TimerId timerId)</span> </span>&#123;</span><br><span class="line">    loop_-&gt;<span class="built_in">runInLoop</span>(</span><br><span class="line">      std::<span class="built_in">bind</span>(&amp;TimerQueue::cancelInLoop, <span class="keyword">this</span>, timerId));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TimerQueue::cancelInLoop</span><span class="params">(TimerId timerid)</span> </span>&#123;</span><br><span class="line">    <span class="function">ActiverTimer <span class="title">atimer</span><span class="params">(timerid.timer_, timerid.sequence_)</span></span>;</span><br><span class="line">    ActiverTimerSet::iterator it = activeTimers_.<span class="built_in">find</span>(atimer);</span><br><span class="line">    <span class="keyword">if</span> (it != activeTimers_.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">size_t</span> n = timers_.<span class="built_in">erase</span>(<span class="built_in">Entry</span>(it-&gt;first-&gt;<span class="built_in">expiration</span>(), it-&gt;first));</span><br><span class="line">        (<span class="type">void</span>)n;</span><br><span class="line">        <span class="keyword">delete</span> it-&gt;first; <span class="comment">// <span class="doctag">FIXME:</span> no delete please</span></span><br><span class="line">        activeTimers_.<span class="built_in">erase</span>(it);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (callingExpiredTimers_)</span><br><span class="line">    &#123;</span><br><span class="line">        cancleTimers_.<span class="built_in">insert</span>(atimer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;TimerQueue::Entry&gt; <span class="title">TimerQueue::getExpired</span><span class="params">(TimeStamp now)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;TimerQueue::Entry&gt; expired;</span><br><span class="line">    <span class="comment">// 这是一个哨兵</span></span><br><span class="line">    <span class="function">Entry <span class="title">sentry</span><span class="params">(now, <span class="keyword">reinterpret_cast</span>&lt;Timer*&gt;(UINTPTR_MAX))</span></span>;</span><br><span class="line">    <span class="comment">// 找到第一个大于或等于的定时器</span></span><br><span class="line">    <span class="keyword">auto</span> end = timers_.<span class="built_in">lower_bound</span>(sentry);</span><br><span class="line">    std::<span class="built_in">copy</span>(timers_.<span class="built_in">begin</span>(), end, <span class="built_in">back_inserter</span>(expired));</span><br><span class="line">    timers_.<span class="built_in">erase</span>(timers_.<span class="built_in">begin</span>(), end);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> Entry&amp; it : expired) &#123;</span><br><span class="line">        <span class="function">ActiverTimer <span class="title">timer</span><span class="params">(it.second, it.second-&gt;sequence())</span></span>;</span><br><span class="line">        <span class="type">size_t</span> n = activeTimers_.<span class="built_in">erase</span>(timer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">move</span>(expired);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TimerQueue::handleRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">TimeStamp <span class="title">now</span><span class="params">(TimeStamp::now())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">readTimerfd</span>(timerfd_, now);</span><br><span class="line"></span><br><span class="line">    std::vector&lt;Entry&gt; expired = <span class="built_in">getExpired</span>(now);</span><br><span class="line"></span><br><span class="line">    callingExpiredTimers_ = <span class="literal">true</span>;</span><br><span class="line">    cancleTimers_.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> Entry&amp; it : expired)</span><br><span class="line">    &#123;</span><br><span class="line">        it.second-&gt;<span class="built_in">run</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    callingExpiredTimers_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">reset</span>(expired, now);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TimerQueue::reset</span><span class="params">(<span class="type">const</span> std::vector&lt;Entry&gt; &amp;expired, TimeStamp now)</span> </span>&#123;</span><br><span class="line">    TimeStamp nextExpire;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> Entry&amp; it : expired) &#123;</span><br><span class="line">        <span class="function">ActiverTimer <span class="title">timer</span><span class="params">(it.second, it.second-&gt;sequence())</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (it.second-&gt;<span class="built_in">repeat</span>()</span><br><span class="line">            &amp;&amp; cancleTimers_.<span class="built_in">find</span>(timer) == cancleTimers_.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            it.second-&gt;<span class="built_in">restart</span>(now);</span><br><span class="line">            <span class="built_in">insert</span>(it.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> it.second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!timers_.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        nextExpire = timers_.<span class="built_in">begin</span>()-&gt;second-&gt;<span class="built_in">expiration</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nextExpire.<span class="built_in">valid</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">resetTimerfd</span>(timerfd_, nextExpire);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="取消定时器的逻辑"><a href="#取消定时器的逻辑" class="headerlink" title="取消定时器的逻辑"></a>取消定时器的逻辑</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TimerQueue::cancel</span><span class="params">(TimerId timerId)</span> </span>&#123;</span><br><span class="line">    loop_-&gt;<span class="built_in">runInLoop</span>(</span><br><span class="line">      std::<span class="built_in">bind</span>(&amp;TimerQueue::cancelInLoop, <span class="keyword">this</span>, timerId));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TimerQueue::cancelInLoop</span><span class="params">(TimerId timerid)</span> </span>&#123;</span><br><span class="line">    <span class="function">ActiverTimer <span class="title">atimer</span><span class="params">(timerid.timer_, timerid.sequence_)</span></span>;</span><br><span class="line">    ActiverTimerSet::iterator it = activeTimers_.<span class="built_in">find</span>(atimer);</span><br><span class="line">    <span class="keyword">if</span> (it != activeTimers_.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">size_t</span> n = timers_.<span class="built_in">erase</span>(<span class="built_in">Entry</span>(it-&gt;first-&gt;<span class="built_in">expiration</span>(), it-&gt;first));</span><br><span class="line">        (<span class="type">void</span>)n;</span><br><span class="line">        <span class="keyword">delete</span> it-&gt;first; <span class="comment">// <span class="doctag">FIXME:</span> no delete please</span></span><br><span class="line">        activeTimers_.<span class="built_in">erase</span>(it);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (callingExpiredTimers_)</span><br><span class="line">    &#123;</span><br><span class="line">        cancleTimers_.<span class="built_in">insert</span>(atimer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>该功能是提供给用户手动取消不想要的定时器任务，其实现逻辑是根据用户传入的TimerId将其从activeTimer（活跃定时器中删除）以及timers<em>（存储定时器的列表）中删除，如果它并没有被触发就直接删除，否则就判断是否正在处理别的定时器任务，是的话现暂存在cancleTimers</em>取消定时器列表中（<strong>因为这样可以防止别的定时器会调用这个定时器而导致未定义行为</strong>），cancleTimers这个列表的东西会在准备开始处理下次的一组过期任务的时候被删除</li>
</ul>
<h4 id="加入定时器的逻辑"><a href="#加入定时器的逻辑" class="headerlink" title="加入定时器的逻辑"></a>加入定时器的逻辑</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">readTimerfd</span><span class="params">(<span class="type">int</span> timerfd, TimeStamp now)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> howmany;</span><br><span class="line">    <span class="type">ssize_t</span> n = ::<span class="built_in">read</span>(timerfd, &amp;howmany, <span class="keyword">sizeof</span> howmany);</span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;TimerQueue::handleRead() %lu at %s&quot;</span>, howmany, now.<span class="built_in">to_string</span>().<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">if</span> (n != <span class="keyword">sizeof</span> howmany)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;TimerQueue::handleRead() reads %ld bytes instead of 8&quot;</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TimerId <span class="title">TimerQueue::addTimer</span><span class="params">(TimerCallback cb, TimeStamp when, <span class="type">double</span> interval)</span> </span>&#123;</span><br><span class="line">    Timer* timer = <span class="keyword">new</span> <span class="built_in">Timer</span>(std::<span class="built_in">move</span>(cb), when, interval);</span><br><span class="line">    loop_-&gt;<span class="built_in">runInLoop</span>(std::<span class="built_in">bind</span>(std::<span class="built_in">bind</span>(&amp;TimerQueue::addTimerInLoop, <span class="keyword">this</span>, timer)));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">TimerId</span>(timer, timer-&gt;<span class="built_in">sequence</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TimerQueue::addTimerInLoop</span><span class="params">(Timer *timer)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> earliestChanged = <span class="built_in">insert</span>(timer);</span><br><span class="line">    <span class="keyword">if</span>(earliestChanged) &#123;</span><br><span class="line">        <span class="built_in">resetTimerfd</span>(timerfd_, timer-&gt;<span class="built_in">expiration</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入到ActiveTimeSet和timers，同时注意是否会影响一个要发生的定时器时间</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TimerQueue::insert</span><span class="params">(Timer *timer)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> earliestChanged = <span class="literal">false</span>;</span><br><span class="line">    TimeStamp when = timer-&gt;<span class="built_in">expiration</span>();</span><br><span class="line">    TimerList::iterator it = timers_.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">if</span>(it == timers_.<span class="built_in">end</span>() || when &lt; it-&gt;first) &#123;</span><br><span class="line">        earliestChanged = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        std::pair&lt;TimerList::iterator, <span class="type">bool</span>&gt; result</span><br><span class="line">          = timers_.<span class="built_in">insert</span>(<span class="built_in">Entry</span>(when, timer));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        std::pair&lt;ActiverTimerSet::iterator, <span class="type">bool</span>&gt; result</span><br><span class="line">          = activeTimers_.<span class="built_in">insert</span>(<span class="built_in">ActiverTimer</span>(timer, timer-&gt;<span class="built_in">sequence</span>()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> earliestChanged;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>加入新的定时器的时候，需要判断新加入的定时器过期时间会不会是最早的(这是通过set红黑数实现的)，也就是下一次会先执行，如果是的话 要更新下一次过期时间给timerfd（调用resettimerfd），然后不管是不是都要加入到对应的存储容器中</li>
</ul>
<h4 id="处理定时器过期逻辑"><a href="#处理定时器过期逻辑" class="headerlink" title="处理定时器过期逻辑"></a>处理定时器过期逻辑</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TimerQueue::handleRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">TimeStamp <span class="title">now</span><span class="params">(TimeStamp::now())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">readTimerfd</span>(timerfd_, now);</span><br><span class="line"></span><br><span class="line">    std::vector&lt;Entry&gt; expired = <span class="built_in">getExpired</span>(now);</span><br><span class="line"></span><br><span class="line">    callingExpiredTimers_ = <span class="literal">true</span>;</span><br><span class="line">    cancleTimers_.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> Entry&amp; it : expired)</span><br><span class="line">    &#123;</span><br><span class="line">        it.second-&gt;<span class="built_in">run</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    callingExpiredTimers_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">reset</span>(expired, now);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;TimerQueue::Entry&gt; <span class="title">TimerQueue::getExpired</span><span class="params">(TimeStamp now)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;TimerQueue::Entry&gt; expired;</span><br><span class="line">    <span class="comment">// 这是一个哨兵</span></span><br><span class="line">    <span class="function">Entry <span class="title">sentry</span><span class="params">(now, <span class="keyword">reinterpret_cast</span>&lt;Timer*&gt;(UINTPTR_MAX))</span></span>;</span><br><span class="line">    <span class="comment">// 找到第一个大于或等于的定时器</span></span><br><span class="line">    <span class="keyword">auto</span> end = timers_.<span class="built_in">lower_bound</span>(sentry);</span><br><span class="line">    std::<span class="built_in">copy</span>(timers_.<span class="built_in">begin</span>(), end, <span class="built_in">back_inserter</span>(expired));</span><br><span class="line">    timers_.<span class="built_in">erase</span>(timers_.<span class="built_in">begin</span>(), end);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> Entry&amp; it : expired) &#123;</span><br><span class="line">        <span class="function">ActiverTimer <span class="title">timer</span><span class="params">(it.second, it.second-&gt;sequence())</span></span>;</span><br><span class="line">        <span class="type">size_t</span> n = activeTimers_.<span class="built_in">erase</span>(timer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">move</span>(expired);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TimerQueue::reset</span><span class="params">(<span class="type">const</span> std::vector&lt;Entry&gt; &amp;expired, TimeStamp now)</span> </span>&#123;</span><br><span class="line">    TimeStamp nextExpire;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> Entry&amp; it : expired) &#123;</span><br><span class="line">        <span class="function">ActiverTimer <span class="title">timer</span><span class="params">(it.second, it.second-&gt;sequence())</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (it.second-&gt;<span class="built_in">repeat</span>()</span><br><span class="line">            &amp;&amp; cancleTimers_.<span class="built_in">find</span>(timer) == cancleTimers_.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            it.second-&gt;<span class="built_in">restart</span>(now);</span><br><span class="line">            <span class="built_in">insert</span>(it.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> it.second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!timers_.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        nextExpire = timers_.<span class="built_in">begin</span>()-&gt;second-&gt;<span class="built_in">expiration</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nextExpire.<span class="built_in">valid</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">resetTimerfd</span>(timerfd_, nextExpire);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">resetTimerfd</span><span class="params">(<span class="type">int</span> timerfd, TimeStamp expiration)</span> </span>&#123;</span><br><span class="line">    itimerspec newValue&#123;&#125;;</span><br><span class="line">    itimerspec oldValue&#123;&#125;;</span><br><span class="line">    <span class="comment">// 定时的间隔时间</span></span><br><span class="line">    newValue.it_value =  <span class="built_in">howMuchTimeFromNow</span>(expiration);</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">timerfd_settime</span>(timerfd, <span class="number">0</span>, &amp;newValue, &amp;oldValue);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;timerfd_settime failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">readTimerfd</span><span class="params">(<span class="type">int</span> timerfd, TimeStamp now)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> howmany;</span><br><span class="line">    <span class="type">ssize_t</span> n = ::<span class="built_in">read</span>(timerfd, &amp;howmany, <span class="keyword">sizeof</span> howmany);</span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;TimerQueue::handleRead() %lu at %s&quot;</span>, howmany, now.<span class="built_in">to_string</span>().<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">if</span> (n != <span class="keyword">sizeof</span> howmany)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;TimerQueue::handleRead() reads %ld bytes instead of 8&quot;</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>由于使用了timerfd，所以定时器过期后会有read事件，接收到后会调用读处理函数，读处理函数中会先读取Timerfd，然后获取过期定时器列表(通过一个哨兵，使用二分找到lower_bound找到第一个大于或等于的位置，执行对应删除)，获取后执行对应任务，最后重新设置下次过期时间以达到循环目的</li>
<li>重新设置的时候需要判断过期任务列表中是否有重复定时器，有的话重新设定，并且更新下一次过期时间给timerfd</li>
</ul>
<h4 id="Timerfd的使用"><a href="#Timerfd的使用" class="headerlink" title="Timerfd的使用"></a>Timerfd的使用</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">createTimerfd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> timerfd = <span class="built_in">timerfd_create</span>(CLOCK_MONOTONIC, TFD_NONBLOCK | TFD_CLOEXEC);</span><br><span class="line">    <span class="keyword">if</span>(timerfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;timerfd_create failed!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> timerfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">resetTimerfd</span><span class="params">(<span class="type">int</span> timerfd, TimeStamp expiration)</span> </span>&#123;</span><br><span class="line">    itimerspec newValue&#123;&#125;;</span><br><span class="line">    itimerspec oldValue&#123;&#125;;</span><br><span class="line">    <span class="comment">// 定时的间隔时间</span></span><br><span class="line">    newValue.it_value =  <span class="built_in">howMuchTimeFromNow</span>(expiration);</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">timerfd_settime</span>(timerfd, <span class="number">0</span>, &amp;newValue, &amp;oldValue);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;timerfd_settime failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">readTimerfd</span><span class="params">(<span class="type">int</span> timerfd, TimeStamp now)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> howmany;</span><br><span class="line">    <span class="type">ssize_t</span> n = ::<span class="built_in">read</span>(timerfd, &amp;howmany, <span class="keyword">sizeof</span> howmany);</span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;TimerQueue::handleRead() %lu at %s&quot;</span>, howmany, now.<span class="built_in">to_string</span>().<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">if</span> (n != <span class="keyword">sizeof</span> howmany)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;TimerQueue::handleRead() reads %ld bytes instead of 8&quot;</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>timerfd 这个名字拆开来看，就是 timer fd，所谓定时器 fd 类型，那么它的可读可写事件一定是跟时间有关系。timerfd 被 new 出来之后 （ <code>timerfd_create</code> ），可以设置超时时间（ <code>timerfd_setting</code> ），超时之后，该句柄可读，读出来的是<strong>超时的次数</strong>。</p>
</li>
<li><p>他有三个用法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 timerfd 句柄</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">timerfd_create</span><span class="params">(<span class="type">int</span> clockid, <span class="type">int</span> flags)</span></span>;</span><br><span class="line"><span class="comment">// 启动或关闭 timerfd 对应的定时器,会返回上次设定时间给传入的参数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">timerfd_settime</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> flags, <span class="type">const</span> <span class="keyword">struct</span> itimerspec *new_value, <span class="keyword">struct</span> itimerspec *old_value)</span></span>;</span><br><span class="line"><span class="comment">// 获取指定 timerfd 距离下一次超时还剩的时间</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">timerfd_gettime</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> itimerspec *curr_value)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>两个需要用得到结构体</p>
<ul>
<li>timespec</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// timespec 结构体用于表示时间，其定义如下：</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">timespec</span> &#123;</span><br><span class="line">    <span class="type">time_t</span> tv_sec;        <span class="comment">/* 秒 */</span></span><br><span class="line">    <span class="type">long</span>   tv_nsec;       <span class="comment">/* 纳秒 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>itimespec</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// itimerspec 结构体用于定义定时器的设置值和剩余时间，</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">itimerspec</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timespec</span> it_interval; <span class="comment">/* 重复周期 */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timespec</span> it_value;    <span class="comment">/* 首次触发时间 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>用法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">timer_t</span> timerid;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">create_timer</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">itimerspec</span> new_value;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">itimerspec</span> curr_value;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">timer_create</span>(CLOCK_REALTIME, <span class="literal">NULL</span>, &amp;timerid) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;timer_create&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">memset</span>(&amp;new_value, <span class="number">0</span>, <span class="built_in">sizeof</span>(new_value));</span><br><span class="line">    new_value.it_value.tv_sec = <span class="number">5</span>;</span><br><span class="line">    new_value.it_interval.tv_sec = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">timer_settime</span>(timerid, <span class="number">0</span>, &amp;new_value, <span class="literal">NULL</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;timer_settime&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">signal_handler</span><span class="params">(<span class="type">int</span> sig, <span class="type">siginfo_t</span> *si, <span class="type">void</span> *uc)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">itimerspec</span> curr_value;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Signal handler called - count: %d\n&quot;</span>, count);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">timer_gettime</span>(timerid, &amp;curr_value) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;timer_gettime&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sigaction</span> sa;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">memset</span>(&amp;sa, <span class="number">0</span>, <span class="built_in">sizeof</span>(sa));</span><br><span class="line">    sa.sa_flags = SA_SIGINFO;</span><br><span class="line">    sa.sa_sigaction = signal_handler;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sigaction</span>(SIGRTMIN, &amp;sa, <span class="literal">NULL</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;sigaction&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">create_timer</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">pause</span>();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>muduo网络库学习</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://pigcanstudy.github.io/posts/4389eda5.html">https://pigcanstudy.github.io/posts/4389eda5.html</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>PigCanStudy</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2024-07-25</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2024-11-29</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"></div></div><link rel="stylesheet" href="/css/coin.css" media="defer" onload="this.media='all'"/><div class="post-reward"><button class="tip-button reward-button"><span class="tip-button__text">投喂作者</span><div class="coin-wrapper"><div class="coin"><div class="coin__middle"></div><div class="coin__back"></div><div class="coin__front"></div></div></div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://tuchuang.voooe.cn/images/2023/01/04/2.webp" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://tuchuang.voooe.cn/images/2023/01/04/2.webp" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://tuchuang.voooe.cn/images/2023/01/04/20f8e49805975b8f8.webp" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://tuchuang.voooe.cn/images/2023/01/04/20f8e49805975b8f8.webp" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></button></div><audio id="coinAudio" src="https://npm.elemecdn.com/akilar-candyassets@1.0.36/audio/aowu.m4a"></audio><script defer="defer" src="/js/coin.js"></script><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/d5cdb644.html"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_14.webp" onerror="onerror=null;src='/assets/r2.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">go的Gin框架的使用</div></div></a></div><div class="next-post pull-right"><a href="/posts/9724705.html"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_14.webp" onerror="onerror=null;src='/assets/r2.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">C++asio网络编程</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><svg class="meta_icon" style="width:22px;height:22px;position:relative;top:5px"><use xlink:href="#icon-mulu1"></use></svg><span style="font-weight:bold">目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Reactor"><span class="toc-text">Reactor</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#muduo%E5%BA%93%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E4%B9%8BChannel%E7%B1%BB"><span class="toc-text">muduo库三大核心组件之Channel类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#channel%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-text">channel头文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#channel%E5%AE%9E%E7%8E%B0"><span class="toc-text">channel实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E8%AE%BE%E8%AE%A1"><span class="toc-text">重要设计</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#muduo%E5%BA%93%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E4%B9%8BEventLoop%E7%B1%BB"><span class="toc-text">muduo库三大核心组件之EventLoop类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-text">重要成员变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-text">重要成员函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%B8%AD%E7%9A%84%E5%B7%A7%E5%A6%99%E8%AE%BE%E8%AE%A1"><span class="toc-text">其中的巧妙设计</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#muduo%E5%BA%93%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E4%B9%8B-Poller-EpollPoller%E7%B1%BB"><span class="toc-text">muduo库三大核心组件之 Poller&#x2F;EpollPoller类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-1"><span class="toc-text">重要成员变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-1"><span class="toc-text">重要成员函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#muduo%E5%BA%93Acceptor%E7%B1%BB"><span class="toc-text">muduo库Acceptor类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Acceptor%E9%87%8D%E8%A6%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-text">Acceptor重要成员变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Acceptor%E9%87%8D%E8%A6%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-text">Acceptor重要成员函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E5%A5%BD%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-text">比较好的设计</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#muduo%E5%BA%93Buffer%E7%B1%BB"><span class="toc-text">muduo库Buffer类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81buffer%E7%B1%BB%EF%BC%9F"><span class="toc-text">为什么需要buffer类？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Buffer%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3"><span class="toc-text">Buffer设计思想</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Buffer%E9%87%8D%E8%A6%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-text">Buffer重要成员变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Buffer%E9%87%8D%E8%A6%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-text">Buffer重要成员函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#iovec%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9A%E4%B9%89"><span class="toc-text">iovec结构体定义</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#muduo%E5%BA%93TcpConnection%E7%B1%BB"><span class="toc-text">muduo库TcpConnection类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E4%BB%A5%E5%8F%8A%E4%B8%80%E4%BA%9B%E6%84%9F%E6%82%9F"><span class="toc-text">设计思想以及一些感悟</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TcpConnection%E9%87%8D%E8%A6%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-text">TcpConnection重要成员变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TcpConnection%E9%87%8D%E8%A6%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-text">TcpConnection重要成员函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#muduo%E5%BA%93TcpServer%E7%B1%BB"><span class="toc-text">muduo库TcpServer类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#TcpServer%E9%87%8D%E8%A6%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-text">TcpServer重要成员变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TcpServer%E9%87%8D%E8%A6%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-text">TcpServer重要成员函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#muduo%E5%BA%93Thread%E7%B1%BB"><span class="toc-text">muduo库Thread类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Thread%E9%87%8D%E8%A6%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-text">Thread重要成员变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Thread%E9%87%8D%E8%A6%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-text">Thread重要成员函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#muduo%E5%BA%93EventLoopThread%E7%B1%BB"><span class="toc-text">muduo库EventLoopThread类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#EventLoopThread%E9%87%8D%E8%A6%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-text">EventLoopThread重要成员变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EventLoopThread%E9%87%8D%E8%A6%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-text">EventLoopThread重要成员函数</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%80%BB%E4%BD%93%E6%9D%A5%E8%AF%B4%EF%BC%8CEventLoopThread%E6%8F%90%E4%BE%9B%E4%BA%86%E5%AF%B9%E5%BA%94eventloop%E5%92%8Cthread%E7%9A%84%E5%B0%81%E8%A3%85%EF%BC%8C%E6%84%8F%E4%B8%BAI-O%E7%BA%BF%E7%A8%8B%E7%B1%BB%EF%BC%8CEventLoopThread%E5%8F%AF%E4%BB%A5%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAIO%E7%BA%BF%E7%A8%8B%EF%BC%8C%E9%80%9A%E8%BF%87startLoop%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AAIO%E7%BA%BF%E7%A8%8B%E7%9A%84loop%EF%BC%8CthreadFunc%E4%B8%AD%E5%BC%80%E5%90%AFloop%E5%BE%AA%E7%8E%AF%E3%80%82"><span class="toc-text">总体来说，EventLoopThread提供了对应eventloop和thread的封装，意为I&#x2F;O线程类，EventLoopThread可以创建一个IO线程，通过startLoop返回一个IO线程的loop，threadFunc中开启loop循环。</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#muduo%E5%BA%93EventLoopThreadPool%E7%B1%BB"><span class="toc-text">muduo库EventLoopThreadPool类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#EventLoopThreadPool%E9%87%8D%E8%A6%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-text">EventLoopThreadPool重要成员变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EventLoopThreadPool%E9%87%8D%E8%A6%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-text">EventLoopThreadPool重要成员函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#EchoServer%E4%B9%8B%E5%BB%BA%E7%AB%8B"><span class="toc-text">EchoServer之建立</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#muduo%E5%BA%93%E4%B8%AD%E7%9A%84%E5%AE%9A%E6%97%B6%E5%99%A8%E7%B1%BB"><span class="toc-text">muduo库中的定时器类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Timer%E7%B1%BB"><span class="toc-text">Timer类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Timer%E9%87%8D%E8%A6%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-text">Timer重要成员变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Timer%E9%87%8D%E8%A6%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-text">Timer重要成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Timer%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3"><span class="toc-text">Timer设计思想</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TimerId%E7%B1%BB"><span class="toc-text">TimerId类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TimerId%E9%87%8D%E8%A6%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-text">TimerId重要成员变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TimerQueue%E7%B1%BB"><span class="toc-text">TimerQueue类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TimerQueue%E9%87%8D%E8%A6%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-text">TimerQueue重要成员变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TimerQueue%E9%87%8D%E8%A6%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-text">TimerQueue重要成员函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%96%E6%B6%88%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E9%80%BB%E8%BE%91"><span class="toc-text">取消定时器的逻辑</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E5%85%A5%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E9%80%BB%E8%BE%91"><span class="toc-text">加入定时器的逻辑</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%AE%9A%E6%97%B6%E5%99%A8%E8%BF%87%E6%9C%9F%E9%80%BB%E8%BE%91"><span class="toc-text">处理定时器过期逻辑</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Timerfd%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">Timerfd的使用</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-color: transparent;"><div id="footer-wrap"><div id="ft"><div class="ft-item-1"><div class="t-top"><div class="t-t-l"><p class="ft-t t-l-t">格言🧬</p><div class="bg-ad"><div>再看看那个光点，它就在这里，这是家园，这是我们 —— 你所爱的每一个人，你认识的一个人，你听说过的每一个人，曾经有过的每一个人，都在它上面度过他们的一生✨</div><div class="btn-xz-box"><a class="btn-xz" target="_blank" rel="noopener" href="https://stellarium.org/">点击开启星辰之旅</a></div></div></div><div class="t-t-r"><p class="ft-t t-l-t">猜你想看💡</p><ul class="ft-links"><li><a href="/posts/eec9786.html">魔改指南</a><a href="/box/nav/">网址导航</a></li><li><a href="/social/link/">我的朋友</a><a href="/comments/">留点什么</a></li><li><a href="/personal/about/">关于作者</a><a href="/archives/">文章归档</a></li><li><a href="/categories/">文章分类</a><a href="/tags/">文章标签</a></li><li><a href="/box/Gallery/">我的画廊</a><a href="/personal/bb/">我的唠叨</a></li><li><a href="/site/time/">建设进程</a><a href="/site/census/">网站统计</a></li></ul></div></div></div><div class="ft-item-2"><p class="ft-t">推荐友链⌛</p><div class="ft-img-group"><div class="img-group-item"><a target="_blank" rel="noopener" href="https://www.fomal.cc/" title="Fomalhaut🥝"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/60e5d4e39da7c077.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div></div></div></div><div class="copyright"><span><b>&copy;2022-2024</b></span><span><b>&nbsp;&nbsp;By PigCanStudy</b></span></div><div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" title="博客框架为Hexo_v6.3.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Frame-Hexo-blue.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" title="主题版本Butterfly_v4.3.1"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Theme-Butterfly-6513df.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" title="本站采用多线部署，主线路托管于Vercel"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Hosted-Vercel-brightgreen.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://user.51.la/" style="margin-inline:5px" title="本站数据分析得益于51la技术支持"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Analytics-51la-3db1eb.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://icp.gov.moe/?keyword=20226665" style="margin-inline:5px" title="本站已加入萌ICP豪华套餐，萌ICP备20226665号"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/萌ICP备-20226665-fe1384.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://bitiful.dogecast.com/buckets" style="margin-inline:5px" title="本网站经Service Worker分流至缤纷云对象存储"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src=" https://sourcebucket.s3.ladydaily.com/badge/Bucket-缤纷云-9c62da.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://www.netdun.net/" style="margin-inline:5px" title="本站使用网盾星球提供CDN加速与防护"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/CDN-网盾星球-fff2cc.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" title="本网站源码由Github提供存储仓库"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src=" https://sourcebucket.s3.ladydaily.com/badge/Source-Github-d021d6.svg" alt=""/></a></p></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button class="share" type="button" title="右键模式" onclick="changeMouseMode()"><i class="fas fa-mouse"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog right_side"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button class="share" type="button" title="分享链接" onclick="share()"><i class="fas fa-share-nodes"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i><span id="percent">0<span>%</span></span></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();"><i class="fa fa-copy"></i><span>复制</span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.baidu.com/s?wd=&quot;+window.getSelection().toString());window.location.reload();"><i class="fa fa-search"></i><span>百度搜索</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();"><i class="fa fa-link"></i><span>转到链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()"><i class="fa fa-copy"></i><span>粘贴</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-post"><a class="rightMenu-item" href="#post-comment"><i class="fas fa-comment"></i><span>空降评论</span></a><a class="rightMenu-item" href="javascript:rmf.copyWordsLink()"><i class="fa fa-link"></i><span>复制本文地址</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>新窗口打开</span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()"><i class="fa fa-link"></i><span>转到链接</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()"><i class="fa fa-download"></i><span>保存图片</span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>在新窗口打开</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制图片链接</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:randomPost()"><i class="fa fa-paper-plane"></i><span>随便逛逛</span></a><a class="rightMenu-item" href="javascript:switchNightMode();"><i class="fa fa-moon"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="/personal/about/"><i class="fa fa-info-circle"></i><span>关于博客</span></a><a class="rightMenu-item" href="javascript:toggleWinbox();"><i class="fas fa-cog"></i><span>美化设置</span></a><a class="rightMenu-item" href="javascript:rmf.fullScreen();"><i class="fas fa-expand"></i><span>切换全屏</span></a><a class="rightMenu-item" href="javascript:window.print();"><i class="fa-solid fa-print"></i><span>打印页面</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.umd.min.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/instant.page/5.1.0/instantpage.min.js" type="module"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/vanilla-lazyload/17.3.1/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><script async="async">var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())
setTimeout(function(){preloader.endLoading();}, 5000);
document.getElementById('loading-box').addEventListener('click',()=> {preloader.endLoading()})</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: '',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: '',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.staticfile.org/twikoo/1.6.8/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script src="https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js"></script><script async src="https://cdn1.tianli0.top/npm/vue@2.6.14/dist/vue.min.js"></script><script async src="https://cdn1.tianli0.top/npm/element-ui@2.15.6/lib/index.js"></script><script async src="https://cdn.bootcdn.net/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script><script defer type="text/javascript" src="https://cdn1.tianli0.top/npm/sweetalert2@8.19.0/dist/sweetalert2.all.js"></script><script async src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><script defer src="https://cdn1.tianli0.top/gh/nextapps-de/winbox/dist/winbox.bundle.min.js"></script><script async src="//at.alicdn.com/t/c/font_3586335_hsivh70x0fm.js"></script><script async src="//at.alicdn.com/t/c/font_3636804_gr02jmjr3y9.js"></script><script async src="//at.alicdn.com/t/c/font_3612150_kfv55xn3u2g.js"></script><script async src="https://cdn.wpon.cn/2022-sucai/Gold-ingot.js"></script><canvas id="universe"></canvas><canvas id="snow"></canvas><script defer src="/js/fomal.js"></script><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.js"></script><script src="https://cdn1.tianli0.top/npm/js-heo@1.0.12/metingjs/Meting.min.js"></script><script src="https://lib.baomitu.com/pjax/0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show","#web_bg",".js-pjax","#bibi","body > title","#app","#tag-echarts","#posts-echart","#categories-echarts"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><a class="magnet_link_more"  href="https://pigcanstudy.github.io/categories/" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(33.333333333333336% - 5px);background: #e9e9e9;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: var(--text-bg-hover)}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/95787e92.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-07-16</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/95787e92.html&quot;);" href="javascript:void(0);" alt="">网络编程教程</a><div class="blog-slider__text">🥧本文介绍了linux基础的系统编程和基础的Linux网络编程</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/95787e92.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/2f7ff9a3.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-07-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/2f7ff9a3.html&quot;);" href="javascript:void(0);" alt="">C++面试笔记</a><div class="blog-slider__text">本文介绍了C++面试笔记的相关知识</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/2f7ff9a3.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/e8e79e61.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-07-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/e8e79e61.html&quot;);" href="javascript:void(0);" alt="">C++并发编程</a><div class="blog-slider__text">本文介绍了C++并发编程的相关知识</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/e8e79e61.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/6e928d8a.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-07-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/6e928d8a.html&quot;);" href="javascript:void(0);" alt="">C++Qt</a><div class="blog-slider__text">本文介绍了C++Qt的相关知识</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/6e928d8a.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/9724705.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-07-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/9724705.html&quot;);" href="javascript:void(0);" alt="">C++asio网络编程</a><div class="blog-slider__text">本文介绍了C++运用asio进行网络编程的相关知识</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/9724705.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><script data-pjax src="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.js"></script><script data-pjax>
  function gitcalendar_injector_config(){
      var parent_div_git = document.getElementById('gitZone');
      var item_html = '<div class="recent-post-item" id="gitcalendarBar" style="width:100%;height:auto;padding:10px;"><style>#git_container{min-height: 320px}@media screen and (max-width:650px) {#git_container{min-height: 0px}}</style><div id="git_loading" style="width:10%;height:100%;margin:0 auto;display: block;"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animatetransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animatetransform></path></svg><style>#git_container{display: none;}</style></div><div id="git_container"></div></div>';
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      console.log('已挂载gitcalendar')
      }

    if( document.getElementById('gitZone') && (location.pathname ==='/site/census/'|| '/site/census/' ==='all')){
        gitcalendar_injector_config()
        GitCalendarInit("/api?null",['#d9e0df', '#c6e0dc', '#a8dcd4', '#9adcd2', '#89ded1', '#77e0d0', '#5fdecb', '#47dcc6', '#39dcc3', '#1fdabe', '#00dab9'],'null')
    }
  </script><!-- hexo injector body_end end --></body></html>