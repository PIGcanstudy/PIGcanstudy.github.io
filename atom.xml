<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>PigCanStudy</title>
  
  
  <link href="https://pigcanstudy.github.io/atom.xml" rel="self"/>
  
  <link href="https://pigcanstudy.github.io/"/>
  <updated>2024-11-29T10:47:30.940Z</updated>
  <id>https://pigcanstudy.github.io/</id>
  
  <author>
    <name>PigCanStudy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mit6.824学习笔记</title>
    <link href="https://pigcanstudy.github.io/posts/abaf39bf.html"/>
    <id>https://pigcanstudy.github.io/posts/abaf39bf.html</id>
    <published>2024-11-29T09:26:24.000Z</published>
    <updated>2024-11-29T10:47:30.940Z</updated>
    
    <content type="html"><![CDATA[<h1>目录</h1><ul><li><a href="#%E7%9B%AE%E5%BD%95">目录</a><ul><li><a href="#mit6824%E8%AF%BE%E7%A8%8B">MIT6.824课程</a><ul><li><a href="#%E5%88%86%E5%B8%83%E7%B3%BB%E7%BB%9F%E7%AE%80%E8%BF%B0">分布系统简述</a><ul><li><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%9A%E4%B9%89">分布式系统的定义</a></li><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F">为什么使用分布式系统？</a></li><li><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8E%86%E5%8F%B2">分布式系统的历史</a></li><li><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%9A%BE%E7%82%B9chalenges">分布式系统的难点（Chalenges）</a></li><li><a href="#%E8%AF%BE%E7%A8%8B%E4%BB%8B%E7%BB%8D">课程介绍</a></li><li><a href="#%E6%94%AF%E6%8C%81%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84">支持分布式系统的底层基础架构</a></li><li><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%B9%E6%80%A7">分布式系统的特性</a></li><li><a href="#mapreduce%E6%A6%82%E8%BF%B0">mapreduce概述</a></li><li><a href="#mapreduce%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B">mapreduce的执行流程</a></li><li><a href="#mapreduce%E7%9A%84%E5%AE%B9%E9%94%99%E6%80%A7">mapreduce的容错性</a></li><li><a href="#mapreduce%E5%85%B6%E4%BB%96%E5%BC%82%E5%B8%B8%E5%9C%BA%E6%99%AF">mapreduce其他异常场景</a></li><li><a href="#%E7%BB%93%E8%AF%AD">结语</a></li></ul></li><li><a href="#threads%E5%92%8Crpc%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8">Threads和RPC(多线程和远程过程调用)</a><ul><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E7%94%A8go%E8%AF%AD%E8%A8%80">为什么选用go语言</a></li><li><a href="#go%E7%9A%84%E5%A4%9A%E5%8D%8F%E7%A8%8B%E6%8C%91%E6%88%98">go的多协程挑战</a></li><li><a href="#go%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%8C%91%E6%88%98">go如何应对多线程的挑战</a></li><li><a href="#go%E7%9A%84%E5%A0%86%E6%A0%88%E5%92%8C%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90">go的堆栈和逃逸分析</a><ul><li><a href="#%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90">逃逸分析</a></li><li><a href="#%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99">逃逸分析的基本原则</a></li><li><a href="#%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E4%B8%BE%E4%BE%8B">逃逸分析举例</a></li></ul></li></ul></li><li><a href="#%E8%B0%B7%E6%AD%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fgfs">谷歌文件系统GFS</a><ul><li><a href="#%E5%AD%98%E5%82%A8">存储</a><ul><li><a href="#%E5%AD%98%E5%82%A8%E8%AE%BE%E8%AE%A1%E7%9A%84%E9%9A%BE%E7%82%B9">存储设计的难点</a></li><li><a href="#%E4%B8%80%E8%87%B4%E6%80%A7">一致性</a></li></ul></li><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AFgfs">什么是GFS？</a></li><li><a href="#gfs%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%8F%96%E6%B5%81%E7%A8%8B">GFS数据读取流程</a></li><li><a href="#gfs-master%E7%AE%80%E8%BF%B0">GFS-Master简述</a></li><li><a href="#gfs-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96">GFS-文件读取</a></li><li><a href="#gfs-%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5">GFS-文件写入</a></li></ul></li><li><a href="#%E4%B8%BB%E5%A4%87%E5%A4%8D%E5%88%B6">主备复制</a><ul><li><a href="#%E5%A4%B1%E8%B4%A5%E7%9A%84%E5%9C%BA%E6%99%AF">失败的场景</a></li><li><a href="#%E4%B8%BB%E5%A4%87%E5%A4%8D%E5%88%B6%E7%9A%84%E5%AE%9E%E7%8E%B0%E9%9A%BE%E7%82%B9">主备复制的实现难点</a></li><li><a href="#%E4%B8%BB%E5%A4%87%E5%A4%8D%E5%88%B6%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95">主备复制的两种方法</a></li><li><a href="#%E5%A4%8D%E5%88%B6%E7%8A%B6%E6%80%81%E6%9C%BArsm-%E5%A4%8D%E5%88%B6%E4%BB%80%E4%B9%88%E7%BA%A7%E5%88%AB%E7%9A%84%E6%93%8D%E4%BD%9C">复制状态机RSM-复制什么级别的操作</a></li><li><a href="#%E9%80%9A%E8%BF%87%E8%99%9A%E6%8B%9F%E5%8C%96%E5%AE%9E%E7%8E%B0%E5%A4%8D%E5%88%B6">通过虚拟化实现复制</a></li><li><a href="#%E5%B7%AE%E5%BC%82%E6%9D%A5%E6%BA%90">差异来源</a></li><li><a href="#vm-ft%E7%9A%84%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86">VM-FT的中断处理</a></li><li><a href="#vm-ft%E5%A4%B1%E8%B4%A5%E5%9C%BA%E6%99%AF%E7%9A%84%E5%A4%84%E7%90%86">VM-FT失败场景的处理</a></li><li><a href="#vm-ft%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98">VM-FT性能问题</a></li></ul></li><li><a href="#%E9%94%99%E8%AF%AF%E5%AE%B9%E5%BF%8D-raft%E7%AE%97%E6%B3%95">错误容忍-Raft算法</a><ul><li><a href="#%E5%8D%95%E7%82%B9%E6%95%85%E9%9A%9C">单点故障</a></li><li><a href="#%E8%84%91%E8%A3%82%E9%97%AE%E9%A2%98">脑裂问题</a></li><li><a href="#raft%E9%87%87%E5%8F%96%E7%9A%84%E7%9A%84%E5%8E%9F%E5%88%99%E5%A4%A7%E5%A4%9A%E6%95%B0%E5%8E%9F%E5%88%99">Raft采取的的原则:大多数原则</a><ul><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B8%AA%E5%8E%9F%E5%88%99%E4%BC%9A%E4%BD%9C%E4%B8%BA%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3">为什么这个原则会作为基本思想</a></li></ul></li><li><a href="#raft%E5%8E%86%E5%8F%B2%E5%8F%91%E5%B1%95">raft历史发展</a></li><li><a href="#%E4%BD%BF%E7%94%A8raft%E6%9E%84%E9%80%A0%E5%A4%8D%E5%88%B6%E7%8A%B6%E6%80%81%E6%9C%BA">使用Raft构造复制状态机</a></li><li><a href="#raft%E6%A6%82%E8%BF%B0">Raft概述</a></li><li><a href="#raft-log%E7%9A%84%E7%94%A8%E9%80%94">Raft log的用途</a></li><li><a href="#raft%E7%9A%84log%E6%A0%BC%E5%BC%8F">Raft的log格式</a></li><li><a href="#raft%E7%9A%84%E9%80%89%E4%B8%BE">Raft的选举</a><ul><li><a href="#%E6%83%85%E5%86%B51-%E9%9B%86%E7%BE%A4%E4%B8%AD%E6%B2%A1%E6%9C%89leader">情况1 ：集群中没有leader</a></li><li><a href="#%E6%83%85%E5%86%B52-%E9%9B%86%E7%BE%A4%E4%B8%AD%E6%9C%89leader%E5%B9%B6%E4%B8%94leader%E5%AE%95%E6%9C%BA%E4%BA%86">情况2 ：集群中有leader，并且leader宕机了</a><ul><li><a href="#%E6%AD%A4%E6%97%B6%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%E5%8F%98%E5%91%B3%E4%BA%86%E5%80%99%E9%80%89%E8%8A%82%E7%82%B9">此时只有一个节点变味了候选节点</a></li><li><a href="#%E6%9C%89%E4%B8%A4%E4%B8%AA%E5%80%99%E9%80%89%E4%BA%BA%E5%90%8C%E6%97%B6%E7%AB%9E%E9%80%89%E9%80%89%E4%B8%BE%E6%9D%A1%E4%BB%B6">有两个候选人同时竞选（选举条件）</a></li></ul></li></ul></li><li><a href="#raft%E7%9A%84%E9%80%89%E4%B8%BE%E8%B6%85%E6%97%B6%E6%97%B6%E9%97%B4">Raft的选举超时时间</a></li><li><a href="#raft-vote%E9%9C%80%E8%AE%B0%E5%BD%95%E5%88%B0%E7%A8%B3%E5%AE%9A%E7%9A%84storage%E6%8C%81%E4%B9%85%E5%8C%96">Raft-vote需记录到稳定的storage（持久化）</a></li><li><a href="#raft-%E6%97%A5%E5%BF%97">Raft-日志</a><ul><li><a href="#raft%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%A5%E5%BF%97%E5%A4%8D%E5%88%B6%E8%BF%87%E7%A8%8B">Raft算法的日志复制过程</a></li><li><a href="#raft-%E6%97%A5%E5%BF%97%E5%88%86%E6%AD%A7">Raft-日志分歧</a></li><li><a href="#raft%E9%80%89%E4%B8%BE%E8%A7%84%E5%88%99">Raft选举规则</a></li><li><a href="#raft-%E6%97%A5%E5%BF%97%E8%A6%86%E5%86%99%E5%90%8C%E6%AD%A5%E6%9C%AA%E4%BC%98%E5%8C%96%E7%89%88%E6%9C%AC">Raft-日志覆写同步（未优化版本）</a></li><li><a href="#raft-%E6%97%A5%E5%BF%97%E6%93%A6%E9%99%A4">Raft-日志擦除</a></li><li><a href="#raft-%E6%97%A5%E5%BF%97%E5%BF%AB%E9%80%9F%E8%A6%86%E5%86%99%E5%90%8C%E6%AD%A5">Raft-日志快速覆写同步</a></li><li><a href="#raft-%E6%8C%81%E4%B9%85%E5%8C%96">Raft-持久化</a></li><li><a href="#raft-%E6%9C%8D%E5%8A%A1%E6%81%A2%E5%A4%8D">Raft-服务恢复</a></li><li><a href="#%E7%BA%BF%E6%80%A7%E4%B8%80%E8%87%B4%E6%80%A7">线性一致性</a></li></ul></li></ul></li></ul></li></ul></li></ul><h2 id="MIT6-824课程">MIT6.824课程</h2><h3 id="分布系统简述">分布系统简述</h3><h4 id="分布式系统的定义">分布式系统的定义</h4><ul><li>非正式的定义，这里认为<strong>多个</strong>只能通过<strong>网络发送/接收数据包进行交互</strong>的系统，(而不是使用多处理核，因为多处理核是可以通过共享内存实现数据的交互的)即构成分布式系统, 它们<strong>合作</strong>来提供一些服务</li></ul><h4 id="为什么使用分布式系统？">为什么使用分布式系统？</h4><ul><li><strong>可以实现数据之间的共享 (sharing)</strong></li><li><strong>通过并行提高性能(increase capacity though parallelism)</strong>(可以将数据分散到多个节点上并行处理。处理海量数据时，传统的单机处理方式无法满足需求，而分布式处理可以将任务划分成小部分，快速处理，从而大大提高性能。)</li><li><em><strong>提高服务容错性 (tolerate faults) （本课重点）</strong></em> (一部分服务宕机不会影响到另一个部分服务，具有高可用性)</li><li><strong>利用物理隔离的手段提高整体服务安全性 (achieve security via isolation)</strong>(许多银行会将敏感的客户数据存放在隔离的数据库中，而与外部系统通过API进行通信。通过物理隔离，这些核心数据不暴露在开放的网络上，从而提高系统的安全性，降低数据被攻击或泄露的风险。)</li></ul><h4 id="分布式系统的历史">分布式系统的历史</h4><ul><li>局域网分布式系统的服务 (1980s)（类似校园网这种）</li><li>互联网规模的分布式系统，比如DNS（域名服务系统）、email</li><li>数据中心 (Data center)，伴随大型网站而生 (1990s)<ol><li>常见的有网页搜索（爬虫实现，然后需要建立大量倒排索引）</li><li>商城购物系统（海量商品、订单、用户信息等数据）</li></ol></li><li>云计算 (Cloud computing) (2000s)<ol><li>本地运算/本地运行应用，转移到云服务上运算/运行应用</li></ol></li></ul><h4 id="分布式系统的难点（Chalenges）">分布式系统的难点（Chalenges）</h4><blockquote><p><strong>网络分区</strong>：那么对于一个n个节点组成的网络来说，如果n 个节点可以被分为k个不相交且覆盖的group, 每个group内所有节点全是两两正常连接，而任意两个group之间的任何节点无连接。当k=1 时，网络正常，当k &gt; 1 时，我们称之为network partition。</p><p><a href="https://www.cnblogs.com/Jscroop/p/14382790.html#_label0">《RabbitMQ实战指南》整理（七）网络分区</a></p><p>RabbitMQ集群内两两节点之间会有信息交互，如果某节点出现网络故障或是端口不同，则会使与此节点的交互出现中断，经过超时判定后，会判定网络分区。网络分区的判断与net_ticktime参数息息相关，其默认值为60。集群内部每个节点间会每隔四分之一net_ticktime记一次应答，如果任何数据被写入节点中，则此节点会被认为已经被应答了，如果连续4次没有应答，则会判定此节点已下线，其余节点可以将此节点剥离出当前分区。</p><p>对于未配置镜像的集群，网络分区发生之后，队列也会随着宿主节点而分散在各自的分区中。对于消息发送方而言，可以成功发送消息，但是会有路由失败的情况，需要配合mandatory等机制保障消息的可靠性，对于消息消费方而言，可能会出现不可预知的现象，比如已消费消息ack会失效。网络分区发生后，客户端与某分区重新建立通信链路，其分区中如果没有相应的队列进程，则会有异常报出。如果从网络分区中恢复，数据不会丢失，但是客户端会重复消费。</p><p>对于已镜像的集群，网络分区的发生会引起消息的丢失，解决办法为消息发送端需要具备Basic.Return的能力，其次在检测到网络分区之后，需要迅速地挂起所有生产者进程，之后连接分区中的每个节点消费分区中所有的队列数据，在消费完之后再处理网络分区，最后从网络分区中恢复之后再恢复生产者进程。整个过程可以最大程度上保证网络分区之后的消息的可靠性。需要注意的是整个过程中会有大量的消息重复，消费客户端需要做好相应的幂等性处理。也可以将所有旧集群资源迁移到新集群来解决这个问题。</p></blockquote><ul><li><p>许多并发场景 (many concurrent part)</p></li><li><p><strong>需要处理故障/宕机问题</strong> (must deal with partial failure)</p></li><li><p><strong>尤其是发生网络分区问题</strong> (network partition)</p></li><li><p>体现性能优势 (realize the performance benefits)</p></li></ul><p>通常任务并非真正所有步骤都并行执行，需要良好的实现才能达到增加机器数就提高吞吐量的效果</p><h4 id="课程介绍">课程介绍</h4><p>实验内容：</p><ul><li><p>Lab1：实现mapreduce</p></li><li><p>Lab2：在存在故障和网络分区的情况下，使用raft协议完成复制</p></li><li><p>Lab3：通过实验2，复制一个Key-Value存储的服务</p></li><li><p>Lab4：构造分片(sharded)的key-value存储服务</p></li></ul><h4 id="支持分布式系统的底层基础架构">支持分布式系统的底层基础架构</h4><ul><li>存储：键值服务器，文件系统等</li><li>计算：分布式计算框架，用来编排或构建分布式应用程序如MapReduce，Spark等</li><li>通信：分布式通信框架，使用RPC（远程过程调用）：RPC的消息传递语义有三个（它们描述了在分布式系统中，消息如何在客户端和服务器之间进行传递，以及对消息传递保障的不同要求）<ol><li>utmost once：最多一次，最多一次的发送消息，不管对方是否收到消息都不会重发</li><li>exactly once：确保一次，确保消息只发送一次，不管对方是否收到消息都不会重发</li><li>at least once：至少一次，至少发送一次，不管对方是否收到消息都发送一次</li></ol></li></ul><p><strong>对于分布式系统的底层基础架构，我们通常抽象的目标是做到让使用者觉得和单机操作无异，这是非常难实现的。</strong>（也就是隐藏分布式中各类难题的具体实现，对外暴露时争取和普通本地串行函数别无二致。）</p><h4 id="分布式系统的特性">分布式系统的特性</h4><blockquote><p><a href="https://www.zhangbj.com/p/769.html">尾部延迟是什么？如何避免尾部延迟？ | 程序员技术之旅 (zhangbj.com)</a>&lt;= 简述概念和产生原因<br>概念：有1%的请求耗时高于99%的请求耗时，影响用户体验，甚至拖垮服务。</p><p><a href="https://www.jdon.com/56122.html">什么是尾部延迟</a><br>我们并行调用N个服务，然后等待最慢的一个。应用我们的直觉表明，随着N的增加，我们等待约100ms缓慢呼叫的可能性越来越大。在N = 1的情况下，发生这种情况的时间约为1％。在N = 10的情况下，大约有10％的时间。在这个简单的模型中，这种基本直觉是正确的。然而，在实际中，我们遇到的情况可能比这个更复杂。</p></blockquote><ul><li><p><strong>容错性</strong>：系统在部分节点故障时仍然可以正常运行，通常通过复制和容错机制实现。</p><ol><li>可用性：一般用p999等指标衡量（p999就是指99.9%，即在所有的请求中，99.9%的请求响应时间都在这个值以下。这意味着只有0.1%的请求响应时间会超过这个值。）<ul><li>主要依赖replication复制技术（例如通过将数据和服务复制到多个节点上，确保即使部分节点发生故障，系统依然能够继续运行。）</li></ul></li><li>可恢复性：当机器崩溃或故障时，在重启时恢复正常工作状态<ul><li>主要依赖logging or transaction（日志或事务）一类的技术</li><li>durable storage，需要将数据写入持久化的存储器（磁盘），便于后续恢复工作</li></ul></li></ol></li><li><p><strong>一致性</strong>:多个服务器应该具有相同的状态，提供一致的服务，不能出现客户端用相同操作请求两个服务器却获得了不同结果的情况。一致性根据程度可以分为最终一致性和强一致性。</p><ol><li>最终一致性：系统保证在一段时间后，所有节点的数据最终都能达到一致。也就是说不保证在任意时刻数据都是一致的</li><li>强一致性：系统保证任意时刻，所有节点的数据都是一致的。具体来说，任何一次读操作都能读到某个数据的最近一次写操作的结果。这意味着系统中的所有进程看到的操作顺序都与全局时钟下的顺序一致。例如，在关系型数据库中，更新后的数据必须能被后续的访问立即看到，这就是强一致性</li></ol></li><li><p><strong>性能</strong>：分布式系统往往希望能比单机系统要具备更高的性能，但是提高性能本身和提供容错性、一致性是冲突的。<br>性能指标一般涉及两个方面：吞吐量和延迟。</p><ul><li>吞吐量：系统处理请求的能力，通常用每秒处理请求数（TPS）来衡量。</li><li>延迟：系统响应请求的时间，通常用平均响应时间（RTT）来衡量。（<strong>尾部延迟</strong>（上述引文有讲）在分布式系统中尤为重要，因为它会严重影响系统的整体性能。）</li></ul></li></ul><p>为了达到强一致性，需要不同机器之间的通信，这可能降低性能</p><p>​为了实现容错，需要从不同机器上复制数据，还需要将数据写入持久化存储器这一昂贵操作</p><p>​通常要兼顾以上3个特性很难做到，常见的实现要么牺牲一点一致性换取更高的性能；要么牺牲一点容错性换取更好的性能，不同的实现方式有不同的权衡。</p><h4 id="mapreduce概述">mapreduce概述</h4><ul><li>论文的背景是google的两位数据工程师需要处理爬虫数据，建立倒排索引，用于网页搜索。需要几个小时处理TB级别的数据。传统的代码实现，并发执行任务，如果中间一个线程出错，可能整个任务都需要重新执行，所以还需要考虑容错性设计。</li></ul><p>​- 程序员通过编写函数式或无状态的map函数和reduce函数的实现，实现分布式数据的处理。mapreduce内部通过其他机制保证执行过程的容错性、分布式通信等问题，对程序员隐藏这些细节。</p><p>​- map-reduce经典举例即统计字母出现的次数，多个进程各自通过map函数统计获取到的数据片段的字母的出现次数；后续再通过reduce函数，汇总聚合map阶段下每个进程对各自负责的数据片段统计的字母出现次数。一旦执行了shuffle，多个reduce函数可以各自只聚合一种字母的出现总次数，彼此之间不干扰。</p><p>​- 开销昂贵的部分即shuffle，map的结果经过shuffle按照一定的顺序整理/排序，然后才分发给不同的reduce处理。这里shuffle的操作理论比map、reduce昂贵。</p><p>提问：排序操作是否可以通过map-reduce完成</p><p>回答：可以，排序在mapreduce中是讨论最多的应用之一，可以通过mapreduce实现。你可以将输入拆分成不同部分，mapper对这些部分进行排序，输出拆分成r个桶，每个reduce对这r个桶进行排序，最后输出完整的文件。</p><h4 id="mapreduce的执行流程">mapreduce的执行流程</h4><p><a href="https://mp.weixin.qq.com/s?__biz=MzIwODA2NjIxOA==&amp;mid=2247484185&amp;idx=1&amp;sn=055263242bfb70e727b8fffb1d879301&amp;chksm=970980dca07e09ca97fef2fda5ad34d5f56df4edc9ce487bc69291fb621fbdd6db4af6a57560&amp;scene=21#wechat_redirect">MIT6.824学习笔记</a>&lt;&lt;== 一位大佬对mapreduce的详细介绍</p><p><img src="../assets/2024-11-29-Mit6-824%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ef809e086995d393077cdc480a64ef2b.png" alt="alt text"></p><ul><li>首先会创建许多worker，以及Master进程。其中一般来说Worker进程有两种一种是负责map任务一种是负责reduce任务（一个Worker会专注执行一种任务要么是reduce要么是map）。</li><li>Master进程，又被称为协调器，负责任务(map,reduce任务)分配给不同的worker</li><li>当输入的数据到来的时候，会被分为M个小文件（每个文件大小大概是16M-64M），然后在集群中启动MapReduce实例，其中有一个Master和多个Worker</li><li>Master会将小文件发给可用的Worker，这是基于GFS实现的，所以不存在网络传输</li><li>Worker得到小文件后，会读取文件并对其进行map操作，输出key/value对（中间状态&lt;a,1&gt;,&lt;b,1&gt;,&lt;a,1&gt;），首先缓存在内存中，在内存上存储实际是一个循环数组，有两个指针，一个指向可读的位置，一个指向可写的位置，当这个数组到达一个阈值(80%)就会执行flush操作，将数据写入磁盘，在内存中已经写入的数据会被移除（移动可读指针）。再写入磁盘前内存中的 (key, value) 对通过 partitioning function() 例如 hash(key) mod R 分为 R 个 regions（这个Regions的个数与执行reduce函数的Worker有关）。写入磁盘后，把这些文件的地址回传给 Master，然后 Master 把这些位置传给 Reduce Worker;</li><li>Reduce Worker 收到 Master 的位置信息后，会使用RPC从MapWorker所在的磁盘读取这些数据，并根据key进行排序，然后将同一key的所有数据聚合在一起（<strong>由于许多不同的 key 值会映射到相同的 Reduce 任务上，因此必须进行排序。如果中间数据太大无法在内存中完成排序，那么就要在外部进行排序</strong>）；</li><li>Reduce Worker 将分组后的值传给用户自定义的 reduce 函数，输出追加到所属分区的输出文件中；</li><li>当所有的 Map 任务和 Reduce 任务都完成后，Master 向用户程序返回结果；</li></ul><p>​ 输入文件在全局文件系统中，被称为GFS。Google现在使用的是不同的global file system，但该论文中使用的是GFS。</p><p>​ 上面流程最后reduce输出结果会被保存到GFS，而map产生的中间文件不会被保存到GFS中（而是保存到worker运行的本地机器上）。</p><p><img src="../assets/2024-11-29-Mit6-824%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image.png" alt="alt text"></p><p>上图为流程的概要</p><p>问题1：在远程读取进程中，文件是否会传输到reducer？</p><p>回答1：是的。map函数产生的中间结果存放在执行map函数的worker机器的磁盘上，而之后解调器分配文件给reducer执行reduce函数时，中间结果数据需要通过网络传输到reducer机器上。这里其实很少有网络通信，因为一个worker在一台机器上，而每台机器同时运行着worker进程和GFS进程。worker运行map产生中间结果存储在本地，而之后协调器给worker分配文件以执行reduce函数时，才需要通过网络获取中间结果数据，最后reduce处理完在写入GFS，写入GFS的动作也往往需要通络传输。</p><p><strong>问题2：协调器是否负责对数据进行分区，并将数据分发到每个worker或机器上？</strong></p><p><strong>回答2：不是的。mapreduce运行用户程序，这些输入数据在GFS中。（也就是说协调器告知worker从GFS取哪些数据进行map，后续协调器又告知worker从哪些worker机器上获取中间结果数据进行reduce，最后又统一写入到GFS中）</strong></p><p>问题3：这里涉及的排序是如何工作的？比如谁负责排序，如何排序？</p><p>回答3：在中间结果数据传递到reduce函数之前，mapreduce库进行一些排序。比如所有的中间结果键a、b、c到一个worker。比如(a,1) (b,1) (c,1) (a,1) 数据，被排序成(a,1) (a,1) (b,1) (c,1) 后才传递给reduce函数。</p><p>问题4：很多函数式编程是否可以归结为mapreduce问题？</p><p>回答4：是的。因为map、reduce函数的概念，在函数式编程语言中非常常见，或者说函数式编程真是map、reduce的灵感来源。</p><h4 id="mapreduce的容错性">mapreduce的容错性</h4><ul><li><p>主要分为两种故障：</p><ul><li>Worker故障：Master 周期性的 ping 每个 Worker，如果指定时间内没回应就是挂了。将这个 Worker 标记为失效，分配给这个失效 Worker 的任务将被重新分配给其他 空闲的Worker；这就是fault tolerance容错的基本方案</li></ul><p>换句话说，如果coordinator没有收到worker反馈task任务完成，那么会coordinator重新分配worker要求执行task（可能分配到同一个worker，重点是task会被重新执行）。<strong>这里涉及一个问题，map是否会被执行两次？</strong></p><p>或许没反馈task执行done完成的worker是遇到网络分区等问题，并没有宕机，或者协调者不能与worker达成网络通信，但实际上worker仍然在运行map任务，它正在产生中间结果。<strong>这里的答案是，同一个map可以被运行两次。</strong></p><p>​ **被执行两次是能够接受的（幂等性问题），正是map和reduce属于函数式(functional)的原因之一。**如果map/reduce是一个funcitonal program，那么使用相同输入运行时，产生的输出会是相同的（也就是保证幂等）。</p><p>**类似的，reduce能够运行两次吗？**是的，和map出于相同的原因，从容错的角度上看，执行reduce函数和map函数并没有太大区别。**需要注意的是，这时候可能有两个reducer同时有相同的输出文件需要写入GFS，它们首先在全局文件系统GFS中产生一个中间文件，然后进行atomic rename原子重命名，将文件重命名为实际的最终名称。**因为在GFS中执行的重命名是原子操作，最后哪个reducer胜出并不重要，因为reduce是函数式的，它们最终输出的数据都是一样的。</p><ul><li>Master 故障：中止整个 MapReduce 运算，重新执行。一般很少出现 Master 故障。</li></ul></li></ul><p><strong>问题1：一台机器应该可以执行多个map任务，如果它分配10个map任务，而在执行第7个map任务时失败了，master得知后，会安排将这7个已完成的map任务分布式地重新执行，可能分散到不同的map机器上，对吗？</strong></p><p><strong>回答1：是的。虽然我认为通常一台机器只运行一个map函数或一个reduce函数，而不是多个。</strong></p><p><strong>问题2：在worker完成map任务后，它是否会直接将文件写入其他机器可见的位置，或者只是将文件保存到自己的文件系统中？</strong></p><p><strong>回答2：map函数总是在本地磁盘产生结果，所以中间结果文件只会在本地文件系统中。</strong></p><p>问题3：即使一次只做一个map任务，但是如果执行了多次map任务后，如果机器突然崩溃，那么会丢失之前负责的所有map任务所产生的中间结果文件，对吗？</p><p>回答3：不，中间结果文件放在本地文件系统中（磁盘中）。所以当机器恢复时，中间结果文件还在那里，因为文件数据是被持久化保存的，而不是只会存在于内存中（换句话说，这里依赖了操作系统的文件系统本身的容错性）。并且map或reduce会直接访问包含intermediate results中间结果的机器。</p><h4 id="mapreduce其他异常场景">mapreduce其他异常场景</h4><ul><li>执行缓慢的worker（Slow workers）？</li></ul><p>比如GFS也在同一台机器上运行占用大量的机器周期或带宽，或硬件本身问题，导致worker执行map/reduce很慢。<strong>慢的worker被称为straggler，当剩下几个map/reduce任务没有执行时，协调者会另外分配相同的map/reduce任务到其他闲置worker上运行，达到backup task的效果</strong>（因为函数式，map/reduce以相同输入执行最后会产生相同输出，所以执行多少次都不会有问题）。</p><p><strong>通过备用任务(backup task)</strong>，性能不会受限于最慢的几个worker，因为有更快的worker会领先它们完成task（map或reduce）。这是应对straggler的普遍做法，通过replicate tasks复制任务，获取更快完成task的输出结果，处理了tail latency尾部延迟问题。</p><h4 id="结语">结语</h4><p>尽管由于一些原因，Google 已经不在使用 MapReduce 了。但 MapReduce 从根本上改变了大规模数据处理架构，它通过一个简单的 API，抽象了处理并行、容错和负载均衡的复杂性，让没有相关经验的程序员也能够在计算机集群上分布式地处理大规模数据集。</p><h3 id="Threads和RPC-多线程和远程过程调用">Threads和RPC(多线程和远程过程调用)</h3><h4 id="为什么选用go语言">为什么选用go语言</h4><p>这里主要讲为什么这个课程选用Go语言进行编程。</p><ul><li>good support for threads/RPC：对线程和RPC的支持度高</li><li>gc：自带GC，无需考虑垃圾回收问题</li><li>type safe：类型安全</li><li>simple：简单易上手</li><li>compiled：编译型语言，运行时开销更低</li></ul><h4 id="go的多协程挑战">go的多协程挑战</h4><ul><li><p>race conditions：多线程会引入竞态条件的场景</p><ul><li>avoid sharing：避免共享内存以防止竞态条件场景的产生（Go有一个竞态检测器race detector，能够辅助识别代码中的一些竞态条件场景）</li><li>use locks：让一系列指令变成原子操作</li></ul></li><li><p>coordination：同步协调问题，比如一个线程的执行依赖另一个线程的执行结果等</p><ul><li>channels：通道允许同时通信和协调</li><li>condition variables：配合互斥锁使用</li></ul></li><li><p>deadlock：死锁问题，比如在go中简单的死锁场景，一个写线程往channel写数据，但是永远没有读线程从channel读数据，那么写线程被永久阻塞，即死锁，go会抓住这种场景，抛出运行时错误runtime error。</p></li></ul><h4 id="go如何应对多线程的挑战">go如何应对多线程的挑战</h4><ul><li>channels：通道<ul><li>no-sharing场景：如果线程间不需要共享内存（变量等），一般偏向于使用channels完成线程间的通信</li></ul></li><li>locks + condition variables：锁和条件变量配套使用<ul><li>shared-memory：如果线程间需要共享内存，则采用锁+条件变量的方案。比如键值对key-value服务，需要共享key-value table。</li></ul></li></ul><h4 id="go的堆栈和逃逸分析">go的堆栈和逃逸分析</h4><blockquote><p><a href="https://zhuanlan.zhihu.com/p/586249256">go的堆栈和逃逸分析详解</a></p><p>相比于把内存分配到堆中，分配到栈中优势更明显。Go语言也是这么做的：Go编译器会尽可能将变量分配到到栈上。但是，当编译器无法证明函数返回的变量有没有被引用时，编译器就必须在堆上分配该变量，以此避免悬挂指针（dangling pointer）的问题。另外，如果局部变量占用内存非常大，也会将其分配在堆上。</p></blockquote><p><strong>问题：go是如何确定内存是分配到栈上还是堆上？</strong></p><p><strong>答案：逃逸分析</strong></p><h5 id="逃逸分析">逃逸分析</h5><ul><li>什么是逃逸分析：<em><strong>编译器通过逃逸分析技术去选择堆或者栈，逃逸分析的基本思想如下：检查变量的生命周期是否是完全可知的，如果通过检查，则在栈上分配。否则，就是所谓的逃逸，必须在堆上进行分配。</strong></em></li></ul><h5 id="逃逸分析的基本原则">逃逸分析的基本原则</h5><ul><li>不同于JAVA JVM的运行时逃逸分析，Go的逃逸分析是在<strong>编译期</strong>完成的：编译期无法确定的参数类型<strong>必定</strong>放到堆中；</li><li>如果变量在函数<strong>外部存在引用</strong>，则<strong>必定</strong>放在堆中；</li><li>如果变量占用<strong>内存较大</strong>时，则<strong>优先</strong>放到堆中；</li><li>如果变量在函数外部<strong>没有引用</strong>，则优先放到<strong>栈</strong>中；</li></ul><h5 id="逃逸分析举例">逃逸分析举例</h5><p>我们使用这个命令来查看逃逸分析的结果： go build -gcflags ‘-m -m -l’</p><ol><li>参数类型是interface类型</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pacakge main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="number">666</span></span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p>这段代码就输出了 a escapes to heap</p><p><strong>原因分析</strong><br>因为Println的参数类型是interface，编译器无法确定它的具体类型，因此必须在堆上分配。</p><ol start="2"><li>变量在外部存在引用</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> *<span class="type">int</span> &#123;</span><br><span class="line">    a := <span class="number">6</span></span><br><span class="line">    <span class="keyword">return</span> &amp;a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    _ := test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong><br>这段代码就输出了moved to head: a</p><p><strong>原因分析</strong><br>变量a在函数外部存在引用。</p><p><strong>我们来分析一下执行过程：当函数执行完毕，对应的栈帧就被销毁，但是引用已经被返回到函数之外。如果这时外部通过引用地址取值，虽然地址还在，但是这块内存已经被释放回收了，这就是非法内存。</strong></p><p>为了避免上述非法内存的情况，在这种情况下变量的内存分配必须分配到堆上</p><ol start="3"><li>变量占用内存较大</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10000</span>, <span class="number">10000</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i ++ &#123;</span><br><span class="line">        a[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong><br>这段代码就输出了make([]int, 10000, 10000) escapes to heap</p><p><strong>原因分析</strong><br>我们定义了一个容量为10000的int类型切片，发生了逃逸，内存分配到了堆上（heap）。</p><ol start="4"><li>变量大小不确定的时候也会分配在堆上</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">l := <span class="number">1</span></span><br><span class="line">a := <span class="built_in">make</span>([]<span class="type">int</span>, l, l)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; l; i++ &#123;</span><br><span class="line">a[i] = i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong><br>这段代码就输出了make([]int, l, l) escapes to heap</p><p><strong>原因分析</strong><br>我们虽然在代码段中给变量 l 赋值了1，但是编译期间只能识别到初始化int类型切片时，传入的长度和容量是变量l，编译期并不能确定变量l的值，所以发生了逃逸，会把内存分配到堆中。</p><h3 id="谷歌文件系统GFS">谷歌文件系统GFS</h3><ul><li>首先我们从三个方面去讨论：<ol><li>从存储</li><li>介绍GFS</li><li>一致性</li></ol></li></ul><h4 id="存储">存储</h4><ul><li>存储的重要性：通常来说应用程序是无状态的，一些用户数据需要永久保存，这就需要存储，最简单的可以存储在本地磁盘上，再者可以存储在数据库中，</li></ul><h5 id="存储设计的难点">存储设计的难点</h5><ul><li>要考虑高性能<ol><li>单个机器的网卡和CPU性能有限，所以需要考虑跨多个服务机器存储数据</li><li>因为要支持MapReduce，所以需要考虑分片</li></ol></li><li>要考虑多机器下的容错<ol><li>数几千台机器共同运行，总有几个会出现故障，所以需要考虑容错</li><li>通常通过复制数据保证容错性，即当前磁盘数据异常/缺失等情况，尝试从另一个磁盘获取数据</li></ol></li><li>通过复制数据保证容错的话又会出现新问题：<ol><li>会出现潜在的数据不一致问题，即多个副本之间数据不一致</li></ol></li><li>那么就又引入了一致性问题<ol><li>因此就需要一些一致性协议来保证数据一致性，一般需要通过一些消息机制保证一致性，这会稍微带来一些性能影响，但一般底层为了保证数据一致性而额外进行的网络通信等操作在整体性能的开销中占比并不会很高。其中可能涉及需要将通信的一些结果写入存储中，这是相对昂贵的操作。</li></ol></li></ul><h5 id="一致性">一致性</h5><p>**并发性(concurrency)<strong>和</strong>故障/失败(failures)**是两个实现一致性时需要考虑的难点。（WHY？）</p><ul><li><p>并发性问题举例：</p><ul><li>W1写1，W2写2；R1和R2准备读取数据。W1和W2并发写，在不关心谁先谁后的情况下，考虑一致性，则我们希望R1和R2都读取到1或者都读取到2，R1和R2读取的值应该一致。（可通过分布式锁等机制解决）</li></ul></li><li><p>故障/失败问题举例：</p><ul><li>一般为了容错性，会通过复制的方式解决。而不成熟的复制操作，会导致读者在不做修改的情况下读取到两次不同的数据。比如，我们要求所有写者写数据时，需要往S1和S2都写一份。此时W1和W2并发地分别写1和2到S1、S2，而R1和R2即使在W1和W2都完成写数操作后，再从S1或S2读数时结果可能是1也可能是2（因为没有明确的协议指出这里W1和W2的数据在S1、S2上以什么方式存储，可能1被2覆盖，反之亦然）。</li></ul></li></ul><h4 id="什么是GFS？">什么是GFS？</h4><ul><li>GFS是一个可扩展的分布式文件系统，由Google开发，用于大规模集群环境中的海量数据存储和处理。</li><li>GFS旨在保持高性能，且有复制、容错机制，但很难保持一致性</li></ul><p>GFS的几个主要特征：</p><ol><li><p>Big：large data set，巨大的数据集</p></li><li><p>Fast：automatic sharding，自动分片到多个磁盘</p></li><li><p>Gloal：all apps see same files，所有应用程序从GFS读取数据时看到相同的文件（一致性）</p></li><li><p>Fault tolerance：automic，尽可能自动地采取一些容错恢复操</p></li></ol><h4 id="GFS数据读取流程">GFS数据读取流程</h4><p><img src="../assets/2024-11-29-Mit6-824%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image.png" alt="alt text"></p><ul><li><p>GFS通过Master管理文件系统的元数据等信息，其他Client只能往GFS写入或读取数据。当应用通过GFS Client读取数据时，大致流程如下：</p><ol><li>Client向Master发起读数据请求</li><li>Master查询需要读取的数据对应的目录等信息，汇总文件块访问句柄、这些文件块所在的服务器节点信息给Client（大文件通常被拆分成多个块Chunk存放到不同服务器上，单个Chunk（块）很大， 这里是64MB）</li><li>Client得知需要读取的Chunk的信息后，直接和拥有这些Chunk的服务器网络通信传输Chunks</li></ol></li></ul><h4 id="GFS-Master简述">GFS-Master简述</h4><ul><li><p>Master主要负责的工作如下:</p><ol><li>维护<strong>文件名</strong>到<strong>块句柄</strong>数组的映射(file name =&gt; chunk handles)(这些信息大多数存放在内存中，所以Master可以快速响应客户端Client)</li><li>维护每个块句柄(chunk handle)的版本(version)</li><li>维护块存储服务器列表(list of chunk servers)<ul><li>主服务器(primary)<ul><li>Master还需维护每一个主服务器(primary)的租赁时间(lease time)</li></ul></li><li>次要服务器(secondaries)<br>典型配置即将chunk存储到3台服务器上</li></ul></li><li>log+check point：通过日志和检查点机制维护文件系统。所有变更操作会先在log中记录，后续才响应Client。这样即使Master崩溃/故障，重启时也能通过log恢复状态。master会定期创建自己状态的检查点，落到持久性存储上，重启/恢复状态时只需重放log中最后一个check point检查点之后的所有操作，所以恢复也很快</li></ol></li><li><p>这里需要思考的是，哪些数据需要放到稳定的存储中(比如磁盘)？</p><ol><li>比如file name =&gt; chunk hanles的映射，平时已经在内存中存储了，还有必要存在稳定的存储中吗？<br>答:需要，否则崩溃后恢复时，内存数据丢失，master无法索引某个具体的文件，相当于丢失了文件。</li><li>chunk handle 到 存放chunk的服务器列表，这一层映射关系，master需要稳定存储吗？<br>答: 不需要，master重启时会要求其他存储chunk数据的服务器说明自己维护的chunk handles数据。这里master只需要内存中维护即可。同样的，主服务器(primary)、次要服务器(secondaries)、主服务器(primary)的租赁时间(lease time)也都只需要在内存中即可。</li><li>chunk handle的version版本号信息呢，master需要稳定存储吗？<br>答:需要。否则master崩溃重启时，master无法区分哪些chunk server存储的chunk最新的。比如可能有服务器存储的chunk version是14，由于网络问题，该服务器还没有拿到最新version 15的数据，master必须能够区分哪些server有最新version的chunk。</li></ol></li></ul><p>问题：Master崩溃重启后，会连接所有的chunk server，找到最大的version？</p><p>回答：Master会尝试和所有chunk server通信，尽量获取最新version。当然有可能拥有最新version的chunk server由于网络等原因正好联系不上，此时能联系上的存活最久的chunk server的version会比master存储的version小。</p><h4 id="GFS-文件读取">GFS-文件读取</h4><ol><li>Client向Master发请求，要求读取X文件的Y偏移量的数据</li><li>Master回复Client，X文件Y偏移量相关的块句柄、块服务器列表、版本号(chunk handle, list of chunk servers, version</li><li>Client 缓存cache块服务器列表(list of chunk servers)</li><li>Client从最近的服务器请求chunk数据(reads from closest servers)</li><li>被Client访问的chunk server检查version，version正确则返回数据</li></ol><ul><li><p><strong>为什么这里Client要缓存list of chunk server信息呢？</strong><br>答：<strong>因为在这里的设计中，Master只有一台服务器，我们希望尽量减少Client和Server之间的通信次数，客户端缓存可以大大减少Master机器的负载。</strong></p></li><li><p><strong>为什么Client尽量访问最近的服务器来获取数据(reads from closest servers)？</strong><br>答: <strong>因为这样在宛如拓扑结构的网络中可以最大限度地减少网络流量(mininize network traffic)，提高整体系统的吞吐量。</strong></p></li><li><p><strong>为什么在Client访问chunk server时，chunk server需要检查verison？</strong><br>答: <strong>为了尽量避免客户端读到过时数据的情况。</strong></p></li></ul><h4 id="GFS-文件写入">GFS-文件写入</h4><p>这里主要关注文件写入中的<strong>append操作</strong>，因为把记录追加到文件中这个在他们的业务中很常见。在mapreduce中，reducer将处理后的记录数据(计算结果)很快地追加(append)到file中。</p><p><img src="../assets/2024-11-29-Mit6-824%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-1.png" alt="alt text"></p><ol><li>Client向Master发出请求，查询应该往哪里写入filename对应的文件。</li><li>Master查询filename到chunk handle映射关系的表，找到需要修改的chunk handle后，再查询chunk handle到chunk server数组映射关系的表，以list of chunk servers(primary、secondaries、version信息)作为Client请求的响应结果<br>接下去有两种情况，已有primary和没有primary(假设这是系统刚启动后不久，还没有primary)<ul><li>有primary: 继续后续流程</li><li>没有Primary:<strong>master在chunk servers中选出一个作为primary，其余的chunk server作为secondaries。(暂时不考虑选出的细节和步骤)</strong><br>(master会增加version（每次有新的primary时，都需要考虑时进入了一个new epoch，所以需要维护新的version），然后向primary和secondaries发送新的version，并且会发给primary有效期限的租约lease。这里primary和secondaries需要将version存储到磁盘，否则重启后内存数据丢失，无法让master信服自己拥有最新version的数据(同理Master也是将version存储在磁盘中)。)</li></ul></li><li>Client发送数据到想写入的chunk servers(primary和secondaries)，有趣的是，这里Client只需访问最近的secondary，而这个被访问的secondary会将数据也转发到列表中的下一个chunk server，此时数据还不会真正被chunk severs存储。（即上图中间黑色粗箭头，secondary收到数据后，马上将数据推送到其他本次需要写的chunk server）,<strong>这么做提高了Client的吞吐量，避免Client本身需要消耗大量网络接口资源往primary和多个secondaries都发送数据。</strong></li><li>数据传递完毕后，Client向primary发送一个message，表明本次为append操作<br>primary此时需要做几件事：<ol><li>primary此时会检查version，如果version不匹配，那么Client的操作会被拒绝</li><li>primary检查lease是否还有效，如果自己的lease无效了，则不再接受任何mutation operations（因为租约无效时，外部可能已经存在一个新的primary了）</li><li>如果version、lease都有效，那么primary会选择一个offset用于写入</li><li>primary将前面接收到的数据写入稳定存储中</li></ol></li><li>primary发送消息到secondaries，表示需要将之前接收的数据写入指定的offset</li><li>secondaries写入数据到primary指定的offset中，并回应primary已完成数据写入</li><li>primary回应Client，你想append追加的数据已完成写入</li></ol><p><em><strong>当然，存在一些情况导致数据append失败，此时primary本身写入成功，但是后续存在某些/某个secondaries写入失败，此时会向Client返回错误error。Client遇到这种错误后，通常会retry整个流程直到数据成功append，这也就是所谓的最少一次语义(do at-least-once)</strong></em></p><ul><li><strong>需要注意的是，假设append失败，Client再次重试，此时流程中primary指定写入的offset和上一次会是一样的吗？</strong><br>不，primary会指定一个新的offset。假设primary+2台secondaries，可能上一次p和s1都写成功，仅s2失败。此时retry需要用新的offset，或许p、s1、s2就都写入成功了。这里可以看出来<strong>副本记录是可以重复的(replicates records can be duplicated)</strong>，这和我们常见的操作系统中标准的文件系统不一样。</li></ul><p>好在应用程序不需要直接和这种特殊的文件系统交互，而是通过库操作，库的内部实现隐藏了这些细节，用户不会看到曾经失败的副本记录数据。如果你append数据，库会给数据绑定一个id，如果库读取到相同id的数据，会跳过前面的一个。同时库内通过checksums检测数据的变化，同时保证数据不会被篡改。</p><h3 id="主备复制">主备复制</h3><blockquote><p><a href="https://blog.csdn.net/weixin_40910614/article/details/117995014">（VM-FT论文解读）容错虚拟机分布式系统的设计</a></p></blockquote><ul><li><p>failures：复制失败场景和对策</p></li><li><p>challenge：实现难点</p></li><li><p>2 appliction：2个典型应用场景的探讨</p><ul><li>状态转移复制(state transfer replication)</li><li>复制状态机(replicated state machines)<br>case study</li></ul></li><li><p>VM FT：VMware fault tolerance</p></li></ul><h4 id="失败的场景">失败的场景</h4><ul><li>常见的复制失败场景分类<ol><li>fail-stop failure：基础设备或计算机组件问题，导致系统暂停工作(stop compute)，一般指计算机原本工作正常，由于一些突发的因素暂时工作失败了，比如网线被切断等。</li><li>logic bugs, configuration errors：本身复制的逻辑有问题，或者复制相关的主从配置有异常，这类failure导致的失败，不能靠系统自身自动修复。</li><li>malicious errors：这里我们的设计假设的内部系统中每一部分都是可信的，所以我们无法处理试图伪造协议的恶意攻击者。</li><li>handling stop failure：比如主集群突发地震无法正常服务，我们希望系统能自动切换到使用backup备份集群提供服务。当然如果主从集群都在一个数据中心，那么一旦出现机房被毁问题，大概率整个系统就无法提供服务了。</li></ol></li></ul><p>我们只关注<strong>处理停止失败(handling stop failures)</strong>。</p><h4 id="主备复制的实现难点">主备复制的实现难点</h4><ul><li><p><strong>为了防止出现脑裂的场景，我们该如何判断一个primary真正的失败了？</strong></p><ul><li>你无法直接区分发生了网络分区问题(network partition)还是实质的机器故障问题(machine failed)</li><li>或许只是部分机器访问不到primary，但是客户端还是正常和primary交互中。你必须有一些机制保证不会让系统同时出现两个primary(假设机制中只允许正常情况下有且只有一个primary工作)。</li><li><strong>(Split-brain system)脑裂场景</strong><br>假设机制不完善，可能导致两个网络分区下各自有一个primary，客户端们和不同的primary交互，最后导致整个系统内部状态产生严重的分歧（比如存储的数据、数据的版本等差异巨大）。此时如果重启整个系统，我们就不得不手动处理这些复杂的分歧状态问题（就好似手动处理git merge冲突似的）。</li></ul></li><li><p><strong>如何让主备保持同步？</strong></p></li></ul><p>**我们的目标是primary失败时，backup能接手primary的工作，并且从primary停止的地方继续工作。这要求backup总是能拿到primary最新写入的数据，保持最新版本。**我们不希望直接向客户端返回错误或者无法响应请求，因为从客户端角度来看，primary和backup无区别，backup就是为容错而生，理应也能正常为自己提供服务。</p><ul><li><p>需要保证应用中的所有变更，按照正确顺序被处理(apply changes in order)</p></li><li><p>必须<strong>避免/解决非决定论(avoid non-determinism)</strong>。即相同的变更在primary和backup上应该有一致的表现。</p></li><li><p><strong>故障转移</strong></p></li></ul><p>primary出现问题时，我们希望切换到backup提供服务。但是切换之前，我们需要保证primary已经完成了所有正在执行的工作。即我们不希望在primary仍然在响应client时突然切换backup（如果遇到网络分区等问题，会使得故障转移难上加难）。</p><blockquote><p><strong>在计算机术语中，故障转移（英语：failover），即当活动的服务或应用意外终止时，快速启用冗余或备用的服务器、系统、硬件或者网络接替它们工作。 故障转移 (failover)与交换转移操作基本相同，只是故障转移通常是自动完成的，没有警告提醒手动完成，而交换转移需要手动进行。</strong></p><p><a href="https://baike.baidu.com/item/%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB/14768924?fr=aladdin">故障转移</a></p></blockquote><h4 id="主备复制的两种方法">主备复制的两种方法</h4><ol><li><p><strong>状态转移(state transfer)</strong>：primary正常和client交互，每次响应client之前，先生成记录checkpoint检查点，将checkpoint同步到备份backup，待backup都同步完状态后，primary再响应client。（<strong>即将主的最新消息同步到备份后，再响应client</strong>）</p></li><li><p><strong>复制状态机(replicated state machine，RSM)</strong>：与状态转移类似，只是这里primary和backup之间同步的不是状态，而是操作。即primary正常和client交互，每次响应client之前，先生成操作记录operations，将operations同步到备份backup，待backup都执行完相同的操作后，primary再响应client。</p></li></ol><p>这两种方案都有被应用，共同的要点在于，<strong>primary响应client之前，首先确保和backup同步到相同的状态，然后再响应client。这样当primary故障时，任意backup接管都能有和原primary对齐的状态。</strong></p><p>这两者的主要区别是<strong>方法一是执行完操作后，得到了结果，把结果同步到备份机上，而方法二则是将要执行的操作同步到备份机上，让备份机自己运行操作，并得到结果。</strong><br>从这就能看出方法一的<strong>缺点</strong>了，如果一个操作得到了非常大的结果，那么同步起来就非常昂贵了</p><p>问题1：为什么client不需要发送数据到backup备机？<br>答1：因为这里client发送的请求是具有确定性的操作，只需向primary请求就够了。主备复制机制保证primary能够将具有确定性的操作正确同步到其他backup，即系统内部自动保证了primary和backup之间的一致性，不需要client额外干预。<strong>接下来的问题即，怎么确定一个操作是否具有确定性？在复制状态机(replicated state machine，RSM)方案中，即要求所有的操作都是具有确定性的，不允许存在非确定性的操作。</strong></p><p>问题2：是不是存在着混合的机制，即混用状态转移(state transfer)和复制状态机(replicated state machine，RSM)？<br>答2: <strong>是的。比如有的混合机制在默认情况下以复制状态机(replicated state machine，RSM)方案工作，而当集群内primary或backup故障，为此创建一个新的replica时则采用状态转移(state transfer)转移/复制现有副本的状态。</strong></p><h4 id="复制状态机RSM-复制什么级别的操作">复制状态机RSM-复制什么级别的操作</h4><p>使用复制状态机时，我们需要考虑什么级别的操作需要被复制。有以下几种可能性：</p><ul><li><strong>应用程序级别的操作(application-level operations)</strong></li></ul><p>比如GFS的文件append或write。如果你在应用程序级别的操作上使用复制状态机，那也意味着你的复制状态机实现内部需要密切关注应用程序的操作细节，比如GFS的append、write操作发生时，复制状态机应该如何处理这些操作。一般而言你需要修改应用程序本身，以执行或作为复制状态机方法的一部分。</p><ul><li><strong>机器层面的操作(machine-level operaitons)，或者说processor level / coputer level</strong></li></ul><p>这里对应的状态state是寄存器的状态、内存的状态，操作operation则是传统的计算机指令。这种级别下，复制状态机无感知应用程序和操作系统，只感知最底层的机器指令。</p><p>有一种传统的进行机器级别复制的方式，比如你可以额外购买机器/处理器，这些硬件本身支持复制/备份，但是这么做很昂贵。</p><p>这里讨论的论文(VM-FM论文)通过虚拟机(virtual machine, VM)实现。</p><h4 id="通过虚拟化实现复制">通过虚拟化实现复制</h4><p><img src="../assets/2024-11-29-Mit6-824%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-2.png" alt="alt text"></p><ul><li><p>虚拟化复制对应用程序透明，且能够提供很强的一致性。早期的VMware就是以此实现的，尽管现在新版可能有所不同。缺陷就是这篇论文只支持单核，不支持多核(multi-core)。或许后来的FT支持了，但应该不是纯粹通过复制状态机实现的，或许是通过状体转移实现的，这些都只是猜测，毕竟VMware没有透露后续产品的技术细节。</p></li><li><p><strong>我们先简单概览一下这个系统实现。</strong></p></li><li><p>首先有一个虚拟机控制器(virtual machine monitor)，或者有时也被称为hypervisor，在这论文中，对应的hypervisor即VM-FT。</p></li><li><p>当发生中断（比如定时器中断）时，作为hypervisor的VM-FT会接收到中断信号，此时它会做两件事：</p><ul><li><strong>通过日志通道将中断信号发送给备份计算机</strong>（sends it over a logging channel to a backup computer）</li><li><strong>将中断信号传递到实际的虚拟机，比如运行在guest space的Linux。</strong></li></ul></li><li><p>同理，当client向primary发送网络数据包packet时，primary所在的硬件产生中断，而VM-FT将同样的中断通过logging channel发送给backup computer（也就是另一个VM-FT），然后将中断发送到当前VM-FT上的虚拟机(比如Linux)。另一台backup的VM-FT上运行着和priamry相同的Linux虚拟机，其也会同样收到来自backup的VM-FT的中断信号。primary虚拟机Linux之后往虚拟网卡写数据，产生中断，同样VM-FT也会将中断往backup的VM-FT发送一份。最后就是primary上的Linux虚拟机和backup上的Linux虚拟机都往各自的虚拟网卡发送了数据，但是backup的VM-FT知道自己是backup备机，所以从虚拟网卡接收数据后什么也不会做，只有primary的VM-FT会真正往物理网卡写数据，响应client的请求。</p></li><li><p>论文中提到，在primary和backup两个VM-FT以外，假设还通过网络和外部一个storage存储保持通讯。外部storage通过一个flag记录primary和backup状态，记录谁是primary等信息。这个存储有两个作用：</p><ul><li><strong>首先他能够进行数据的存储</strong></li><li><strong>第二它能够在一定程度上防止脑裂的发生，因为它有一个flag标志，并且使用了testandset原理来保证flag的修改。</strong></li></ul></li><li><p>当primary和backup之间发生网络分区问题，而primary、backup仍可以与这个外部storage通信时，primary和backup互相会认为对方宕机了，都想把自己当作新的primary为外界的client提供服务。<strong>此时，原primary和原backup都试图通过test-and-set原子操作在外部storage修改flag记录（比如由0改成1之类的），谁先完成修改修改，谁就被外部storage认定为新的primary；而后来者test-and-set操作会返回1(test-and-set会返回旧值，这里返回1而不是0，表示已经有人领先自己把0改成1了)，其得知自己是后来者，会主动放弃称为primary的机会，在论文中提到会选择终结自己(terminate itself)。</strong></p></li></ul><p>test-and-set的伪代码如下:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">test-<span class="keyword">and</span>-<span class="keyword">set</span>():</span><br><span class="line">  <span class="function">acquire <span class="title">lock</span>()</span></span><br><span class="line"><span class="function">  <span class="keyword">if</span> flag</span> == <span class="number">0</span>:</span><br><span class="line">    flag = <span class="number">1</span>;</span><br><span class="line">    <span class="function">release <span class="title">lock</span>()</span></span><br><span class="line"><span class="function">    <span class="keyword">return</span> 0</span></span><br><span class="line"><span class="function">  <span class="keyword">else</span>:</span></span><br><span class="line"><span class="function">    release <span class="title">lock</span>()</span></span><br><span class="line"><span class="function">    <span class="keyword">return</span> 1</span></span><br></pre></td></tr></table></figure><ul><li>虚拟机primary和backup都可能会失效，所以为了架构的高可用性，VMWare提出了一个技术FT VMotion，用来负责backup的创建。它能够直接对一个VM进行克隆，并且在完成克隆后会建立好和primary的Logging channel，被克隆一方是primary，另一个就是backup。根据协议，当backup启动完成备份时，flag就被重置为0。</li></ul><h4 id="差异来源">差异来源</h4><ul><li><p>如果前面primary执行的指令都是确定性的，那么primary和backup无疑可以保证拥有相同的状态。但是不可避免的是可能出现一些非确定性的事件，我们需要考虑如何处理。我们的<strong>目标即，将每一条非确定性的指令(non-deterministic instruction)变成确定性指令(deterministic instruction)</strong>。</p></li><li><p><strong>非确定性的指令(non-deterministic instruction)</strong></p><ul><li>比如获取时间的指令，我们不可能保证primary和backup都在同一时间执行，返回值一般来说会不同。</li></ul></li><li><p><strong>网络包接收/时钟中断(input packets / timer interrupters)</strong></p><ul><li>比如网络包输入时导致中断，primary和backup在原本CPU执行流中插入中断处理的位置可能不同。比如primary在第1～2条指令执行的位置插入网络包的中断处理，而backup在第2～3条指令执行的位置插入中断处理，这也有可能导致后续primary和backup的状态不一致。所以我们希望这里数据包产生的中断（或者时钟中断），在primary和backup相同的CPU指令流位置插入执行中断处理，确保不会产生不一致的状态。</li></ul></li></ul><p>那么它是怎么将<strong>非确定事件变为确定性事件的呢？</strong></p><p>答：解决这个问题是利用了<strong>日志</strong>。primary的所有确定性操作和不确定事件的所有状态都会记录在log entry流中，<strong>通过Logging channel发送给backup并使其replay。</strong></p><p><strong>举个例子，一个操作让 primary 生成一个随机数，那么 primary 会在日志中记录当前生成这个操作的所有状态，比如它是根据当前时间或者是当前某个时钟周期当作 seed，这些随机性全部由 hypervisor 来处理，backup 进行日志 replay 时，碰到这种随机性事件，hypervisor 让它执行的时候跟 primary 得出的结果一模一样</strong>，让两者在状态上没有差别，很了不起。</p><h4 id="VM-FT的中断处理">VM-FT的中断处理</h4><p>根据前面的讨论，可以知道中断是一个非确定性的差异来源，我们需要有机制保证primary和backup处理中断后仍保持状态一致。</p><p>​这里VM-FT是这样处理的，当接受到中断时，VM-FT能知道CPU已经执行了多少指令（比如执行了100条指令），并且计算一个位置（比如100），告知backup之后在指令执行到第100条的时候，执行中断处理程序。大多数处理器（比如x86）支持在执行到第X条指令后停止，然后将控制权返还给操作系统（这里即虚拟机监视器）。</p><p>​通过上面的流程，VM-FT能保证primary和backup按照相同的指令流顺序执行。当然，这里backup会落后一条message（因为primary总是领先backup执行完需要在logging channel上传递的消息）。</p><h4 id="VM-FT失败场景的处理">VM-FT失败场景的处理</h4><p>这里举例primary故障的场景:<br>比如primary本来维护一个计数器为10，client请求将其自增到11，但是primary内部自增了计数器到11，但是响应client前正好故障了。如果backup此时接手，其执行完logging channel里要求同步的指令，但是自增到11这个并没有反映到bakcup上。如果client再次请求自增计数器，其会获取到11而不是12。</p><p><img src="../assets/2024-11-29-Mit6-824%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-3.png" alt="alt text"></p><ul><li>上述场景实际上不会发生，因为VM-FT定义了一个<strong>Output Rule</strong>。</li><li>为了保证上述要求，设计输出规则（如上图）：<ol><li>primary<strong>在所有关于本次Output的信息都发送给backup后（并且要确保backup收到，backup会发送一个ACK），才会把output发送给外界。</strong></li><li>primary只是推迟将output发送给外界，不会暂停执行后面的任务（异步执行）。</li></ol></li></ul><p>如图，<strong>简单来说，就是primary收到一条信息，并且这条信息是需要回复的（即，要output），那么primary先会写日志并且传给backup，backup收到以后发送一个确认收到的ACK给primary，然后primary才会执行output。</strong></p><ul><li>但是，这种方法不能保证Exactly once（只发送一次），因为若primary在收到backup的ACK之后，已经发出了output，但是此时挂掉了，然后backup顶上去之后不能判断是否是在发送了output之后宕机的，所以它会再发一次。这个问题容易解决：<ol><li>output是通过网络进行发送的，例如TCP之类的网络协议能够检测重复的数据包；</li><li>对于一个写操作，它就是两次在同一个位置写，也不影响结果。</li></ol></li></ul><h4 id="VM-FT性能问题">VM-FT性能问题</h4><p>因为VM-FT的操作都基于机器指令或中断的级别上，所以需要牺牲一定的性能。</p><p>论文中统计在primary/backup模式下运行时，性能和平时单机差异不会太大，保持在0.94~0.98的水平。而当网络输入输出流量很高时，性能下降很明显，下降将近30%。这里导致性能下降的原因可能是，primary处理大量数据包时，需要等待backup也处理完毕。</p><p>问题：如果primary宕机了几分钟，backup重新创建一个replica并通过test-and-set将storage的flag从0设置为1，自己成为新的primary。然后原primary又恢复了，这时候会怎么样？</p><p>回答：原primary会被clean，terminate自己。</p><p>问题：处理大量网络数据包时，primary只会等待backup确认第一个数据包吗？</p><p>回答：不是，primary每处理一个数据包，都会通过logging channel同步到backup，并且等待backup返回ack。满足了输出规则(output rule)之后，primary才会发出响应。这里它们有一些方法让这个过程尽量快。</p><p>问题：关于logging channel，我看论文中提到用UDP（发送心跳会用这个）。那如果出现故障，某个packet没有被确认，primary是不是直接认为backup失败，然后不会有任何重播？</p><p>回答：不是。因为有定时器中断，定时器中断大概每10ms左右触发一次。如果有包接受失败，primary会在心跳中断处理时尝试重发几次给backup，如果等待了可能几秒了还是有问题，那么可能直接stop停止工作。</p><h3 id="错误容忍-Raft算法">错误容忍-Raft算法</h3><blockquote><p><a href="https://zhuanlan.zhihu.com/p/488916891">Raft 协议原理详解，10 分钟带你掌握！</a><br><a href="https://www.bilibili.com/video/BV1so4y1r7eM?spm_id_from=333.788.videopod.sections&amp;vd_source=772b61fb408cdf9169f726ab21790987">Raft算法讲解视频</a></p></blockquote><h4 id="单点故障">单点故障</h4><p>前面介绍过的复制系统，都存在单点故障问题(single point of failure)。</p><ul><li>mapreduce中的cordinator</li><li>GFS的master</li><li>VM-FT的test-and-set存储服务器storage</li></ul><p>而上诉的方案中，采用单机管理而不是采用多实例/多机器的原因，是为了避免**脑裂(split-brain)**问题。</p><p>​不过大多数情况下，单点故障是可以接受的，因为单机故障率显著比多机出现一台故障的概率低，并且重启单机以恢复工作的成本也相对较低，只需要容忍一小段时间的重启恢复工作。</p><h4 id="脑裂问题">脑裂问题</h4><ul><li>定义：是指在分布式系统中，由于网络分区或其他故障导致集群中的节点无法相互通信，进而形成多个独立的子集（通常是两个），每个子集都认为自己是唯一的集群。 这种情况可能导致数据的不一致性、系统的不可用性和其他严重问题</li></ul><p>Raft是避免单点故障问题的一种方案，在介绍Raft之前，<strong>我们要知道单机管理的某些协议在多机下是如何产生脑裂问题的</strong>，体会下为什么必须需要比这些协议更加严谨的协议</p><p>以VM-FT的test-and-set存储服务器storage举例。假设我们复制storage服务器，使其有两个实例机器S1、S2。（即打破单机管理的场景，看看简单的多机管理下有什么问题）</p><p>假设此时C1想要争取称为Primary，于是向S1和S2都发起test-and-set请求。假设因为某种原因，S2没有响应，S1响应，成功将0改成1，此时C1可能直接认为自己成为Primary。</p><p>这里S2没有响应可以先简单分析两种可能：</p><ol><li><p><strong>S2失败/宕机了，对所有请求方都无法提供服务</strong><br>如果是这种情况，那么C1成为Primary不会有任何问题，S2就如同从来不曾存在，任何其他C同样只能访问到S1，他们都会知道自己无法成为Primary，并且整个系统只会存在C1作为Primary。</p></li><li><p><strong>S2和C1之间产生了网络分区(network partition)，仅C1无法访问到S2</strong></p></li></ol><p>这时候如果存在C2也向S1和S2发出请求，此时S1虽然将0改成1会失败，但是S2会成功。<strong>如果我们的协议不够严谨，这里C2会认为自己成为了Primary，导致整个系统存在两个Primary。这也就是严重的脑裂问题。</strong></p><ul><li><strong>产生这种问题的原因在于，对于请求方，无法简单地判断上诉两种情况，因为对他们来说两种情况的表现都是一样的。</strong></li></ul><p>因此，为避免出现脑裂，我们需要先<strong>解决网络分区问题</strong>。</p><h4 id="Raft采取的的原则-大多数原则">Raft采取的的原则:大多数原则</h4><p>诸如Raft一类的协议用于解决单点故障问题，同时也用于解决网络分区问题。这类解决方案的基本思想即：大多数原则(majority rule)，<strong>简单理解就是少数服从多数（获取票数多于一半）</strong>。</p><h5 id="为什么这个原则会作为基本思想">为什么这个原则会作为基本思想</h5><ul><li>我们来看看这个原则可以解决一些什么问题</li></ul><p>就那我们上一个举例来扩展，我们假设storage服务一共有三个实例，S1、S2、S3。</p><p>此时C1同时向S1、S2、S3请求test-and-set，其中S1和S2成功将0改成1，S3因为其他问题没有响应，但是我们不关系为什么。这里按照majority rule，只要3个S中有2个给出成功响应，我们就认为C1能够成为Primary。此时就算同时有C2向S1、S2、S3发起请求，就算S3成功了，C2根据majorty rule，3台只成功1台，不能成为Primary。<br><strong>这样就解决了脑裂问题，因为只有C1能够成为Primary，而C2只能访问到S1，S2。</strong></p><p>在之后准备介绍的Raft，和这里描述的工作流程基本一致。</p><ul><li>在majority rule下，尽管发生网络分区，只会一个拥有多数的分区，不会有其他分区具有多数，只有拥有多数的分区能继续工作（比如这里3台被拆成1台、2台的分区，只有和后者成功通信的能继续工作）。</li><li>而如果极端情况下所有分区都不占多数（ 比如这里3台被拆成1台、1台、1台的分区），那么整个系统都不能运行。</li></ul><p>上诉3台的场景，只能容忍1台宕机，如果宕机2台，那么任何人都无法达到majorty的情况。<strong>这里通过2f+1拓展可容忍宕机的机器数，f表示可容忍宕机的机器数量。2f+1，即使宕机了f台，剩下的f+1&gt;f，仍然可以组成majority完成服务。</strong></p><p>例如，当f=2时，表示系统内最多可容忍2台机器处于宕机状态，那么至少需要部署5台服务器（2x2+1=5）。</p><h4 id="raft历史发展">raft历史发展</h4><ul><li><p>在1980s～1990s，基本不存在诸如majority的协议，所以一直存在单点故障的问题。</p></li><li><p>在1990s出现了两种被广泛讨论协议，但是由于当时的应用没有自动化容错的需求，所以基本没有被应用。但近15年来(2000s~2020s)大量商用产品使用到这些协议：</p><ol><li>Paxos</li><li>View-Stamped replication (也被称为VR)</li></ol></li></ul><blockquote><p>附上Paxos算法的相关讲解文章: <a href="https://zhuanlan.zhihu.com/p/31780743">Paxos算法详解</a></p></blockquote><ul><li>我们将要讨论的是Raft，大概在2014左右有相关的论文，它应用广泛，你可以用它来实现一个完全复制状态机(complete replicated state machine)。</li></ul><h4 id="使用Raft构造复制状态机">使用Raft构造复制状态机</h4><p>系统正常工作时，大致流程如下：</p><ol><li>Client向3台机器中作为leader的机器发查询请求</li><li>leader机器将接收到的请求记录到底层raft的顺序log中</li><li>当前leader的raft将顺序log中尾部新增的log记录通过网络同步到其他2台机器</li><li>其他两台K/V机器的raft成功追加log记录到自己的顺序log中后，回应leader一个ACK</li><li>leader的raft得知其他机器成功将log存储到各自的storage后，将log操作反映给自己的K/V应用，执行这个操请求，并且设为了提交状态</li><li>K/V应用实际进行K/V查询，并且将结果响应给Client，之后就会通知其他群众提交状态，以保持同步</li></ol><p>系统出现异常时，发生如下事件：</p><ol><li>Client向leader请求</li><li>leader向其他2台机器同步log并且获得ACK</li><li>leader准备响应时突然宕机，无法响应Client</li><li>其他2台机器重新选举出其中1台作为新的leader</li><li>Client请求超时或失败，重新发起请求，系统内部failover故障转移，所以这次Client请求到的是新leader</li><li>新leader同样记录log并且同步log到另一台机器获取到ACK</li><li>新leader响应Client</li></ol><p>这里可以想到的是，剩下存活的两台机器的log中会有<strong>重复请求</strong>，而我们需要能够检测(detect)出这些重复请求。</p><p>问题：访问leader的client数量通常是多少？</p><p>回答：我想你的疑问是系统只有1个leader的话，那能承受多少请求量。实际上，具体的系统设计还会采用shard将数据分片到多个raft实例上，每个shard可以再有各自的leader，这样就可以平均请求的负载到其他机器上了。</p><p>问题：旧leader宕机后，client怎么知道要和新leader通信？</p><p>回答：client中有系统中所有服务器的访问列表，这里举例中有3个服务器。当其中一台请求失败时，client会重新随机请求3台中的1台，直到请求成功。</p><h4 id="Raft概述">Raft概述</h4><p>首先我们要知道Raft的几个重要角色：</p><ol><li>Leader：Raft协议中，每个副本(replica)都有可能成为Leader，Leader负责处理客户端的请求，并将其转发给其他副本。Leader在Raft中扮演着重要的角色，它负责将客户端请求转发给其他副本，并在必要时进行日志的复制。</li><li>Candidate：Raft协议中，当Leader出现故障时，会选举出一个新的Leader。在Raft中，Candidate扮演着重要的角色，它会向其他副本发送请求，询问是否可以成为新的Leader。</li><li>Follower：Raft协议中，Follower是Raft中最基本的角色，它只负责接收Leader的日志，并将其提交到自己的存储中。Follower在Raft中扮演着重要的角色，它负责接收Leader的日志，并将其提交到自己的存储中。</li></ol><p>然后在进行选举过程中，还有几个重要的概念：</p><ol><li>Leader Election（领导人选举）：简称选举，就是从候选人中选出领袖；</li><li>Term（任期）：它其实是个单独递增的连续数字，每一次任期就会重新发起一次领导人选举；</li><li>Election Timeout（选举超时）：就是一个超时时间，当群众超时未收到领袖的心跳时，会重新进行选举。</li></ol><p>接下来我们重新描述下Raft的工作流程（此时已经有一个leader,另外两台为follower）：</p><ol><li>客户端向Leader发送请求；</li><li>Leader将请求记录到log尾部，并将其转发给其他的fllower；</li><li>Follower接收到Leader的请求后，将其记录到自己的log中，然后会回复Leader一个ACK；</li><li>此时leader和follower1共2台机器成功追加log，达到majority（必须符合大多数原则），于是leader可以进行commit，将操作移交给上层的kv服务。（这里即使宕机了一台，之后重新选举，包含最后操作的服务器将当选成为新的leader，比如原leader或follower1将当选，所以服务能继续正常提供）</li><li>leader将log提交到自己的存储中commit后响应Client，完成一次请求，并且会发请求给所有的follower，让他们也进行commit。</li></ol><p>问题：如果log从leader同步到其他follower时，leader宕机了，会怎么样？</p><p>回答：会重新发生选举，而拥有<strong>最新操作</strong>log的机器成为新leader后会将追加的log条目传递给其他follower，这样就保证这些机器都拥有最新的log了</p><h4 id="Raft-log的用途">Raft log的用途</h4><ol><li>重传:leader向follower同步消息时，消息可能传递失败，所以需要log记录，方便重传</li><li><strong>顺序执行: 我们需要被同步的操作，以相同的顺序出现在所有的replica上</strong></li><li>持久化(persistence)：持久化log数据，才能支持失败重传，重启后日志恢复等机制</li><li><strong>试探性操作(space tentative)</strong>：比如follower接收到来自leader的log后，并不知道哪些操作被leader提交了，可能等待一会直到明确操作被commit了才进行后续操作。我们需要一些空间来做这些试探性操作(tentative operations)，而log很合适。</li></ol><p>​ <strong>尽管中间有些时间点，可能有些机器的log是落后的。但是当一段时间没有新log产生时，最终这些机器的log会同步到完全相同的状态(logs identical on all servers)</strong>。并且因为这些log是有顺序的，意味着上层的kv服务最终也会达到相同的状态。</p><h4 id="Raft的log格式">Raft的log格式</h4><p><img src="../assets/2024-11-29-Mit6-824%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-4.png" alt="alt text"></p><p>每一个日志条目一般包括三个属性：整数索引Log Index、任期号Term和指令Commond。每个条目所包含的“整数索引”即该条目在日志文件中的槽位，“任期号”对应到图中就是每个方块中的数字，用于检测在不同服务器上日志的不一致问题，指令即用于被状态机执行的外部命令，图中就是带箭头的数字。</p><h4 id="Raft的选举">Raft的选举</h4><h5 id="情况1-：集群中没有leader">情况1 ：集群中没有leader</h5><p>我们假设一共有五个节点，每个节点的初始状态都是follower，它们都有着不同的超时时间，terms技术为1<br>Raft的选举过程如下：</p><ol><li>首先，等待一段时间，直至五个节点有一个节点超时了，然后超时的节点会变成candidate，并投自己一票，再向其他节点发送投票请求，并且会执行terms + 1；</li><li>由于此时只有一个候选人，所以其他节点都选了赞成票，票数大于集群个数的一半，于是候选节点变成了leader</li><li>成为leader后会不断向follower发送心跳</li></ol><h5 id="情况2-：集群中有leader，并且leader宕机了">情况2 ：集群中有leader，并且leader宕机了</h5><h6 id="此时只有一个节点变味了候选节点">此时只有一个节点变味了候选节点</h6><ol><li>其他follower由于没有收到leader的心跳，会一直等待，知道自己的超时时间超时，于是超时的节点就会成为候选人，发起新一轮竞选</li><li>后续操作和情况一类似就不赘述了</li></ol><h6 id="有两个候选人同时竞选（选举条件）">有两个候选人同时竞选（选举条件）</h6><p><em><strong>follower投给哪个候选人取决于Term（任期）更高的人，如果任期相同就会投给日志最新的人，如果日志都相同了，就先到先得</strong></em></p><ul><li><strong>未出现投票分裂</strong></li></ul><ol><li>两个候选人都会先给自己投一票，然后向其他节点发送投票请求（即使接受节点宕机），并且会执行terms + 1；</li><li>候选人之间会互投反对票，follower会根据一个上述规则投给一个候选人</li><li>其中一位候选人得到了超过半数的票，成为leader，并开始不断向follower发送心跳</li></ol><ul><li><strong>出现投票分裂</strong></li></ul><ol><li>两个候选人都会先给自己投一票，然后向其他节点发送投票请求（即使接受节点宕机），并且会执行terms + 1；</li><li>候选人之间会互投反对票，follower会根据一个上述规则投给一个候选人</li><li>此时假设票数相同都为两票，就出现了投票分裂</li><li>又可以分为两种情况：<ul><li>假设此时另外一个follower先超时，将term + 1，由于这个新term大于其他两个候选人的term，所以其他候选人会给他投赞成票，于是他就成为leader</li><li>假设此时两个候选人同时超时，又会发送新一轮选举，然后继续循环等待，（为了避免这个情况，Raft在设计时会将选举超时时间设为一个随机值（150ms到300ms之间），避免所有节点同时超时，先到的也会先获得赞成票），直至打破循环</li></ul></li><li>新leader开始不断向follower发送心跳</li></ol><h4 id="Raft的选举超时时间">Raft的选举超时时间</h4><p>选举超时的时间，应该设置成大概多少才合适？</p><ul><li><strong>略大于心跳时间(&gt;= few heartbeats)</strong></li></ul><p>如果选举超时比心跳还短，那么系统将频繁发起选举，而选举期间系统对外呈现的是阻塞请求，不能正常响应client。因为election时很可能丢失同步的log，一直频繁地更新term，不接受旧leader的log（旧leader的term低于新term，同步log消息会被拒绝）</p><ul><li><strong>加入一些随机数(random value)</strong></li></ul><p>加入适当范围的随机数，能够避免无限循环下去的<strong>分裂选举(split vote)问题</strong>。random value越大，越能够减少进行split vote的次数，但random value越大，也意味着对于client来说，整个系统停止提供对外服务的时间越长（对外表现和宕机差不多，反正选举期间无法正常响应client的请求）</p><ul><li><strong>尽量短(short enough that down time is short)</strong></li></ul><p>因为选举期间，对外client表现上如同宕机一般，无法正常响应请求，所以我们希望eleciton timeout能够尽量短</p><p>​Raft论文进行了大量实验，以得到250ms～300ms这个在它们系统中的合理值作为eleciton timeout。</p><h4 id="Raft-vote需记录到稳定的storage（持久化）">Raft-vote需记录到稳定的storage（持久化）</h4><ul><li>这里提一个选举中的细节问题。假设还是leader宕机，follower1和follower2中的follower1发起选举。follower1会先vote自己，然后发起拉票请求希望follower2投票自己。</li></ul><p>​- 这里follower1应该用一个稳定的storage记录自己的vote历史记录，有人知道为什么吗？原因是避免重复vote。假设follower1在vote自己后宕机一小段时间后恢复，我们需要避免follower1又vote自己一次，不然follower1由于vote过自己两次，直接就可以无视其他follower的投票认为自己成为了leader。</p><p>​<em><strong>所以，为了保证每个term，每个机器只会进行一次vote行为，以保证最后只会产生一个leader，每个参选者都需要用稳定的storage记录自己的vote行为。</strong></em></p><p>问题：这里需要记录vote之前当前机器自身是follower、leader或者candidate吗？<br>答：需要</p><h4 id="Raft-日志">Raft-日志</h4><p>首先说明下集中图形代表啥：</p><ol><li>虚线代表日志未提交<br><img src="../assets/2024-11-29-Mit6-824%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-5.png" alt="alt text"></li><li>箭头代表下一索引，圆圈代表日志提交成功的索引下标<br><img src="../assets/2024-11-29-Mit6-824%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-6.png" alt="alt text"></li><li></li></ol><h5 id="Raft算法的日志复制过程">Raft算法的日志复制过程</h5><p>假设起始情况如下图：<br><img src="../assets/2024-11-29-Mit6-824%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-7.png" alt="alt text"></p><ol><li>leader会向其他follower发送日志更新请求</li><li>S2收到日志并写入本地，然后s1继续发送直至s2与s1一致<br><img src="../assets/2024-11-29-Mit6-824%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-8.png" alt="alt text"></li><li>由于只收到一个follower的回复，所以现在还不能提交日志，此时S3恢复</li><li>leader节点会先进行日志探测，寻找S3日志第一个不符位置，然后向S3发送日志同步请求</li><li>S3收到第一条日志写入本地并发送确认，leader接收到确认后由于缓存日志的节点数超过了一半，所以提交了第一个日志<br><img src="../assets/2024-11-29-Mit6-824%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-9.png" alt="alt text"></li><li>S3收到第二条复制日志后，会把第一条提交，并发送确认，leader收到确认后提交第二条日志<br><img src="../assets/2024-11-29-Mit6-824%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-10.png" alt="alt text"></li><li>leader继续发送第三条复制日志请求，并且会向S2发送日志提交请求（心跳信息），S2会一次性提交2条日志<br><img src="../assets/2024-11-29-Mit6-824%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-11.png" alt="alt text"></li><li>leader提交第三条日志，并通知其他两个节点提交第三条日志<br><img src="../assets/2024-11-29-Mit6-824%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-12.png" alt="alt text"></li></ol><h5 id="Raft-日志分歧">Raft-日志分歧</h5><blockquote><p><a href="https://mit-public-courses-cn-translatio.gitbook.io/mit6-824/lecture-07-raft2/7.2-xuan-ju-yue-shu-election-restriction">选举约束</a><br>如果你去看处理RequestVote的代码和Raft论文的图2，当某个节点为候选人投票时，节点应该将候选人的任期号记录在持久化存储中。（换言之，就算当前server的term记录落后于其他server，也可以通过通信知道下一次选举term值应该是多少，比如S1的term为5，但是S2的term为7，S1下次选举时也知道要从term8开始，而不是term6）</p></blockquote><p><img src="../assets/2024-11-29-Mit6-824%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-13.png" alt="alt text"></p><ul><li>根据上述图片我们可以分析出<br>a 的 term以及index是 6, 9<br>b 的 term以及index是 4, 4<br>c 的 term以及index是 6, 11<br>d 的 term以及index是 7，12<br>e 的 term以及index是 4， 7<br>f 的 term以及index是 3，11</li></ul><p>我们可以知道可能成为候选人的分别是a, c, d 因为他们可以得到超过半数的票<br>因为他们发起候选人投票的</p><h5 id="Raft选举规则">Raft选举规则</h5><p><em><strong>首先一个候选人发起选举时，调用的RequestVote RPC携带的参数分别是最新的term，该节点最后一条条目的term和index（不管有没有提交），follower接收到这些信息的时候，是拿自己日志中最后一个term和index与收到的term和index进行比较的。不管此日志条目是否提交</strong></em></p><p>有两个规定：</p><ol><li><strong>候选人的term如果大于投票者的最后一个日志条目的任期就投赞成票</strong></li><li><strong>如果任期相同则看候选人最后一个日志条目的下标索引是不是更大，是的话就投赞成票</strong></li></ol><ul><li>majority：大多数原则，即至少获取整个系统内大于全部机器数量一半的选票（包括自己，且每人只能投一次票，**宕机的机器也算在系统机器总数内。**如果剩余机器数压根凑不到刚好大于一半的机器数，则没有人能够成功获选）</li><li><strong>at-least-up-to-date：能当选的机器一定是具有最新term的机器</strong>（因为 Raft 选举过程中要求的是日志“至少”一样新，而不是严格“必须”拥有最高任期的日志。）</li></ul><h5 id="Raft-日志覆写同步（未优化版本）">Raft-日志覆写同步（未优化版本）</h5><ul><li>一共有两个指针，分别是:<ol><li><strong>nextIndex</strong>：所有raft节点都维护nextIndex<strong>乐观的</strong>变量用于记录<strong>下一个需要填充log entry的log index</strong>。这里说乐观，因为<strong>当leader当选时，leader会初始化nextIndex值为当前log index值+1</strong>，表示认为<strong>leader自身的log一定是最新的</strong></li><li><strong>matchIndex</strong>：leader为所有raft节点(包括leader自己)维护一个<strong>悲观的</strong>matchIndex用于记录<strong>leader和其他follower从0开始往后最长能匹配上的log index的位置+1</strong>，表示<strong>leader和某个follower在matchIndex之前的所有log entry都是对齐的</strong>。这里说悲观，<strong>因为leader当选时，leader会初始化matchIndex值为0</strong>，表示认为自身log中没有一条记录和其他follower能匹配上。随着leader和其他follower同步消息时，matchIndex会<strong>慢慢增加</strong>。leader为每个自己的follower维护matchIndex，因为平时根据majority规则，需要保证log已经同步到足够多的followers上。</li></ol></li></ul><p>假设这里有S1～S3三台服务器组成Raft集群，每个Server的log记录如下，(X, Y)表示在log index X有log entry term=Y的log记录：</p><ul><li>S1：(10, 3)</li><li>S2：(10, 3); (11, 3); (12, 5)</li><li>S3：(10, 3); (11, 3); (12, 4)</li></ul><p>这里可以看出来S2是term5的leader。</p><p>这里S2通过heartbeats流程顺带发起log catch up，即想要和其他followers同步log entry的整体记录情况，按照majority原则，只需要向除了自身外的一台服务器发送消息即可，这里假设向S3发请求。</p><ol><li><p>S2向S3，发送heartbeat，携带信息（当前nextIndex指向的term，nextIndex-1的term值，nextIndex-1值），即(空，5，12)</p></li><li><p>S3收到后，检查自己的log发现自己log index12为term4，回复S2一条否定消息no，表明自己还存活，但是不能同意S2要求的append操作，因为S3自己发现自己的log落后了。</p></li><li><p>S2看到S3的否定回应后，认为S3落后于自己，于是将自己的nextIndex从13改成12</p></li><li><p>S2重新发一条请求到S3，这次nextIndex是12，所以携带信息(5, 3, 11)</p></li><li><p>S3接收到后，检查自己log index11的位置为3，发现和S2说的一样，于是按照S2的log记录，在自己log index12的位置将term4改成term5，然后回复S2一条确定消息ok</p></li><li><p>S2收到来自S3的ok后，认为S3这次通信后log和自己对齐是最新的了</p></li><li><p>S2将自己维护的对应S3的matchIndex更新为13，表示log index13之前的log entry，作为leader的S2和作为follower的S3是对齐的</p></li></ol><p>到这里为止，S2能够知道log index12的log entry term5至少在2个server上得到复制(S2和S3)，已经满足了majority原则了，所以S2能将消息传递到上层应用了。不幸的是，这不完全是对的。下面会讨论为什么。</p><p>这里未优化的版本有个很大的问题，那就是如果Raft集群中出现log落后很多的server，leader需要进行很多次请求才能将其log与自己对齐。</p><h5 id="Raft-日志擦除">Raft-日志擦除</h5><blockquote><p><a href="https://vearne.cc/archives/1851">聊聊RAFT的一个实现(4)–NOPCommand</a><br><a href="https://www.cnblogs.com/xybaby/p/10124083.html#_label_7">对下面这句话的解释</a></p></blockquote><p><strong>也就是说，某个leader选举成功之后，不会直接提交前任leader时期的日志，而是通过提交当前任期的日志的时候“顺手”把之前的日志也提交了，具体怎么实现了，在log matching部分有详细介绍。那么问题来了，如果leader被选举后没有收到客户端的请求呢，论文中有提到，在任期开始的时候发立即尝试复制、提交一条空的log</strong></p><h5 id="Raft-日志快速覆写同步">Raft-日志快速覆写同步</h5><p><img src="../assets/2024-11-29-Mit6-824%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-14.png" alt="alt text"></p><p>如果通过前面&quot;7.2 Log catch up(unoptimized)&quot;流程，可知道假设S2要向S1同步历史log的记录，那么需要从log index5（nextIndex=6）开始请求，一直请求到log index1（nextIndex=2）的位置后，才能找到S2和S1对齐的第一个位置log index1，然后又以1log index为单位，一直同步到nextIndex=6为止。这显然很浪费网络资源。</p><p>这里Log catch up quickly在论文中没有很详细的描述，但是大致流程如下：</p><ul><li>S2假设在term7当选leader，于是nextIndex=6，如之前一样，向S1发送heartbeat时携带log同步信息，(空，6，5)，对应（当前nextIndex指向的term，nextIndex-1的term，nextIndex-1值）</li><li>S1收到后，对比自己logIndex5位置为term5。此时S1不再是简单返回no，还顺带回复自己的log信息（即请求中logIndex位置的term值，这个term值最早出现的logIndex位置），这里S1回复（5，2），表示S2heartbeat中说的logIndex5位置自己是term5不对齐，并且term5的值在自己log可追溯到logIndex2</li><li>S2收到回应后，可以直接将nextIndex改成2，并且下次heartbeat携带的信息变成（[6,6,6,6], 4, 1），表示nextIndex即往后的数据为[6,6,6,6]</li><li>S1收到heartnbeat后，发现logIndex1是term4是对齐的，于是按照S2说的，将logIndex2开始往后的共4个位置替换成[6,6,6,6]。</li></ul><p>当然也可以使用更高级的方法，比如二分来优化，上述流程只是一种方法，意思大概就是一次性<strong>否定匹配当前不匹配term第一个出现的位置</strong></p><h5 id="Raft-持久化">Raft-持久化</h5><blockquote><p><a href="https://mit-public-courses-cn-translatio.gitbook.io/mit6-824/lecture-07-raft2/7.4-chi-jiu-hua-persistent">持久化</a><br>Log需要被持久化存储的原因是，这是唯一记录了应用程序状态的地方。Raft论文图2并没有要求我们持久化存储应用程序状态。假如我们运行了一个数据库或者为VMware FT运行了一个Test-and-Set服务，根据Raft论文图2，实际的数据库或者实际的test-set值，并不会被持久化存储，只有Raft的Log被存储了。所以当服务器重启时，唯一能用来重建应用程序状态的信息就是存储在Log中的一系列操作，所以Log必须要被持久化存储。</p><p>那currentTerm呢？为什么currentTerm需要被持久化存储？是的，currentTerm和votedFor都是用来确保每个任期只有最多一个Leader。在一个故障的场景中，如果一个服务器收到了一个RequestVote请求，并且为服务器1投票了，之后它故障。如果它没有存储它为哪个服务器投过票，当它故障重启之后，收到了来自服务器2的同一个任期的另一个RequestVote请求，那么它还是会投票给服务器2，因为它发现自己的votedFor是空的，因此它认为自己还没投过票。现在这个服务器，在同一个任期内同时为服务器1和服务器2投了票。因为服务器1和服务器2都会为自己投票，它们都会认为自己有过半选票（3票中的2票），那它们都会成为Leader。现在同一个任期里面有了两个Leader。这就是为什么votedFor必须被持久化存储。</p><p>currentTerm的情况要更微妙一些，但是实际上还是为了实现一个任期内最多只有一个Leader，我们之前实际上介绍过这里的内容。如果（重启之后）我们不知道任期号是什么，很难确保一个任期内只有一个Leader。</p></blockquote><p>我们这里主要考虑Reboot重启时发生/需要做的事情。</p><ul><li><p>策略1：一个Raft节点崩溃重启后，必须重新加入Raft集群。即对于整个Raft集群来说，重启和新加入Raft节点没有太大区别</p><ul><li>重新加入(re-join)，重新加入Raft集群</li><li>重放日志(replay the log)，需要重新执行本地存储的log（我理解上只有未commit的需要重放，当然如果不能区分哪些commit的话，那就是所有现存log需要重放）</li></ul></li></ul><p>策略2：快速重启(start from your persistence state)，从上一次存储的持久化状态(快照)的位置开始工作，后续可以通过log catch up的机制，赶上leader的log状态</p><p>人们更偏向于策略2，快速重启。这就需要搞清楚，需要持久化哪些状态。</p><p>Raft持久化以下状态state：</p><ul><li>vote for：投票情况，因为需要保证每轮term每个server只能投票一次</li><li>log：崩溃前的log记录，因为我们需要保证(promise)已发生的(commit)不会被回退。否则崩溃重启后，可能发生一些奇怪的事情，比如client先前的请求又重新生效一次，导致某个K/V被覆盖成旧值之类的。</li><li>current term：崩溃前的当前term值。因为选举(election)需要用到，用于投票和拉票流程，并且<strong>需要保证单调递增</strong>(monotonic increasing)</li></ul><p>问题：什么时候，server决定进行持久化的动作呢？</p><p>回答：<strong>每当上面提到的需要持久化的变量state发生变化时，都应该进行持久化</strong>，写入稳定存储(磁盘)，即使这可能是很昂贵的操作。你必须<strong>保证在回复client或者leader的请求之前，先将需要持久化的数据写入稳定存储</strong>，然后再回复。否则如果先回复，但是持久化之前崩溃了，你相当于丢失了一些无法找回的记录。</p><h5 id="Raft-服务恢复">Raft-服务恢复</h5><p>类似的，服务重启恢复时有两种策略：</p><ul><li>日志重放(replay log)：理论上将log中的记录全部重放一遍，能得到和之前一致的工作状态。这一般来说是很昂贵的策略，特别是工作数年的服务，从头开始执行一遍log，耗时难以估量。所以一般人们不会考虑策略1。</li><li><strong>周期性快照(periodic snapshots)</strong>：假设在i的位置创建了快照，那么可以裁剪log，只保留i往后的log。此时重启后可以通过snapshot快照先快速恢复到某个时刻的状态，然后后续可以再通过log catch up或其他手段，将log同步到最新状态。（一般来说周期性的快照不会落后最新版本太多，所以恢复工作要少得多）</li></ul><p>这里可以扩展考虑一些场景，比如Raft集群中加入新的follower时，可以让leader将自己的snapshot传递给follower，帮助follower快速同步到近期的状态，尽管可能还是有些落后最新版本，但是根据后续log catch up等机制可以帮助follower随后快速跟进到最新版本log。</p><p>使用快照时，需要注意几点：</p><ol><li>需要拒绝旧版本的快照：有可能收到的snapshot比当前服务状态还老</li><li>需要保持快照后的log数据：在加载快照时，如果有新log产生，需要保证加载快照后这些新产生的log能够能到保留</li></ol><h5 id="线性一致性">线性一致性</h5><p>在论文中对整个系统提供的服务的正确性称为<strong>线性一致性(Linearizability)</strong>，线性一致性需要保证满足一下三个条件：</p><ol><li><p><strong>整体操作顺序一致(total order of operations)</strong><br>即使操作实际上并发进行，你仍然可以按照整体顺序对它们进行排序。（即后续可以根据读写操作的返回值，对所有读写操作整理出一个符合逻辑的整体执行顺序）</p></li><li><p><strong>实时匹配(match real-time)</strong><br>顺序和真实时间匹配，如果第一个操作在第二个操作开始前就完成，那么在整体顺序中，第一个操作必须排在第二个操作之前(换言之如果这么排序后，整体的执行结果不符合逻辑，那么就不符合&quot;实时匹配&quot;)。</p></li><li><p><strong>读操作总是返回最后一次写操作的结果(read return results of last write)</strong></p></li></ol><p><strong>问题：这里说的线性一致性，是不是就是人们说的强一致性？</strong></p><p><strong>回答：是的。一般直觉就是表现上像单机，而技术文献中准确定义称为线性一致性。</strong></p><p>问题：人们为什么决定定义这个property？（指，线性一致性这个概念为啥会被定义出来）</p><p>回答：比如你希望多机系统对外表现如同单机一样，线性一致性就是非常直观的定义。数据库世界中有类似的术语，叫做<strong>可串行化(serializability)</strong>。基本上<strong>线性一致性和可串行化的唯一区别是，可串行化不需要实时匹配(match real-time)</strong>。当然，人们对强一致性有不同定义，而我们这里认为线性一致性就是一种强一致性。</p><p>问题：可以稍微详细一点介绍clerk吗？</p><p>回答：clerk是一个RPC库，它可以帮助记录请求的RPC服务器列表。比如它认为server1是leader，于是Client发请求时，通过clerk会发送到server1，如果server1宕机了，也许clerk根据维护的server列表，会尝试将Client的请求发送到server2，猜测server2是leader。并且clerk会标记每次请求(get、put等)，生成请求id，可以帮助server服务检测重复的请求。</p><p>问题：论文12页中提到follower擦除旧log，但是不能回滚状态机，是吗？</p><p>回答：正如前面日志擦除所说，<strong>Raft可以擦除未提交(uncommitted)的log。</strong></p><p><strong>问题：server加载snapshot的时候，怎么保证后续还可以接收新的log</strong></p><p><strong>回答：可以在加载snapshot之前，先通过COW写时复制的fork创建子进程，子进程加载snapshot，而父进程继续提供服务，例如获取新的log之类的。因为子进程和父进程共享同样的物理内存，所以后续总有办法使得加载完snapshot的子进程获取父进程这段时间内新增的log。</strong></p><p>问题：当生成snapshot且因此压缩/删除旧log后，sever维护的log index是从0开始，还是在原本的位置继续往后？</p><p>回答：从原本的位置继续往后，不会回退log index索引。</p>]]></content>
    
    
    <summary type="html">本文描述的是Mit6.824课程的笔记</summary>
    
    
    
    <category term="分布式" scheme="https://pigcanstudy.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="分布式" scheme="https://pigcanstudy.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="MIT6.824" scheme="https://pigcanstudy.github.io/tags/MIT6-824/"/>
    
  </entry>
  
  <entry>
    <title>go中Gorm的使用</title>
    <link href="https://pigcanstudy.github.io/posts/119a915f.html"/>
    <id>https://pigcanstudy.github.io/posts/119a915f.html</id>
    <published>2024-11-29T09:26:02.000Z</published>
    <updated>2024-12-18T08:41:56.997Z</updated>
    
    <content type="html"><![CDATA[<h1>目录</h1><ul><li><a href="#%E7%9B%AE%E5%BD%95">目录</a><ul><li><a href="#%E5%89%8D%E8%A8%80">前言</a></li><li><a href="#%E5%AE%89%E8%A3%85gorm">安装Gorm</a></li><li><a href="#gorm%E8%BF%9E%E6%8E%A5mysql%E6%95%B0%E6%8D%AE%E5%BA%93">Gorm连接mysql数据库</a><ul><li><a href="#gorm%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BA%A6%E5%AE%9A">GORM的一些约定</a><ul><li><a href="#%E4%B8%BB%E9%94%AE">主键</a></li><li><a href="#%E8%A1%A8%E5%90%8D">表名</a></li></ul></li><li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E9%93%BE%E6%8E%A5%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E5%BC%8F">数据库链接的基本方式</a></li><li><a href="#%E7%8E%B0%E6%9C%89%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F">现有的数据库连接方式</a></li></ul></li><li><a href="#gorm%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">Gorm定义数据库模型的注意事项</a></li><li><a href="#gorm%E6%93%8D%E4%BD%9Cmysql%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95">GORM操作mysql的基本用法</a><ul><li><a href="#%E5%88%9B%E5%BB%BA">创建</a><ul><li><a href="#%E5%88%9B%E5%BB%BA%E8%A1%A8">创建表</a></li><li><a href="#%E5%88%9B%E5%BB%BA%E8%AE%B0%E5%BD%95%E5%A2%9E%E5%8A%A0%E8%AE%B0%E5%BD%95">创建记录(增加记录)</a></li></ul></li><li><a href="#%E6%9F%A5%E8%AF%A2">查询</a><ul><li><a href="#%E4%BD%BF%E7%94%A8%E4%B8%80%E8%88%AC%E6%9F%A5%E8%AF%A2%E5%86%85%E7%BD%AE%E7%9A%84%E6%9F%A5%E8%AF%A2%E6%8E%A5%E5%8F%A3">使用一般查询(内置的查询接口)</a></li><li><a href="#%E4%BD%BF%E7%94%A8where%E6%96%B9%E6%B3%95">使用Where()方法</a><ul><li><a href="#%E6%99%AE%E9%80%9Asql%E6%9F%A5%E8%AF%A2">普通sql查询</a></li><li><a href="#stuct%E4%BB%A5%E5%8F%8Amap%E6%9F%A5%E8%AF%A2">Stuct以及Map查询</a></li></ul></li><li><a href="#not%E6%9D%A1%E4%BB%B6">Not条件</a></li><li><a href="#or%E6%9D%A1%E4%BB%B6">Or条件</a></li><li><a href="#%E5%86%85%E8%81%94%E6%9D%A1%E4%BB%B6">内联条件</a></li><li><a href="#%E9%A2%9D%E5%A4%96%E6%9F%A5%E8%AF%A2%E9%80%89%E9%A1%B9">额外查询选项</a></li><li><a href="#%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98">一些问题</a><ul><li><a href="#firstorinit%E6%96%B9%E6%B3%95">FirstOrInit()方法</a></li></ul></li><li><a href="#firstorcreate%E6%96%B9%E6%B3%95">FirstOrCreate()方法</a></li><li><a href="#%E9%AB%98%E7%BA%A7%E6%9F%A5%E8%AF%A2">高级查询</a><ul><li><a href="#%E9%80%89%E6%8B%A9%E5%AD%97%E6%AE%B5%E6%9F%A5%E8%AF%A2">选择字段查询</a></li><li><a href="#%E6%8E%92%E5%BA%8Forder">排序Order()</a></li><li><a href="#limit">Limit()</a></li><li><a href="#offset">Offset()</a></li><li><a href="#count">Count()</a></li><li><a href="#group--having">Group &amp; Having</a></li><li><a href="#joins">Joins</a></li><li><a href="#pluck">Pluck</a></li><li><a href="#scan">Scan</a></li></ul></li></ul></li><li><a href="#%E9%93%BE%E5%BC%8F%E6%93%8D%E4%BD%9C%E7%9B%B8%E5%85%B3">链式操作相关</a><ul><li><a href="#%E9%93%BE%E5%BC%8F%E6%93%8D%E4%BD%9C">链式操作</a></li><li><a href="#%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E6%96%B9%E6%B3%95">立即执行方法</a></li><li><a href="#%E8%8C%83%E5%9B%B4">范围</a></li><li><a href="#%E5%A4%9A%E4%B8%AA%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E6%96%B9%E6%B3%95">多个立即执行方法</a></li></ul></li><li><a href="#%E6%9B%B4%E6%96%B0">更新</a><ul><li><a href="#%E6%9B%B4%E6%96%B0%E6%89%80%E6%9C%89%E5%AD%97%E6%AE%B5">更新所有字段</a><ul><li><a href="#%E5%A6%82%E6%9E%9C%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%9C%89%E5%AD%97%E6%AE%B5-%E5%B0%B1%E4%BC%9A%E6%89%A7%E8%A1%8Cupdate%E8%AF%AD%E5%8F%A5">如果数据库中有字段 就会执行UPDATE语句</a></li><li><a href="#%E5%A6%82%E6%9E%9C%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%B2%A1%E6%9C%89%E5%AD%97%E6%AE%B5%E5%B0%B1%E4%BC%9A%E6%89%A7%E8%A1%8Cinsert%E8%AF%AD%E5%8F%A5">如果数据库中没有字段，就会执行INSERT语句</a></li></ul></li><li><a href="#%E6%9B%B4%E6%96%B0%E6%8C%87%E5%AE%9A%E5%AD%97%E6%AE%B5">更新指定字段</a></li><li><a href="#%E6%9B%B4%E6%96%B0%E9%80%89%E5%AE%9A%E5%AD%97%E6%AE%B5">更新选定字段</a></li><li><a href="#%E6%89%B9%E9%87%8F%E6%9B%B4%E6%96%B0">批量更新</a></li><li><a href="#%E4%BD%BF%E7%94%A8sql%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%9B%B4%E6%96%B0">使用sql表达式更新</a></li></ul></li><li><a href="#%E5%88%A0%E9%99%A4">删除</a><ul><li><a href="#%E5%88%A0%E9%99%A4%E8%AE%B0%E5%BD%95">删除记录</a></li><li><a href="#%E6%89%B9%E9%87%8F%E5%88%A0%E9%99%A4">批量删除</a></li></ul></li><li><a href="#%E4%BA%8B%E5%8A%A1">事务</a><ul><li><a href="#%E7%A6%81%E7%94%A8%E9%BB%98%E8%AE%A4%E4%BA%8B%E5%8A%A1">禁用默认事务</a></li><li><a href="#gorm%E6%89%8B%E5%8A%A8%E6%8E%A7%E5%88%B6%E4%BA%8B%E5%8A%A1">Gorm手动控制事务</a><ul><li><a href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B">事务的执行流程</a></li><li><a href="#%E6%89%8B%E5%8A%A8%E6%8E%A7%E5%88%B6%E4%BA%8B%E5%8A%A1">手动控制事务</a></li></ul></li></ul></li></ul></li></ul></li></ul><h2 id="前言">前言</h2><p>以下是官方文档的地址，也是我参考的文档</p><blockquote><p><a href="https://gorm.io/zh_CN/docs/models.html">GORM官方中文文档</a></p></blockquote><ul><li>虽然 database/sql 是一个功能强大的工具，但 GORM 的出现是为了简化数据库操作，提高开发效率，让开发者能更专注于业务逻辑而非低层的数据库细节。这就是 GORM 的设计理念。</li></ul><p>本文只讲述如何链接mysql数据库并进行相应操作</p><h2 id="安装Gorm">安装Gorm</h2><ol><li>首先新建项目并且使用go mod init初始化项目</li><li>调用以下两句命令安装GORM：</li></ol><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">go</span> <span class="built_in">get</span> -u gorm.io/gorm</span><br><span class="line"><span class="built_in">go</span> <span class="built_in">get</span> -u gorm.io/driver/mysql</span><br></pre></td></tr></table></figure><ol start="3"><li>通过查看mod 或者使用 go mod graph查看是否安装成功</li></ol><h2 id="Gorm连接mysql数据库">Gorm连接mysql数据库</h2><h3 id="GORM的一些约定">GORM的一些约定</h3><ol><li>主键：GORM 使用一个名为ID 的字段作为每个模型的默认主键。</li><li>表名：默认情况下，GORM 将结构体名称转换为 snake_case 并为表名加上<strong>复数形式。</strong><br>例如，一个 User 结构体在数据库中的表名变为 users 。可以使用重定义某个标的名字来做到自定义表名，例如: <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(User)</span></span> TableName() <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;user&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>列名：GORM 自动将结构体字段名称转换为 snake_case 作为数据库中的列名。</li><li>时间戳字段：GORM使用字段 CreatedAt(该字段的值将会是初次创建记录的时间。) 和 UpdatedAt 来自动跟踪记录的创建和更新时间(该字段的值将会是每次更新记录的时间)。</li></ol><h4 id="主键">主键</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID   <span class="type">string</span> <span class="comment">// 名为`ID`的字段会默认作为表的主键</span></span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用`AnimalID`作为主键</span></span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">struct</span> &#123;</span><br><span class="line">  AnimalID <span class="type">int64</span> <span class="string">`gorm:&quot;primary_key&quot;`</span></span><br><span class="line">  Name     <span class="type">string</span></span><br><span class="line">  Age      <span class="type">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="表名">表名</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;&#125; <span class="comment">// 默认表名是 `users`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 User 的表名设置为 `profiles`</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(User)</span></span> TableName() <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;profiles&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u User)</span></span> TableName() <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> u.Role == <span class="string">&quot;admin&quot;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;admin_users&quot;</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;users&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁用默认表名的复数形式，如果置为 true，则 `User` 的默认表名是 `user`</span></span><br><span class="line">db.SingularTable(<span class="literal">true</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="数据库链接的基本方式">数据库链接的基本方式</h3><ol><li>首先我们需要导入需要用到的包，并且定义数据库链接信息 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;gorm.io/driver/mysql&quot;</span></span><br><span class="line">    <span class="string">&quot;gorm.io/gorm&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 数据库连接信息</span></span><br><span class="line">    dsn := <span class="string">&quot;root:123456@(localhost:3306)/pigcanstudy?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>其中连接信息的模板是 <code>&quot;user:password@(localhost)/dbname?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;</code></li></ul></li><li>然后我们使用gorm.Open()方法连接数据库 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 连接数据库</span></span><br><span class="line">db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  log.Fatalf(<span class="string">&quot;failed to connect to database: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> db.Close()</span><br></pre></td></tr></table></figure><ul><li>其中mysql.Open()方法是用来连接mysql数据库的，dsn参数是连接信息，&amp;gorm.Config{}是gorm的配置信息，可以不用管</li></ul></li></ol><h3 id="现有的数据库连接方式">现有的数据库连接方式</h3><p>GORM 允许通过一个现有的数据库连接来初始化 *gorm.DB</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;database/sql&quot;</span></span><br><span class="line">  <span class="string">&quot;gorm.io/driver/mysql&quot;</span></span><br><span class="line">  <span class="string">&quot;gorm.io/gorm&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 数据库连接信息</span></span><br><span class="line">  dsn := <span class="string">&quot;root:123456@(localhost:3306)/pigcanstudy?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;</span></span><br><span class="line"></span><br><span class="line">sqlDB, _ := sql.Open(<span class="string">&quot;mysql&quot;</span>, dsn)</span><br><span class="line">  gormDB, _ := gorm.Open(mysql.New(mysql.Config&#123;</span><br><span class="line">    Conn: sqlDB,</span><br><span class="line">  &#125;), &amp;gorm.Config&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Gorm定义数据库模型的注意事项">Gorm定义数据库模型的注意事项</h2><ol><li><strong>结构体的名称必须首字母大写，并且和数据库表名称对应</strong></li><li>结构体中的<strong>字段名称的首字母必须大写</strong>，并且和数据库表中的列名对应</li><li><strong>默认情况表名是结构体的复数形式</strong>，可以通过重写<code>TableName()</code>方法自定义表名</li></ol><h2 id="GORM操作mysql的基本用法">GORM操作mysql的基本用法</h2><p>假设我们声明的模型是如下定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> models</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Id    <span class="type">int</span></span><br><span class="line">Name  <span class="type">string</span></span><br><span class="line">Email <span class="type">string</span></span><br><span class="line">pwd   <span class="type">string</span></span><br><span class="line">sex   <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *User)</span></span> TableName() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;user&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="创建">创建</h3><blockquote><p>附带下mysql的书写和执行顺序<br><a href="https://www.cnblogs.com/east7/p/14217030.html">mysql书写和执行顺序</a></p></blockquote><h4 id="创建表">创建表</h4><p>一般情况下，我们都是先将数据库表创建完后在进行实际项目的开发，所以这里创建用的较少，但是我们可以了解下如何创建表：</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 自动迁徙（作用是自动迁移数据库表的结构，以与 User 结构体的定义保持一致）</span></span><br><span class="line"><span class="comment">// 这意味着它会根据 User 结构体的字段信息来创建或更新数据库中的相应表。</span></span><br><span class="line">db.AutoMigrate(&amp;User&#123;&#125;)</span><br></pre></td></tr></table></figure><p>也就是说可以是用AutoMigrate方法来自动创建表格</p><h4 id="创建记录-增加记录">创建记录(增加记录)</h4><ol><li>使用上面的定义的模型</li><li>使用create创建</li></ol><p>代码如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;gorm.io/driver/mysql&quot;</span></span><br><span class="line"><span class="string">&quot;gorm.io/gorm&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">ID    <span class="type">uint</span></span><br><span class="line">Name  <span class="type">string</span></span><br><span class="line">Email <span class="type">string</span></span><br><span class="line">Pwd   <span class="type">string</span></span><br><span class="line">Sex   <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(User)</span></span> TableName() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;user&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 数据库连接信息</span></span><br><span class="line">dsn := <span class="string">&quot;root:123456@(localhost:3306)/db1?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;</span></span><br><span class="line"><span class="comment">// 连接数据库</span></span><br><span class="line">db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">&quot;failed to connect to database: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取原始数据库的链接*sql.DB的对象</span></span><br><span class="line"><span class="comment">// sqlDB, err := db.DB()</span></span><br><span class="line"><span class="comment">// if err != nil &#123;</span></span><br><span class="line"><span class="comment">// log.Fatalf(&quot;failed to get DB: %v&quot;, err)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------------------------------------创建表格-----------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动迁徙（作用是自动迁移数据库表的结构，以与 User 结构体的定义保持一致）</span></span><br><span class="line"><span class="comment">// 这意味着它会根据 User 结构体的字段信息来创建或更新数据库中的相应表。</span></span><br><span class="line">db.AutoMigrate(&amp;User&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------------------------------------插入记录-----------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量插入</span></span><br><span class="line"><span class="keyword">var</span> users []User = []User&#123;</span><br><span class="line">&#123;ID: <span class="number">1</span>, Name: <span class="string">&quot;Alice&quot;</span>, Email: <span class="string">&quot;alice@example.com&quot;</span>, Pwd: <span class="string">&quot;123456&quot;</span>, Sex: <span class="number">1</span>&#125;,</span><br><span class="line">&#123;ID: <span class="number">2</span>, Name: <span class="string">&quot;Bob&quot;</span>, Email: <span class="string">&quot;bob@example.com&quot;</span>, Pwd: <span class="string">&quot;654321&quot;</span>, Sex: <span class="number">2</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建记录</span></span><br><span class="line">db.Create(&amp;users)</span><br><span class="line"></span><br><span class="line"><span class="comment">//挨个插入</span></span><br><span class="line">user1 := User&#123;ID: <span class="number">3</span>, Name: <span class="string">&quot;Charlie&quot;</span>, Email: <span class="string">&quot;charlie@example.com&quot;</span>, Pwd: <span class="string">&quot;123456&quot;</span>, Sex: <span class="number">1</span>&#125;</span><br><span class="line">user2 := User&#123;ID: <span class="number">4</span>, Name: <span class="string">&quot;Dave&quot;</span>, Email: <span class="string">&quot;dave@example.com&quot;</span>, Pwd: <span class="string">&quot;654321&quot;</span>, Sex: <span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建记录</span></span><br><span class="line">db.Create(&amp;user1)</span><br><span class="line">db.Create(&amp;user2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查询">查询</h3><h4 id="使用一般查询-内置的查询接口">使用一般查询(内置的查询接口)</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// ------------------------------First() 方法------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> u User</span><br><span class="line"></span><br><span class="line"><span class="comment">// db.First(desc interface&#123;&#125;, conds ...interface&#123;&#125;)</span></span><br><span class="line"><span class="comment">// 第一个参数是要查询的结构体，第二个参数是查询条件，可以为空，表示无条件查询</span></span><br><span class="line"><span class="comment">// 这个接口会根据条件查询符合条件的第一条记录，并将其赋值给第一个参数的结构体</span></span><br><span class="line"><span class="comment">// 例如查询第一个pwd为123456的记录(仅当主键为整形可用)</span></span><br><span class="line">db.First(&amp;u, <span class="string">&quot;pwd = ?&quot;</span>, <span class="string">&quot;123456&quot;</span>)</span><br><span class="line"><span class="comment">// 对应的sql语句是: SELECT * FROM user WHERE pwd = &#x27;123456&#x27; LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据主键查询第一条记录</span></span><br><span class="line">db.First(&amp;u)</span><br><span class="line"><span class="comment">// 对应的sql语句是: SELECT * FROM user OREDER BY id LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------------------------Find()方法-------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// db.Find(dest interface&#123;&#125;, conds ...interface&#123;&#125;)</span></span><br><span class="line"><span class="comment">// 第一个参数是要查询的结构体切片，第二个参数是查询条件，可以为空，表示无条件查询</span></span><br><span class="line"><span class="comment">// 这个接口会根据条件查询所有符合条件的记录，并将其赋值给第一个参数的结构体切片</span></span><br><span class="line"><span class="comment">// 例如查询所有Sex为1(男)的记录</span></span><br><span class="line"><span class="keyword">var</span> uu []User</span><br><span class="line">db.Find(&amp;uu, <span class="string">&quot;Sex = ?&quot;</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment">// 对应的sql语句是: SELECT * FROM user WHERE Sex = 1;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------------------------Take()方法-------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// db.Take(dest interface&#123;&#125;, conds ...interface&#123;&#125;)</span></span><br><span class="line"><span class="comment">// 这个接口和db.First()类似，但是它查询的时候不是排序的，如果给定了条件，则会先根据条件查询符合条件的第一条记录，然后将其赋值给dest参数的结构体，然后返回。</span></span><br><span class="line"><span class="comment">// 例如查询第一个Sex为1(男)的记录</span></span><br><span class="line"><span class="keyword">var</span> u User</span><br><span class="line">db.Take(&amp;u, <span class="string">&quot;Sex = ?&quot;</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment">// SELECT * FROM user WHERE Sex = 1 LIMIT 1;</span></span><br><span class="line"></span><br><span class="line">db.Take(&amp;u)</span><br><span class="line"><span class="comment">// SELECT * FROM user LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------------------------Last()方法------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// db.Last(dest interface&#123;&#125;, conds ...interface&#123;&#125;)</span></span><br><span class="line"><span class="comment">// 这个接口是根据主键查询（满足条件）最后一条记录</span></span><br><span class="line"><span class="comment">// 例如查询满足Sex为1(男)的最后一条记录</span></span><br><span class="line">db.Last(&amp;u, <span class="string">&quot;Sex = ?&quot;</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment">// 对应的sql语句是: SELECT * FROM user WHERE Sex = 1 ORDER BY id DESC LIMIT 1;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="使用Where-方法">使用Where()方法</h4><h5 id="普通sql查询">普通sql查询</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="keyword">var</span> u User</span><br><span class="line"></span><br><span class="line"> <span class="comment">// ---------------------------db.Where()方法------------------------------</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// db.Where(query interface&#123;&#125;, args ...interface&#123;&#125;)</span></span><br><span class="line"> <span class="comment">// 第一个参数是查询条件，可以是字符串或者map或者结构体，第二个参数是参数（只有当前面为字符串且出现了 ？ 时候才会使用 也就是sql注入），可以为空，表示无参数</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 例如查询第一个名字为Alice的记录</span></span><br><span class="line"> db.Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;Alice&quot;</span>).First(&amp;u)</span><br><span class="line"> <span class="comment">// 对应的sql语句是: SELECT * FROM user WHERE name = &#x27;Alice&#x27; LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 得到所有满足pwd为123456的记录</span></span><br><span class="line"> db.Where(<span class="string">&quot;pwd = ?&quot;</span>, <span class="string">&quot;123456&quot;</span>).Find(&amp;u)</span><br><span class="line"> <span class="comment">// 对应的sql语句是: SELECT * FROM user WHERE pwd = &#x27;123456&#x27;;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 得到所有不满足name为Alice的记录</span></span><br><span class="line"> db.Where(<span class="string">&quot;name &lt;&gt; ?&quot;</span>, <span class="string">&quot;Alice&quot;</span>).Find(&amp;u)</span><br><span class="line"> <span class="comment">// 对应的sql语句是: SELECT * FROM user WHEARE name &lt;&gt; &#x27;Alice&#x27;;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 得到所有name满足一个查询数组条件的记录</span></span><br><span class="line">db.Where(<span class="string">&quot;name IN (?)&quot;</span>, []<span class="type">string</span>&#123;<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>&#125;).Find(&amp;uu)</span><br><span class="line"><span class="comment">// 对应的sql语句是: SELECT * FROM user WHERE name IN (&#x27;Alice&#x27;, &#x27;Bob&#x27;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询名字为%A%的所有记录</span></span><br><span class="line">db.Where(<span class="string">&quot;name LIKE ?&quot;</span>, <span class="string">&quot;%A%&quot;</span>).Find(&amp;uu)</span><br><span class="line"><span class="comment">// 对应的sql语句是: SELECT * FROM user WHERE name LIKE &#x27;%A%&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询名字为Alice同时密码为123456的记录</span></span><br><span class="line">db.Where(<span class="string">&quot;name = ? AND pwd = ?&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;123456&quot;</span>).Find(&amp;uu)</span><br><span class="line"><span class="comment">// 对应的sql语句是: SELECT * FROM user WHERE name = &#x27;Alice&#x27; AND pwd = &#x27;123456&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询更新时间为上周的记录</span></span><br><span class="line">db.Where(<span class="string">&quot;updated_at &gt; ?&quot;</span>, time.Now().Add(<span class="number">-7</span>*<span class="number">24</span>*time.Hour)).Find(&amp;uu)</span><br><span class="line"><span class="comment">// 对应的sql语句是: SELECT * FROM user WHERE updated_at &gt; &#x27;2024-11-24 00:00:00&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询创建时间位于一个区间之间的记录</span></span><br><span class="line">db.Where(<span class="string">&quot;created_at BETWEEN ? AND ?&quot;</span>, <span class="string">&quot;2021-01-01 00:00:00&quot;</span>, <span class="string">&quot;2022-01-01 00:00:00&quot;</span>).Find(&amp;uu)</span><br><span class="line"><span class="comment">// 对应的sql语句是: SELECT * FROM user WHERE created_at BETWEEN &#x27;2021-01-01 00:00:00&#x27; AND &#x27;2022-01-01 00:00:00&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="Stuct以及Map查询">Stuct以及Map查询</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> uuu User</span><br><span class="line"><span class="comment">// 使用结构体查询</span></span><br><span class="line">db.Where(User&#123;Name: <span class="string">&quot;Alice&quot;</span>, Pwd: <span class="string">&quot;123456&quot;</span>&#125;).Find(&amp;uuu)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;查询结果为: &quot;</span>, uuu)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> uuuu User</span><br><span class="line"><span class="comment">// 使用map来查询</span></span><br><span class="line">db.Where(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;pwd&quot;</span>: <span class="string">&quot;654321&quot;</span>&#125;).Find(&amp;uuuu)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;查询结果为: &quot;</span>, uuuu)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>注意</strong>:当通过结构体进行查询时，GORM将会只通过非零值字段查询，这意味着如果你的字段值为0，‘’，false或者其他零值时，将不会被用于构建查询条件，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.Where(&amp;User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>, Age: <span class="number">0</span>&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name = &quot;jinzhu&quot;;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>你可以使用指针或实现 Scanner/Valuer 接口来避免这个问题.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用指针</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">  Age  *<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Scanner/Valuer</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">  Age  sql.NullInt64  <span class="comment">// sql.NullInt64 实现了 Scanner/Valuer 接口</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Not条件">Not条件</h4><p>作用与 Where 类似的情形如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ---------------------------db.Not()方法---------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// db.Not(query interface&#123;&#125;, args ...interface&#123;&#125;)</span></span><br><span class="line"><span class="comment">// 第一个为查询的条件，第二个参数是条件的具体值，可以为空，表示无参数</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  使用Not()时候有两种区别：</span></span><br><span class="line"><span class="comment">    1. 使用name = ? 作为条件，会被翻译成 NOT (name = &#x27;Alice&#x27;) 这种形式，例如：</span></span><br><span class="line"><span class="comment">    db.Not(&quot;name = ?&quot;, &quot;Alice&quot;).Find(&amp;u)</span></span><br><span class="line"><span class="comment">    对应的sql语句是: SELECT * FROM user WHERE NOT (name = &#x27;Alice&#x27;);</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    db.Not(&quot;name = ?&quot;, []string&#123;&quot;Alice&quot;, &quot;Bob&quot;&#125;).Find(&amp;u)</span></span><br><span class="line"><span class="comment">    其对应的sql语句是 SELECT * FROM user WHERE NOT name = (&#x27;Alice&#x27;, &#x27;Bob&#x27;) 这种写法是错的，所以编译器会报错，这是就得使用下面这种方式</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    2. 翻译成NOT IN的形式，例如：</span></span><br><span class="line"><span class="comment">    db.Not(&quot;name&quot;, []string&#123;&quot;Alice&quot;, &quot;Bob&quot;&#125;).Find(&amp;u)</span></span><br><span class="line"><span class="comment">    对应的sql语句是: SELECT * FROM user WHERE name NOT IN (&#x27;Alice&#x27;, &#x27;Bob&#x27;)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到所有name不为Alice的记录</span></span><br><span class="line">db.Not(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;Alice&quot;</span>).Find(&amp;uu)</span><br><span class="line"><span class="comment">// 对应的sql语句是 SELECT* FROM user WHERE NOT (name = &#x27;Alice&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到所有name不为Alice且pwd不为123456的记录</span></span><br><span class="line">db.Not(<span class="string">&quot;name = ? AND pwd = ?&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;123456&quot;</span>).Find(&amp;uu)</span><br><span class="line"><span class="comment">// 对应的sql语句是 SELECT* FROM user WHERE NOT (name = &#x27;Alice&#x27; AND pwd = &#x27;123456&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到name不在切片（[]string&#123;&quot;Alice&quot;, &quot;Bob&quot;&#125;）中的记录</span></span><br><span class="line">db.Not(<span class="string">&quot;name&quot;</span>, []<span class="type">string</span>&#123;<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>&#125;).Find(&amp;uu)</span><br><span class="line"><span class="comment">// 对应的sql语句是 SELECT* FROM user WHERE name NOT IN (&#x27;Alice&#x27;, &#x27;Bob&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用结构体来查询</span></span><br><span class="line">db.Not(User&#123;Name: <span class="string">&quot;Alice&quot;</span>, Pwd: <span class="string">&quot;123456&quot;</span>&#125;).Find(&amp;uu)</span><br><span class="line"><span class="comment">// 对应的sql语句是 SELECT * FROM user WHERE NOT (name = &#x27;Alice&#x27; AND pwd = &#x27;123456&#x27;)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Or条件">Or条件</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ---------------------------db.Or()方法----------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// db.Or(query interface&#123;&#125;, args ...interface&#123;&#125;)</span></span><br><span class="line"><span class="comment">// 第一个参数为查询条件，可以是字符串或者map或者结构体，第二个参数是条件的具体值，可以为空，表示无参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接使用Or()方法，例如：</span></span><br><span class="line">db.Or(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;Alice&quot;</span>).Or(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;Bob&quot;</span>).Find(&amp;uu)</span><br><span class="line"><span class="comment">// 对应的sql语句是: SELECT * FROM user WHERE name = &#x27;Alice&#x27; OR name = &#x27;Bob&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Or()方法和Where()方法组合，例如：</span></span><br><span class="line">db.Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;Alice&quot;</span>).Or(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;Bob&quot;</span>).Find(&amp;uu)</span><br><span class="line"><span class="comment">// 对应的sql语句是: SELECT * FROM user WHERE name = &#x27;Alice&#x27; OR name = &#x27;Bob&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用结构体</span></span><br><span class="line">db.Where(<span class="string">&quot;name = &#x27;Alice&#x27;&quot;</span>).Or(User&#123;Name: <span class="string">&quot;Bob&quot;</span>, Pwd: <span class="string">&quot;123456&quot;</span>&#125;).Find(&amp;uu)</span><br><span class="line"><span class="comment">// 对应的sql语句是 SELECT * FROM `user` WHERE name = &#x27;Alice&#x27; OR (`user`.`name` = &#x27;Bob&#x27; AND `user`.`pwd` = &#x27;654321&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用MAP</span></span><br><span class="line">db.Where(<span class="string">&quot;namse = &#x27;Alice&#x27;&quot;</span>).Or(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;pwd&quot;</span>: <span class="string">&quot;654321&quot;</span>&#125;).Find(&amp;uu)</span><br><span class="line"><span class="comment">// 对应的sql语句是 SELECT * FROM `user` WHERE name = &#x27;Alice&#x27; OR (`name` = &#x27;Bob&#x27; AND `pwd` = &#x27;654321&#x27;)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>注意</strong>: 使用结构体和使用MAP来查询的时候其最终被翻译成的sql语句有所差别，前者会加上表名，后者不会。具体看上面例子。</p><h4 id="内联条件">内联条件</h4><p>就是把条件卸载一起，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">db.First(&amp;u, <span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;Alice&quot;</span>)</span><br><span class="line"><span class="comment">// 对应的sql语句是: SELEECT * FROM user WHERE name = &#x27;Alice&#x27; ORDER BY `user`.`id` LIMIT 1;</span></span><br><span class="line"></span><br><span class="line">db.Find(&amp;users, <span class="string">&quot;name &lt;&gt; ? AND age &gt; ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>, <span class="number">20</span>)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name &lt;&gt; &quot;jinzhu&quot; AND age &gt; 20;</span></span><br><span class="line"></span><br><span class="line">db.First(&amp;u, <span class="string">&quot;name = ? AND pwd = ?&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;123456&quot;</span>)</span><br><span class="line"></span><br><span class="line">db.Where(<span class="string">&quot;name = ? AND pwd = ?&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;123456&quot;</span>).Find(&amp;uu)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="额外查询选项">额外查询选项</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为查询 SQL 添加额外的 SQL 操作</span></span><br><span class="line">db.Set(<span class="string">&quot;gorm:query_option&quot;</span>, <span class="string">&quot;FOR UPDATE&quot;</span>).First(&amp;user, <span class="number">10</span>)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE id = 10 FOR UPDATE;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="一些问题">一些问题</h4><ol><li>诸如db.Where和db.Not方法它是怎么确定查询的是数据库的哪个表格的？</li></ol><p>答: Gorm会根据你定义的模型（也就是你定义的结构体）来确定查询的表格，这些方法必须跟着Find(&amp;uu)或者First(&amp;u)等方法一起使用才会生效。跟了这个之后就知道查询的是哪个表格了。</p><h5 id="FirstOrInit-方法">FirstOrInit()方法</h5><p>作用: 查询满足条件的第一条记录，如果没有找到,就初始化一个满足给定条件的结构体并返回。但是并<strong>不会</strong>在数据库中<strong>创建新的记录</strong>,并且仅支持<strong>结构体和map</strong>两种查询条件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.FirstOrInit(&amp;u, User&#123;Name: <span class="string">&quot;ppig&quot;</span>, Pwd: <span class="string">&quot;123456&quot;</span>, Sex: <span class="number">1</span>&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通常会和Attrs和Assign方法一起使用，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// ---------------------------db.Attrs()方法----------------------</span></span><br><span class="line"><span class="comment">// 如果未找到才会使用参数初始化结构体</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 找的到的情况下</span></span><br><span class="line">db.Where(User&#123;Name: <span class="string">&quot;ppig&quot;</span>, Pwd: <span class="string">&quot;123456&quot;</span>, Sex: <span class="number">1</span>&#125;).Attrs(<span class="string">&quot;age&quot;</span>, <span class="number">20</span>).FirstOrInit(&amp;u)</span><br><span class="line"><span class="comment">// 输出 &#123;1 Alice alice@example.com 123456 1&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 没找到的情况下</span></span><br><span class="line">db.Where(User&#123;Name: <span class="string">&quot;ppid&quot;</span>, Pwd: <span class="string">&quot;123456&quot;</span>, Sex: <span class="number">1</span>&#125;).Attrs(<span class="string">&quot;sex&quot;</span>, <span class="number">2</span>).FirstOrInit(&amp;u)</span><br><span class="line"><span class="comment">// 输出 查询结果为:  &#123;1 ppid alice@example.com 123456 2&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------------------db.Assign()方法----------------------</span></span><br><span class="line"><span class="comment">// 不管有没有找到都会将参数赋给结构体</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 找的到的情况下</span></span><br><span class="line">db.Where(User&#123;Name: <span class="string">&quot;Alice&quot;</span>, Pwd: <span class="string">&quot;123456&quot;</span>, Sex: <span class="number">1</span>&#125;).Assign(User&#123;Sex: <span class="number">2</span>&#125;).FirstOrInit(&amp;u)</span><br><span class="line"><span class="comment">// 输出 &#123;1 Alice alice@example.com 123456 2&#125;（数据库中sex为1）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 没找到的情况下</span></span><br><span class="line"><span class="comment">// 未找到</span></span><br><span class="line">db.Where(User&#123;Name: <span class="string">&quot;non_existing&quot;</span>&#125;).Assign(User&#123;Sex: <span class="number">2</span>&#125;).FirstOrInit(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM USERS WHERE name = &#x27;non_existing&#x27;;</span></span><br></pre></td></tr></table></figure><p>那么这种有啥实际的应用场景吗？</p><ol><li>可以在未找到的情况下初始化一个对象，然后选择性的create进数据库中</li><li>可以避免一些相同的初始化而导致代码冗余</li></ol><h4 id="FirstOrCreate-方法">FirstOrCreate()方法</h4><p>作用: 查询满足条件的第一条记录，如果没有找到,就创建一条新的记录并返回。但是并<strong>不会</strong>在数据库中<strong>更新已存在的记录</strong>,并且仅支持<strong>结构体和map</strong>两种查询条件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="comment">// 使用FirstOrCreate()方法 先查询是否存在，如果存在并且配上了（Assign）就会更新，不存在就需要下面的方法创建一个记录，否则会出现创建重复id记录的情况(如果指定了自增就不需要下面的方法了，可以直接使用）下述一行代码就能插入</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">     ID    <span class="type">uint</span> <span class="string">`gorm:&quot;primaryKey;autoIncrement&quot;`</span></span><br><span class="line">     Name  <span class="type">string</span></span><br><span class="line">     Email <span class="type">string</span></span><br><span class="line">     Pwd   <span class="type">string</span></span><br><span class="line">     Sex   <span class="type">int</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">db.Where(User&#123;Name: <span class="string">&quot;ppsd&quot;</span>, Pwd: <span class="string">&quot;123456&quot;</span>, Sex: <span class="number">2</span>&#125;).Assign(User&#123;Sex: <span class="number">1</span>&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">// ---------------------------不用自增字段的话----------------------</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> maxID <span class="type">uint</span></span><br><span class="line">err = db.Model(&amp;User&#123;&#125;).Select(<span class="string">&quot;MAX(id)&quot;</span>).Scan(&amp;maxID).Error</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Error:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新的记录</span></span><br><span class="line">nextID := maxID + <span class="number">1</span></span><br><span class="line">inputUser := User&#123;</span><br><span class="line">ID:   nextID, <span class="comment">// 手动设置下一个 ID</span></span><br><span class="line">Name: <span class="string">&quot;ppid&quot;</span>,</span><br><span class="line">Pwd:  <span class="string">&quot;123456&quot;</span>,</span><br><span class="line">Sex:  <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Print(<span class="string">&quot;输入的记录为: &quot;</span>, inputUser)</span><br><span class="line"></span><br><span class="line">db.Where(inputUser).Assign(User&#123;ID: nextID, Sex: <span class="number">2</span>&#125;).FirstOrCreate(&amp;u)</span><br><span class="line">fmt.Println(<span class="string">&quot;查询结果为: &quot;</span>, u)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>基本用法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 未找到</span></span><br><span class="line">db.FirstOrCreate(&amp;user, User&#123;Name: <span class="string">&quot;non_existing&quot;</span>&#125;)</span><br><span class="line"><span class="comment">//// INSERT INTO &quot;users&quot; (name) VALUES (&quot;non_existing&quot;);</span></span><br><span class="line"><span class="comment">//// user -&gt; User&#123;Id: 112, Name: &quot;non_existing&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到</span></span><br><span class="line">db.Where(User&#123;Name: <span class="string">&quot;Jinzhu&quot;</span>&#125;).FirstOrCreate(&amp;user)</span><br><span class="line"><span class="comment">//// user -&gt; User&#123;Id: 111, Name: &quot;Jinzhu&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------------------db.Attrs()方法-----------------------------</span></span><br><span class="line"><span class="comment">// 如果未找到，将使用参数初始化结构体，并创建一条新的记录</span></span><br><span class="line"> <span class="comment">// 未找到</span></span><br><span class="line">db.Where(User&#123;Name: <span class="string">&quot;non_existing&quot;</span>&#125;).Attrs(User&#123;Age: <span class="number">20</span>&#125;).FirstOrCreate(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name = &#x27;non_existing&#x27;;</span></span><br><span class="line"><span class="comment">//// INSERT INTO &quot;users&quot; (name, age) VALUES (&quot;non_existing&quot;, 20);</span></span><br><span class="line"><span class="comment">//// user -&gt; User&#123;Id: 112, Name: &quot;non_existing&quot;, Age: 20&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到</span></span><br><span class="line">db.Where(User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>&#125;).Attrs(User&#123;Age: <span class="number">30</span>&#125;).FirstOrCreate(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name = &#x27;jinzhu&#x27;;</span></span><br><span class="line"><span class="comment">//// user -&gt; User&#123;Id: 111, Name: &quot;jinzhu&quot;, Age: 20&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------------------db.Assign()方法------------------------------</span></span><br><span class="line"><span class="comment">// 未找到</span></span><br><span class="line">db.Where(User&#123;Name: <span class="string">&quot;non_existing&quot;</span>&#125;).Assign(User&#123;Age: <span class="number">20</span>&#125;).FirstOrCreate(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name = &#x27;non_existing&#x27;;</span></span><br><span class="line"><span class="comment">//// INSERT INTO &quot;users&quot; (name, age) VALUES (&quot;non_existing&quot;, 20);</span></span><br><span class="line"><span class="comment">//// user -&gt; User&#123;Id: 112, Name: &quot;non_existing&quot;, Age: 20&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到</span></span><br><span class="line">db.Where(User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>&#125;).Assign(User&#123;Age: <span class="number">30</span>&#125;).FirstOrCreate(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name = &#x27;jinzhu&#x27;;</span></span><br><span class="line"><span class="comment">//// UPDATE users SET age=30 WHERE id = 111;</span></span><br><span class="line"><span class="comment">//// user -&gt; User&#123;Id: 111, Name: &quot;jinzhu&quot;, Age: 30&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="高级查询">高级查询</h4><blockquote><p>这里补充说下COALESCES()的用法，用一句话来说就是COALESCES(expr1, expr2, expr3,…), 这个函数就是用来返回从左到右的第一个非NULL表达式的值。<br><a href="https://blog.csdn.net/weixin_38750084/article/details/83034294">函数：COALESCE()</a></p></blockquote><h5 id="选择字段查询">选择字段查询</h5><p>使用Select()方法可以选择需要查询的字段，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> us User</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 1.直接指定字段</span></span><br><span class="line">db.Select(<span class="string">&quot;name, email&quot;</span>).Where(<span class="string">&quot;id = 4&quot;</span>).Find(&amp;us)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;查询结果为: &quot;</span>, us)</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 这样查询完后输出&#123;0 Dave dave@example.com  0&#125;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 2.使用切片指定字段</span></span><br><span class="line"> db.Select([]<span class="type">string</span>&#123;<span class="string">&quot;name&quot;</span>, <span class="string">&quot;email&quot;</span>&#125;).Where(<span class="string">&quot;id = 3&quot;</span>).Find(&amp;us)</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 3.指定表格</span></span><br><span class="line"> db.Table(<span class="string">&quot;user&quot;</span>).Select(<span class="string">&quot;name, email&quot;</span>).Where(<span class="string">&quot;id = 2&quot;</span>).Find(&amp;us)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="排序Order">排序Order()</h5><p>Order()方法的定义:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Order(value <span class="keyword">interface</span>&#123;&#125;, reorder ...<span class="type">bool</span>) *DB</span><br></pre></td></tr></table></figure><p>Order，指定从数据库中检索出记录的顺序。设置第二个参数 reorder 为 true ，可以覆盖前面定义的排序条件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单字段排序</span></span><br><span class="line">db.Order(<span class="string">&quot;sex desc&quot;</span>).Find(&amp;us)</span><br><span class="line"><span class="comment">// 对应的sql语句是: SELECT * FROM user OREDER BY sex DESC</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多字段排序</span></span><br><span class="line">db.Order(<span class="string">&quot;sex desc, name&quot;</span>).Find(&amp;us)</span><br><span class="line">db.Order(<span class="string">&quot;sex desc&quot;</span>).Order(<span class="string">&quot;name&quot;</span>).Find(&amp;us)</span><br><span class="line"><span class="comment">// 对应的sql语句是: SELECT * FROM `user` ORDER BY sex desc, name</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="Limit">Limit()</h5><p>作用： 指定从数据库检索出的最大记录数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db.Order(<span class="string">&quot;sex desc&quot;</span>).Limit(<span class="number">3</span>).Find(&amp;us)</span><br><span class="line"><span class="comment">// 对应的sql语句是: SELECT * FROM user ORDER BY sex DESC LIMIT 3</span></span><br><span class="line"><span class="comment">// 此时指挥输出三条记录</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当参数为-1的时候，表示取消之前的limit条件</span></span><br><span class="line">db.Limit(<span class="number">3</span>).Find(&amp;users1).Limit(<span class="number">-1</span>).Find(&amp;users2)</span><br></pre></td></tr></table></figure><h5 id="Offset">Offset()</h5><p>作用： 指定从数据库检索出的记录的起始位置（指定开始返回记录前要跳过的记录数。）, 一般配合Limit()方法一起使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例如有如下需求：查找入职员工时间排名倒数第三的员工所有信息</span></span><br><span class="line"><span class="comment">// 原生的sql语句是: 1. SELECT * FROM employees ORDER BY hire_date DESC Limit 1 OFFSET 2; </span></span><br><span class="line">db.Order(<span class="string">&quot;hire_date desc&quot;</span>).Limit(<span class="number">1</span>).Offset(<span class="number">2</span>).Find(&amp;employee)</span><br><span class="line"><span class="comment">// 其作用就是去掉前两个值，只返回第三个值。</span></span><br><span class="line"><span class="comment">// 也可以这样写：2. SELECT * FROM employees ORDER BY hire_date DESC LIMIT 2, 1;</span></span><br></pre></td></tr></table></figure><h5 id="Count">Count()</h5><p>获取记录总数</p><ul><li><strong>注意</strong>：使用的时候必须放到.Find()方法之后，否则不会执行查询操作。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> count <span class="type">int64</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 例如获取性别为男（2）的用户总</span></span><br><span class="line">db.Where(<span class="string">&quot;sex = ?&quot;</span>, <span class="number">2</span>).Find(&amp;users).Count(&amp;count)</span><br><span class="line"> <span class="comment">// 对应的sql语句是: SELECT COUNT(*) FROM user WHERE sex = 2;</span></span><br><span class="line"></span><br><span class="line">db.Table(<span class="string">&quot;user&quot;</span>).Count(&amp;count)</span><br><span class="line"> <span class="comment">// 对应的sql语句是: SELECT COUNT(*) FROM user;</span></span><br><span class="line"></span><br><span class="line">db.Table(<span class="string">&quot;user&quot;</span>).Select(<span class="string">&quot;count(pwd)&quot;</span>).Count(&amp;count)</span><br><span class="line"> <span class="comment">// 对应的sql语句是: SELECT COUNT(pwd) FROM user;</span></span><br><span class="line"></span><br><span class="line">db.Model(&amp;User&#123;&#125;).Count(&amp;count)</span><br><span class="line"> <span class="comment">// 对应的sql语句是: SELECT COUNT(*) FROM user;</span></span><br></pre></td></tr></table></figure><ul><li><strong>注意</strong>： Count 必须是链式查询的最后一个操作 ，因为它会覆盖前面的 SELECT，但如果里面使用了 count 时不会覆盖</li></ul><h5 id="Group-Having">Group &amp; Having</h5><p>作用： 用于分组和过滤数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.请编写 SQL 查询，找出每个部门的总薪资，并只返回总薪资超过 50000 的部门名称和总薪资。</span></span><br><span class="line"><span class="comment">// 2.结果需要按照总薪资从高到低排序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 首先是sql语句: </span></span><br><span class="line"><span class="comment">SELECT department, SUM(salary) AS total_salary FROM employees GROUP BY department HAVING total_salary &gt; 50000 ORDER BY total_salary DESC;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后是Gorm的写法:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> emp []<span class="keyword">struct</span> &#123;</span><br><span class="line">Department   <span class="type">string</span></span><br><span class="line">Total_salary <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> employee []employees.Employee</span><br><span class="line">db.Table(<span class="string">&quot;employees&quot;</span>).Find(&amp;employee)</span><br><span class="line">fmt.Println(<span class="string">&quot;员工数据:&quot;</span>, employee)</span><br><span class="line"></span><br><span class="line">db.Table(<span class="string">&quot;employees&quot;</span>).Select(<span class="string">&quot;department, SUM(salary) as total_salary&quot;</span>).Group(<span class="string">&quot;department&quot;</span>).Having(<span class="string">&quot;total_salary &gt; ?&quot;</span>, <span class="number">50000</span>).Order(<span class="string">&quot;total_salary DESC&quot;</span>).Scan(&amp;emp)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;查询结果为: &quot;</span>, emp)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="Joins">Joins</h5><p>作用： 用于连接多个表。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">rows, err := db.Table(<span class="string">&quot;employees&quot;</span>).Joins(<span class="string">&quot;INNER JOIN user ON employees.id = user.id&quot;</span>).Where(<span class="string">&quot;user.name = ?&quot;</span>, <span class="string">&quot;Alice&quot;</span>).Or(<span class="string">&quot;user.name = ?&quot;</span>, <span class="string">&quot;Bob&quot;</span>).Rows()</span><br><span class="line"> <span class="comment">// 对应的sql语句是: SELECT * FROM employees INNER JOIN user ON employees.id = user.id WHERE user.name = &#x27;Alice&#x27; OR user.name = &#x27;Bob&#x27;;</span></span><br><span class="line"> <span class="comment">// 也可以是left join right join</span></span><br><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line"><span class="keyword">var</span> e employees.Employee</span><br><span class="line">db.ScanRows(rows, &amp;e)</span><br><span class="line">employee = <span class="built_in">append</span>(employee, e)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;员工数据:&quot;</span>, employee)</span><br></pre></td></tr></table></figure><h5 id="Pluck">Pluck</h5><p>Pluck，查询 model 中的<strong>一个列作为切片</strong>，如果您想要查询多个列，您应该使用 Scan</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 GORM 查询用户</span></span><br><span class="line"><span class="keyword">var</span> uu []user.User</span><br><span class="line"><span class="keyword">var</span> names []<span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行查找并提取名字</span></span><br><span class="line">db.Model(&amp;uu).Pluck(<span class="string">&quot;name&quot;</span>, &amp;names)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;查询结果为: &quot;</span>, names)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行查找并提取名字</span></span><br><span class="line">db.Table(<span class="string">&quot;user&quot;</span>).Pluck(<span class="string">&quot;name&quot;</span>, &amp;names)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 想查询多个字段？ 这样做：</span></span><br><span class="line">  db.Select(<span class="string">&quot;name, age&quot;</span>).Find(&amp;users)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="Scan">Scan</h5><p>Scan 扫描结果至一个struct</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Result <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">  Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result Result</span><br><span class="line">db.Table(<span class="string">&quot;users&quot;</span>).Select(<span class="string">&quot;name, age&quot;</span>).Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;Antonio&quot;</span>).Scan(&amp;result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> results []Result</span><br><span class="line">db.Table(<span class="string">&quot;users&quot;</span>).Select(<span class="string">&quot;name, age&quot;</span>).Where(<span class="string">&quot;id &gt; ?&quot;</span>, <span class="number">0</span>).Scan(&amp;results)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原生 SQL</span></span><br><span class="line">db.Raw(<span class="string">&quot;SELECT name, age FROM users WHERE name = ?&quot;</span>, <span class="string">&quot;Antonio&quot;</span>).Scan(&amp;result)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="链式操作相关">链式操作相关</h3><h4 id="链式操作">链式操作</h4><p>在调用立即执行方法前不会调用Query语句, 所以你可以用链式操作来构造复杂的查询条件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链式操作</span></span><br><span class="line">tx := db.Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;Alice&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加更多查询条件</span></span><br><span class="line"><span class="keyword">if</span> flag := <span class="literal">true</span>; flag &#123;</span><br><span class="line">tx = tx.Where(<span class="string">&quot;sex = ?&quot;</span>, <span class="string">&quot;男&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">tx = tx.Where(<span class="string">&quot;sex = ?&quot;</span>, <span class="string">&quot;女&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> f := <span class="literal">true</span>; f &#123;</span><br><span class="line">tx = tx.Where(<span class="string">&quot;Addr = ?&quot;</span>, <span class="string">&quot;中国&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result := tx.Find(&amp;uu)</span><br></pre></td></tr></table></figure><h4 id="立即执行方法">立即执行方法</h4><p>立即执行方法指的是会立马执行Query语句，并返回结果。常见的立即执行方法有：<br><code>Create</code>, <code>First</code>, <code>Find</code>, <code>Scan</code>, <code>Delete</code>, <code>Update</code>, <code>Save</code>等。</p><h4 id="范围">范围</h4><p><code>Scopes</code> , 此方法是建立在链式操作的基础之上的，基于它，可以抽取一些通用逻辑，写出更多的可重用函数库。例如: 你可以把查询超过1000的或者表示已付款的查询逻辑封装成一个函数，之后需要用到的时候，使用<code>Scopes</code>方法来调用即可</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AgeBiggerThan18</span><span class="params">(db *gorm.DB)</span></span> *gorm.DB &#123;</span><br><span class="line"><span class="keyword">return</span> db.Where(<span class="string">&quot;age &gt; 18&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 数据库连接信息</span></span><br><span class="line">dsn := <span class="string">&quot;root:123456@(localhost:3306)/db1?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;</span></span><br><span class="line"><span class="comment">// 连接数据库</span></span><br><span class="line">db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">&quot;failed to connect to database: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">db = db.Debug()</span><br><span class="line">  <span class="comment">// 使用Scope方法调用</span></span><br><span class="line">  tx = tx.Scopes(AgeBiggerThan18)</span><br><span class="line">  result := tx.Find(&amp;uu)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多个立即执行方法">多个立即执行方法</h4><p>在 GORM 中使用多个立即执行方法时，后一个立即执行方法会复用前一个立即执行方法的条件 (不包括内联条件) 。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.Where(<span class="string">&quot;name LIKE ?&quot;</span>, <span class="string">&quot;jinzhu%&quot;</span>).Find(&amp;users, <span class="string">&quot;id IN (?)&quot;</span>, []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;).Count(&amp;count)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>生成的sql语句是这样的:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;jinzhu%&#x27;</span> <span class="keyword">AND</span> id <span class="keyword">IN</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;jinzhu%&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="更新">更新</h3><h4 id="更新所有字段">更新所有字段</h4><p><code>save()</code> 默认会更新该对象的所有字段，即使你没有赋值</p><h5 id="如果数据库中有字段-就会执行UPDATE语句">如果数据库中有字段 就会执行UPDATE语句</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> uu[<span class="number">0</span>].Age = <span class="number">40</span></span><br><span class="line">uu[<span class="number">0</span>].Sex = <span class="string">&quot;女&quot;</span></span><br><span class="line">uu[<span class="number">0</span>].Addr = <span class="string">&quot;北京&quot;</span></span><br><span class="line"></span><br><span class="line">db.Save(&amp;uu[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p>对应的sql语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> `people` <span class="keyword">SET</span> `name`<span class="operator">=</span><span class="string">&#x27;Alice&#x27;</span>,`age`<span class="operator">=</span><span class="number">40</span>,`sex`<span class="operator">=</span><span class="string">&#x27;女&#x27;</span>,`addr`<span class="operator">=</span><span class="string">&#x27;北京&#x27;</span> <span class="keyword">WHERE</span> `id` <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h5 id="如果数据库中没有字段，就会执行INSERT语句">如果数据库中没有字段，就会执行INSERT语句</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">u := people.People&#123;</span><br><span class="line">Name: <span class="string">&quot;Xiaoming&quot;</span>,</span><br><span class="line">Age:  <span class="number">20</span>,</span><br><span class="line">Sex:  <span class="string">&quot;男&quot;</span>,</span><br><span class="line">Addr: <span class="string">&quot;北京&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">db.Save(&amp;u)</span><br></pre></td></tr></table></figure><p>对应的sql语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `people` (`name`,`age`,`sex`,`addr`) <span class="keyword">VALUES</span> (<span class="string">&#x27;Xiaoming&#x27;</span>,<span class="number">20</span>,<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;北京&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="更新指定字段">更新指定字段</h4><p>可以使用<code>Updates</code>或者<code>Update</code>方法来更新指定字段</p><p>这两的区别是 前者用来更新多个字段，后者只能用于更新单个字段,前者需要用map或者结构体来更新</p><p>使用的时候需要注意，在sql语法中 update确实在Where之前，但是在Gorm中，Update一定得放在之后，因为Update属于立即执行方法，Where则不是，立即执行方法得放在最后</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> db.Model(&amp;people.People&#123;&#125;).Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;Alice&quot;</span>).Update(<span class="string">&quot;age&quot;</span>, <span class="number">18</span>)</span><br><span class="line"></span><br><span class="line">db.Model(&amp;people.People&#123;&#125;).Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;Bob&quot;</span>).Updates(people.People&#123;Age: <span class="number">18</span>, Sex: <span class="string">&quot;女&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 警告：当使用 struct 更新时，GORM只会更新那些非零值的字段</span></span><br><span class="line"> <span class="comment">// 对于下面的操作，不会发生任何更新，&quot;&quot;, 0, false 都是其类型的零值</span></span><br><span class="line"> db.Model(&amp;user).Updates(User&#123;Name: <span class="string">&quot;&quot;</span>, Age: <span class="number">0</span>, Active: <span class="literal">false</span>&#125;)</span><br></pre></td></tr></table></figure><p>对应的sql语句是</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> `people` <span class="keyword">SET</span> `age` <span class="operator">=</span> <span class="number">18</span> <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Alice&#x27;</span></span><br><span class="line"><span class="keyword">UPDATE</span> people <span class="keyword">SET</span> age <span class="operator">=</span> <span class="number">38</span> <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Alice&#x27;</span> 不加``符号也能运行</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> `people` <span class="keyword">SET</span> `age`<span class="operator">=</span><span class="number">18</span>,`sex`<span class="operator">=</span><span class="string">&#x27;女&#x27;</span> <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Bob&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="更新选定字段">更新选定字段</h4><p>如果你想更新或忽略某些字段，你可以使用<code>Select</code>，<code>Omit</code>方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用来忽略某个字段</span></span><br><span class="line">db.Model(&amp;people.People&#123;&#125;).Omit(<span class="string">&quot;name&quot;</span>).Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;xiaoming&quot;</span>).Updates(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">12</span>&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 对应的<span class="keyword">SQL</span>语句</span><br><span class="line"><span class="keyword">UPDATE</span> `people` <span class="keyword">SET</span> `age`<span class="operator">=</span><span class="number">12</span> <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;xiaoming&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="批量更新">批量更新</h4><p>可以一次性更新多个记录的某些字段为相同的值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.Model(&amp;people.People&#123;&#125;).Where(<span class="string">&quot;ID in (?)&quot;</span>, []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;).Updates(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">12</span>&#125;)</span><br><span class="line"><span class="comment">// 对应的SQL语句</span></span><br><span class="line">UPDATE <span class="string">`people`</span> SET <span class="string">`name`</span>=<span class="string">&#x27;hello&#x27;</span>,<span class="string">`age`</span>=<span class="number">12</span> WHERE <span class="string">`id`</span> IN (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="使用sql表达式更新">使用sql表达式更新</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.Model(&amp;people.People&#123;&#125;).Where(<span class="string">&quot;ID = ?&quot;</span>, <span class="number">1</span>).Update(<span class="string">&quot;age&quot;</span>, gorm.Expr(<span class="string">&quot;age * ? + ?&quot;</span>, <span class="number">2</span>, <span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对应的SQL语句</span></span><br><span class="line">UPDATE <span class="string">`people`</span> SET <span class="string">`age`</span>=age * <span class="number">2</span> + <span class="number">10</span> WHERE <span class="string">`id`</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="删除">删除</h3><h4 id="删除记录">删除记录</h4><p><strong>注意:</strong> 删除记录时，请确保主键字段有值，GORM 会通过主键去删除记录，如果主键为空，GORM 会删除该 model 的所有记录。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.Delete(&amp;people.People&#123;&#125;, <span class="string">&quot;id = ?&quot;</span>, <span class="string">&quot;3&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为删除 SQL 添加额外的 SQL 操作</span></span><br><span class="line">db.Set(<span class="string">&quot;gorm:delete_option&quot;</span>, <span class="string">&quot;OPTION (OPTIMIZE FOR UNKNOWN)&quot;</span>).Delete(&amp;email)</span><br><span class="line"><span class="comment">//// DELETE from emails where id=10 OPTION (OPTIMIZE FOR UNKNOWN);</span></span><br></pre></td></tr></table></figure><h4 id="批量删除">批量删除</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db.Where(<span class="string">&quot;email LIKE ?&quot;</span>, <span class="string">&quot;%haohao%&quot;</span>).Delete(Email&#123;&#125;)</span><br><span class="line"><span class="comment">//// DELETE from emails where email LIKE &quot;%haohao%&quot;;</span></span><br><span class="line"></span><br><span class="line">db.Delete(Email&#123;&#125;, <span class="string">&quot;email LIKE ?&quot;</span>, <span class="string">&quot;%jinzhu%&quot;</span>)</span><br><span class="line"><span class="comment">//// DELETE from emails where email LIKE &quot;%jinzhu%&quot;;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="事务">事务</h3><p>事务在实际的项目中非常的有用，那么在gorm中它是如何使用的呢？</p><h4 id="禁用默认事务">禁用默认事务</h4><p>为了确保数据一致性，GORM 会在事务里执行写入操作（创建、更新、删除）。如果没有这方面的要求，您可以在初始化时禁用它，这将获得大约 30%+ 性能提升。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局禁用</span></span><br><span class="line">db, err := gorm.Open(sqlite.Open(<span class="string">&quot;gorm.db&quot;</span>), &amp;gorm.Config&#123;</span><br><span class="line">  SkipDefaultTransaction: <span class="literal">true</span>, <span class="comment">//&lt;=</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 持续会话模式</span></span><br><span class="line">tx := db.Session(&amp;Session&#123;SkipDefaultTransaction: <span class="literal">true</span>&#125;)</span><br><span class="line">tx.First(&amp;user, <span class="number">1</span>)</span><br><span class="line">tx.Find(&amp;users)</span><br><span class="line">tx.Model(&amp;user).Update(<span class="string">&quot;Age&quot;</span>, <span class="number">18</span>)</span><br></pre></td></tr></table></figure><h4 id="Gorm手动控制事务">Gorm手动控制事务</h4><h5 id="事务的执行流程">事务的执行流程</h5><p>要在事务中执行一系列操作，通常您可以参照下面的流程来执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">db.Transaction(<span class="function"><span class="keyword">func</span><span class="params">(tx *gorm.DB)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">  <span class="comment">// 在事务中执行一些 db 操作（从这里开始，您应该使用 &#x27;tx&#x27; 而不是 &#x27;db&#x27;）</span></span><br><span class="line">  <span class="keyword">if</span> err := tx.Create(&amp;Animal&#123;Name: <span class="string">&quot;Giraffe&quot;</span>&#125;).Error; err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="comment">// 返回任何错误都会回滚事务</span></span><br><span class="line">  <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> err := tx.Create(&amp;Animal&#123;Name: <span class="string">&quot;Lion&quot;</span>&#125;).Error; err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回 nil 提交事务</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="手动控制事务">手动控制事务</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开启事务</span></span><br><span class="line">tx := db.Begin()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在事务中做一些数据库操作 (这里应该使用 &#x27;tx&#x27; ，而不是 &#x27;db&#x27;)</span></span><br><span class="line"></span><br><span class="line">tx.Create(...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果有错误就手动回滚</span></span><br><span class="line"></span><br><span class="line">tx.Rollback()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果无错误就提交事务</span></span><br><span class="line"></span><br><span class="line">tx.Commit()</span><br></pre></td></tr></table></figure><p>例子：结合gin框架使用事务来执行银行转账</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Transaction</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;project/models&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line"><span class="string">&quot;gorm.io/gorm&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TransactionController <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(con TransactionController)</span></span> Transfer(c *gin.Context) &#123;</span><br><span class="line"><span class="comment">// 开启事务</span></span><br><span class="line">tx := models.DB.Begin()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确保在函数结束时回滚事务（如果需要）</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">tx.Rollback()</span><br><span class="line">c.JSON(<span class="number">400</span>, gin.H&#123;</span><br><span class="line"><span class="string">&quot;success&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="string">&quot;error&quot;</span>:   <span class="string">&quot;余额不足&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> tx.Error != <span class="literal">nil</span> &#123;</span><br><span class="line">tx.Rollback()</span><br><span class="line">c.JSON(<span class="number">500</span>, gin.H&#123;</span><br><span class="line"><span class="string">&quot;success&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="string">&quot;error&quot;</span>:   tx.Error.Error(),</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义用户余额结构体</span></span><br><span class="line"><span class="keyword">var</span> user1, user2 models.Balance</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询小明的账户余额</span></span><br><span class="line"><span class="keyword">if</span> err := tx.Table(<span class="string">&quot;balance&quot;</span>).Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;小明&quot;</span>).First(&amp;user1).Error; err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err == gorm.ErrRecordNotFound &#123;</span><br><span class="line">c.JSON(<span class="number">404</span>, gin.H&#123;</span><br><span class="line"><span class="string">&quot;success&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="string">&quot;error&quot;</span>:   <span class="string">&quot;小明的账户未找到&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">c.JSON(<span class="number">500</span>, gin.H&#123;</span><br><span class="line"><span class="string">&quot;success&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="string">&quot;error&quot;</span>:   err.Error(),</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">tx.Rollback()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询Alice的账户余额</span></span><br><span class="line"><span class="keyword">if</span> err := tx.Table(<span class="string">&quot;balance&quot;</span>).Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;Alice&quot;</span>).First(&amp;user2).Error; err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err == gorm.ErrRecordNotFound &#123;</span><br><span class="line">c.JSON(<span class="number">404</span>, gin.H&#123;</span><br><span class="line"><span class="string">&quot;success&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="string">&quot;error&quot;</span>:   <span class="string">&quot;Alice的账户未找到&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">c.JSON(<span class="number">500</span>, gin.H&#123;</span><br><span class="line"><span class="string">&quot;success&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="string">&quot;error&quot;</span>:   err.Error(),</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">tx.Rollback()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查小明的余额是否足够</span></span><br><span class="line"><span class="keyword">if</span> user1.Money &lt; <span class="number">2000</span> &#123;</span><br><span class="line">c.JSON(<span class="number">400</span>, gin.H&#123;</span><br><span class="line"><span class="string">&quot;success&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="string">&quot;error&quot;</span>:   <span class="string">&quot;余额不足&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">tx.Rollback()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新小明的账户余额</span></span><br><span class="line">user1.Money -= <span class="number">2000</span></span><br><span class="line"><span class="keyword">if</span> err := tx.Save(&amp;user1).Error; err != <span class="literal">nil</span> &#123;</span><br><span class="line">c.JSON(<span class="number">500</span>, gin.H&#123;</span><br><span class="line"><span class="string">&quot;success&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="string">&quot;error&quot;</span>:   err.Error(),</span><br><span class="line">&#125;)</span><br><span class="line">tx.Rollback()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新Alice的账户余额</span></span><br><span class="line">user2.Money += <span class="number">2000</span></span><br><span class="line"><span class="keyword">if</span> err := tx.Save(&amp;user2).Error; err != <span class="literal">nil</span> &#123;</span><br><span class="line">c.JSON(<span class="number">500</span>, gin.H&#123;</span><br><span class="line"><span class="string">&quot;success&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="string">&quot;error&quot;</span>:   err.Error(),</span><br><span class="line">&#125;)</span><br><span class="line">tx.Rollback()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交事务</span></span><br><span class="line">tx.Commit()</span><br><span class="line"></span><br><span class="line">c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line"><span class="string">&quot;success&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>其中可以使用Find().Error来获取错误码。然后根据错误码来判断是否需要回滚</li></ul>]]></content>
    
    
    <summary type="html">本文描述的是go的gorm框架的使用</summary>
    
    
    
    <category term="go" scheme="https://pigcanstudy.github.io/categories/go/"/>
    
    <category term="Gorm" scheme="https://pigcanstudy.github.io/categories/go/Gorm/"/>
    
    
    <category term="go" scheme="https://pigcanstudy.github.io/tags/go/"/>
    
    <category term="Gorm" scheme="https://pigcanstudy.github.io/tags/Gorm/"/>
    
  </entry>
  
  <entry>
    <title>go底层知识</title>
    <link href="https://pigcanstudy.github.io/posts/86dbdeb6.html"/>
    <id>https://pigcanstudy.github.io/posts/86dbdeb6.html</id>
    <published>2024-11-29T09:25:45.000Z</published>
    <updated>2024-11-29T10:47:30.946Z</updated>
    
    <content type="html"><![CDATA[<h1>目录</h1><ul><li><a href="#%E7%9B%AE%E5%BD%95">目录</a><ul><li><a href="#go%E7%9A%84%E5%BA%95%E5%B1%82%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86">go的底层相关知识</a><ul><li><a href="#go%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F">go的类型系统</a></li><li><a href="#%E7%B1%BB%E5%9E%8B%E5%85%83%E6%95%B0%E6%8D%AE">类型元数据</a></li><li><a href="#go%E6%8E%A5%E5%8F%A3%E5%BA%95%E5%B1%82">go接口底层</a><ul><li><a href="#%E7%A9%BA%E6%8E%A5%E5%8F%A3%E5%BA%95%E5%B1%82">空接口底层</a></li><li><a href="#%E9%9D%9E%E7%A9%BA%E6%8E%A5%E5%8F%A3%E5%BA%95%E5%B1%82">非空接口底层</a></li></ul></li><li><a href="#%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84">类型断言是如何工作的</a></li><li><a href="#go%E7%9A%84%E5%A0%86%E6%A0%88%E5%92%8C%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90">go的堆栈和逃逸分析</a><ul><li><a href="#%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90">逃逸分析</a><ul><li><a href="#%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99">逃逸分析的基本原则</a></li><li><a href="#%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E4%B8%BE%E4%BE%8B">逃逸分析举例</a></li></ul></li></ul></li><li><a href="#go%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2">go的字符串</a></li><li><a href="#go%E7%9A%84%E5%88%87%E7%89%87%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0">go的切片底层实现</a><ul><li><a href="#118%E4%B9%8B%E5%89%8D%E7%9A%84%E6%89%A9%E5%AE%B9%E8%A7%84%E5%88%99">1.18之前的扩容规则</a></li><li><a href="#118%E4%B9%8B%E5%90%8E%E7%9A%84%E6%89%A9%E5%AE%B9%E8%A7%84%E5%88%99">1.18之后的扩容规则</a></li></ul></li><li><a href="#go%E7%9A%84map%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86">go的map底层原理</a><ul><li><a href="#go-map%E7%9A%84%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89">go map的结构定义</a><ul><li><a href="#tophash%E4%BD%9C%E4%B8%BA%E7%8A%B6%E6%80%81%E4%BD%8D">tophash作为状态位</a></li><li><a href="#hmap">hmap</a></li><li><a href="#go-map%E6%89%A9%E5%AE%B9%E8%A7%84%E5%88%99">go map扩容规则</a><ul><li><a href="#%E7%BF%BB%E5%80%8D%E6%89%A9%E5%AE%B9">翻倍扩容</a></li><li><a href="#%E7%AD%89%E9%87%8F%E6%89%A9%E5%AE%B9">等量扩容</a></li></ul></li></ul></li></ul></li><li><a href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88">函数调用栈</a></li><li><a href="#%E9%97%AD%E5%8C%85%E5%BA%95%E5%B1%82">闭包底层</a><ul><li><a href="#%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0">闭包函数</a></li></ul></li></ul></li></ul></li></ul><h2 id="go的底层相关知识">go的底层相关知识</h2><h3 id="go的类型系统">go的类型系统</h3><ul><li>首先<strong>接口类型是无效的方法接收者</strong>，要理解这句话就要知道什么是<strong>方法？</strong>，<strong>方法是与特定类型关联的函数</strong>，那什么是方法接收者，方法接收者：<strong>方法有一个接收者（receiver），它指定了这个方法属于哪个类型。</strong></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Person 就是方法接受者， 这就是定义了Person结构体的一种方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> SayHello() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello, my name is&quot;</span>, p.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>理解方法接收者后，因为接口他只是定义了方法，本身不能实现方法，也就不能作为<strong>方法接收者</strong></li></ul><h3 id="类型元数据">类型元数据</h3><ul><li>不管是自定义类型还是内置类型，都有相应的类型元数据，类型元数据用来记录一些信息，例如：类型名称，大小，类型边界 等信息<br>所以底层会有一个_type结构体来存储类型元数据，其结构体如下：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> _type <span class="keyword">struct</span> &#123;</span><br><span class="line">    size       <span class="type">uintptr</span> <span class="comment">// 类型大小</span></span><br><span class="line">    ptrdata    <span class="type">uintptr</span> <span class="comment">// 指针大小</span></span><br><span class="line">    hash       <span class="type">uint32</span>  <span class="comment">// 哈希值</span></span><br><span class="line">    tflag      tflag   <span class="comment">// 类型标志</span></span><br><span class="line">    align      <span class="type">uint8</span>   <span class="comment">// 对齐</span></span><br><span class="line">    fieldalign <span class="type">uint8</span>   <span class="comment">// 字段对齐</span></span><br><span class="line">    kind       <span class="type">uint8</span>   <span class="comment">// 类型种类</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的信息作为元数据的头部，其下面还会有一些其他的描述数据，例如切片元数据的类型元数据结构如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slicetype <span class="keyword">struct</span> &#123;</span><br><span class="line">    typ _type</span><br><span class="line">    elem *_type <span class="comment">// 切片元素类型,指向的是切片存储类型的类型元数据（例如stringtype，inttype等等）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>elem就是其中一种描述数据</p><ul><li><strong>对于自定义类型来说</strong>，其类型还会有一个uncommontype结构体字段，其结构体如下：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> uncommontype <span class="keyword">struct</span> &#123;</span><br><span class="line">    pkgpath nameoff <span class="comment">// 包路径</span></span><br><span class="line">    mcount <span class="type">uint16</span>   <span class="comment">// 方法数量</span></span><br><span class="line">    xcount <span class="type">uint16</span>   <span class="comment">// 字段数量</span></span><br><span class="line">    moff   <span class="type">uint32</span>   <span class="comment">// 方法列表偏移值</span></span><br><span class="line">    _      <span class="type">uint32</span>   <span class="comment">// 未使用</span></span><br><span class="line">    _      <span class="type">uint32</span>   <span class="comment">// 未使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细讲讲方法列表偏移值的作用，这个偏移值就是uncommontype结构体的moff字段，加上uncommontype的地址就是方法列表所在位置,如图<br><img src="../assets/2024-11-29-go%E5%BA%95%E5%B1%82%E7%9F%A5%E8%AF%86/image-1.png" alt="alt text"></p><ul><li>type 的两种不同用法的区别：</li></ul><p><img src="../assets/2024-11-29-go%E5%BA%95%E5%B1%82%E7%9F%A5%E8%AF%86/image-2.png" alt="alt text"></p><h3 id="go接口底层">go接口底层</h3><h4 id="空接口底层">空接口底层</h4><ul><li>因为空接口可以指向任意类型，所以在底层只需要知道指向的地址在哪，以及指向的是什么类型就行，所以其底层大概如下：<br><img src="../assets/2024-11-29-go%E5%BA%95%E5%B1%82%E7%9F%A5%E8%AF%86/image-3.png" alt="alt text"></li><li>赋值前后的变化：<ol><li>赋值前：两个字段都是nil<br><img src="../assets/2024-11-29-go%E5%BA%95%E5%B1%82%E7%9F%A5%E8%AF%86/image-4.png" alt="alt text"></li><li>赋值后：data字段指向实际地址，_type执行类型元数据<br><img src="../assets/2024-11-29-go%E5%BA%95%E5%B1%82%E7%9F%A5%E8%AF%86/image-5.png" alt="alt text"></li></ol></li></ul><h4 id="非空接口底层">非空接口底层</h4><ul><li><p>非空接口（有方法的接口）底层的结构如下：<br><img src="../assets/2024-11-29-go%E5%BA%95%E5%B1%82%E7%9F%A5%E8%AF%86/image-6.png" alt="alt text"></p></li><li><p>非空接口赋值前后的变化：</p><ol><li>赋值前：两个字段都是nil</li><li>赋值后：<br><img src="../assets/2024-11-29-go%E5%BA%95%E5%B1%82%E7%9F%A5%E8%AF%86/image-7.png" alt="alt text"><br>对上图的解释：<br>首先<strong>data字段就是指向实际的地址</strong>，<strong>tab字段就是接口的相关信息</strong>，从上到下分别是<strong>inter（指向的是对应接口类型的元数据）</strong><br><strong>_type(指向*os.File类型元数据)，hash为快速判断是否相等的哈希值，然后是两个空接口的字段，分别是两个空接口的类型元数据及hash值，hash是用来快速判断是否相等。</strong><br><strong>fun则是一个数字，里面存的是拷贝过来的方法，这样就不需要反复去元数据中查找了，并且能快速定位到方法</strong><br><strong>其次对于itab只要知道了inter和_type就知道了itab的类型，也就是说inter和_type可以唯一确定一个itab，因此在底层有缓存机制</strong><br>在go中会把用到的itab结构体缓存起来，并且创建以接口类型和动态类型为key，指向itab的指针为值的哈希表，需要itab时会首先在这个哈希表（接口类型哈希值与动态类型哈希值进行异或得到哈希表的哈希值）中查找，没有的话就创建一个itab结构体并加入到哈希表中</li></ol></li></ul><h3 id="类型断言是如何工作的">类型断言是如何工作的</h3><h3 id="go的堆栈和逃逸分析">go的堆栈和逃逸分析</h3><blockquote><p><a href="https://zhuanlan.zhihu.com/p/586249256">go的堆栈和逃逸分析详解</a></p><p>相比于把内存分配到堆中，分配到栈中优势更明显。Go语言也是这么做的：Go编译器会尽可能将变量分配到到栈上。但是，当编译器无法证明函数返回的变量有没有被引用时，编译器就必须在堆上分配该变量，以此避免悬挂指针（dangling pointer）的问题。另外，如果局部变量占用内存非常大，也会将其分配在堆上。</p></blockquote><p><strong>问题：go是如何确定内存是分配到栈上还是堆上？</strong></p><p><strong>答案：逃逸分析</strong></p><h4 id="逃逸分析">逃逸分析</h4><ul><li>什么是逃逸分析：<em><strong>编译器通过逃逸分析技术去选择堆或者栈，逃逸分析的基本思想如下：检查变量的生命周期是否是完全可知的，如果通过检查，则在栈上分配。否则，就是所谓的逃逸，必须在堆上进行分配。</strong></em></li></ul><h5 id="逃逸分析的基本原则">逃逸分析的基本原则</h5><ul><li>不同于JAVA JVM的运行时逃逸分析，Go的逃逸分析是在<strong>编译期</strong>完成的：编译期无法确定的参数类型<strong>必定</strong>放到堆中；</li><li>如果变量在函数<strong>外部存在引用</strong>，则<strong>必定</strong>放在堆中；</li><li>如果变量占用<strong>内存较大</strong>时，则<strong>优先</strong>放到堆中；</li><li>如果变量在函数外部<strong>没有引用</strong>，则优先放到<strong>栈</strong>中；</li></ul><h5 id="逃逸分析举例">逃逸分析举例</h5><p>我们使用这个命令来查看逃逸分析的结果： go build -gcflags ‘-m -m -l’</p><ol><li>参数类型是interface类型</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pacakge main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="number">666</span></span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p>这段代码就输出了 a escapes to heap</p><p><strong>原因分析</strong><br>因为Println的参数类型是interface，编译器无法确定它的具体类型，因此必须在堆上分配。</p><ol start="2"><li>变量在外部存在引用</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> *<span class="type">int</span> &#123;</span><br><span class="line">    a := <span class="number">6</span></span><br><span class="line">    <span class="keyword">return</span> &amp;a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    _ := test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong><br>这段代码就输出了moved to head: a</p><p><strong>原因分析</strong><br>变量a在函数外部存在引用。</p><p><strong>我们来分析一下执行过程：当函数执行完毕，对应的栈帧就被销毁，但是引用已经被返回到函数之外。如果这时外部通过引用地址取值，虽然地址还在，但是这块内存已经被释放回收了，这就是非法内存。</strong></p><p>为了避免上述非法内存的情况，在这种情况下变量的内存分配必须分配到堆上</p><ol start="3"><li>变量占用内存较大</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10000</span>, <span class="number">10000</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i ++ &#123;</span><br><span class="line">        a[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong><br>这段代码就输出了make([]int, 10000, 10000) escapes to heap</p><p><strong>原因分析</strong><br>我们定义了一个容量为10000的int类型切片，发生了逃逸，内存分配到了堆上（heap）。</p><ol start="4"><li>变量大小不确定的时候也会分配在堆上</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">l := <span class="number">1</span></span><br><span class="line">a := <span class="built_in">make</span>([]<span class="type">int</span>, l, l)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; l; i++ &#123;</span><br><span class="line">a[i] = i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong><br>这段代码就输出了make([]int, l, l) escapes to heap</p><p><strong>原因分析</strong><br>我们虽然在代码段中给变量 l 赋值了1，但是编译期间只能识别到初始化int类型切片时，传入的长度和容量是变量l，编译期并不能确定变量l的值，所以发生了逃逸，会把内存分配到堆中。</p><h3 id="go的字符串">go的字符串</h3><ul><li><p>在go中字符串是以字符串<strong>所占字节数结尾</strong>的，例如:</p><ol><li>Hello 字符串 那么它结尾就会存5</li><li>如果是Hello世界，那么他结尾就是5+3+3=11</li></ol></li><li><p>一个字符串所占用的内存空间为<strong>16字节</strong>,Why?<br>首先字符串是一个类型，一个字符串由一个指向字符串值的指针和一个int型数据组成，这个int数据表示字符串值所占的实际字节数，所以一个字符串所占用的内存为8（指针的大小）+8（int的大小）=16字节。</p></li><li><p>在go中字符串是存在<strong>只读内存段</strong>中，不能对字符串内部进行修改，如果想要修改可以转换成byteSlice切片，但这样会导致原来的内存失效，数据被拷贝到新内存中，但是也可以通过使用unsafe包和slice结构时就可以做到使用原来的内存，也就导致依然无法修改内部内容</p></li></ul><h3 id="go的切片底层实现">go的切片底层实现</h3><ul><li><p>slice 切片底层一共有三个数据，一个表示data数据指针，一个表示长度，一个表示容量</p></li><li><p>给slice切片开辟的时候有两种方式，第一种方式用**make（in[]，2，5）**这样会开辟一个有5容量的底层数组，并且默认赋值0，再执行append操作就会在第三个位置插入，然后长度改为3， 如图:<br><img src="../assets/2024-11-29-go%E5%BA%95%E5%B1%82%E7%9F%A5%E8%AF%86/b75afeb9552e6dabc9f5ebc6a00f5da.jpg" alt="alt text"></p></li><li><p>另一种方式使用<strong>new</strong>，使用new的话不会开辟数组空间，且返回的是一个切片的起始地址，只有通过append之后触发了扩容机制，扩容底层数组，导致了地址的分配</p></li></ul><p><img src="../assets/2024-11-29-go%E5%BA%95%E5%B1%82%E7%9F%A5%E8%AF%86/image-8.png" alt="alt text"></p><ul><li>对于以下情况</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr := [<span class="number">10</span>]<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125; <span class="comment">// 开辟一个数组</span></span><br><span class="line">s1 := arr[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">s2 := arr[<span class="number">7</span>:]</span><br></pre></td></tr></table></figure><p>这样的话，s1和s2的底层数组指向的都是数组的对应地址，如图所示:<br><img src="../assets/2024-11-29-go%E5%BA%95%E5%B1%82%E7%9F%A5%E8%AF%86/image-9.png" alt="alt text"><br>所以如果修改s1或者s2的元素，会影响到arr的元素，因为他们指向的是同一个数组的不同部分。同时s1的容量是9长度是3而s2的长度和容量都是3</p><p>但是如果向s2append新元素，就会开辟新空间，把数组的应位置的元素拷贝到新空间，由于容量不够就会触发扩容机制，会2倍扩容，之后会把新元素追加到后面，如图所示:<br><img src="../assets/2024-11-29-go%E5%BA%95%E5%B1%82%E7%9F%A5%E8%AF%86/image-10.png" alt="alt text"></p><p><strong>go中int占8字节</strong></p><h4 id="1-18之前的扩容规则">1.18之前的扩容规则</h4><ol><li><p>在分配内存空间之前需要先确定新的切片容量，运行时根据切片的当前容量选择不同的策略进行扩容：</p></li><li><p>如果期望容量大于当前容量的两倍就会使用期望容量；</p></li><li><p>如果当前切片的长度小于 1024 就会将容量翻倍；</p></li><li><p>如果当前切片的长度大于等于 1024 就会每次增加 25% 的容量，直到新容量大于期望容量；</p></li></ol><p><img src="../assets/2024-11-29-go%E5%BA%95%E5%B1%82%E7%9F%A5%E8%AF%86/image-11.png" alt="alt text"></p><p>记录内存的变化如下:</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span> -&gt;   <span class="number">-1</span>] <span class="built_in">cap</span> = <span class="number">0</span>     |  after <span class="built_in">append</span> <span class="number">0</span>     <span class="built_in">cap</span> = <span class="number">1</span>   </span><br><span class="line">[<span class="number">0</span> -&gt;    <span class="number">0</span>] <span class="built_in">cap</span> = <span class="number">1</span>     |  after <span class="built_in">append</span> <span class="number">1</span>     <span class="built_in">cap</span> = <span class="number">2</span>   </span><br><span class="line">[<span class="number">0</span> -&gt;    <span class="number">1</span>] <span class="built_in">cap</span> = <span class="number">2</span>     |  after <span class="built_in">append</span> <span class="number">2</span>     <span class="built_in">cap</span> = <span class="number">4</span>   </span><br><span class="line">[<span class="number">0</span> -&gt;    <span class="number">3</span>] <span class="built_in">cap</span> = <span class="number">4</span>     |  after <span class="built_in">append</span> <span class="number">4</span>     <span class="built_in">cap</span> = <span class="number">8</span>   </span><br><span class="line">[<span class="number">0</span> -&gt;    <span class="number">7</span>] <span class="built_in">cap</span> = <span class="number">8</span>     |  after <span class="built_in">append</span> <span class="number">8</span>     <span class="built_in">cap</span> = <span class="number">16</span>  </span><br><span class="line">[<span class="number">0</span> -&gt;   <span class="number">15</span>] <span class="built_in">cap</span> = <span class="number">16</span>    |  after <span class="built_in">append</span> <span class="number">16</span>    <span class="built_in">cap</span> = <span class="number">32</span>  </span><br><span class="line">[<span class="number">0</span> -&gt;   <span class="number">31</span>] <span class="built_in">cap</span> = <span class="number">32</span>    |  after <span class="built_in">append</span> <span class="number">32</span>    <span class="built_in">cap</span> = <span class="number">64</span>  </span><br><span class="line">[<span class="number">0</span> -&gt;   <span class="number">63</span>] <span class="built_in">cap</span> = <span class="number">64</span>    |  after <span class="built_in">append</span> <span class="number">64</span>    <span class="built_in">cap</span> = <span class="number">128</span> </span><br><span class="line">[<span class="number">0</span> -&gt;  <span class="number">127</span>] <span class="built_in">cap</span> = <span class="number">128</span>   |  after <span class="built_in">append</span> <span class="number">128</span>   <span class="built_in">cap</span> = <span class="number">256</span> </span><br><span class="line">[<span class="number">0</span> -&gt;  <span class="number">255</span>] <span class="built_in">cap</span> = <span class="number">256</span>   |  after <span class="built_in">append</span> <span class="number">256</span>   <span class="built_in">cap</span> = <span class="number">512</span> </span><br><span class="line">[<span class="number">0</span> -&gt;  <span class="number">511</span>] <span class="built_in">cap</span> = <span class="number">512</span>   |  after <span class="built_in">append</span> <span class="number">512</span>   <span class="built_in">cap</span> = <span class="number">1024</span></span><br><span class="line">[<span class="number">0</span> -&gt; <span class="number">1023</span>] <span class="built_in">cap</span> = <span class="number">1024</span>  |  after <span class="built_in">append</span> <span class="number">1024</span>  <span class="built_in">cap</span> = <span class="number">1280</span></span><br><span class="line">[<span class="number">0</span> -&gt; <span class="number">1279</span>] <span class="built_in">cap</span> = <span class="number">1280</span>  |  after <span class="built_in">append</span> <span class="number">1280</span>  <span class="built_in">cap</span> = <span class="number">1696</span></span><br><span class="line">[<span class="number">0</span> -&gt; <span class="number">1695</span>] <span class="built_in">cap</span> = <span class="number">1696</span>  |  after <span class="built_in">append</span> <span class="number">1696</span>  <span class="built_in">cap</span> = <span class="number">2304</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="1-18之后的扩容规则">1.18之后的扩容规则</h4><ol><li><p>在分配内存空间之前需要先确定新的切片容量，运行时根据切片的当前容量选择不同的策略进行扩容：</p></li><li><p>如果期望容量大于当前容量的两倍就会使用期望容量；</p></li><li><p>如果当前切片的长度小于阈值（默认 256）就会将容量翻倍；</p></li><li><p>如果当前切片的长度大于等于阈值（默认 256），就会每次增加 25% 的容量，基准是 newcap + 3*threshold，直到新容量大于期望容量；</p></li></ol><p><img src="../assets/2024-11-29-go%E5%BA%95%E5%B1%82%E7%9F%A5%E8%AF%86/image-12.png" alt="alt text"></p><p>算出期望扩容后还会内存对齐，会调用roundupsize函数进行内存对齐</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> class_to_size = [_NumSizeClasses]<span class="type">uint16</span>&#123;<span class="number">0</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">24</span>, <span class="number">32</span>, <span class="number">48</span>, <span class="number">64</span>, <span class="number">80</span>, <span class="number">96</span>, <span class="number">112</span>, <span class="number">128</span>, <span class="number">144</span>, <span class="number">160</span>, <span class="number">176</span>, <span class="number">192</span>, <span class="number">208</span>, <span class="number">224</span>, <span class="number">240</span>, <span class="number">256</span>, <span class="number">288</span>, <span class="number">320</span>, <span class="number">352</span>, <span class="number">384</span>, <span class="number">416</span>, <span class="number">448</span>, <span class="number">480</span>, <span class="number">512</span>, <span class="number">576</span>, <span class="number">640</span>, <span class="number">704</span>, <span class="number">768</span>, <span class="number">896</span>, <span class="number">1024</span>, <span class="number">1152</span>, <span class="number">1280</span>, <span class="number">1408</span>, <span class="number">1536</span>, <span class="number">1792</span>, <span class="number">2048</span>, <span class="number">2304</span>, <span class="number">2688</span>, <span class="number">3072</span>, <span class="number">3200</span>, <span class="number">3456</span>, <span class="number">4096</span>, <span class="number">4864</span>, <span class="number">5376</span>, <span class="number">6144</span>, <span class="number">6528</span>, <span class="number">6784</span>, <span class="number">6912</span>, <span class="number">8192</span>, <span class="number">9472</span>, <span class="number">9728</span>, <span class="number">10240</span>, <span class="number">10880</span>, <span class="number">12288</span>, <span class="number">13568</span>, <span class="number">14336</span>, <span class="number">16384</span>, <span class="number">18432</span>, <span class="number">19072</span>, <span class="number">20480</span>, <span class="number">21760</span>, <span class="number">24576</span>, <span class="number">27264</span>, <span class="number">28672</span>, <span class="number">32768</span>&#125;</span><br></pre></td></tr></table></figure><p>假设我们运行此处代码:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">s1 = <span class="built_in">append</span>(s1, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>期望容量是5，但实际会输出6</p><p>继续分析可以得出，divRoundUp的结果为 (40 +8 - 1) / 8 = 5， size_to_class8[5] = 5，class_to_size[5] = 48，最终结果capmem为48</p><p>具体可以看如下链接<a href="https://zhuanlan.zhihu.com/p/630224339">扩容后内存对齐是怎么对齐的</a></p><p>执行下述代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go 1.18</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSliceGrowing</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">   s := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4098</span>; i++ &#123;</span><br><span class="line">      s = <span class="built_in">append</span>(s, i)</span><br><span class="line">      t.Log(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">=== RUN   TestSliceGrowing</span><br><span class="line">    slice_test.<span class="keyword">go</span>:<span class="number">32</span>: <span class="number">1</span> <span class="number">1</span></span><br><span class="line">    slice_test.<span class="keyword">go</span>:<span class="number">32</span>: <span class="number">2</span> <span class="number">2</span></span><br><span class="line">    slice_test.<span class="keyword">go</span>:<span class="number">32</span>: <span class="number">3</span> <span class="number">4</span></span><br><span class="line">    slice_test.<span class="keyword">go</span>:<span class="number">32</span>: <span class="number">4</span> <span class="number">4</span></span><br><span class="line">    slice_test.<span class="keyword">go</span>:<span class="number">32</span>: <span class="number">5</span> <span class="number">8</span></span><br><span class="line">    slice_test.<span class="keyword">go</span>:<span class="number">32</span>: <span class="number">6</span> <span class="number">8</span></span><br><span class="line">    slice_test.<span class="keyword">go</span>:<span class="number">32</span>: <span class="number">7</span> <span class="number">8</span></span><br><span class="line">    slice_test.<span class="keyword">go</span>:<span class="number">32</span>: <span class="number">8</span> <span class="number">8</span></span><br><span class="line">    slice_test.<span class="keyword">go</span>:<span class="number">32</span>: <span class="number">9</span> <span class="number">16</span></span><br><span class="line">    ......</span><br><span class="line">    slice_test.<span class="keyword">go</span>:<span class="number">32</span>: <span class="number">128</span> <span class="number">128</span></span><br><span class="line">    slice_test.<span class="keyword">go</span>:<span class="number">32</span>: <span class="number">129</span> <span class="number">256</span></span><br><span class="line">    ......</span><br><span class="line">    slice_test.<span class="keyword">go</span>:<span class="number">32</span>: <span class="number">256</span> <span class="number">256</span></span><br><span class="line">    slice_test.<span class="keyword">go</span>:<span class="number">32</span>: <span class="number">257</span> <span class="number">512</span></span><br><span class="line">    ......</span><br><span class="line">    slice_test.<span class="keyword">go</span>:<span class="number">32</span>: <span class="number">512</span> <span class="number">512</span></span><br><span class="line">    slice_test.<span class="keyword">go</span>:<span class="number">32</span>: <span class="number">513</span> <span class="number">848</span></span><br><span class="line">    ......</span><br><span class="line">    slice_test.<span class="keyword">go</span>:<span class="number">32</span>: <span class="number">848</span> <span class="number">848</span></span><br><span class="line">    slice_test.<span class="keyword">go</span>:<span class="number">32</span>: <span class="number">849</span> <span class="number">1280</span></span><br><span class="line">    ......</span><br><span class="line">    slice_test.<span class="keyword">go</span>:<span class="number">32</span>: <span class="number">1280</span> <span class="number">1280</span></span><br><span class="line">    slice_test.<span class="keyword">go</span>:<span class="number">32</span>: <span class="number">1281</span> <span class="number">1792</span></span><br><span class="line">    ......</span><br><span class="line">    slice_test.<span class="keyword">go</span>:<span class="number">32</span>: <span class="number">1792</span> <span class="number">1792</span></span><br><span class="line">    slice_test.<span class="keyword">go</span>:<span class="number">32</span>: <span class="number">1793</span> <span class="number">2560</span></span><br><span class="line">    ......</span><br><span class="line">    slice_test.<span class="keyword">go</span>:<span class="number">32</span>: <span class="number">2560</span> <span class="number">2560</span></span><br><span class="line">    slice_test.<span class="keyword">go</span>:<span class="number">32</span>: <span class="number">2561</span> <span class="number">3408</span></span><br><span class="line">    ......</span><br><span class="line">    slice_test.<span class="keyword">go</span>:<span class="number">32</span>: <span class="number">3408</span> <span class="number">3408</span></span><br><span class="line">    slice_test.<span class="keyword">go</span>:<span class="number">32</span>: <span class="number">3409</span> <span class="number">5120</span>  </span><br></pre></td></tr></table></figure><h3 id="go的map底层原理">go的map底层原理</h3><p>go中map使用的是<strong>渐进性扩容</strong>，这样可以避免一次性迁移太多的数据而导致消费过多的时间</p><h4 id="go-map的结构定义">go map的结构定义</h4><p><img src="../assets/2024-11-29-go%E5%BA%95%E5%B1%82%E7%9F%A5%E8%AF%86/image-13.png" alt="alt text"></p><ul><li>一个map的结构定义如下：<ol><li>count：元素个数</li><li>flags：标记位，包括是否扩容，是否有哈希冲突</li><li>B: 表示2的B次方</li><li>buckets：存储键值对的数组，每个bucket是一个bucket结构，存储键值对</li><li>oldbuckets：扩容时使用，指向旧的buckets数组</li><li>hash0：哈希种子</li><li>nevacuate：表示下一次进行迁徙的旧桶编号</li><li>extra：额外的存储空间,指向的是mapextra结构体，存储的是溢出桶的信息</li></ol></li></ul><p>一个bmap大概如下:<br><img src="../assets/2024-11-29-go%E5%BA%95%E5%B1%82%E7%9F%A5%E8%AF%86/image-15.png" alt="alt text"></p><p>其中h1到h8表示tophash，<strong>tophash</strong>一共由两个作用: 一是状态位，二是存储key值的高八位</p><h5 id="tophash作为状态位">tophash作为状态位</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">emptyRest      = <span class="number">0</span>  <span class="comment">// 有两层意思：一是表示该tophash对应的K/V位置是可用的；二是表示该位置后面的K/V位置都是可用的。</span></span><br><span class="line">emptyOne       = <span class="number">1</span>  <span class="comment">// 仅表示该tophash对应的K/V位置是可用的，其后面的是否可用不知道。</span></span><br><span class="line">evacuatedX     = <span class="number">2</span>  <span class="comment">// 与迁移有关</span></span><br><span class="line">evacuatedY     = <span class="number">3</span> <span class="comment">// 与迁移有关</span></span><br><span class="line">evacuatedEmpty = <span class="number">4</span> <span class="comment">// 当bucket被迁移完时，tophash值置为evacuatedEmpty。</span></span><br><span class="line">minTopHash     = <span class="number">5</span> </span><br></pre></td></tr></table></figure><p>emptyRest的作用:</p><ul><li><p>判断bucket是否为空<br>当tophash[0]==emptyRest表示整个bucket都是空的，这就是源码里面判断bucket是否为空的方法。</p></li><li><p>查找时快速判断后面位置是否还需遍历<br>如在查找时，在一个bucket中，找到tophash[2]位置，发现值为emptyRest，就可以判断该bucket没有该元素，继续查找下一个bucket</p></li></ul><p>详细介绍可以看<a href="https://blog.csdn.net/fengshenyun/article/details/97296412">Golang之map tophash详解</a></p><h5 id="hmap">hmap</h5><p><img src="../assets/2024-11-29-go%E5%BA%95%E5%B1%82%E7%9F%A5%E8%AF%86/image-16.png" alt="alt text"></p><p>当一个位置的bmap存满了，可能会在其后面添加溢出桶，溢出桶的overflow指向下一个溢出桶的位置，单个桶的容量为8个元素</p><h5 id="go-map扩容规则">go map扩容规则</h5><p>go map扩容规则如下：</p><ol><li>Go语言map的默认负载因子是6.5，也就是说当<strong>count/2^B &gt; 6.5</strong>时，就会触发<strong>翻倍扩容（是旧桶容量的两倍）</strong>；</li><li>如果负载因子没有超标，但是使用了太多的溢出桶，就会触发<strong>等量扩容</strong>，即<strong>新桶容量等于旧桶容量</strong>；</li></ol><h6 id="翻倍扩容">翻倍扩容</h6><p>翻倍扩容时，旧桶里的元素会被<strong>分流</strong>到新的桶中，比如0号桶（旧桶容量是四个）会被分流到新桶的0号或者4号桶中如图所示:</p><p><img src="../assets/2024-11-29-go%E5%BA%95%E5%B1%82%E7%9F%A5%E8%AF%86/image-17.png" alt="alt text"></p><h6 id="等量扩容">等量扩容</h6><p>有两个规则：</p><ol><li>当B&lt;=15, 且常规桶的数量不超过2^15时，溢出桶的数目超过常规桶(2^B),就会触发等量扩容；</li><li>如果B&gt;15, 且溢出桶的数目超过2^15，就会触发等量扩容；</li></ol><p><strong>为什么需要等量扩容？</strong></p><p>因为在溢出桶中可能有很多元素被删除了，导致一个溢出桶内只有少量的元素，但是数量没变，这是就需要等量扩容了</p><h3 id="函数调用栈">函数调用栈</h3><ul><li>在go语言函数栈帧布局中，返回值在函数参数之上，<strong>如果一个函数内有defer函数，那么这个函数再放回前是先给放回值赋值，在执行defer函数</strong>，如图所示:<br><img src="../assets/2024-11-29-go%E5%BA%95%E5%B1%82%E7%9F%A5%E8%AF%86/image-18.png" alt="alt text"></li></ul><p>所以上图中main函数中的<strong>b为1而不是2</strong></p><p>如果使用的是<strong>匿名返回值</strong>,结果又会不一样</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">incr</span><span class="params">(a <span class="type">int</span>)</span></span>(b <span class="type">int</span>)&#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        a ++</span><br><span class="line">        b ++</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    a++</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a, b <span class="type">int</span></span><br><span class="line">    b = incr(a)</span><br><span class="line">    fmt.Println(a,b) <span class="comment">// 输出 0, 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这个函数中在返回a的时候，a的值为1会赋值给b，此时b也等于1，然后执行defer函数，a再加1，此时a等于2，b也等于2，由于a是局部变量，所以输出为0，2<br><img src="../assets/2024-11-29-go%E5%BA%95%E5%B1%82%E7%9F%A5%E8%AF%86/image-19.png" alt="alt text"></li></ul><h3 id="闭包底层">闭包底层</h3><ul><li>当函数作为返回值或者作为参数以及变量的时候，go语言称这些为<strong>function value</strong>，<strong>function value本质上是一个指针</strong>，但是不直接指向函数帧的入口，而是指向一个叫做<strong>funcval</strong>的结构体，结构体内部<strong>为指向函数指令入口地址的指针</strong>，也就是说function value本质采用了<strong>二级指针的方式</strong>,如图所示:<br><img src="../assets/2024-11-29-go%E5%BA%95%E5%B1%82%E7%9F%A5%E8%AF%86/image-20.png" alt="alt text"></li></ul><p>具体例子:</p><p><img src="../assets/2024-11-29-go%E5%BA%95%E5%B1%82%E7%9F%A5%E8%AF%86/image-21.png" alt="alt text"></p><p>其中addr1为A函数的入口地址，addr2为<strong>function value的地址</strong>, f1与f2指向的是addr2也就是<strong>function value的地址</strong><br>那么<strong>为什么要通过funcval结构体包装函数入口地址，来实现二级指针调用呢？</strong></p><p><strong>答案是为闭包服务</strong></p><h4 id="闭包函数">闭包函数</h4><p><strong>补充下闭包的定义：闭包是指一个函数有权访问到其外部函数作用域中的变量</strong></p><ul><li><strong>闭包函数定义</strong>: 当一个函数的<strong>返回值是另外一个函数</strong>，而返回的那个函数如果<strong>调用了其父函数内部的其它变量</strong>，如果返回的这个<strong>函数在外部被执行</strong>，就产生了闭包<br>例如：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    c := <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> c</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f1 := create()</span><br><span class="line">    f2 := create()</span><br><span class="line">    fmt.Println(f1(), f2()) <span class="comment">// 输出 2 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>闭包函数使用外部变量的时候，会有一个<strong>捕获列表</strong>，这个捕获列表里面的值就是我捕捉的外部变量</li><li>捕获列表里面的变量会copy一份外部变量，并且与funcval结构体一块被分配到堆上，堆上的funcval结构体的入口地址就会赋值给函数对象，如图所示:<br><img src="../assets/2024-11-29-go%E5%BA%95%E5%B1%82%E7%9F%A5%E8%AF%86/image-23.png" alt="alt text"></li></ol><p>总结来说go语言中闭包就是有捕获列表的Function Value，其是通过寄存器的值来存储Function Value的地址，这样在闭包函数中就能通过寄存器取出funcval结构体的地址，然后加上相应偏离找到捕获变量</p><p><img src="../assets/2024-11-29-go%E5%BA%95%E5%B1%82%E7%9F%A5%E8%AF%86/image-24.png" alt="alt text"></p><p>在以上图片的例子中，捕获变量除了初始化还会被修改，这是变量就会逃逸到推上，然后fs[0]和fs[1]都使用这个堆上变量，如图所示:<br><img src="../assets/2024-11-29-go%E5%BA%95%E5%B1%82%E7%9F%A5%E8%AF%86/image-25.png" alt="alt text"></p><p>所以函数最终输出都为2</p>]]></content>
    
    
    <summary type="html">本文介绍的是go底层源码级别的相关知识</summary>
    
    
    
    <category term="go" scheme="https://pigcanstudy.github.io/categories/go/"/>
    
    
    <category term="go" scheme="https://pigcanstudy.github.io/tags/go/"/>
    
    <category term="go底层知识" scheme="https://pigcanstudy.github.io/tags/go%E5%BA%95%E5%B1%82%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>go的语法基础</title>
    <link href="https://pigcanstudy.github.io/posts/a0a85a77.html"/>
    <id>https://pigcanstudy.github.io/posts/a0a85a77.html</id>
    <published>2024-11-29T09:21:18.000Z</published>
    <updated>2024-11-29T10:47:30.947Z</updated>
    
    <content type="html"><![CDATA[<h1>目录</h1><ul><li><a href="#%E7%9B%AE%E5%BD%95">目录</a><ul><li><a href="#golang%E7%BB%93%E6%9E%84%E4%BD%93">golang结构体</a><ul><li><a href="#%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%8C%BF%E5%90%8D%E5%AD%97%E6%AE%B5">结构体的匿名字段</a></li><li><a href="#%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%B5%8C%E5%A5%97">结构体的嵌套</a><ul><li><a href="#%E6%AD%A3%E5%B8%B8%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E5%B5%8C%E5%A5%97">正常的结构体嵌套</a></li><li><a href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%8C%BF%E5%90%8D%E5%AD%97%E6%AE%B5%E5%B5%8C%E5%A5%97">结构体匿名字段嵌套</a></li></ul></li><li><a href="#%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E7%BB%A7%E6%89%BF">结构体的继承</a></li></ul></li><li><a href="#golang%E6%8E%A5%E5%8F%A3">golang接口</a><ul><li><a href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F">接口的定义方式</a></li><li><a href="#%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%96%B9%E5%BC%8F">实现接口的方式</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">使用接口的注意事项</a></li><li><a href="#%E5%AE%9A%E4%B9%89%E6%97%B6%E5%80%BC%E6%8E%A5%E5%8F%97%E5%92%8C%E6%8C%87%E9%92%88%E6%8E%A5%E5%8F%97%E7%9A%84%E5%8C%BA%E5%88%AB">定义时值接受和指针接受的区别</a></li><li><a href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%B8%AA%E6%8E%A5%E5%8F%A3">如何实现多个接口</a></li><li><a href="#%E7%A9%BA%E6%8E%A5%E5%8F%A3">空接口</a></li><li><a href="#%E7%A9%BA%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82%E4%BB%A5%E5%8F%8A%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E7%9A%84%E4%B8%80%E7%A7%8D%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F">空接口的使用细节，以及类型断言的一种使用方式</a></li></ul></li><li><a href="#golang%E5%8D%8F%E7%A8%8B">golang协程</a><ul><li><a href="#%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F">协程的创建方式</a></li><li><a href="#%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F">协程的同步方式</a><ul><li><a href="#%E4%BD%BF%E7%94%A8syncwaitgroup%E6%9D%A5%E7%AD%89%E5%BE%85%E5%8D%8F%E7%A8%8B%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%AF%95">使用sync.WaitGroup来等待协程执行完毕</a></li></ul></li></ul></li><li><a href="#golang%E7%AE%A1%E9%81%93">golang管道</a><ul><li><a href="#%E7%AE%A1%E9%81%93%E5%BA%95%E5%B1%82%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">管道底层的数据结构</a></li><li><a href="#select%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86">select的底层原理</a></li><li><a href="#select%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B">select的执行过程</a></li></ul></li><li><a href="#go%E7%9A%84%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6">go的反射机制</a><ul><li><a href="#%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E7%9A%84%E5%AE%9A%E4%B9%89">反射机制的定义</a></li><li><a href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7">反射的重要性</a></li><li><a href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E5%88%86%E7%B1%BB">反射的分类</a><ul><li><a href="#%E7%B1%BB%E5%9E%8B%E5%8F%8D%E5%B0%84">类型反射：</a></li><li><a href="#%E5%80%BC%E5%8F%8D%E5%B0%84">值反射</a></li></ul></li><li><a href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E5%BA%94%E7%94%A8">反射的应用</a><ul><li><a href="#%E4%B8%8E%E7%A9%BA%E6%8E%A5%E5%8F%A3%E9%85%8D%E5%90%88%E4%BD%BF%E7%94%A8%E5%BE%97%E5%88%B0%E7%9C%9F%E5%AE%9E%E6%95%B0%E6%8D%AE">与空接口配合使用，得到真实数据</a></li><li><a href="#%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E8%AE%BE%E7%BD%AE%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC">通过反射设置变量的值</a></li><li><a href="#%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%80%BC%E4%B8%8E%E7%B1%BB%E5%9E%8B">反射获取结构体的值与类型</a><ul><li><a href="#%E8%8E%B7%E5%8F%96%E5%B1%9E%E6%80%A7">获取属性</a></li><li><a href="#%E8%8E%B7%E5%8F%96%E6%96%B9%E6%B3%95">获取方法</a></li><li><a href="#%E5%8F%8D%E5%B0%84%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95">反射调用方法</a></li></ul></li></ul></li></ul></li><li><a href="#go%E7%9A%84%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C">go的文件操作</a><ul><li><a href="#%E4%BD%BF%E7%94%A8os%E6%89%93%E5%BC%80%E5%B9%B6%E4%BD%BF%E7%94%A8%E5%85%B6%E8%BF%94%E5%9B%9E%E7%9A%84file%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6">使用os打开并使用其返回的file读取文件</a></li><li><a href="#%E4%BD%BF%E7%94%A8bufio%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE">使用bufio读取数据</a></li><li><a href="#%E4%BD%BF%E7%94%A8ioutil%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6">使用ioutil读取文件</a></li><li><a href="#osopenfile%E5%92%8Cfilewrite%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6">os.openfile()和file.Write()写入文件</a></li><li><a href="#%E4%BD%BF%E7%94%A8bufiowriter%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6">使用bufio.writer写入文件</a></li><li><a href="#%E4%BD%BF%E7%94%A8oswritefile%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6">使用os.WriteFile()写入文件</a></li></ul></li><li><a href="#go%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95">go排序方法</a><ul><li><a href="#%E6%8E%92%E5%BA%8F%E6%95%B4%E6%95%B0%E6%B5%AE%E7%82%B9%E6%95%B0%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%87%E7%89%87">排序整数，浮点数和字符串切片</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%AF%94%E8%BE%83%E5%99%A8%E6%8E%92%E5%BA%8F">使用自定义比较器排序</a></li><li><a href="#%E6%8E%92%E5%BA%8F%E4%BB%BB%E6%84%8F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">排序任意数据结构</a></li><li><a href="#%E6%8E%92%E5%BA%8F%E5%85%B7%E4%BD%93%E7%9A%84%E7%AE%97%E6%B3%95%E5%92%8C%E5%A4%8D%E6%9D%82%E5%BA%A6">排序具体的算法和复杂度</a></li></ul></li><li><a href="#go%E5%BA%8F%E5%88%97%E5%8C%96%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86">go序列化相关知识</a><ul><li><a href="#json%E5%BA%8F%E5%88%97%E5%8C%96">Json序列化</a></li><li><a href="#struct-tag">Struct Tag</a></li><li><a href="#json%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96">Json反序列化</a></li><li><a href="#%E4%BD%BF%E7%94%A8encoder%E5%92%8Cdecoder%E8%BF%9B%E8%A1%8C%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96">使用Encoder和Decoder进行序列化和反序列化</a></li><li><a href="#gob%E5%BA%8F%E5%88%97%E5%8C%96">gob序列化</a><ul><li><a href="#gob%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%E7%A8%8B">Gob序列化流程</a></li></ul></li></ul></li><li><a href="#go%E7%9A%84%E5%86%85%E7%BD%AE%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8">go的内置定时器的使用</a><ul><li><a href="#ticker%E5%AE%9A%E6%97%B6%E5%99%A8">Ticker定时器</a></li><li><a href="#timer%E5%AE%9A%E6%97%B6%E5%99%A8">Timer定时器</a></li><li><a href="#after">After()</a></li></ul></li><li><a href="#%E5%81%9A%E9%A1%B9%E7%9B%AE%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98">做项目遇到的一些问题</a><ul><li><a href="#map%E9%80%9A%E8%BF%87%E7%B4%A2%E5%BC%95%E8%BF%94%E5%9B%9E%E7%9A%84%E6%98%AF%E5%89%AF%E6%9C%AC%E6%94%B9%E5%8F%98%E5%89%AF%E6%9C%AC%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8D%E4%BC%9A%E6%94%B9%E5%8F%98map%E4%B8%AD%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E5%8E%9F%E6%95%B0%E6%8D%AE">Map通过索引返回的是副本，改变副本结构体不会改变map中的结构体原数据</a></li><li><a href="#%E4%B8%8D%E5%90%8C%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C%E7%9B%B8%E5%90%8C%E5%8C%85%E4%B8%8B%E7%9A%84%E4%B8%8D%E5%90%8C%E6%BA%90%E4%BB%A3%E7%A0%81%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E7%8E%B0%E8%B1%A1">不同进程运行相同包下的不同源代码文件的一些现象</a></li><li><a href="#select-%E9%85%8D%E5%90%88%E9%80%9A%E9%81%93%E4%BD%BF%E7%94%A8%E7%9A%84%E6%97%B6%E5%80%99%E7%9A%84%E4%B8%80%E4%BA%9B%E9%80%BB%E8%BE%91">select 配合通道使用的时候的一些逻辑</a></li></ul></li></ul></li></ul><h2 id="golang结构体">golang结构体</h2><h3 id="结构体的匿名字段">结构体的匿名字段</h3><p><strong>匿名字段</strong>是指结构体中没有字段名的字段</p><h3 id="结构体的嵌套">结构体的嵌套</h3><h4 id="正常的结构体嵌套">正常的结构体嵌套</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">    City <span class="type">string</span></span><br><span class="line">    Phone <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age <span class="type">int</span></span><br><span class="line">    Address Address <span class="comment">// 这就是嵌套的结构体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样使用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    user1 := Person&#123;</span><br><span class="line">        Name: <span class="string">&quot;Tom&quot;</span>,</span><br><span class="line">        Age: <span class="number">20</span>,</span><br><span class="line">        Address: Address&#123;</span><br><span class="line">            City: <span class="string">&quot;Beijing&quot;</span>,</span><br><span class="line">            Phone: <span class="string">&quot;1234567890&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    user1.Address.City = <span class="string">&quot;Shanghai&quot;</span> <span class="comment">// 改变嵌套结构体的属性值</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(user1.Address.City) <span class="comment">// 输出 Shanghai</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结构体匿名字段嵌套">结构体匿名字段嵌套</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">    City <span class="type">string</span></span><br><span class="line">    Phone <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age <span class="type">int</span></span><br><span class="line">    Address <span class="comment">// 这就是嵌套的结构体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样使用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    user1 := Person&#123;</span><br><span class="line">        Name: <span class="string">&quot;Tom&quot;</span>,</span><br><span class="line">        Age: <span class="number">20</span>,</span><br><span class="line">        Address: Address&#123;</span><br><span class="line">            City: <span class="string">&quot;Beijing&quot;</span>,</span><br><span class="line">            Phone: <span class="string">&quot;1234567890&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    user1.City = <span class="string">&quot;Shenzhen&quot;</span> <span class="comment">// 可以这么访问改变结构体的属性值</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(user1.Address.City) <span class="comment">// 输出 Shanghai</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ol><li>如果外层结构体与嵌套结构体有同名字段，使用user1.City访问的时候，会优先访问外层字段</li><li>如果两个嵌套匿名结构体有同名字段，而外层没有同名字段，例如:</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">    City <span class="type">string</span></span><br><span class="line">    Phone <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Email stuct &#123;</span><br><span class="line">    Account <span class="type">string</span></span><br><span class="line">    City <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age <span class="type">int</span></span><br><span class="line">    Address</span><br><span class="line">    Email</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">user1 := Person&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>定义方式如上，如果使用user1.City访问，会访问哪个字段呢，这样就会报错，必须使用user1.Address.City访问或者使用user1.Email.City访问，否则会报错</p><h3 id="结构体的继承">结构体的继承</h3><ul><li>结构体继承就能看作是一个结构体匿名嵌套</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a Animal)</span></span> run() &#123;</span><br><span class="line">  fmt.Println(a.Name, <span class="string">&quot; is running!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">  Animal <span class="comment">// 继承Animal结构体</span></span><br><span class="line">  Age    <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Dog)</span></span> wang() &#123;</span><br><span class="line">  fmt.Println(d.Name, <span class="string">&quot; is wang!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  d := Dog&#123;</span><br><span class="line">    Animal: Animal&#123;</span><br><span class="line">      Name: <span class="string">&quot;小狗&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    Age: <span class="number">4</span>,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  d.run()</span><br><span class="line">  d.wang()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出:</span></span><br><span class="line"><span class="comment">小狗  is running!</span></span><br><span class="line"><span class="comment">小狗  is wang!</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="golang接口">golang接口</h2><h3 id="接口的定义方式">接口的定义方式</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Animal <span class="keyword">interface</span> &#123;</span><br><span class="line">    speak()</span><br><span class="line">    eat()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现接口的方式">实现接口的方式</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">  name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Dog)</span></span> speak() &#123;</span><br><span class="line">  fmt.Println(d.name, <span class="string">&quot; says woof!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Dog)</span></span> eat() &#123;</span><br><span class="line">  fmt.Println(d.name, <span class="string">&quot; is eating meat!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">  name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Cat)</span></span> speak() &#123;</span><br><span class="line">  fmt.Println(c.name, <span class="string">&quot; says meow!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Cat)</span></span> eat() &#123;</span><br><span class="line">  fmt.Println(c.name, <span class="string">&quot; is eating fish!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> animal Animal</span><br><span class="line">  <span class="keyword">var</span> dog Dog</span><br><span class="line">  <span class="keyword">var</span> cat Cat</span><br><span class="line">  animal = dog <span class="comment">// 让狗实现 动物接口</span></span><br><span class="line">  animal.speak()</span><br><span class="line">  animal.eat()</span><br><span class="line">  cat.speak()</span><br><span class="line">  cat.eat()</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="使用接口的注意事项">使用接口的注意事项</h3><pre><code>1. 接口的定义中，**方法的签名必须一致，参数列表也必须一致。**2. 接口的实现中，**必须实现接口中定义的所有方法。**</code></pre><h3 id="定义时值接受和指针接受的区别">定义时值接受和指针接受的区别</h3><pre><code>1. 定义值接受的时候, 实例化后的结构体值类型和指针类型都可以赋值给接口变量<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Usber <span class="keyword">interface</span> &#123;</span><br><span class="line">    start()</span><br><span class="line">    stop()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Phone <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Phone)</span></span> start() &#123;</span><br><span class="line">    fmt.Println(p.Name, <span class="string">&quot;is starting&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Phone)</span></span> stop() &#123;</span><br><span class="line">    fmt.Println(p.Name, <span class="string">&quot;is stopping&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> u1 Usber = Phone&#123;Name: <span class="string">&quot;xiaomi&quot;</span>&#125;</span><br><span class="line">    u1.start()</span><br><span class="line">    u1.stop()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正确使用方法</span></span><br><span class="line">    <span class="keyword">var</span> u Usber = &amp;Phone&#123;Name: <span class="string">&quot;iPhone&quot;</span>&#125;</span><br><span class="line">    u.start()</span><br><span class="line">    u.stop()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>2. 定义指针接受的时候，实例化后只有结构体指针类型可以赋值给接口变量<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line">  <span class="keyword">import</span> (</span><br><span class="line">      <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">type</span> Usber <span class="keyword">interface</span> &#123;</span><br><span class="line">      start()</span><br><span class="line">      stop()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">type</span> Phone <span class="keyword">struct</span> &#123;</span><br><span class="line">      Name <span class="type">string</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="params">(p *Phone)</span></span> start() &#123;</span><br><span class="line">      fmt.Println(p.Name, <span class="string">&quot;is starting&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="params">(p *Phone)</span></span> stop() &#123;</span><br><span class="line">      fmt.Println(p.Name, <span class="string">&quot;is stopping&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 错误使用方法</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  var u Usber = Phone&#123;Name: &quot;iPhone&quot;&#125;</span></span><br><span class="line"><span class="comment">  u.start()</span></span><br><span class="line"><span class="comment">  u.stop()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确使用方法</span></span><br><span class="line"><span class="keyword">var</span> u Usber = &amp;Phone&#123;Name: <span class="string">&quot;iPhone&quot;</span>&#125;</span><br><span class="line">u.start()</span><br><span class="line">u.stop()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>3. 既有指针又有值接收，与指针接受类似</code></pre><h3 id="如何实现多个接口">如何实现多个接口</h3><p>直接让结构体实例化两次接口就行，如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Animaler1 <span class="keyword">interface</span> &#123;</span><br><span class="line">  SetName(<span class="type">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Animaler2 <span class="keyword">interface</span> &#123;</span><br><span class="line">  GetName() <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">  name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dog)</span></span> SetName(name <span class="type">string</span>) &#123;</span><br><span class="line">  d.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Dog)</span></span> GetName() <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> d.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  d := &amp;Dog&#123;<span class="string">&quot;小黑&quot;</span>&#125;</span><br><span class="line">  <span class="keyword">var</span> a1 Animaler1 = d <span class="comment">// 实现Animaler1接口</span></span><br><span class="line">  <span class="keyword">var</span> a2 Animaler2 = d <span class="comment">// 实现Animaler2接口</span></span><br><span class="line">  fmt.Println(a2.GetName())</span><br><span class="line">  a1.SetName(<span class="string">&quot;小白&quot;</span>)</span><br><span class="line">  fmt.Println(a2.GetName())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>接口的嵌套</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Animaler1 <span class="keyword">interface</span> &#123;</span><br><span class="line">  SetName(<span class="type">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Animaler2 <span class="keyword">interface</span> &#123;</span><br><span class="line">  GetName() <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Animaler <span class="keyword">interface</span> &#123; <span class="comment">// 嵌套Animaler1和Animaler2接口</span></span><br><span class="line">  Animaler1</span><br><span class="line">  Animaler2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">  name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dog)</span></span> SetName(name <span class="type">string</span>) &#123;</span><br><span class="line">  d.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Dog)</span></span> GetName() <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> d.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  d := &amp;Dog&#123;<span class="string">&quot;小黑&quot;</span>&#125;</span><br><span class="line">  <span class="keyword">var</span> a Animaler = d</span><br><span class="line">  fmt.Println(a.GetName())</span><br><span class="line">  a.SetName(<span class="string">&quot;小白&quot;</span>)</span><br><span class="line">  fmt.Println(a.GetName())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="空接口">空接口</h3><p>没有定义任何方法的接口就叫做空接口，空接口表示没有任何约束，因此任何类型变量都可以实现空接口<br>1. <strong>灵活性：由于空接口可以接受任何类型的值，它为编写更灵活的函数和数据结构提供了便利。例如，你可以编写一个接收空接口作为参数的函数，这个函数可以处理不同类型的输入。</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrintValue</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>2. <strong>map的val为空接口,表示可以存储任意类型的值</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">m[<span class="string">&quot;key&quot;</span>] = <span class="number">123</span></span><br><span class="line">m[<span class="string">&quot;key&quot;</span>] = <span class="string">&quot;hello&quot;</span></span><br><span class="line">fmt.Println(m[<span class="string">&quot;key&quot;</span>]) <span class="comment">// 输出 123 hello</span></span><br></pre></td></tr></table></figure><br>3. <strong>切片实现空接口</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice = []<span class="keyword">interface</span>&#123;&#125;&#123;<span class="number">1</span>, <span class="string">&quot;hello&quot;</span>, <span class="literal">true</span>&#125;</span><br><span class="line">fmt.Println(slice) <span class="comment">// 输出 [1 hello true]</span></span><br></pre></td></tr></table></figure><br>4. <strong>类型断言</strong>：<em><strong>在使用空接口时，通常需要通过类型断言来获取实际值的具体类型。这使得在需要时可以安全地访问原始值。</strong></em><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// v.(类型) 即为断言</span></span><br><span class="line"><span class="keyword">var</span> v <span class="keyword">interface</span>&#123;&#125; = <span class="string">&quot;Hello&quot;</span></span><br><span class="line">str, ok := v.(<span class="type">string</span>); </span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">    fmt.Println(str) <span class="comment">// 输出: Hello</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>5. <strong>实现多态：通过使用空接口，可以实现某种程度的多态，使得不同类型的对象可以通过同一个接口进行操作。这在设计API时尤为有用。</strong></p><h3 id="空接口的使用细节，以及类型断言的一种使用方式">空接口的使用细节，以及类型断言的一种使用方式</h3><pre><code>1. 空接口给切片或者map作为值类型的时候在使用的时候，不能详细访问里面的细节(详细下标，或者结构体里的值)，例如:<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"> <span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">     City  <span class="type">string</span></span><br><span class="line">     Phone <span class="type">string</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">     <span class="keyword">var</span> mp <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125; = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">     mp[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;Alice&quot;</span></span><br><span class="line">     mp[<span class="string">&quot;age&quot;</span>] = <span class="number">25</span></span><br><span class="line">     mp[<span class="string">&quot;address&quot;</span>] = Address&#123;<span class="string">&quot;New York&quot;</span>, <span class="string">&quot;123-456-7890&quot;</span>&#125;</span><br><span class="line">     mp[<span class="string">&quot;arrays&quot;</span>] = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 错误用法 因为空接口无法详细访问</span></span><br><span class="line">     <span class="comment">//fmt.Println(mp[&quot;address&quot;].City)</span></span><br><span class="line">     <span class="comment">//fmt.Println(mp[&quot;arrays&quot;][0])</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// 正确用法, 使用类型推断来实现</span></span><br><span class="line">     v, ok := mp[<span class="string">&quot;address&quot;</span>].(Address)</span><br><span class="line">     <span class="keyword">if</span> ok &#123;</span><br><span class="line">         fmt.Println(v.City)</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     k, ok := mp[<span class="string">&quot;arrays&quot;</span>].([]<span class="type">int</span>)</span><br><span class="line">     <span class="keyword">if</span> ok &#123;</span><br><span class="line">         fmt.Println(k[<span class="number">0</span>])</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     fmt.Println(mp[<span class="string">&quot;arrays&quot;</span>].([]<span class="type">int</span>)[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></code></pre><h2 id="golang协程">golang协程</h2><ul><li><p><strong>进程，线程，协程之间的区别</strong></p></li><li><p><strong>获取及设置本机CPU核数</strong></p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nums := runtime.NumCPU() <span class="comment">// 获取CPU的核数</span></span><br><span class="line">fmt.Println(<span class="string">&quot;CPU核数:&quot;</span>, nums)</span><br><span class="line"></span><br><span class="line">runtime.GOMAXPROCS(nums - <span class="number">1</span>) <span class="comment">// 设置最大的CPU核数</span></span><br><span class="line">fmt.Println(<span class="string">&quot;CPU核数:&quot;</span>, runtime.GOMAXPROCS(<span class="number">0</span>))</span><br></pre></td></tr></table></figure><ol><li>以上两种方式 一个属获取本机cpu核数，一个是（<strong>runtime.GOMAXPROCS 函数</strong>）设置项目中的最大协程数且返回调用之前的最大线程数（即之前的 GOMAXPROCS 值）。当传入0的时候，表示只获取值而不修改</li></ol></li></ul><h3 id="协程的创建方式">协程的创建方式</h3><ul><li><strong>使用go关键字创建协程</strong><br>使用<strong>go</strong>关键字即可创建, go后面跟着协程要执行的任务函数  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> text()</span><br></pre></td></tr></table></figure></li></ul><h3 id="协程的同步方式">协程的同步方式</h3><h4 id="使用sync-WaitGroup来等待协程执行完毕">使用sync.WaitGroup来等待协程执行完毕</h4><ul><li><p>sync.WaitGroup是一种类型 其有三种函数 Add()、Done()、Wait(), 其中Add()用来增加协程的数量，Done()用来减少协程的数量，Wait()用来等待所有的协程执行完毕。在代码中使用方式如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wd sync.WaitGroup <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;test1() 执行%d次\n&quot;</span>, i)</span><br><span class="line">        time.Sleep(time.Millisecond * <span class="number">100</span>) <span class="comment">// 延迟100毫秒</span></span><br><span class="line">    &#125;</span><br><span class="line">    wd.Done() <span class="comment">// 通知main()函数结束 计数器减1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;test2() 执行%d次\n&quot;</span>, i)</span><br><span class="line">        time.Sleep(time.Millisecond * <span class="number">50</span>) <span class="comment">// 延迟50毫秒</span></span><br><span class="line">    &#125;</span><br><span class="line">    wd.Done() <span class="comment">// 通知main()函数结束</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    wd.Add(<span class="number">1</span>)  <span class="comment">// 计数器加1</span></span><br><span class="line">    <span class="keyword">go</span> test1() <span class="comment">// 使用go关键字启动一个协程</span></span><br><span class="line">    wd.Add(<span class="number">1</span>)  <span class="comment">// 计数器加1</span></span><br><span class="line">    <span class="keyword">go</span> test2() <span class="comment">// 使用go关键字启动另一个协程</span></span><br><span class="line">    wd.Wait()  <span class="comment">// 等待两个协程执行完毕</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;main() 执行完毕&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>使用互斥锁 Mutex</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    mu   sync.Mutex                           <span class="comment">// 互斥锁</span></span><br><span class="line">    cond             = sync.NewCond(&amp;mu)      <span class="comment">// 条件变量</span></span><br><span class="line">    ch   <span class="keyword">chan</span> <span class="type">string</span> = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">100</span>) <span class="comment">// 管道</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">producer</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">200</span>; i++ &#123;</span><br><span class="line">        mu.Lock()</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(ch) == <span class="built_in">cap</span>(ch) &#123; <span class="comment">// 如果管道已满，等待</span></span><br><span class="line">            cond.Wait()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 生产者生产数据</span></span><br><span class="line">        s := <span class="string">&quot;生产者生产&quot;</span> + strconv.Itoa(i)</span><br><span class="line">        fmt.Println(s)</span><br><span class="line">        ch &lt;- s       <span class="comment">// 放入管道</span></span><br><span class="line">        cond.Signal() <span class="comment">// 通知消费者</span></span><br><span class="line">        mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mu.Lock()</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(ch) == <span class="built_in">cap</span>(ch) &#123; <span class="comment">// 等待所有生产者完成</span></span><br><span class="line">        cond.Wait()</span><br><span class="line">    &#125;</span><br><span class="line">    ch &lt;- <span class="string">&quot;结束&quot;</span>    <span class="comment">// 生产者结束</span></span><br><span class="line">    cond.Signal() <span class="comment">// 通知消费者</span></span><br><span class="line">    mu.Unlock()</span><br><span class="line">    wg.Done() <span class="comment">// 生产者完成</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consumer</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        mu.Lock()</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(ch) == <span class="number">0</span> &#123; <span class="comment">// 如果管道为空，等待</span></span><br><span class="line">            cond.Wait()</span><br><span class="line">        &#125;</span><br><span class="line">        s := &lt;-ch <span class="comment">// 从管道取出数据</span></span><br><span class="line">        mu.Unlock()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> s == <span class="string">&quot;结束&quot;</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(<span class="string">&quot;消费者消费&quot;</span>, s)</span><br><span class="line">        </span><br><span class="line">        cond.Signal() <span class="comment">// 通知生产者</span></span><br><span class="line">    &#125;</span><br><span class="line">    wg.Done() <span class="comment">// 消费者完成</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> consumer() <span class="comment">// 启动消费者</span></span><br><span class="line"></span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> producer()</span><br><span class="line"></span><br><span class="line">    wg.Wait()</span><br><span class="line">    <span class="built_in">close</span>(ch) <span class="comment">// 关闭管道</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>使用读写锁 RWMutex</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    wg      sync.WaitGroup</span><br><span class="line">    numChan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1000</span>)</span><br><span class="line">    mutex   sync.RWMutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reader</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mutex.RLock()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(numChan); i++ &#123;</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">    &#125;</span><br><span class="line">    mutex.RUnlock()</span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writer</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mutex.Lock()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">        numChan &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">    mutex.Unlock()</span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> writer()</span><br><span class="line">    <span class="keyword">go</span> writer()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> reader()</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="golang管道">golang管道</h2><ul><li><p><strong>管道(channel)在go中是一种类型，并且是引用类型，声明方式如下:</strong></p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="type">int</span> <span class="comment">// 声明一个管道，其中int为管道中数据的类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ch3 <span class="keyword">chan</span> []<span class="type">int</span> <span class="comment">// 声明一个管道，其中[]int为管道中数据的类型</span></span><br></pre></td></tr></table></figure></li><li><p><strong>因为是引用类型，必须要创建空间才能使用管道，创建管道的函数有make()和new()两种，区别如下:</strong></p><ul><li>make()函数：make()函数用于创建管道，其返回值是一个管道，并且会初始化管道的缓冲区大小，如果缓冲区大小为0，则表示无缓冲区，如果缓冲区大小大于0，则表示有缓冲区。</li><li>new()函数：new()函数用于创建管道，其返回值是一个指针，指向一个管道，但是并不会初始化管道的缓冲区大小。</li></ul>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 格式是：make(chan 数据类型, 缓冲区大小)</span></span><br><span class="line"><span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="type">int</span> = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure></li><li><p><strong>管道的操作方式</strong></p><ol><li>接受与发送都使用**&lt;-**运算符</li><li>发送数据到管道：使用管道的 &lt;- 运算符，将数据发送到管道中。</li></ol>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- <span class="number">10</span> <span class="comment">// 发送数据10到管道ch</span></span><br></pre></td></tr></table></figure><ol start="3"><li>从管道接收数据：使用管道的 &lt;- 运算符，从管道中接收数据。</li></ol>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x := &lt;-ch <span class="comment">// 从管道ch接收数据并赋值给变量x</span></span><br></pre></td></tr></table></figure><ol start="4"><li>关闭管道：当管道中的数据全部被接收完毕后，需要关闭管道，以防止其他协程继续向管道中发送数据。</li></ol>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">close</span>(ch) <span class="comment">// 关闭管道ch</span></span><br></pre></td></tr></table></figure><ol start="5"><li>管道的阻塞与非阻塞：当管道中没有数据时，从管道接收数据会阻塞，直到有数据可接收。当管道中没有数据时，向管道发送数据会阻塞，直到有数据接收者。</li></ol>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 管道的阻塞</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">2</span>)</span><br><span class="line">ch &lt;- <span class="number">2</span></span><br><span class="line">ch &lt;- <span class="number">3</span></span><br><span class="line">ch &lt;- <span class="number">4</span> <span class="comment">// 此时管道中有三个数据，但是只有两个接收者，所以此时会阻塞，直到有接收者接收数据</span></span><br><span class="line"></span><br><span class="line">ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>) <span class="comment">// 无缓冲区的管道</span></span><br><span class="line">m := &lt;-ch1 <span class="comment">// 此时会阻塞，直到有数据被发送到管道中</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="6"><li>管道的容量：管道的容量表示管道中可以存储的数据的数量，如果管道的容量为0，则表示无缓冲区，如果管道的容量大于0，则表示有缓冲区。</li></ol>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cap</span>(ch) <span class="comment">// 获取管道ch的容量</span></span><br></pre></td></tr></table></figure><ol start="7"><li>管道的长度：管道的长度表示管道中当前存储的数据的数量。</li></ol>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">len</span>(ch) <span class="comment">// 获取管道ch的长度</span></span><br></pre></td></tr></table></figure><ol start="8"><li>管道的遍历：<ol><li>管道的遍历可以使用for range语句，遍历管道中的数据，在遍历前需要先关闭管道。否则会报错 all goroutines are asleep - deadlock! <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line">ch &lt;- <span class="number">1</span></span><br><span class="line">ch &lt;- <span class="number">2</span></span><br><span class="line">ch &lt;- <span class="number">3</span></span><br><span class="line"><span class="built_in">close</span>(ch) <span class="comment">// 关闭管道</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历管道</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> ch &#123; <span class="comment">// 管道没有key值</span></span><br><span class="line">    fmt.Println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>使用for循环遍历管道中的数据，在遍历前可以不关闭管道 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line">ch &lt;- <span class="number">1</span></span><br><span class="line">ch &lt;- <span class="number">2</span>                </span><br><span class="line">ch &lt;- <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历管道</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">3</span>; i ++ &#123;</span><br><span class="line">    fmt.Println(&lt;-ch) <span class="comment">// 从管道中接收数据并打印</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol></li><li><p><strong>管道的应用</strong></p><ol><li>生产者-消费者模型：生产者生产数据，并将数据放入管道中，消费者从管道中取出数据进行处理。</li></ol> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    mu   sync.Mutex                           <span class="comment">// 互斥锁</span></span><br><span class="line">    cond             = sync.NewCond(&amp;mu)      <span class="comment">// 条件变量</span></span><br><span class="line">    ch   <span class="keyword">chan</span> <span class="type">string</span> = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">100</span>) <span class="comment">// 管道</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">producer</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">200</span>; i++ &#123;</span><br><span class="line">        mu.Lock()</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(ch) == <span class="built_in">cap</span>(ch) &#123; <span class="comment">// 如果管道已满，等待</span></span><br><span class="line">            cond.Wait()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 生产者生产数据</span></span><br><span class="line">        s := <span class="string">&quot;生产者生产&quot;</span> + strconv.Itoa(i)</span><br><span class="line">        fmt.Println(s)</span><br><span class="line">        ch &lt;- s       <span class="comment">// 放入管道</span></span><br><span class="line">        cond.Signal() <span class="comment">// 通知消费者</span></span><br><span class="line">        mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mu.Lock()</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(ch) == <span class="built_in">cap</span>(ch) &#123; <span class="comment">// 等待所有生产者完成</span></span><br><span class="line">        cond.Wait()</span><br><span class="line">    &#125;</span><br><span class="line">    ch &lt;- <span class="string">&quot;结束&quot;</span>    <span class="comment">// 生产者结束</span></span><br><span class="line">    cond.Signal() <span class="comment">// 通知消费者</span></span><br><span class="line">    mu.Unlock()</span><br><span class="line">    wg.Done() <span class="comment">// 生产者完成</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consumer</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        mu.Lock()</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(ch) == <span class="number">0</span> &#123; <span class="comment">// 如果管道为空，等待</span></span><br><span class="line">            cond.Wait()</span><br><span class="line">        &#125;</span><br><span class="line">        s := &lt;-ch <span class="comment">// 从管道取出数据</span></span><br><span class="line">        mu.Unlock()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> s == <span class="string">&quot;结束&quot;</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(<span class="string">&quot;消费者消费&quot;</span>, s)</span><br><span class="line">        </span><br><span class="line">        cond.Signal() <span class="comment">// 通知生产者</span></span><br><span class="line">    &#125;</span><br><span class="line">    wg.Done() <span class="comment">// 消费者完成</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> consumer() <span class="comment">// 启动消费者</span></span><br><span class="line"></span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> producer()</span><br><span class="line"></span><br><span class="line">    wg.Wait()</span><br><span class="line">    <span class="built_in">close</span>(ch) <span class="comment">// 关闭管道</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>引用类型与C++中的区别</strong></p><ol><li>首先在函数传参中，go语言中传参是值传递，而C++中传参是引用传递（别名），虽说go中传递引用是值传递，但是却是复制的一个类似结构体的东西，里面有一个指针，指向的内存与传入的实参是一致的，但是参数地址与实参不一致</li><li>go中引用类型有切片，map，channel等</li></ol></li><li><p>select多路复用与管道的结合</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    wg      sync.WaitGroup</span><br><span class="line">    numChan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1000</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    intChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">    stringChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        intChan &lt;- i</span><br><span class="line">        stringChan &lt;- strconv.Itoa(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> v := &lt;-intChan:</span><br><span class="line">            fmt.Printf(<span class="string">&quot;Received int value: %d\n&quot;</span>, v)</span><br><span class="line">        <span class="keyword">case</span> k := &lt;-stringChan:</span><br><span class="line">            fmt.Printf(<span class="string">&quot;Received string value: %s\n&quot;</span>, k)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;No more values&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>select与操作系统的IOselect有联系吗？<br>没什么联系，操作系统的select是IO多路复用，每次调用得到一组就绪的文件描述符，然后程序逐个处理。golang这个select就是runtime.selectgo函数，实现的是channel批量监听，但是每次等待成功后只处理一个channel。两者互不依赖，有点像的话，也就都是批量监听了。</li></ol></li></ul><h3 id="管道底层的数据结构">管道底层的数据结构</h3><ul><li>首先管道支持<strong>多个协程访问</strong>，所以底层肯定有<strong>锁</strong>，其次管道可能会有缓冲区，所以需要<strong>指向缓冲区的指针</strong>以及<strong>最大长度</strong>还有已经存储了<strong>多少数据</strong>以及<strong>每个元素占用内存大小和其类型</strong>，<br>由于管道会阻塞所以有<strong>两个队列，发送队列和接受队列</strong>，这两个队列来存储被阻塞的协程，由于是基于缓冲区的，所以会有一个<strong>写下标和读下标</strong>，写下标表示管道中可以写入数据的位置，<br>读下标表示管道中可以读取数据的位置，最后还有一个标志<strong>是否关闭的状态位</strong>，其内容大致如下：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">stuct <span class="keyword">chan</span> &#123;</span><br><span class="line">    lock mutex <span class="comment">// 锁</span></span><br><span class="line">    qcount <span class="type">uint</span> <span class="comment">// 队列长度</span></span><br><span class="line">    dataqsiz <span class="type">uint</span> <span class="comment">// 缓冲区大小</span></span><br><span class="line">    buf unsafe.Pointer <span class="comment">// 指向缓冲区的指针    </span></span><br><span class="line">    elemsize <span class="type">uint16</span> <span class="comment">// 每个元素的大小</span></span><br><span class="line">    closed <span class="type">uint32</span> <span class="comment">// 是否关闭的状态位</span></span><br><span class="line">    sendx <span class="type">uint</span> <span class="comment">// 发送队列的下标</span></span><br><span class="line">    recvx <span class="type">uint</span> <span class="comment">// 接收队列的下标</span></span><br><span class="line">    recvq waitq <span class="comment">// 接收队列</span></span><br><span class="line">    sendq waitq <span class="comment">// 发送队列</span></span><br><span class="line">    elemtype *_type <span class="comment">// 每个元素的类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="select的底层原理">select的底层原理</h3><ul><li>会被编译器翻译成执行selectgo函数，其函数由6个参数和两个返回值</li><li>参数：首先由一个指向一个数组，里面装的是select中所有的case分支，第二个参数是指向一个uint16类型的数组，其大小等于case的两倍。实际会被分为两个数组，一个数组用来乱序轮询（保证公平性），一个用来对所有加锁操作进行排序（避免死锁），第四第五个参数分别表示send和recv操作的分支分别有多少个<br>block参数则是表示多路select是否要阻塞等待(对应是否由default分支决定)</li><li>返回值：第一个返回值表示哪个分支被执行（对应数组下标，如果阻塞为-1），第二个表示是实际收到了一个值还是得到了0值<br>大致如下：<br><img src="../assets/2024-11-29-go%E7%9A%84%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/img.jpg" alt="alt text"></li></ul><h3 id="select的执行过程">select的执行过程</h3><ul><li>首先对所有管道进行顺序加锁，然后按照乱序的轮询顺序检查所有channel的等待队列和缓冲区，接下来就是channel相关操作的判断看是否需要阻塞，如果阻塞了就要挂起等待，当有数据时就按序解锁并唤醒执行，执行完后按序加锁，阻塞协程离开队列最后按序解锁</li></ul><h2 id="go的反射机制">go的反射机制</h2><h3 id="反射机制的定义">反射机制的定义</h3><ul><li>在计算机学中，反射式编程（英语：reflective programming）或反射（英语：reflection），是指计算机程序(runtime）可以访问、检测和修改它本身状态或行为的一种能力。用比喻来说，反射就是程序在运行的时候能够“观察”并且修改自己的行为。</li></ul><h3 id="反射的重要性">反射的重要性</h3><p>反射在许多方面都非常有用，比如：</p><ol><li><strong>动态编程</strong>: 通过反射，你可以动态地创建对象，调用方法，甚至构建全新的类型。</li><li><strong>框架与库开发</strong>: 很多流行的Go框架，如Gin、Beego等，都在内部使用反射来实现灵活和高度可定制的功能。</li><li><strong>元编程</strong>: 你可以写出可以自我分析和自我修改的代码，这在配置管理、依赖注入等场景中尤为有用。</li></ol><h3 id="反射的分类">反射的分类</h3><p>反射在Go中主要有两个方向：</p><ol><li>类型反射（Type Reflection）: 主要关注于程序运行时获取变量的类型信息。</li><li>值反射（Value Reflection）: 主要关注于程序运行时获取或设置变量的值</li></ol><h4 id="类型反射：">类型反射：</h4><ul><li>通过reflect库中的Typeof函数实现，<strong>Kind就是获取其底层的类型</strong>，比如你定义一个Person结构体，<strong>Kind就是struct而Name就是Person</strong></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码示例：类型反射</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inspectType</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    t := reflect.TypeOf(x)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Type Name:&quot;</span>, t.Name()) <span class="comment">// 名称</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Type Kind:&quot;</span>, t.Kind()) <span class="comment">// 种类</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    inspectType(<span class="number">42</span>)     <span class="comment">// Type Name: int, Type Kind: int</span></span><br><span class="line">    inspectType(<span class="string">&quot;hello&quot;</span>)<span class="comment">// Type Name: string, Type Kind: string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="值反射">值反射</h4><ul><li>通过reflect库中的ValueOf函数实现</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码示例：值反射</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inspectValue</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    v := reflect.ValueOf(x)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Value:&quot;</span>, v)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Is Zero:&quot;</span>, v.IsZero())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    inspectValue(<span class="number">42</span>)       <span class="comment">// Value: 42, Is Zero: false</span></span><br><span class="line">    inspectValue(<span class="string">&quot;&quot;</span>)       <span class="comment">// Value: , Is Zero: true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反射的应用">反射的应用</h3><h4 id="与空接口配合使用，得到真实数据">与空接口配合使用，得到真实数据</h4><ul><li>可以使用类型断言 也能使用反射来实现</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectValue</span><span class="params">(value <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 想要实现value根据对应类型得到不同操作</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用反射来获取值</span></span><br><span class="line">  v := reflect.ValueOf(value)</span><br><span class="line">  <span class="keyword">switch</span> v.Kind() &#123;</span><br><span class="line">  <span class="keyword">case</span> reflect.Int:</span><br><span class="line">    fmt.Println(<span class="string">&quot;int value:&quot;</span>, v.Int()+<span class="number">10</span>)</span><br><span class="line">  <span class="keyword">case</span> reflect.String:</span><br><span class="line">    fmt.Println(<span class="string">&quot;string value:&quot;</span>, v.String()+<span class="string">&quot; world&quot;</span>)</span><br><span class="line">  <span class="keyword">case</span> reflect.Bool:</span><br><span class="line">    fmt.Println(<span class="string">&quot;bool value:&quot;</span>, !v.Bool())</span><br><span class="line">  <span class="keyword">case</span> reflect.Float32:</span><br><span class="line">    fmt.Println(<span class="string">&quot;float32 value:&quot;</span>, v.Float()+<span class="number">1.0</span>)</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;unknown type&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用类型断言也能实现</span></span><br><span class="line">  x, ok := value.(<span class="type">int</span>)</span><br><span class="line">  <span class="keyword">if</span> ok &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;int value:&quot;</span>, x+<span class="number">10</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  y, ok := value.(<span class="type">string</span>)</span><br><span class="line">  <span class="keyword">if</span> ok &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;string value:&quot;</span>, y+<span class="string">&quot; world&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  z, ok := value.(<span class="type">bool</span>)</span><br><span class="line">  <span class="keyword">if</span> ok &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;bool value:&quot;</span>, !z)</span><br><span class="line">  &#125;</span><br><span class="line">  h, ok := value.(<span class="type">float32</span>)</span><br><span class="line">  <span class="keyword">if</span> ok &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;float32 value:&quot;</span>, h+<span class="number">1.0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">10</span></span><br><span class="line">  <span class="keyword">var</span> b <span class="type">string</span> = <span class="string">&quot;hello&quot;</span></span><br><span class="line">  <span class="keyword">var</span> c <span class="type">bool</span> = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">var</span> d <span class="type">float32</span> = <span class="number">3.14</span></span><br><span class="line"></span><br><span class="line">  reflectValue(a)</span><br><span class="line">  reflectValue(b)</span><br><span class="line">  reflectValue(c)</span><br><span class="line">  reflectValue(d)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="通过反射设置变量的值">通过反射设置变量的值</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 想要修改传入的值（前提参数为空接口）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误用法1：直接传入值，而不是指针</span></span><br><span class="line"><span class="comment">// 错误原因 reflect.Value.SetInt using unaddressable value</span></span><br><span class="line"><span class="comment">// func SetVal(val interface&#123;&#125;) &#123;</span></span><br><span class="line"><span class="comment">// // 首先 获取传入值</span></span><br><span class="line"><span class="comment">// v := reflect.ValueOf(val)</span></span><br><span class="line"><span class="comment">// // 然后根据获取的值的类型进行修改使得改变值</span></span><br><span class="line"><span class="comment">// if v.Kind() == reflect.Int &#123;</span></span><br><span class="line"><span class="comment">// v.SetInt(100)</span></span><br><span class="line"><span class="comment">// &#125; else if v.Kind() == reflect.String &#123;</span></span><br><span class="line"><span class="comment">// v.SetString(&quot;new string&quot;)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetVal</span><span class="params">(val <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 首先 获取传入值</span></span><br><span class="line">  v := reflect.ValueOf(val).Elem()</span><br><span class="line">  fmt.Println(v.Kind())</span><br><span class="line">  <span class="comment">// 然后根据获取的值的类型进行修改使得改变值</span></span><br><span class="line">  <span class="keyword">if</span> v.Kind() == reflect.Int &#123;</span><br><span class="line">    v.SetInt(<span class="number">100</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> v.Kind() == reflect.String &#123;</span><br><span class="line">    v.SetString(<span class="string">&quot;new string&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line">  b := <span class="string">&quot;string&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 错误用法</span></span><br><span class="line">  <span class="comment">// SetVal(a)</span></span><br><span class="line">  <span class="comment">// SetVal(b)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 正确用法</span></span><br><span class="line">  SetVal(&amp;a)</span><br><span class="line">  SetVal(&amp;b)</span><br><span class="line"></span><br><span class="line">  fmt.Println(a)</span><br><span class="line">  fmt.Println(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="反射获取结构体的值与类型">反射获取结构体的值与类型</h4><h5 id="获取属性">获取属性</h5><ul><li>使用Filed(i)来获取第i个字段</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name    <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">  Age     <span class="type">int</span>    <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">  Address <span class="type">string</span> <span class="string">`json:&quot;address&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetStruct</span><span class="params">(p <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 获取类型指定字段类型</span></span><br><span class="line">  t := reflect.TypeOf(p)</span><br><span class="line">  <span class="comment">// 使用Filed</span></span><br><span class="line">  field0 := t.Field(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  fmt.Println(<span class="string">&quot;第一个字段名&quot;</span>, field0.Name)</span><br><span class="line">  fmt.Println(<span class="string">&quot;第一个字段类型&quot;</span>, field0.Type)</span><br><span class="line">  fmt.Println(<span class="string">&quot;第一个字段标签&quot;</span>, field0.Tag.Get(<span class="string">&quot;json&quot;</span>))</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  person1 := Person&#123;<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>, <span class="string">&quot;China&quot;</span>&#125;</span><br><span class="line">  GetStruct(person1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用FiledByName(name)来获取指定字段</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name    <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">  Age     <span class="type">int</span>    <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">  Address <span class="type">string</span> <span class="string">`json:&quot;address&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetStruct</span><span class="params">(p <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 获取类型指定字段类型</span></span><br><span class="line">  t := reflect.TypeOf(p)</span><br><span class="line">  <span class="comment">// 使用FiledByName获取指定字段</span></span><br><span class="line">  field0, ok := t.FieldByName(<span class="string">&quot;Age&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span> ok &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;第一个字段名&quot;</span>, field0.Name)</span><br><span class="line">    fmt.Println(<span class="string">&quot;第一个字段类型&quot;</span>, field0.Type)</span><br><span class="line">    fmt.Println(<span class="string">&quot;第一个字段标签&quot;</span>, field0.Tag.Get(<span class="string">&quot;json&quot;</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  person1 := Person&#123;<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>, <span class="string">&quot;China&quot;</span>&#125;</span><br><span class="line">  GetStruct(person1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过NumField()来获取结构体的字段数量，并且遍历所有字段</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name    <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">  Age     <span class="type">int</span>    <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">  Address <span class="type">string</span> <span class="string">`json:&quot;address&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetStruct</span><span class="params">(p <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 获取类型指定字段类型</span></span><br><span class="line">  t := reflect.TypeOf(p)</span><br><span class="line">  <span class="comment">// 使用FiledByName获取指定字段</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumField(); i++ &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;第%d个字段的名称为：%s\n&quot;</span>, i, t.Field(i).Name)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;第%d个字段的类型为：%s\n&quot;</span>, i, t.Field(i).Type)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  person1 := Person&#123;<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>, <span class="string">&quot;China&quot;</span>&#125;</span><br><span class="line">  GetStruct(person1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>获取值也有上述三种方法，不过反射的时候改为Valueof，例如</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name    <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">  Age     <span class="type">int</span>    <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">  Address <span class="type">string</span> <span class="string">`json:&quot;address&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetStruct</span><span class="params">(p <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 获取类型指定字段类型</span></span><br><span class="line">  t := reflect.ValueOf(p)</span><br><span class="line">  <span class="comment">// 使用FiledByName获取指定字段</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumField(); i++ &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;第%d个字段的值为：%v\n&quot;</span>, i, t.Field(i))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  person1 := Person&#123;<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>, <span class="string">&quot;China&quot;</span>&#125;</span><br><span class="line">  GetStruct(person1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>通过反射修改结构体值，也是与修改变量类似</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name    <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">  Age     <span class="type">int</span>    <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">  Address <span class="type">string</span> <span class="string">`json:&quot;address&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> GetPerson() <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> str = fmt.Sprintf(<span class="string">&quot;%+v\n&quot;</span>, p)</span><br><span class="line">  <span class="keyword">return</span> str</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span></span> SetPerson(name <span class="type">string</span>, age <span class="type">int</span>, address <span class="type">string</span>) &#123;</span><br><span class="line">  p.Name = name</span><br><span class="line">  p.Age = age</span><br><span class="line">  p.Address = address</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> Print() &#123;</span><br><span class="line">  fmt.Println(p.GetPerson())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetStructField</span><span class="params">(p <span class="keyword">interface</span>&#123;&#125;, key <span class="type">string</span>, str <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 获取类型指定字段类型</span></span><br><span class="line">  v := reflect.ValueOf(p)</span><br><span class="line">  <span class="comment">// 调用指定名字的方法有参数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> v.Kind() != reflect.Ptr &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;not a pointer&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> v.Elem().Kind() != reflect.Struct &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;not a struct pointer&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  v.Elem().FieldByName(key).SetString(str)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  person1 := Person&#123;<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>, <span class="string">&quot;China&quot;</span>&#125;</span><br><span class="line">  fmt.Println(person1.GetPerson())</span><br><span class="line">  SetStructField(&amp;person1, <span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Jerry&quot;</span>)</span><br><span class="line">  fmt.Println(person1.GetPerson())</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="获取方法">获取方法</h5><ul><li>使用Method(i)来获取方法，其中方法的顺序是通过Ascii码确定的+NumMethod()来获取方法数量</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name    <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">  Age     <span class="type">int</span>    <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">  Address <span class="type">string</span> <span class="string">`json:&quot;address&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> GetPerson() <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> str = fmt.Sprintf(<span class="string">&quot;%+v\n&quot;</span>, p)</span><br><span class="line">  <span class="keyword">return</span> str</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span></span> SetPerson(name <span class="type">string</span>, age <span class="type">int</span>, address <span class="type">string</span>) &#123;</span><br><span class="line">  p.Name = name</span><br><span class="line">  p.Age = age</span><br><span class="line">  p.Address = address</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> Print() &#123;</span><br><span class="line">  fmt.Println(p.GetPerson())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetStructMethod</span><span class="params">(p <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 获取类型指定字段类型</span></span><br><span class="line">  t := reflect.TypeOf(p)</span><br><span class="line">  <span class="comment">// 使用FiledByName获取指定字段</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumMethod(); i++ &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;第%d个方法的名称为：%v\n&quot;</span>, i, t.Method(i).Name)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;第%d个方法的类型为：%v\n&quot;</span>, i, t.Method(i).Type)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  person1 := Person&#123;<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>, <span class="string">&quot;China&quot;</span>&#125;</span><br><span class="line">  GetStructMethod(person1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>通过MethodByName(str)来获取</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name    <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">  Age     <span class="type">int</span>    <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">  Address <span class="type">string</span> <span class="string">`json:&quot;address&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> GetPerson() <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> str = fmt.Sprintf(<span class="string">&quot;%+v\n&quot;</span>, p)</span><br><span class="line">  <span class="keyword">return</span> str</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span></span> SetPerson(name <span class="type">string</span>, age <span class="type">int</span>, address <span class="type">string</span>) &#123;</span><br><span class="line">  p.Name = name</span><br><span class="line">  p.Age = age</span><br><span class="line">  p.Address = address</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> Print() &#123;</span><br><span class="line">  fmt.Println(p.GetPerson())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetStructMethod</span><span class="params">(p <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 获取类型指定字段类型</span></span><br><span class="line">  t := reflect.TypeOf(p)</span><br><span class="line">  <span class="comment">// 使用FiledByName获取指定字段</span></span><br><span class="line">  method1, ok := t.MethodByName(<span class="string">&quot;Print&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span> ok &#123;</span><br><span class="line">    fmt.Println(method1.Name)</span><br><span class="line">    fmt.Println(method1.Type)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  person1 := Person&#123;<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>, <span class="string">&quot;China&quot;</span>&#125;</span><br><span class="line">  GetStructMethod(person1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="反射调用方法">反射调用方法</h5><p>首先必须通过反射获取值也就是使用felect.ValueOf()，然后通过反射调用方法，调用方法的语法如下：修改方法必须传入引用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name    <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">  Age     <span class="type">int</span>    <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">  Address <span class="type">string</span> <span class="string">`json:&quot;address&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> GetPerson() <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> str = fmt.Sprintf(<span class="string">&quot;%+v\n&quot;</span>, p)</span><br><span class="line">  <span class="keyword">return</span> str</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span></span> SetPerson(name <span class="type">string</span>, age <span class="type">int</span>, address <span class="type">string</span>) &#123;</span><br><span class="line">  p.Name = name</span><br><span class="line">  p.Age = age</span><br><span class="line">  p.Address = address</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> Print() &#123;</span><br><span class="line">  fmt.Println(p.GetPerson())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetStructMethod</span><span class="params">(p <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 获取类型指定字段类型</span></span><br><span class="line">  v := reflect.ValueOf(p)</span><br><span class="line">  <span class="comment">// 调用指定名字的方法有参数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 首先得定义切片</span></span><br><span class="line">  <span class="keyword">var</span> args []reflect.Value</span><br><span class="line">  args = <span class="built_in">append</span>(args, reflect.ValueOf(<span class="string">&quot;小黑&quot;</span>), reflect.ValueOf(<span class="number">18</span>), reflect.ValueOf(<span class="string">&quot;Earth&quot;</span>))</span><br><span class="line"></span><br><span class="line">  v.MethodByName(<span class="string">&quot;SetPerson&quot;</span>).Call(args)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 无参数</span></span><br><span class="line"></span><br><span class="line">  v.MethodByName(<span class="string">&quot;Print&quot;</span>).Call(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  person1 := Person&#123;<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>, <span class="string">&quot;China&quot;</span>&#125;</span><br><span class="line">  GetStructMethod(&amp;person1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="go的文件操作">go的文件操作</h2><h3 id="使用os打开并使用其返回的file读取文件">使用os打开并使用其返回的file读取文件</h3><ul><li><strong>注意倒数第三行拷贝数据的写法</strong></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;io&quot;</span></span><br><span class="line">  <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 可以使用相对路径，也可以使用绝对路径（此方法打开是只读）</span></span><br><span class="line">  file, err := os.Open(<span class="string">&quot;./main.go&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 打开一定要记得关闭</span></span><br><span class="line">  <span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开始读取文件 使用for循环读，并且需要传入存储读取数据的切片</span></span><br><span class="line">  <span class="comment">// 最终读取数据的存放位置</span></span><br><span class="line">  <span class="keyword">var</span> endSlice []<span class="type">byte</span></span><br><span class="line">  <span class="comment">// 临时读取数据的存放位置</span></span><br><span class="line">  tmpSlice := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">128</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    n, err := file.Read(tmpSlice)</span><br><span class="line">    <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;文件读取完毕&quot;</span>)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;文件读取失败&quot;</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    endSlice = <span class="built_in">append</span>(endSlice, tmpSlice[:n]...) <span class="comment">// 注意此处写法，必须要有:n以及...，只有这样才能读取完整数据，否则会读取到随机数据，因为tmpSlice可能未读满</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fmt.Println(<span class="type">string</span>(endSlice))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="使用bufio读取数据">使用bufio读取数据</h3><ul><li><strong>用此方法时候注意在读取到EOF的时候也要累加数据，否则会丢失数据</strong></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;bufio&quot;</span></span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;io&quot;</span></span><br><span class="line">  <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 可以使用相对路径，也可以使用绝对路径（此方法打开是只读）</span></span><br><span class="line">  file, err := os.Open(<span class="string">&quot;./main.go&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 打开一定要记得关闭</span></span><br><span class="line">  <span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开始读取文件 使用for循环读，使用bufio来读取</span></span><br><span class="line">  reader := bufio.NewReader(file)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> ans <span class="type">string</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    line, err := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>) <span class="comment">// 读取一行</span></span><br><span class="line">    <span class="keyword">if</span> err == io.EOF &#123;                   <span class="comment">// 读取到文件末尾</span></span><br><span class="line">      <span class="comment">// 注意还此时line可能还有数据</span></span><br><span class="line">      ans += line</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ans += line <span class="comment">// 读取到一行数据，添加到ans中</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fmt.Println(ans) <span class="comment">// 输出ans</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>以上两种都是流的读取方法</li><li>下述是一次读取整个文件的方法</li></ul><h3 id="使用ioutil读取文件">使用ioutil读取文件</h3><ul><li><strong>此方法在go1.16以上版本被弃用，可以使用os.ReadFile()代替,因为这个实现上就是用了os.ReadFile</strong></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 开始读取文件</span></span><br><span class="line">  slice, err := os.ReadFile(<span class="string">&quot;./main.go&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打印文件内容</span></span><br><span class="line">  fmt.Println(<span class="type">string</span>(slice))</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="os-openfile-和file-Write-写入文件">os.openfile()和file.Write()写入文件</h3><p><img src="1730192967697.jpg" alt="alt text"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;os&quot;</span></span><br><span class="line">  <span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 开始读取文件</span></span><br><span class="line">  <span class="comment">// 三个参数分别是文件名、打开模式、权限（用于Linux）</span></span><br><span class="line">  file, err := os.OpenFile(<span class="string">&quot;./test.txt&quot;</span>, os.O_CREATE|os.O_RDWR, <span class="number">0666</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 写入文件 方式以一</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    file.WriteString(<span class="string">&quot;hello world&quot;</span> + strconv.Itoa(i) + <span class="string">&quot;\r\n&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  str := <span class="string">&quot;omg no hello world \r\n&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 写入文件方式二</span></span><br><span class="line">  file.Write([]<span class="type">byte</span>(str))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用bufio-writer写入文件">使用bufio.writer写入文件</h3><ul><li>总体流程是这样的：<ol><li>先通过os.OpenFile打开文件，并通过bufio.NewWriter创建一个bufio.Writer</li><li>然后通过WriteString或Write方法写入数据（此时会先<strong>写入缓存区</strong>）</li><li>最后通过Flush方法将缓存区的数据写入文件</li><li>最后关闭文件</li></ol></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;bufio&quot;</span></span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 开始读取文件</span></span><br><span class="line">  <span class="comment">// 三个参数分别是文件名、打开模式、权限（用于Linux）</span></span><br><span class="line">  file, err := os.OpenFile(<span class="string">&quot;./test.txt&quot;</span>, os.O_CREATE|os.O_RDWR|os.O_APPEND, <span class="number">0666</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">  writer := bufio.NewWriter(file)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 写入缓存区</span></span><br><span class="line">  writer.WriteString(<span class="string">&quot;hello world zxsssn\r\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 写入文件</span></span><br><span class="line">  writer.Flush()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="使用os-WriteFile-写入文件">使用os.WriteFile()写入文件</h3><ul><li>此方法虽简单但会清空文件里的内容再写入</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  err := os.WriteFile(<span class="string">&quot;./test.txt&quot;</span>, []<span class="type">byte</span>(<span class="string">&quot;hello world&quot;</span>), <span class="number">0666</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="go排序方法">go排序方法</h2><h3 id="排序整数，浮点数和字符串切片">排序整数，浮点数和字符串切片</h3><p>对于 []int, []float, []string 这种元素类型是基础类型的切片使用 sort 包提供的下面几个函数进行排序。</p><ul><li>sort.Ints(slice)</li><li>sort.Float64s(slice)</li><li>sort.Strings(slice)</li></ul><h3 id="使用自定义比较器排序">使用自定义比较器排序</h3><ul><li>使用 sort.Slice 函数排序，它使用一个用户提供的函数来对序列进行排序，函数类型为 func(i, j int) bool，其中参数 i, j 是序列中的索引。</li><li>sort.SliceStable 在排序切片时会保留相等元素的原始顺序。</li><li>上面两个函数让我们可以排序结构体切片 (order by struct field value)。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">  Key   <span class="type">string</span></span><br><span class="line">  Value <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">  people := []Person&#123;</span><br><span class="line">    &#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Cob&quot;</span>, <span class="number">30</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Vharlie&quot;</span>, <span class="number">20</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Favid&quot;</span>, <span class="number">35</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Eve&quot;</span>, <span class="number">28</span>&#125;,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fmt.Println(people)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用slice排序</span></span><br><span class="line">  sort.Slice(people, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> people[i].Key &lt; people[j].Key</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  fmt.Println(people)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用sliceStable降序排序</span></span><br><span class="line">    sort.SliceStable(people, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> people[i].Key &gt; people[j].Key</span><br><span class="line">  &#125;)</span><br><span class="line">  fmt.Println(people)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="排序任意数据结构">排序任意数据结构</h3><ul><li>使用 sort.Sort 或者 sort.Stable 函数。</li><li>他们可以排序实现了 sort.Interface 接口的任意类型</li><li>也就是说每个自定义的切片中都有一些内置的接口，比如sort.Interface，sort.Interface定义了三个方法，我们可以实现这三个方法，然后传入自定义的切片进行排序。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">  Key   <span class="type">string</span></span><br><span class="line">  Value <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ByValue []Person</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByValue)</span></span> Len() <span class="type">int</span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(a) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByValue)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> a[i].Value &lt; a[j].Value &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByValue)</span></span> Swap(i, j <span class="type">int</span>)      &#123; a[i], a[j] = a[j], a[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">  people := []Person&#123;</span><br><span class="line">    &#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Cob&quot;</span>, <span class="number">30</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Vharlie&quot;</span>, <span class="number">20</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Favid&quot;</span>, <span class="number">35</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Eve&quot;</span>, <span class="number">28</span>&#125;,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fmt.Println(people)</span><br><span class="line"></span><br><span class="line">  sort.Sort(ByValue(people))</span><br><span class="line"></span><br><span class="line">  fmt.Println(people)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>也可以实现结构体内部数组的排序</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> customSort <span class="keyword">struct</span> &#123;</span><br><span class="line">    p    []*Person</span><br><span class="line">    less <span class="function"><span class="keyword">func</span><span class="params">(x, y *Person)</span></span> <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x customSort)</span></span> Len() <span class="type">int</span> &#123;<span class="built_in">len</span>(x.p)&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x customSort)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> x.less(x.p[i], x.p[j]) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x customSort)</span></span> Swap(i, j <span class="type">int</span>)      &#123; x.p[i], x.p[j] = x.p[j], x.p[i] &#125;</span><br></pre></td></tr></table></figure><ul><li>让我们定义一个根据多字段排序的函数，它主要的排序键是 Age，Age 相同了再按 Name 进行倒序排序。下面是该排序的调用，其中这个排序使用了匿名排序函数：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sort.Sort(customSort&#123;persons, <span class="function"><span class="keyword">func</span><span class="params">(x, y *Person)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.Age != y.Age &#123;</span><br><span class="line">        <span class="keyword">return</span> x.Age &lt; y.Age</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> x.Name != y.Name &#123;</span><br><span class="line">        <span class="keyword">return</span> x.Name &gt; y.Name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;&#125;)</span><br></pre></td></tr></table></figure><h3 id="排序具体的算法和复杂度">排序具体的算法和复杂度</h3><ul><li>Go 的 sort 包中所有的排序算法在最坏的情况下会做 n log n 次 比较，n 是被排序序列的长度，所以排序的时间复杂度是 O(n log n*)。其大多数的函数都是用改良后的快速排序算法实现的。</li></ul><h2 id="go序列化相关知识">go序列化相关知识</h2><h3 id="Json序列化">Json序列化</h3><ul><li>GO提供了 Marshal 方法：Go Struct转换为JSON对象，函数签名：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Marshal</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>)</span><br></pre></td></tr></table></figure><ul><li>举例</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name   <span class="type">string</span></span><br><span class="line">  Gender <span class="type">string</span></span><br><span class="line">  Age    <span class="type">uint32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 默认初始化</span></span><br><span class="line">  p := Person&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;male&quot;</span>, <span class="number">23</span>&#125;</span><br><span class="line">  fmt.Println(p)</span><br><span class="line">  fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, p) <span class="comment">//&#123;a male 23&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 指定成员初始化</span></span><br><span class="line">  p1 := Person&#123;Name: <span class="string">&quot;wsq&quot;</span>, Gender: <span class="string">&quot;male&quot;</span>&#125;</span><br><span class="line">  fmt.Println(p1) <span class="comment">//&#123;wsq male 0&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 序列化</span></span><br><span class="line">  b, _ := json.Marshal(p)</span><br><span class="line">  fmt.Println(<span class="type">string</span>(b)) <span class="comment">//&#123;&quot;Name&quot;:&quot;a&quot;,&quot;Gender&quot;:&quot;male&quot;,&quot;Age&quot;:23&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>只支持struct中导出的field才能被序列化，即首字母大写的field</li><li>GO中不是所有类型都支持序列化，其中key只支持string</li><li>无法对channel,complex,function序列化</li><li>数据中如存在循环引用，不支持序列化，因为会递归。</li><li>pointer序列化后是其指向的值或者是nil</li></ul><h3 id="Struct-Tag">Struct Tag</h3><ul><li><p>指定 JSON filed name<br>序列化后的json串中的name一般为小写，我们通过struct tag实现</p></li><li><p>指定field为empty<br>使用omitempty告诉Marshal函数，如field对应类型为zero-value，那么序列化的json对象中不包含此field</p></li><li><p>跳过field<br>仅使用&quot;-&quot;表示跳过指定的field,保护某些字段不被序列化</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name   <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">  Gender <span class="type">string</span> <span class="string">`json:&quot;gender&quot;`</span></span><br><span class="line">  Age    <span class="type">uint32</span> <span class="string">`json:&quot;age,omitempty&quot;`</span></span><br><span class="line">  Passwd <span class="type">string</span> <span class="string">`json:&quot;-&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 默认初始化</span></span><br><span class="line">  p := Person&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;male&quot;</span>, <span class="number">23</span>, <span class="string">&quot;mimi&quot;</span>&#125;</span><br><span class="line">  fmt.Println(p)</span><br><span class="line">  fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, p) <span class="comment">//&#123;a male 23&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 指定成员初始化</span></span><br><span class="line">  p1 := Person&#123;Name: <span class="string">&quot;wsq&quot;</span>, Gender: <span class="string">&quot;male&quot;</span>&#125;</span><br><span class="line">  fmt.Println(p1) <span class="comment">//&#123;wsq male 0&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 序列化</span></span><br><span class="line">  b, _ := json.Marshal(p)</span><br><span class="line">  fmt.Println(<span class="type">string</span>(b)) <span class="comment">//&#123;&quot;Name&quot;:&quot;a&quot;,&quot;Gender&quot;:&quot;male&quot;,&quot;Age&quot;:23&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 反序列化</span></span><br><span class="line">  <span class="keyword">var</span> pp Person</span><br><span class="line">  err := json.Unmarshal(b, &amp;pp)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    errors.New(<span class="string">&quot;unmarshal error&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;%T, %v\n&quot;</span>, pp, pp)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Struct Tag</span></span><br><span class="line">  <span class="comment">// 指定JSON的field name</span></span><br><span class="line">  c, _ := json.Marshal(p)</span><br><span class="line">  fmt.Println(<span class="type">string</span>(c)) <span class="comment">//&#123;&quot;name&quot;:&quot;a&quot;,&quot;gender&quot;:&quot;male&quot;,&quot;age&quot;:23&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 指定field是empty时的行为</span></span><br><span class="line">  d, _ := json.Marshal(p1)</span><br><span class="line">  fmt.Println(<span class="type">string</span>(d)) <span class="comment">//&#123;&quot;name&quot;:&quot;wsq&quot;,&quot;gender&quot;:&quot;male&quot;&#125;</span></span><br><span class="line">  <span class="comment">// 跳过指定field</span></span><br><span class="line">  importPerson := Person&#123;Name: <span class="string">&quot;wsq&quot;</span>, Passwd: <span class="string">&quot;password&quot;</span>&#125;</span><br><span class="line">  importPersonMar, _ := json.Marshal(importPerson)</span><br><span class="line">  fmt.Println(<span class="type">string</span>(importPersonMar)) <span class="comment">//&#123;&quot;name&quot;:&quot;wsq&quot;,&quot;gender&quot;:&quot;&quot;&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Json反序列化">Json反序列化</h3><ul><li>GO提供了 Unmarshal 方法：JSON对象转换为Go Struct，函数签名：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Unmarshal</span><span class="params">(data []<span class="type">byte</span>, v <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">error</span></span><br></pre></td></tr></table></figure><ul><li>举例</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name   <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">  Gender <span class="type">string</span> <span class="string">`json:&quot;gender&quot;`</span></span><br><span class="line">  Age    <span class="type">uint32</span> <span class="string">`json:&quot;age,omitempty&quot;`</span></span><br><span class="line">  Passwd <span class="type">string</span> <span class="string">`json:&quot;-&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 默认初始化</span></span><br><span class="line">  p := Person&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;male&quot;</span>, <span class="number">23</span>, <span class="string">&quot;mimi&quot;</span>&#125;</span><br><span class="line">  fmt.Println(p)</span><br><span class="line">  fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, p) <span class="comment">//&#123;a male 23&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 指定成员初始化</span></span><br><span class="line">  p1 := Person&#123;Name: <span class="string">&quot;wsq&quot;</span>, Gender: <span class="string">&quot;male&quot;</span>&#125;</span><br><span class="line">  fmt.Println(p1) <span class="comment">//&#123;wsq male 0&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 序列化</span></span><br><span class="line">  b, _ := json.Marshal(p)</span><br><span class="line">  fmt.Println(<span class="type">string</span>(b)) <span class="comment">//&#123;&quot;Name&quot;:&quot;a&quot;,&quot;Gender&quot;:&quot;male&quot;,&quot;Age&quot;:23&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 反序列化</span></span><br><span class="line">  <span class="keyword">var</span> pp Person</span><br><span class="line">  err := json.Unmarshal(b, &amp;pp)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    errors.New(<span class="string">&quot;unmarshal error&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;%T, %v\n&quot;</span>, pp, pp)</span><br></pre></td></tr></table></figure><h3 id="使用Encoder和Decoder进行序列化和反序列化">使用Encoder和Decoder进行序列化和反序列化</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">  Age  <span class="type">int</span>    <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">  person1 := Person&#123;<span class="string">&quot;张三&quot;</span>, <span class="number">30</span>&#125;</span><br><span class="line">  <span class="comment">// 编码结果暂存到 buffer</span></span><br><span class="line">  bytes1 := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">  _ = json.NewEncoder(bytes1).Encode(person1)</span><br><span class="line">  <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Print(<span class="string">&quot;json.NewEncoder 编码结果: &quot;</span>, <span class="type">string</span>(bytes1.Bytes()))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解码</span></span><br><span class="line">  str2 := bytes1.String()</span><br><span class="line">  <span class="keyword">var</span> person2 Person</span><br><span class="line">  <span class="comment">// 创建一个 string reader 作为参数</span></span><br><span class="line">  err = json.NewDecoder(strings.NewReader(str2)).Decode(&amp;person2)</span><br><span class="line">  <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;json.NewDecoder 解码结果: &quot;</span>, person2.Name, person2.Age)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="gob序列化">gob序列化</h3><ul><li>Gob 是 Go 自己的以二进制形式序列化和反序列化程序数据的格式；可以在 encoding 包中找到。 这种格式的数据简称为 Gob （即 Go binary 的缩写）。 类似于 Python 的 “pickle” 和 Java 的 “Serialization”。 Gob 通常用于远程方法调用（RPCs，参见 15.9 的 rpc 包）参数和结果的传输，以及应用程序和机器之间的数据传输。</li></ul><h4 id="Gob序列化流程">Gob序列化流程</h4><p>其调用流程和json类似</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gob1.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;bytes&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;encoding/gob&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> P <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y, Z <span class="type">int</span></span><br><span class="line">    Name    <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Q <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y *<span class="type">int32</span></span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Initialize the encoder and decoder.  Normally enc and dec would be      </span></span><br><span class="line">    <span class="comment">// bound to network connections and the encoder and decoder would      </span></span><br><span class="line">    <span class="comment">// run in different processes.      </span></span><br><span class="line">    <span class="keyword">var</span> network bytes.Buffer   <span class="comment">// Stand-in for a network connection      </span></span><br><span class="line">    enc := gob.NewEncoder(&amp;network) <span class="comment">// Will write to network.      </span></span><br><span class="line">    dec := gob.NewDecoder(&amp;network) <span class="comment">// Will read from network.      </span></span><br><span class="line">    <span class="comment">// Encode (send) the value.      </span></span><br><span class="line">    err := enc.Encode(P&#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="string">&quot;Pythagoras&quot;</span>&#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">&quot;encode error:&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Decode (receive) the value.      </span></span><br><span class="line">    <span class="keyword">var</span> q Q</span><br><span class="line">    err = dec.Decode(&amp;q)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">&quot;decode error:&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%q: &#123;%d,%d&#125;\n&quot;</span>, q.Name, *q.X, *q.Y)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:   &quot;Pythagoras&quot;: &#123;3,4&#125;</span></span><br></pre></td></tr></table></figure><p>该例子是以字节缓冲模拟网络传输的简单例子</p><h2 id="go的内置定时器的使用">go的内置定时器的使用</h2><ul><li>在go的time包中一共提供了三种定时器的使用方式：<ul><li>Timer：定时器，只执行一次</li><li>After()：定时器，只执行一次，返回一个通道，可以接收定时器的执行结果</li><li>Tick：定时器，周期性执行，返回一个通道，可以接收定时器的执行结果</li></ul></li></ul><h3 id="Ticker定时器">Ticker定时器</h3><ul><li>使用方式如下:</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  ticker := time.NewTicker(time.Second * <span class="number">1</span>) <span class="comment">// 创建一个Ticker，并且设置时间间隔为1秒</span></span><br><span class="line">  fmt.Println(<span class="string">&quot;start&quot;</span>)</span><br><span class="line">  ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="type">int</span></span><br><span class="line">    <span class="keyword">for</span> x &lt; <span class="number">10</span> &#123;</span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> &lt;-ticker.C:</span><br><span class="line">        x++</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%d\n&quot;</span>, x)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ticker.Stop()</span><br><span class="line">    ch &lt;- <span class="number">0</span></span><br><span class="line">  &#125;()</span><br><span class="line">  &lt;-ch <span class="comment">// 通过通道阻塞，让任务可以执行完指定的次数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>每次超时后，Ticker会向内部的管道发送当前时间，也就是说我们可以通过内部管道是否有新消息到来来判断是否超时。</li></ul><h3 id="Timer定时器">Timer定时器</h3><ul><li>使用方式如下:</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  Timer := time.NewTimer(time.Second * <span class="number">1</span>)</span><br><span class="line">  ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> &lt;-Timer.C:</span><br><span class="line">        fmt.Println(<span class="string">&quot;Timer expired&quot;</span>)</span><br><span class="line">        x++</span><br><span class="line">        <span class="keyword">if</span> x &lt;= <span class="number">10</span> &#123;</span><br><span class="line">          fmt.Println(x)</span><br><span class="line">          Timer.Reset(time.Second)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          ch &lt;- <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line">  &lt;-ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>思路和Ticker类似，但是只执行一次</li></ul><h3 id="After">After()</h3><ul><li>方法定义如下:</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">After</span><span class="params">(d Duration)</span></span> &lt;-<span class="keyword">chan</span> Time &#123;</span><br><span class="line">    <span class="keyword">return</span> NewTimer(d).C</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>从定义来看after函数只是timer的语法糖</p></li><li><p>使用方式如下:</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    tt := time.NewTimer(time.Second * <span class="number">2</span>)</span><br><span class="line">    &lt;-tt.C</span><br><span class="line">    fmt.Println(<span class="string">&quot;over.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    &lt;-time.After(time.Second * <span class="number">4</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;再等待4秒退出。tt 没有终止，打印出 over 后会看见在继续执行...&quot;</span>)</span><br><span class="line">    tt.Stop()</span><br><span class="line">    t := &lt;-time.After(time.Second * <span class="number">2</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;tt.Stop()后， tt 仍继续执行，只是关闭了 tt.C 通道。&quot;</span>, t)</span><br><span class="line"></span><br><span class="line">    ch &lt;- <span class="number">1</span></span><br><span class="line">  &#125;()</span><br><span class="line">  &lt;-ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>在我看来After函数的出现是为了让使用timer的时候更方便，而不需要调用timer.Reset函数</p></li><li><p>这种方式会阻塞当且协程，直到超时或接收到消息，有没有什么方法可以不阻塞，并且判断是否超市呢？</p></li><li><p>以下方法便能做到</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time.Now().After(t time.Time) <span class="type">bool</span>  <span class="comment">// 判断当前时间是否在t之后（可以做到不阻塞还能判断是否超时）</span></span><br></pre></td></tr></table></figure><h2 id="做项目遇到的一些问题">做项目遇到的一些问题</h2><h3 id="Map通过索引返回的是副本，改变副本结构体不会改变map中的结构体原数据">Map通过索引返回的是副本，改变副本结构体不会改变map中的结构体原数据</h3><p>将一个变量声明为map[int]Task 类型，然后我想要通过<strong>索引修改Task结构体的内容(map[<a href="http://task.id">task.id</a>].status = “done”)会出错</strong>，<strong>提示&quot;cannot assign to struct field value in map&quot;</strong><br>原因：Go 的行为: 在 Go 中，map[] 返回的是结构体的副本，因此无法直接修改 map 中的结构体字段。需要取出副本、修改后再放回,这与C++不一样</p><h3 id="不同进程运行相同包下的不同源代码文件的一些现象">不同进程运行相同包下的不同源代码文件的一些现象</h3><ol><li><strong>首先进程间的数据不共享</strong>，而且你在两个源文件定义的东西，都会在进程中被声明与初始化，<strong>但是你在一个进程中改变某值并不会影响另外一个值</strong><br>例如: 你在A.go中定义了numReduce初始化为10，然后你在A.go中修改为20，A.go运行在一个进程中，B.go在另外一个进程运行，获取A的值只能获得10，因为两个进程中A.go的numReduce的值是不共享的。<br>同理使用单例模式也一样，在A进程中初始化了单例，在B进程再次获得单例的时候，还是会初始化一次，而且使用的是B进程内的变量<br>我在写项目的时候并没有第一时间发现这个问题，导致找bug花费了不少时间</li></ol><h3 id="select-配合通道使用的时候的一些逻辑">select 配合通道使用的时候的一些逻辑</h3><ol><li><strong>select 配合通道使用的时候，如果没有任何case可以执行，则会阻塞，直到有case可以执行</strong></li><li><strong>select 配合通道使用的时候，如果有多个case都可以执行，则会随机选择一个执行</strong></li><li><strong>通道先有数据的情况下，会执行现有数据的case，然后退出select</strong></li></ol>]]></content>
    
    
    <summary type="html">本文讲述的是go的部分语法基础</summary>
    
    
    
    <category term="go" scheme="https://pigcanstudy.github.io/categories/go/"/>
    
    
    <category term="go" scheme="https://pigcanstudy.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>go的Gin框架的使用</title>
    <link href="https://pigcanstudy.github.io/posts/d5cdb644.html"/>
    <id>https://pigcanstudy.github.io/posts/d5cdb644.html</id>
    <published>2024-11-29T08:37:17.000Z</published>
    <updated>2024-12-19T08:14:43.406Z</updated>
    
    <content type="html"><![CDATA[<h1>目录</h1><ul><li><a href="#%E7%9B%AE%E5%BD%95">目录</a><ul><li><a href="#gin%E7%AE%80%E4%BB%8B">Gin简介</a></li><li><a href="#gin%E7%9A%84%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA">Gin的环境搭建</a></li><li><a href="#restful-api">Restful API</a><ul><li><a href="#%E6%94%BE%E5%9B%9Exml%E6%95%B0%E6%8D%AE">放回XML数据</a></li><li><a href="#%E8%BF%94%E5%9B%9Ejsonp%E6%95%B0%E6%8D%AE">返回JSONP数据</a></li><li><a href="#%E6%94%BE%E5%9B%9Ejson%E6%95%B0%E6%8D%AE">放回JSON数据</a></li></ul></li><li><a href="#html%E6%B8%B2%E6%9F%93">HTML渲染</a><ul><li><a href="#html%E6%A8%A1%E6%9D%BF%E9%83%BD%E5%9C%A8%E4%B8%80%E4%B8%AA%E7%9B%AE%E5%BD%95%E4%B8%8B">HTML模板都在一个目录下</a></li><li><a href="#html%E6%A8%A1%E6%9D%BF%E5%88%86%E6%95%A3%E5%9C%A8%E5%90%84%E4%B8%AA%E7%9B%AE%E5%BD%95%E4%B8%8B">HTML模板分散在各个目录下</a></li></ul></li><li><a href="#gin%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95">gin的基本语法</a><ul><li><a href="#%E8%BE%93%E5%87%BA%E5%8F%98%E9%87%8F">输出变量</a></li><li><a href="#%E6%B3%A8%E9%87%8A">注释</a></li><li><a href="#%E5%8F%98%E9%87%8F">变量</a></li><li><a href="#%E7%A7%BB%E9%99%A4%E7%A9%BA%E6%A0%BC">移除空格</a></li><li><a href="#%E6%AF%94%E8%BE%83%E5%87%BD%E6%95%B0">比较函数</a></li><li><a href="#with">With</a></li><li><a href="#range">range</a></li><li><a href="#%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD">条件判断</a></li><li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0">自定义模板函数</a></li></ul></li><li><a href="#%E8%B7%AF%E7%94%B1%E8%AF%A6%E8%A7%A3">路由详解</a><ul><li><a href="#%E8%8E%B7%E5%8F%96get%E8%AF%B7%E6%B1%82%E4%BC%A0%E6%9D%A5%E7%9A%84%E5%80%BC">获取GET请求传来的值</a><ul><li><a href="#%E8%8E%B7%E5%8F%96querystring%E5%8F%82%E6%95%B0">获取querystring参数</a></li></ul></li><li><a href="#%E8%8E%B7%E5%8F%96path%E5%8F%82%E6%95%B0">获取path参数</a></li><li><a href="#%E8%8E%B7%E5%8F%96post%E8%AF%B7%E6%B1%82%E7%9A%84form%E8%A1%A8%E5%8D%95%E6%95%B0%E6%8D%AE">获取Post请求的form表单数据</a></li><li><a href="#%E8%8E%B7%E5%8F%96json%E5%8F%82%E6%95%B0">获取JSON参数</a></li><li><a href="#%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A%E5%88%B0%E7%BB%93%E6%9E%84%E4%BD%93">参数绑定到结构体</a></li><li><a href="#%E8%B7%AF%E7%94%B1%E5%88%86%E7%BB%84">路由分组</a></li></ul></li><li><a href="#gin%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E5%88%B6%E5%99%A8">Gin自定义控制器</a><ul><li><a href="#%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E7%BB%A7%E6%89%BF">控制器的继承</a></li></ul></li><li><a href="#gin%E4%B8%AD%E9%97%B4%E4%BB%B6">Gin中间件</a><ul><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AFgin%E4%B8%AD%E9%97%B4%E4%BB%B6">什么是Gin中间件</a></li><li><a href="#%E8%B7%AF%E7%94%B1%E4%B8%AD%E9%97%B4%E4%BB%B6">路由中间件</a><ul><li><a href="#ctxnext%E8%B0%83%E7%94%A8%E8%AF%A5%E8%AF%B7%E6%B1%82%E7%9A%84%E5%89%A9%E4%BD%99%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F">ctx.Next()调用该请求的剩余处理程序</a></li><li><a href="#%E4%B8%80%E4%B8%AA%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AA%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F">一个路由配置多个中间件的执行顺序</a></li></ul></li><li><a href="#%E5%85%A8%E5%B1%80%E4%B8%AD%E9%97%B4%E4%BB%B6">全局中间件</a></li><li><a href="#%E5%9C%A8%E8%B7%AF%E7%94%B1%E5%88%86%E7%BB%84%E4%B8%AD%E9%85%8D%E7%BD%AE%E4%B8%AD%E9%97%B4%E4%BB%B6">在路由分组中配置中间件</a></li><li><a href="#%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%92%8C%E5%AF%B9%E5%BA%94%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE">中间件和对应控制器之间共享数据</a></li><li><a href="#%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">中间件注意事项</a></li></ul></li><li><a href="#gin%E8%87%AA%E5%AE%9A%E4%B9%89model">Gin自定义Model</a><ul><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AFmodel">什么是Model</a></li><li><a href="#model%E9%87%8C%E9%9D%A2%E5%B0%81%E8%A3%85%E5%85%AC%E5%85%B1%E7%9A%84%E6%96%B9%E6%B3%95">Model里面封装公共的方法</a></li><li><a href="#%E5%9C%A8model%E4%B8%AD%E6%B3%A8%E5%86%8C%E5%85%A8%E5%B1%80%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0">在Model中注册全局模板函数</a></li></ul></li><li><a href="#gin%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0">Gin文件上传</a><ul><li><a href="#%E5%8D%95%E4%B8%AA%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0">单个文件上传</a></li><li><a href="#%E5%A4%9A%E4%B8%AA%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0">多个文件上传</a></li><li><a href="#%E6%8C%89%E6%97%A5%E6%9C%9F%E5%AD%98%E5%82%A8%E6%96%87%E4%BB%B6">按日期存储文件</a></li><li><a href="#%E6%80%BB%E7%BB%93">总结</a></li></ul></li><li><a href="#gin%E7%9A%84cookie%E7%9B%B8%E5%85%B3">Gin的Cookie相关</a><ul><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AFcookie">什么是Cookie</a></li><li><a href="#cookie%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8A%9F%E8%83%BD">Cookie可以实现的功能</a></li><li><a href="#%E8%AE%BE%E7%BD%AEcookie">设置Cookie</a></li><li><a href="#%E8%8E%B7%E5%8F%96cookie">获取Cookie</a></li><li><a href="#%E5%88%A0%E9%99%A4cookie">删除Cookie</a></li><li><a href="#%E5%A4%9A%E4%B8%AA%E4%BA%8C%E7%BA%A7%E5%9F%9F%E5%90%8D%E5%85%B1%E4%BA%ABcookie">多个二级域名共享cookie</a></li><li><a href="#%E6%A1%88%E4%BE%8B%E4%BD%BF%E7%94%A8">案例使用</a></li></ul></li><li><a href="#gin%E7%9A%84session%E7%9B%B8%E5%85%B3">Gin的Session相关</a><ul><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AFsession">什么是Session</a></li><li><a href="#session%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B">Session的工作流程</a></li><li><a href="#gin%E4%B8%AD%E4%BD%BF%E7%94%A8session">Gin中使用Session</a></li><li><a href="#%E5%9F%BA%E4%BA%8Ecookie%E5%AD%98%E5%82%A8session">基于Cookie存储Session</a></li><li><a href="#%E5%9F%BA%E4%BA%8Eredis%E5%AD%98%E5%82%A8session">基于Redis存储Session</a></li><li><a href="#%E6%80%BB%E7%BB%93-1">总结</a></li></ul></li><li><a href="#gin%E4%B8%AD%E4%BD%BF%E7%94%A8go-ini%E6%9D%A5%E5%8A%A0%E8%BD%BDini%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">gin中使用go-ini来加载.ini配置文件</a><ul><li><a href="#go-ini%E4%BB%8B%E7%BB%8D">go-ini介绍</a></li><li><a href="#go-ini%E4%BD%BF%E7%94%A8">go-ini使用</a></li></ul></li></ul></li></ul><h2 id="Gin简介">Gin简介</h2><p>Gin是一个Go语言编写的Web框架，它是一个轻量级的Web框架，提供了诸如路由、中间件、日志、配置管理等功能。其运行速度非常块，适用于API服务、微服务等场景。</p><h2 id="Gin的环境搭建">Gin的环境搭建</h2><ul><li>在运行下述语句之前，请先确保有已经执行了 go mod init 命令</li></ul><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="built_in">get</span> -<span class="keyword">u</span> github.<span class="keyword">com</span>/gin-gonic/gin</span><br></pre></td></tr></table></figure><p>这里补充一个<strong>热加载</strong>的第三方库，其目的是在不重启程序的情况下可以实时更新代码，提高开发效率。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">go</span> install github.com/gravityblast/fresh<span class="variable">@latest</span></span><br></pre></td></tr></table></figure><h2 id="Restful-API">Restful API</h2><ol><li>Gin框架提供一系列的路由方法，其形式大概为请求路由+ Handler函数</li><li>在Handler函数中我们可以返回一些后台数据，比如JSON、HTML、XML等格式的数据</li></ol><p>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 创建默认的路由引擎</span></span><br><span class="line">  router := gin.Default()</span><br><span class="line"></span><br><span class="line">  router.LoadHTMLGlob(<span class="string">&quot;templates/*&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注册路由</span></span><br><span class="line">  router.GET(<span class="string">&quot;/ping&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">    ctx.HTML(<span class="number">200</span>, <span class="string">&quot;ping.html&quot;</span>, gin.H&#123;</span><br><span class="line">      <span class="string">&quot;message&quot;</span>: <span class="string">&quot;pong&quot;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  router.GET(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">    ctx.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">      <span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello Gin&quot;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  router.POST(<span class="string">&quot;/login&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">    ctx.String(<span class="number">200</span>, <span class="string">&quot;login success&quot;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  router.PUT(<span class="string">&quot;/user&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">    ctx.JSONP(<span class="number">200</span>, <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">      <span class="string">&quot;id&quot;</span>:   <span class="number">1</span>,</span><br><span class="line">      <span class="string">&quot;name&quot;</span>: <span class="string">&quot;admin&quot;</span>,</span><br><span class="line">      <span class="string">&quot;age&quot;</span>:  <span class="number">20</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  router.DELETE(<span class="string">&quot;/user&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">    ctx.XML(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">      <span class="string">&quot;message&quot;</span>: <span class="string">&quot;delete success&quot;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 启动Web服务</span></span><br><span class="line">  router.Run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="放回XML数据">放回XML数据</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式1</span></span><br><span class="line">  router.DELETE(<span class="string">&quot;/user&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">    ctx.XML(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">      <span class="string">&quot;message&quot;</span>: <span class="string">&quot;delete success&quot;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  router.GET(<span class="string">&quot;/moreXML&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 方式2使用结构体</span></span><br><span class="line">    <span class="keyword">type</span> Message <span class="keyword">struct</span> &#123;</span><br><span class="line">      Name    <span class="type">string</span></span><br><span class="line">      Age     <span class="type">int</span></span><br><span class="line">      Message <span class="type">string</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> msg Message</span><br><span class="line">    msg.Name = <span class="string">&quot;admin&quot;</span></span><br><span class="line">    msg.Age = <span class="number">20</span></span><br><span class="line">    msg.Message = <span class="string">&quot;moreXML success&quot;</span></span><br><span class="line">    ctx.XML(http.StatusOK, msg)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="返回JSONP数据">返回JSONP数据</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">router.PUT(<span class="string">&quot;/user&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">    ctx.JSONP(<span class="number">200</span>, <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">      <span class="string">&quot;id&quot;</span>:   <span class="number">1</span>,</span><br><span class="line">      <span class="string">&quot;name&quot;</span>: <span class="string">&quot;admin&quot;</span>,</span><br><span class="line">      <span class="string">&quot;age&quot;</span>:  <span class="number">20</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h3 id="放回JSON数据">放回JSON数据</h3><p>其实与其他都类似，这就不一一举例了，只需要把.XML换成.JSON即可。</p><h2 id="HTML渲染">HTML渲染</h2><ul><li>可以分为两种情况</li></ul><h3 id="HTML模板都在一个目录下">HTML模板都在一个目录下</h3><p>目录结构如下：<br><img src="../assets/2024-11-29-go%E7%9A%84Gin%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8/image.png" alt="alt text"></p><p>使用步骤如下：</p><ol><li>首先创建好模板文件，比如<code>ping.html</code></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br><span class="line">    &lt;meta http-equiv=<span class="string">&quot;X-UA-Compatible&quot;</span> content=<span class="string">&quot;ie=edge&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;templates/ping&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &#123;&#123;.message&#125;&#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>然后在主函数中需要提前使用LoadHTMLGlob()或者LoadHTMLFiles()方法加载模板文件</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">router.LoadHTMLGlob(<span class="string">&quot;templates/*&quot;</span>)</span><br></pre></td></tr></table></figure><ol start="3"><li>最后在路由中使用HTML()方法渲染模板</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">router.GET(<span class="string">&quot;/ping&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">    ctx.HTML(<span class="number">200</span>, <span class="string">&quot;ping.html&quot;</span>, gin.H&#123;</span><br><span class="line">      <span class="string">&quot;message&quot;</span>: <span class="string">&quot;pong&quot;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>其中步骤1下的<code>&#123;&#123;.message&#125;&#125;</code> 这个message就是在gin.H中定义的变量，在gin.H中定义的变量可以在模板中使用。</p><h3 id="HTML模板分散在各个目录下">HTML模板分散在各个目录下</h3><ul><li><p>目录结构如下:<br><img src="../assets/2024-11-29-go%E7%9A%84Gin%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8/image-1.png" alt="alt text"></p></li><li><p>使用步骤如下：</p></li></ul><ol><li>创建模板的时候，要使用define定义名称</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;define <span class="string">&quot;admin/index.html&quot;</span>&#125;&#125;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &#123;&#123;.title&#125;&#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>:define定义的时候需要加上模板路径</p><ol start="2"><li>在主函数下需要加载模板文件</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">router.LoadHTMLGlob(<span class="string">&quot;templates/**/*&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：这里的<code>/**/*</code>表示匹配所有目录下的所有文件，如果在default下还有一级目录，并且想要访问的话就需要&quot;templates/<strong>/</strong>/*&quot;<br>3. 在路由中使用HTML()方法渲染模板</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 创建默认的路由引擎</span></span><br><span class="line">  router := gin.Default()</span><br><span class="line"></span><br><span class="line">  router.LoadHTMLGlob(<span class="string">&quot;templates/**/*&quot;</span>)</span><br><span class="line"></span><br><span class="line">  router.GET(<span class="string">&quot;/ping&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">    ctx.HTML(<span class="number">200</span>, <span class="string">&quot;admin/ping.html&quot;</span>, gin.H&#123;</span><br><span class="line">      <span class="string">&quot;message&quot;</span>: <span class="string">&quot;pong&quot;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  router.GET(<span class="string">&quot;/admin&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">    ctx.HTML(<span class="number">200</span>, <span class="string">&quot;admin/index.html&quot;</span>, gin.H&#123;</span><br><span class="line">      <span class="string">&quot;title&quot;</span>: <span class="string">&quot;Admin Page&quot;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  router.GET(<span class="string">&quot;/question&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">    ctx.HTML(<span class="number">200</span>, <span class="string">&quot;default/question.html&quot;</span>, gin.H&#123;</span><br><span class="line">      <span class="string">&quot;title&quot;</span>: <span class="string">&quot;Question Page&quot;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 启动Web服务</span></span><br><span class="line">  router.Run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>注意</strong>：这里的模板文件名要和路由匹配的路径名一致，比如<code>admin/ping.html</code>和<code>admin/index.html</code>而不能是<code>/admin/ping.html/</code></li></ul><h2 id="gin的基本语法">gin的基本语法</h2><h3 id="输出变量">输出变量</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;define &quot;admin/index.html&quot;&#125;&#125;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    &#123;&#123;.title&#125;&#125;</span><br><span class="line">    &#123;&#123;.user.Name&#125;&#125;</span><br><span class="line">    &#123;&#123;.user.Gender&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br></pre></td></tr></table></figure><ul><li>其中user是一个结构体变量</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">user1 := User&#123;</span><br><span class="line">    Name:   <span class="string">&quot;admin&quot;</span>,</span><br><span class="line">    Age:    <span class="number">20</span>,</span><br><span class="line">    Gender: <span class="string">&quot;male&quot;</span>,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  router.GET(<span class="string">&quot;/ping&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">    ctx.HTML(<span class="number">200</span>, <span class="string">&quot;admin/ping.html&quot;</span>, gin.H&#123;</span><br><span class="line">      <span class="string">&quot;message&quot;</span>: <span class="string">&quot;pong&quot;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  router.GET(<span class="string">&quot;/admin&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">    ctx.HTML(<span class="number">200</span>, <span class="string">&quot;admin/index.html&quot;</span>, gin.H&#123;</span><br><span class="line">      <span class="string">&quot;title&quot;</span>: <span class="string">&quot;Admin Page&quot;</span>,</span><br><span class="line">      <span class="string">&quot;user&quot;</span>:  user1, <span class="comment">// 使用结构体</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><ul><li>这样在模板中就可以使用user1的Name和Gender变量了</li></ul><h3 id="注释">注释</h3><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="template-tag">&#123;&#123;/* <span class="name">注释内容</span> */&#125;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="变量">变量</h3><p>可以在模板中声明变量具体语法如下:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;$obj := .title&#125;&#125;</span><br></pre></td></tr></table></figure><ul><li>声明变量，并将.title的值赋值给它</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;$obj&#125;&#125;</span><br></pre></td></tr></table></figure><ul><li>输出变量的值</li></ul><h3 id="移除空格">移除空格</h3><p>有时候我们在使用模板语法的时候会不可避免的引入一下空格或者换行符，这样模板最终渲<br>染出来的内容可能就和我们想的不一样，这个时候可以使用<code>&#123;&#123;-`语法去除模板内容左侧的所有空白符号， 使用`-&#125;&#125;</code>去除模板内容右侧的所有空白符号。具体语法如下:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;- .title -&#125;&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：-要紧挨，同时与模板值之间需要使用空格分隔。</p><h3 id="比较函数">比较函数</h3><p>布尔函数会将任何类型的零值视为假，其余视为真。<br>下面是定义为函数的二元比较运算的集合：<br>eq 如果 arg1 == arg2 则返回真<br>ne 如果 arg1 != arg2 则返回真<br>lt 如果 arg1 &lt; arg2 则返回真<br>le 如果 arg1 &lt;= arg2 则返回真<br>gt 如果 arg1 &gt; arg2 则返回真<br>ge 如果 arg1 &gt;= arg2 则返回真</p><h3 id="With">With</h3><p>使用with来输出结构体</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;with .user&#125;&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>姓名：&#123;&#123;.Name&#125;&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>性别：&#123;&#123;.user.Gender&#125;&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>年龄：&#123;&#123;.Age&#125;&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="range">range</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">router.GET(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.HTML(http.StatusOK, <span class="string">&quot;default/index.html&quot;</span>, <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123; <span class="string">&quot;hobby&quot;</span>: []<span class="type">string</span>&#123;<span class="string">&quot;吃饭&quot;</span>, <span class="string">&quot;睡觉&quot;</span>, <span class="string">&quot;写代码&quot;</span>&#125;, &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;range $key,$value := .hobby&#125;&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;$value&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="条件判断">条件判断</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;if gt .score 90&#125;&#125;</span><br><span class="line">优秀</span><br><span class="line">&#123;&#123;else if gt .score 60&#125;&#125;</span><br><span class="line">及格</span><br><span class="line">&#123;&#123;else&#125;&#125;</span><br><span class="line">不及格</span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义模板函数">自定义模板函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建默认的路由引擎</span></span><br><span class="line">  router := gin.Default()</span><br><span class="line"></span><br><span class="line">  <span class="comment">//注册全局模板函数 注意顺序，注册模板函数需要在加载模板上面</span></span><br><span class="line">  router.SetFuncMap(template.FuncMap&#123;</span><br><span class="line">    <span class="string">&quot;formatDate&quot;</span>: <span class="function"><span class="keyword">func</span><span class="params">(t <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">      t += <span class="string">&quot; hello world&quot;</span></span><br><span class="line">      <span class="keyword">return</span> t</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  router.LoadHTMLGlob(<span class="string">&quot;templates/**/*&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>在模板中使用</li></ul><p><code>&#123;&#123;.title | formatDate&#125;&#125;</code> 或者 <code>&#123;&#123;formatDate .title&#125;&#125;</code></p><h2 id="路由详解">路由详解</h2><h3 id="获取GET请求传来的值">获取GET请求传来的值</h3><h4 id="获取querystring参数">获取querystring参数</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">router.GET(<span class="string">&quot;/user&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 获取请求参数</span></span><br><span class="line">    name := ctx.Query(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">    age := ctx.DefaultQuery(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;0&quot;</span>)</span><br><span class="line">    ctx.String(<span class="number">200</span>, <span class="string">&quot;name: %s, age: %s&quot;</span>, name, age)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><ul><li>其中defaultQuery就是如果age没有的话就返回0</li></ul><h3 id="获取path参数">获取path参数</h3><p>/user/20</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r.GET(<span class="string">&quot;/user/:uid&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">uid := ctx.Param(<span class="string">&quot;uid&quot;</span>)</span><br><span class="line">ctx.String(<span class="number">200</span>, <span class="string">&quot;userID=%s&quot;</span>, uid)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="获取Post请求的form表单数据">获取Post请求的form表单数据</h3><p>定义一个html的页面</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; define &quot;default/add_user.html&quot; &#125;&#125;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/doAddUser&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> /&gt;</span></span><br><span class="line">    密码: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br></pre></td></tr></table></figure><ul><li>通过PostForm来获取数据</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">//Default返回一个默认的路由引擎</span></span><br><span class="line">  r := gin.Default()</span><br><span class="line">  r.POST(<span class="string">&quot;/user/search&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    <span class="comment">// DefaultPostForm取不到值时会返回指定的默认值</span></span><br><span class="line">    <span class="comment">//username := c.DefaultPostForm(&quot;username&quot;, &quot;小王子&quot;)</span></span><br><span class="line">    username := c.PostForm(<span class="string">&quot;username&quot;</span>)</span><br><span class="line">    address := c.PostForm(<span class="string">&quot;password&quot;</span>)</span><br><span class="line">    <span class="comment">//输出json结果给调用方</span></span><br><span class="line">    c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">      <span class="string">&quot;message&quot;</span>:  <span class="string">&quot;ok&quot;</span>,</span><br><span class="line">      <span class="string">&quot;username&quot;</span>: username,</span><br><span class="line">      <span class="string">&quot;password&quot;</span>:  address,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  r.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取JSON参数">获取JSON参数</h3><p>当前端请求的数据通过JSON提交时，例如向/json发送一个JSON格式的POST请求，则获取请求参数的方式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">r.POST(<span class="string">&quot;/json&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 注意：下面为了举例子方便，暂时忽略了错误处理</span></span><br><span class="line">  b, _ := c.GetRawData()  <span class="comment">// 从c.Request.Body读取请求数据</span></span><br><span class="line">  <span class="comment">// 定义map或结构体</span></span><br><span class="line">  <span class="keyword">var</span> m <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">  <span class="comment">// 反序列化</span></span><br><span class="line">  _ = json.Unmarshal(b, &amp;m)</span><br><span class="line"></span><br><span class="line">  c.JSON(http.StatusOK, m)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="参数绑定到结构体">参数绑定到结构体</h3><p>为了能够更方便的获取请求相关参数，提高开发效率，我们可以基于<strong>请求的 Content-Type识别请求数据类型并利用反射机制</strong>自动提取请求中 QueryString、form 表单、JSON、XML 等参数到结构体中。 下面的示例代码演示了.**ShouldBind()**强大的功能，<strong>它能够基于请求自动提取 JSON、form 表单和 QueryString 类型的数据，并把值绑定到指定的结构体对象</strong></p><p>shouldBind方法底层实现原理大概就是首先通过读取请求的 Content-Type 头判断请求数据类型，然后根据 Content-Type 头与请求Method确认绑定关系，binding，binding是一个接口类型，有一个方法是bind方法，每种数据类型哦都会实现这接口，这个bind的作用就是读取请求数据，并通过反射的方法遍历结构体字段，然后把请求数据设置到结构体字段中。</p><p>ShouldBind会按照下面的顺序解析请求中的数据完成绑定：</p><p>如果是 GET 请求，只使用 Form 绑定引擎（query）。<br>如果是 POST 请求，首先检查 content-type 是否为 JSON 或 XML，然后再使用 Form（form-data）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name   <span class="type">string</span> <span class="string">`form:&quot;name&quot; json:&quot;name&quot; xml:&quot;name&quot;`</span></span><br><span class="line">  Age    <span class="type">int</span>    <span class="string">`form:&quot;age&quot; json:&quot;age&quot; xml:&quot;age&quot;`</span></span><br><span class="line">  Gender <span class="type">string</span> <span class="string">`form:&quot;gender&quot; json:&quot;gender&quot; xml:&quot;gender&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> user User</span><br><span class="line"></span><br><span class="line">router.GET(<span class="string">&quot;/answer&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> user User</span><br><span class="line">  <span class="keyword">if</span> err := ctx.ShouldBind(&amp;user); err == <span class="literal">nil</span> &#123;</span><br><span class="line">    ctx.JSON(<span class="number">200</span>, user)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ctx.JSON(http.StatusBadRequest, gin.H&#123;<span class="string">&quot;error&quot;</span>: err.Error()&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.POST(<span class="string">&quot;/answerJson&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> user User</span><br><span class="line">  <span class="keyword">if</span> err := ctx.ShouldBind(&amp;user); err == <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(user)</span><br><span class="line">    ctx.JSON(<span class="number">200</span>, user)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ctx.JSON(http.StatusBadRequest, gin.H&#123;<span class="string">&quot;error&quot;</span>: err.Error()&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="路由分组">路由分组</h3><ul><li>为什么需要路由分组，进行路由分组一方面可以方便管理路由，减小一个文件下的代码的冗余性，另一方面可以进行分组开发，就相当于把一个大代码就行分成多个小代码，每个小代码都有自己的功能，这样可以更好的进行开发和维护。</li></ul><p>首先目录结构如下：<br><img src="../assets/2024-11-29-go%E7%9A%84Gin%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8/image-2.png" alt="alt text"></p><ul><li>路由分组的使用方法如下：</li></ul><p>adminRouters.go如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> routers</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AdminRoutersInit</span><span class="params">(r *gin.Engine)</span></span> &#123;</span><br><span class="line">  <span class="comment">// Admin routers</span></span><br><span class="line">  adminRouters := r.Group(<span class="string">&quot;/admin&quot;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    adminRouters.GET(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">      ctx.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">        <span class="string">&quot;path&quot;</span>:    ctx.Request.URL.Path,</span><br><span class="line">        <span class="string">&quot;message&quot;</span>: <span class="string">&quot;Welcome to admin page&quot;</span>,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    adminRouters.GET(<span class="string">&quot;/news&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">      ctx.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">        <span class="string">&quot;path&quot;</span>:    ctx.Request.URL.Path,</span><br><span class="line">        <span class="string">&quot;message&quot;</span>: <span class="string">&quot;news page&quot;</span>,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其他Routers.go类似我就不张贴了</p><p>main.go如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;project/routers&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name   <span class="type">string</span> <span class="string">`form:&quot;name&quot; json:&quot;name&quot; xml:&quot;name&quot;`</span></span><br><span class="line">  Age    <span class="type">int</span>    <span class="string">`form:&quot;age&quot; json:&quot;age&quot; xml:&quot;age&quot;`</span></span><br><span class="line">  Gender <span class="type">string</span> <span class="string">`form:&quot;gender&quot; json:&quot;gender&quot; xml:&quot;gender&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 创建默认的路由引擎</span></span><br><span class="line">  router := gin.Default()</span><br><span class="line"></span><br><span class="line">  routers.AdminRoutersInit(router)</span><br><span class="line"></span><br><span class="line">  routers.UserRoutersInit(router)</span><br><span class="line"></span><br><span class="line">  routers.ApiRoutersInit(router)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 启动Web服务</span></span><br><span class="line">  router.Run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Gin自定义控制器">Gin自定义控制器</h2><p>一个路由的处理函数可以直接放在GET路由中，但是当项目变得很庞大的时候，这样就不妥，所以需要把处理函数放在控制器中，接下来就讲讲控制器</p><ol><li>方式一：把函数直接抽离到外面</li></ol><p>原来的形式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">adminRouters.GET(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">      ctx.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">        <span class="string">&quot;path&quot;</span>:    ctx.Request.URL.Path,</span><br><span class="line">        <span class="string">&quot;message&quot;</span>: <span class="string">&quot;Welcome to admin page&quot;</span>,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>使用后的形式:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Index</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">  ctx.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">    <span class="string">&quot;path&quot;</span>:    ctx.Request.URL.Path,</span><br><span class="line">    <span class="string">&quot;message&quot;</span>: <span class="string">&quot;Welcome to admin page&quot;</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">adminRouters.GET(<span class="string">&quot;/&quot;</span>, Index)</span><br></pre></td></tr></table></figure><ol><li>方式二：把函数抽离到外面，但是以结构体组织，这个结构体就能看出是一个控制器</li></ol><p>原来的形式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">adminRouters.GET(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">      ctx.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">        <span class="string">&quot;path&quot;</span>:    ctx.Request.URL.Path,</span><br><span class="line">        <span class="string">&quot;message&quot;</span>: <span class="string">&quot;Welcome to admin page&quot;</span>,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>使用后的形式:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> admin</span><br><span class="line"></span><br><span class="line"><span class="comment">// AdminController.go 文件中</span></span><br><span class="line"><span class="keyword">type</span> AdminController <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(con *AdminController)</span></span> Index(ctx *gin.Context) &#123;</span><br><span class="line">  ctx.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">    <span class="string">&quot;path&quot;</span>:    ctx.Request.URL.Path,</span><br><span class="line">    <span class="string">&quot;message&quot;</span>: <span class="string">&quot;Welcome to admin page&quot;</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;project/admin&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name   <span class="type">string</span> <span class="string">`form:&quot;name&quot; json:&quot;name&quot; xml:&quot;name&quot;`</span></span><br><span class="line">  Age    <span class="type">int</span>    <span class="string">`form:&quot;age&quot; json:&quot;age&quot; xml:&quot;age&quot;`</span></span><br><span class="line">  Gender <span class="type">string</span> <span class="string">`form:&quot;gender&quot; json:&quot;gender&quot; xml:&quot;gender&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">  adminRouters.GET(<span class="string">&quot;/&quot;</span>, admin.AdminController&#123;&#125;.Index)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 启动Web服务</span></span><br><span class="line">  router.Run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此方式可以优化成单例模式</p><h3 id="控制器的继承">控制器的继承</h3><p>与结构体继承一致</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> admin</span><br><span class="line"><span class="keyword">import</span> ( <span class="string">&quot;net/http&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> BaseController <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c BaseController)</span></span> Success(ctx *gin.Context) &#123;</span><br><span class="line">ctx.String(http.StatusOK, <span class="string">&quot;成功&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c BaseController)</span></span> Error(ctx *gin.Context) &#123;</span><br><span class="line">ctx.String(http.StatusOK, <span class="string">&quot;失败&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>NewsController继承BaseController</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> admin</span><br><span class="line"><span class="keyword">import</span> ( <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> NewsController <span class="keyword">struct</span> &#123;</span><br><span class="line">BaseController</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c NewsController)</span></span> Index(ctx *gin.Context) &#123;</span><br><span class="line">c.Success(ctx)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Gin中间件">Gin中间件</h2><h3 id="什么是Gin中间件">什么是Gin中间件</h3><ul><li>Gin 框架允许开发者在处理请求的过程中，加入用户自己的钩子（Hook）函数。这个钩子函数就叫中间件，中间件适合处理一些公共的业务逻辑，<strong>比如登录认证、权限校验、数据分页、记录日志、耗时统计等。</strong></li></ul><p><strong>通俗的讲</strong>：中间件就是匹配路由前和匹配路由完成后执行的一系列操作</p><h3 id="路由中间件">路由中间件</h3><p>Gin 中的中间件必须是一个 <strong>gin.HandlerFunc</strong> 类型，配置路由的时候可以传递多个func 回调函数，最后一个 func 回调函数前面触发的方法都可以称为中间件。</p><h4 id="ctx-Next-调用该请求的剩余处理程序">ctx.Next()调用该请求的剩余处理程序</h4><p>中间件里面加上 ctx.Next()可以让我们在路由匹配完成后执行一些操作。<br>比如我们统计一个请求的执行时间。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;text/template&quot;</span></span><br><span class="line">  <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把Unix时间戳转换为时间字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UnixToTime</span><span class="params">(unix <span class="type">int64</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">  <span class="comment">// 转换为时间对象</span></span><br><span class="line">  t := time.UnixMicro(unix)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 格式化时间字符串并返回</span></span><br><span class="line">  <span class="keyword">return</span> t.Format(<span class="string">&quot;2024-11-23 15:04:05&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取一个路由执行时间的中间件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetTimeMiddleware</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;执行时间中间件&quot;</span>)</span><br><span class="line">  <span class="comment">// 获取当前时间戳</span></span><br><span class="line">  startTime := time.Now().UnixNano()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行剩余的请求函数（就是取处理路由请求处理函数）</span></span><br><span class="line">  c.Next()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取执行完路由后的时间戳</span></span><br><span class="line">  endTime := time.Now().UnixNano()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算执行时间并打印</span></span><br><span class="line">  fmt.Println(<span class="string">&quot;路由执行时间: &quot;</span>, endTime-startTime, <span class="string">&quot;ns&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 创建一个默认的路由引擎</span></span><br><span class="line">  r := gin.Default()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置自定义模板函数</span></span><br><span class="line">  r.SetFuncMap(template.FuncMap&#123;</span><br><span class="line">    <span class="string">&quot;UnixToTime&quot;</span>: UnixToTime,</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 加载模板文件</span></span><br><span class="line">  r.LoadHTMLGlob(<span class="string">&quot;templates/**/*&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// // 配置静态Web目录 第一个参数表示路由，第二个参数表示映射的目录</span></span><br><span class="line">  <span class="comment">// r.Static(&quot;/static&quot;, &quot;./static&quot;)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注册路由</span></span><br><span class="line">  r.GET(<span class="string">&quot;/getdog&quot;</span>, GetTimeMiddleware, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 开始数据库查询</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;开始查询数据库&quot;</span>)</span><br><span class="line">    <span class="comment">// 处理请求(模拟数据库查询耗时)</span></span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line"></span><br><span class="line">    c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">      <span class="string">&quot;message&quot;</span>: <span class="string">&quot;小狗有一百条&quot;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 启动服务</span></span><br><span class="line">  r.Run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>程序输出:</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">执行时间中间件</span><br><span class="line">开始查询数据库</span><br><span class="line">路由执行时间:  <span class="number">1000162500</span> ns</span><br></pre></td></tr></table></figure><p>明显可以看到其执行顺序是先执行中间件，执行到c.Next()后执行剩余的函数（<strong>可以是路由处理函数也可以是其他的中间件函数</strong>），如何在处理剩余中间件的未执行部分(c.Next()后面)</p><p>**c.Abort()**这个函数表示中止路由处理函数，但是还会继续执行c.Abort()后面的函数</p><h4 id="一个路由配置多个中间件的执行顺序">一个路由配置多个中间件的执行顺序</h4><p>看如下例子:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;text/template&quot;</span></span><br><span class="line">  <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把Unix时间戳转换为时间字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UnixToTime</span><span class="params">(unix <span class="type">int64</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">  <span class="comment">// 转换为时间对象</span></span><br><span class="line">  t := time.UnixMicro(unix)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 格式化时间字符串并返回</span></span><br><span class="line">  <span class="keyword">return</span> t.Format(<span class="string">&quot;2024-11-23 15:04:05&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例子中间件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleMiddleware</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;执行例子中间件&quot;</span>)</span><br><span class="line"></span><br><span class="line">  c.Next()</span><br><span class="line"></span><br><span class="line">  fmt.Println(<span class="string">&quot;例子中间件执行完毕&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取一个路由执行时间的中间件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetTimeMiddleware</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;执行时间中间件&quot;</span>)</span><br><span class="line">  <span class="comment">// 获取当前时间戳</span></span><br><span class="line">  startTime := time.Now().UnixNano()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行剩余的请求函数（就是取处理路由请求处理函数）</span></span><br><span class="line">  c.Next()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取执行完路由后的时间戳</span></span><br><span class="line">  endTime := time.Now().UnixNano()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算执行时间并打印</span></span><br><span class="line">  fmt.Println(<span class="string">&quot;路由执行时间: &quot;</span>, endTime-startTime, <span class="string">&quot;ns&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 创建一个默认的路由引擎</span></span><br><span class="line">  r := gin.Default()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置自定义模板函数</span></span><br><span class="line">  r.SetFuncMap(template.FuncMap&#123;</span><br><span class="line">    <span class="string">&quot;UnixToTime&quot;</span>: UnixToTime,</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 加载模板文件</span></span><br><span class="line">  r.LoadHTMLGlob(<span class="string">&quot;templates/**/*&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// // 配置静态Web目录 第一个参数表示路由，第二个参数表示映射的目录</span></span><br><span class="line">  <span class="comment">// r.Static(&quot;/static&quot;, &quot;./static&quot;)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注册路由</span></span><br><span class="line">  r.GET(<span class="string">&quot;/getdog&quot;</span>, ExampleMiddleware, GetTimeMiddleware, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 开始数据库查询</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;开始查询数据库&quot;</span>)</span><br><span class="line">    <span class="comment">// 处理请求(模拟数据库查询耗时)</span></span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;查询数据库完毕&quot;</span>)</span><br><span class="line"></span><br><span class="line">    c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">      <span class="string">&quot;message&quot;</span>: <span class="string">&quot;小狗有一百条&quot;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 启动服务</span></span><br><span class="line">  r.Run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">16</span><span class="punctuation">:</span><span class="number">28</span><span class="punctuation">:</span><span class="number">45</span> app         <span class="string">| 执行例子中间件</span></span><br><span class="line"><span class="number">16</span><span class="punctuation">:</span><span class="number">28</span><span class="punctuation">:</span><span class="number">45</span> app         <span class="string">| 执行时间中间件</span></span><br><span class="line">开始查询数据库</span><br><span class="line"><span class="number">16</span><span class="punctuation">:</span><span class="number">28</span><span class="punctuation">:</span><span class="number">46</span> app         <span class="string">| 查询数据库完毕</span></span><br><span class="line"><span class="number">16</span><span class="punctuation">:</span><span class="number">28</span><span class="punctuation">:</span><span class="number">46</span> app         <span class="string">| 路由执行时间:  1000586500 ns</span></span><br><span class="line">例子中间件执行完毕</span><br></pre></td></tr></table></figure><ul><li>可以发现这执行顺序是先处理最前面的中间件，依次往后处理，然后执行.Next（）是从后往前，类似于栈的执行顺序</li></ul><h3 id="全局中间件">全局中间件</h3><p>使用c.Use()方法可以注册全局中间件，全局中间件会在每个请求处理函数之前执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其他不变</span></span><br><span class="line">c.Use(ExampleMiddleware, GetTimeMiddleware)</span><br><span class="line"></span><br><span class="line">r.GET(<span class="string">&quot;/getdog&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 开始数据库查询</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;开始查询数据库&quot;</span>)</span><br><span class="line">    <span class="comment">// 处理请求(模拟数据库查询耗时)</span></span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;查询数据库完毕&quot;</span>)</span><br><span class="line"></span><br><span class="line">    c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">      <span class="string">&quot;message&quot;</span>: <span class="string">&quot;小狗有一百条&quot;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><ul><li>执行顺序和上述类似</li></ul><h3 id="在路由分组中配置中间件">在路由分组中配置中间件</h3><p>一共有两种方式：</p><ol><li>方式1：直接在Group中加入中间件</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> routers</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;project/middleware&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UserRoutersInit</span><span class="params">(r *gin.Engine)</span></span> &#123;</span><br><span class="line">  <span class="comment">// Admin routers</span></span><br><span class="line">  adminRouters := r.Group(<span class="string">&quot;/user&quot;</span>, middleware.InitMiddleware) <span class="comment">// &lt;-- 看这里</span></span><br><span class="line">  &#123;</span><br><span class="line">    adminRouters.GET(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">      ctx.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">        <span class="string">&quot;path&quot;</span>:    ctx.Request.URL.Path,</span><br><span class="line">        <span class="string">&quot;message&quot;</span>: <span class="string">&quot;Welcome to admin page&quot;</span>,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    adminRouters.GET(<span class="string">&quot;/play&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">      ctx.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">        <span class="string">&quot;path&quot;</span>:    ctx.Request.URL.Path,</span><br><span class="line">        <span class="string">&quot;message&quot;</span>: <span class="string">&quot;play page&quot;</span>,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>方式2：使用Use()</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> routers</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;project/middleware&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UserRoutersInit</span><span class="params">(r *gin.Engine)</span></span> &#123;</span><br><span class="line">  <span class="comment">// Admin routers</span></span><br><span class="line">  adminRouters := r.Group(<span class="string">&quot;/user&quot;</span>)</span><br><span class="line">  adminRouters.Use(middleware.InitMiddleware) <span class="comment">// &lt;-- 看这里</span></span><br><span class="line">  &#123;</span><br><span class="line">    adminRouters.GET(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">      ctx.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">        <span class="string">&quot;path&quot;</span>:    ctx.Request.URL.Path,</span><br><span class="line">        <span class="string">&quot;message&quot;</span>: <span class="string">&quot;Welcome to admin page&quot;</span>,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    adminRouters.GET(<span class="string">&quot;/play&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">      ctx.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">        <span class="string">&quot;path&quot;</span>:    ctx.Request.URL.Path,</span><br><span class="line">        <span class="string">&quot;message&quot;</span>: <span class="string">&quot;play page&quot;</span>,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中间件和对应控制器之间共享数据">中间件和对应控制器之间共享数据</h3><ul><li>设置值<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.Set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;jack&quot;</span>)</span><br></pre></td></tr></table></figure></li><li>获取值<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name := c.Get(<span class="string">&quot;name&quot;</span>)</span><br></pre></td></tr></table></figure></li><li>中间件设置值<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitAdminMiddleware</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;路由分组中间件&quot;</span>)</span><br><span class="line"><span class="comment">// 可以通过 ctx.Set 在请求上下文中设置值，后续的处理函数能够取到该值</span></span><br><span class="line">ctx.Set(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;张三&quot;</span>)</span><br><span class="line"><span class="comment">// 调用该请求的剩余处理程序</span></span><br><span class="line">ctx.Next()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>控制器获取值<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c UserController)</span></span> Index(ctx *gin.Context) &#123;</span><br><span class="line">username, _ := ctx.Get(<span class="string">&quot;username&quot;</span>)</span><br><span class="line">fmt.Println(username)</span><br><span class="line">ctx.String(http.StatusOK, <span class="string">&quot;这是用户首页 111&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>这样就可以在控制器中通过Get获取值</p><h3 id="中间件注意事项">中间件注意事项</h3><ul><li><strong>gin 默认中间件</strong></li></ul><p>gin.Default()默认使用了 Logger 和 Recovery 中间件，其中：<br>• Logger 中间件将日志写入 gin.DefaultWriter，即使配置了 GIN_MODE=release。<br>• Recovery 中间件会 recover 任何 panic。如果有 panic 的话，会写入 500 响应码。<br>如果不想使用上面两个默认的中间件，可以使用 gin.New()新建一个没有任何默认中间件的<br>路由。</p><ul><li><strong>gin 中间件中使用goroutine</strong><br>当在中间件或 handler 中启动新的 goroutine 时，<strong>不能使用原始的上下文（c *gin.Context）</strong>, 必须使用其<strong>只读副本（c.Copy()）</strong><br>例如:</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">r.GET(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">  cCp := c.Copy()</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// simulate a long task with time.Sleep(). 5 seconds</span></span><br><span class="line">    time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">    <span class="comment">// 这里使用你创建的副本</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Done! in path &quot;</span> + cCp.Request.URL.Path)</span><br><span class="line">  &#125;()</span><br><span class="line">  c.String(<span class="number">200</span>, <span class="string">&quot;首页&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Why? Gin的上下文是非线程安全的</p><h2 id="Gin自定义Model">Gin自定义Model</h2><h3 id="什么是Model">什么是Model</h3><p>如果我们的应用非常简单的话，我们可以在 Controller 里面处理常见的业务逻辑。但是如果我们有一个功能想在多个控制器、或者多个模板里面<strong>复用</strong>的话，那么我们就可以把<strong>公共的功能单独抽取出来作为一个模块（Model）</strong>。 Model 是逐步抽象的过程，一般我们会在 Model里面封装一些公共的方法让不同 Controller 使用，也可以在 Model 中实现和数据库打交道</p><h3 id="Model里面封装公共的方法">Model里面封装公共的方法</h3><p>例如TimeToUnix 和 UnixToTime 这两个方法在控制器和模板中都需要使用到，所以可以把它提取出来成为一个model,例如:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> models</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 把Unix时间戳转换为时间字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UnixToTime</span><span class="params">(unix <span class="type">int64</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">  <span class="comment">// 根据Unix时间戳生成时间对象</span></span><br><span class="line">  t := time.Unix(unix, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 格式化时间字符串并返回</span></span><br><span class="line">  <span class="keyword">return</span> t.Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把日期转换为时间戳</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TimeToUnix</span><span class="params">(t <span class="type">string</span>)</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">  template := <span class="string">&quot;2006-01-02 15:04:05&quot;</span></span><br><span class="line">  <span class="comment">// 解析时间字符串，time.Local表示本地时间的时区</span></span><br><span class="line">  tm, err := time.ParseInLocation(template, t, time.Local)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> tm.Unix()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到当前时间的时间戳</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetCurrentTime</span><span class="params">()</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> time.Now().Unix()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>注意</strong>: 当使用时间模板的时候，其值必须是2006年1月2日 15:04:05这个时间点，否则解析出来的会出错，但是格式可以不一样，可以是<code>2006-01-02 15:04:05</code> 或者 <code>2006/01/02 15:04:05</code></li></ul><h3 id="在Model中注册全局模板函数">在Model中注册全局模板函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// models/tools.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 把Unix时间戳转换为时间字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UnixToTime</span><span class="params">(unix <span class="type">int64</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">  <span class="comment">// 根据Unix时间戳生成时间对象</span></span><br><span class="line">  t := time.Unix(unix, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 格式化时间字符串并返回</span></span><br><span class="line">  <span class="keyword">return</span> t.Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.go</span></span><br><span class="line">r := gin.Default()</span><br><span class="line">r.SetFuncMap(template.FuncMap&#123; <span class="string">&quot;unixToDate&quot;</span>: models.UnixToDate, &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板</span></span><br><span class="line">&lt;h2&gt;&#123;&#123;.now | unixToDate&#125;&#125;&lt;/h2&gt;</span><br></pre></td></tr></table></figure><p>这样就可以在模板中使用<code>unixToDate</code>函数了</p><h2 id="Gin文件上传">Gin文件上传</h2><p>功能：将前端上传的文件保存到服务器中</p><h3 id="单个文件上传">单个文件上传</h3><ol><li>前端使用HTML表单上传文件（需要在上传文件的 form 表单上面需要加入 enctype=“multipart/form-data”）</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; define &quot;admin/user/add.html&quot;&#125;&#125;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span> = <span class="string">&quot;/admin/user/doUpload&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">        用户名: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">&quot;text&quot;</span> <span class="attr">name</span> = <span class="string">&quot;username&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入用户名&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        头 像: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">&quot;file&quot;</span> <span class="attr">name</span> = <span class="string">&quot;face&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">&quot;submit&quot;</span> <span class="attr">value</span> = <span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>编写业务逻辑</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// userRouter.go </span></span><br><span class="line">adminRouters.GET(<span class="string">&quot;/add&quot;</span>, admin.UserController&#123;&#125;.Add)</span><br><span class="line"></span><br><span class="line"><span class="comment">// userController.go</span></span><br><span class="line"><span class="keyword">type</span> UserController <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(con UserController)</span></span> Add(c *gin.Context) &#123;</span><br><span class="line">  c.HTML(http.StatusOK, <span class="string">&quot;admin/user/add.html&quot;</span>, gin.H&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// adminRouter.go</span></span><br><span class="line">adminRouters.POST(<span class="string">&quot;/user/doUpload&quot;</span>, admin.DoAdd)</span><br><span class="line"></span><br><span class="line"><span class="comment">// adminController.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoAdd</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 从表单中获取用户名</span></span><br><span class="line">  username := c.PostForm(<span class="string">&quot;username&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取上传的文件名，对应html中的name属性</span></span><br><span class="line">  file, err := c.FormFile(<span class="string">&quot;face&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    c.JSON(http.StatusInternalServerError, gin.H&#123;</span><br><span class="line">      <span class="string">&quot;message&quot;</span>: err.Error(),</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  dst := path.Join(<span class="string">&quot;./static/uploads&quot;</span>, file.Filename)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保存文件到本地dst路径下</span></span><br><span class="line">  c.SaveUploadedFile(file, dst)</span><br><span class="line"></span><br><span class="line">  c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">    <span class="string">&quot;success&quot;</span>:  <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;path&quot;</span>:     dst,</span><br><span class="line">    <span class="string">&quot;username&quot;</span>: username,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="多个文件上传">多个文件上传</h3><p>同名文件的上传:</p><ol><li>前端使用HTML表单上传文件（需要在上传文件的 form 表单上面需要加入 enctype=“multipart/form-data”）</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; define &quot;admin/user/add.html&quot;&#125;&#125;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span> = <span class="string">&quot;/admin/user/doUpload&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">        用户名: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">&quot;text&quot;</span> <span class="attr">name</span> = <span class="string">&quot;username&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入用户名&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        头 像1: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">&quot;file&quot;</span> <span class="attr">name</span> = <span class="string">&quot;face[]&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        头 像2: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">&quot;file&quot;</span> <span class="attr">name</span> = <span class="string">&quot;face[]&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        头 像3: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">&quot;file&quot;</span> <span class="attr">name</span> = <span class="string">&quot;face[]&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">&quot;submit&quot;</span> <span class="attr">value</span> = <span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>编写业务逻辑</li></ol><p>与单文件相比，修改的主要是:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> admin</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;net/http&quot;</span></span><br><span class="line">  <span class="string">&quot;path&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行获取前端上传的文件和下载到本地</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoAdd</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 从表单中获取用户名</span></span><br><span class="line">  username := c.PostForm(<span class="string">&quot;username&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 会返回一个 MultipartForm 对象，该对象包含了上传的文件和其他表单数据</span></span><br><span class="line">  form, err := c.MultipartForm()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取上传的文件名，对应html中的name属性</span></span><br><span class="line">  files := form.File[<span class="string">&quot;face[]&quot;</span>]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    c.JSON(http.StatusInternalServerError, gin.H&#123;</span><br><span class="line">      <span class="string">&quot;message&quot;</span>: err.Error(),</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历所有文件</span></span><br><span class="line">  <span class="keyword">for</span> _, file := <span class="keyword">range</span> files &#123;</span><br><span class="line">    <span class="comment">// 处理单个文件</span></span><br><span class="line">    dst := path.Join(<span class="string">&quot;./static/uploads&quot;</span>, file.Filename)</span><br><span class="line">    <span class="comment">// 保存文件到本地dst路径下</span></span><br><span class="line">    c.SaveUploadedFile(file, dst)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">    <span class="string">&quot;success&quot;</span>:  <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;username&quot;</span>: username,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>注意</strong>: c.MultipartForm()会返回一个 MultipartForm 对象，该对象包含了上传的文件和其他表单数据<br>其内容如下:</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;multipart.<span class="title class_">Form</span>&#123;<span class="title class_">Value</span><span class="symbol">:map</span>[string][]string&#123;<span class="string">&quot;username&quot;</span><span class="symbol">:[]string</span>&#123;<span class="string">&quot;2&quot;</span>&#125;&#125;, <span class="title class_">File</span><span class="symbol">:map</span>[string][]*multipart.<span class="title class_">FileHeader</span>&#123;<span class="string">&quot;face[]&quot;</span><span class="symbol">:[]*multipart</span>.<span class="title class_">FileHeader</span>&#123;(*multipart.<span class="title class_">FileHeader</span>)(<span class="number">0xc000290180</span>), (*multipart.<span class="title class_">FileHeader</span>)(<span class="number">0xc0002901e0</span>), (*multipart.<span class="title class_">FileHeader</span>)(<span class="number">0xc000290240</span>)&#125;&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="按日期存储文件">按日期存储文件</h3><p>假设现在要实现这样的功能，将前端上传的图片获取到本地，并且存储在当天日期的文件下，文件名使用当时的时间戳</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> admin</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;log&quot;</span></span><br><span class="line">  <span class="string">&quot;os&quot;</span></span><br><span class="line">  <span class="string">&quot;path&quot;</span></span><br><span class="line">  <span class="string">&quot;project/models&quot;</span></span><br><span class="line">  <span class="string">&quot;strconv&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行获取前端上传的文件和下载到本地</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoAdd</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 获取上传的文件</span></span><br><span class="line">  file, err := c.FormFile(<span class="string">&quot;face&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Println(err)</span><br><span class="line">    c.String(<span class="number">400</span>, <span class="string">&quot;上传文件失败&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查文件的后缀名是否是jpg，.png，.jpeg，.gif</span></span><br><span class="line"></span><br><span class="line">  allowedExts := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>&#123;</span><br><span class="line">    <span class="string">&quot;.jpg&quot;</span>:  <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;.png&quot;</span>:  <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;.jpeg&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;.gif&quot;</span>:  <span class="literal">true</span>,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  extName := path.Ext(file.Filename)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ok := allowedExts[extName]; !ok &#123;</span><br><span class="line">    c.String(<span class="number">400</span>, <span class="string">&quot;上传文件格式不正确&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建文件目录</span></span><br><span class="line"></span><br><span class="line">  curDay := models.GetDay()</span><br><span class="line"></span><br><span class="line">  dir := <span class="string">&quot;./static/upload/&quot;</span> + curDay</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果存在就不会做任何事，否则就创建目录</span></span><br><span class="line">  os.MkdirAll(dir, <span class="number">0666</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 命名文件</span></span><br><span class="line">  fileName := strconv.FormatInt(models.GetCurrentTime(), <span class="number">10</span>) + extName</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行存储操作</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 存储的目的地</span></span><br><span class="line">  dst := path.Join(dir, fileName)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 存储文件</span></span><br><span class="line">  c.SaveUploadedFile(file, dst)</span><br><span class="line"></span><br><span class="line">  c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">    <span class="string">&quot;message&quot;</span>: <span class="string">&quot;上传成功&quot;</span>,</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="总结">总结</h3><p>获取上传文件的主要步骤是:</p><ol><li>使用c.FormFile(前端定义的name属性)获取上传的文件</li><li>使用c.SaveUploadedFile(获取的文件，目的地)保存文件到本地</li></ol><p>这期间可以做任何事，比如自定义存储路径和文件名等等，其中c指的是gin.Context对象，可以获取请求信息，设置响应信息等等。</p><h2 id="Gin的Cookie相关">Gin的Cookie相关</h2><h3 id="什么是Cookie">什么是Cookie</h3><ul><li>HTTP 是无状态协议。简单地说，当你浏览了一个页面，然后转到同一个网站的另一个页面，服务器无法认识到这是同一个浏览器在访问同一个网站。每一次的访问，都是没有任何关系的。如果我们要实现多个页面之间共享数据的话我们就可以使用 Cookie 或者 Session 实现</li><li>cookie 是存储于访问者计算机的浏览器中。可以让我们用同一个浏览器访问同一个域名的时候共享数据。</li></ul><h3 id="Cookie可以实现的功能">Cookie可以实现的功能</h3><ol><li>实现用户登录状态保持</li><li>保存用户浏览历史记录</li><li>猜你喜欢，智能推荐</li><li>电商网站的购物车功能</li></ol><h3 id="设置Cookie">设置Cookie</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.SetCookie(<span class="type">name</span>, <span class="keyword">value</span> string, maxAge <span class="type">int</span>, <span class="type">path</span>, <span class="keyword">domain</span> string, secure, httpOnly <span class="type">bool</span>)</span><br></pre></td></tr></table></figure><ol><li>第一个参数 key</li><li>第二个参数 value</li><li>第三个参数 过期时间.如果只想设置 Cookie 的保存路径而不想设置存活时间，可以在第三个参数中传递 nil</li><li>第四个参数 cookie 的路径</li><li>第五个参数 cookie 的路径 Domain 作用域 本地调试配置成 localhost , 正式上线配置成域名</li><li>第六个参数是 secure ，当 secure 值为 true 时，cookie 在 HTTP 中是无效，在 HTTPS 中才有效</li><li>第七个参数 httpOnly，是微软对 COOKIE 做的扩展。如果在 COOKIE 中设置了“httpOnly”属性，则通过程序（JS 脚本、applet 等）将无法读取到 COOKIE 信息，防止 XSS 攻击产生</li></ol><h3 id="获取Cookie">获取Cookie</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.Cookie(name <span class="type">string</span>) (value <span class="type">string</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure><h3 id="删除Cookie">删除Cookie</h3><p>删除Cookie 可以重新设置Cookie，让过期时间为-1即可</p><h3 id="多个二级域名共享cookie">多个二级域名共享cookie</h3><ol><li>分别把 <a href="http://a.pigcanstudy.com">a.pigcanstudy.com</a> 和 <a href="http://b.pigcanstudy.com">b.pigcanstudy.com</a> 解析到我们的服务器</li><li>我们想的是用户在 <a href="http://a.pigcanstudy.com">a.pigcanstudy.com</a> 中设置 Cookie 信息后在 <a href="http://b.pigcanstudy.com">b.pigcanstudy.com</a> 中获取刚才设置的cookie，也就是实现多个二级域名共享 cookie</li></ol><p>这时候可以这样使用</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">c</span>.SetCookie(<span class="string">&quot;usrename&quot;</span><span class="punctuation">,</span> <span class="string">&quot;张三&quot;</span><span class="punctuation">,</span> <span class="number">3600</span><span class="punctuation">,</span> <span class="string">&quot;/&quot;</span><span class="punctuation">,</span> <span class="string">&quot;.itying.com&quot;</span><span class="punctuation">,</span> <span class="keyword">false</span><span class="punctuation">,</span> <span class="keyword">true</span>)</span><br></pre></td></tr></table></figure><h3 id="案例使用">案例使用</h3><ul><li>需求如下:<ol><li>在 /setcookie 路由上，当你访问这个路由时，会设置一个名为 username 的cookie，值为 小鸟，并且设置过期时间为3600秒（1小时）。</li><li>然后在 /getcookie 路由上，当你访问这个路由时，会获取刚才设置的cookie，并返回给你。</li></ol></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cookieRouter.go</span></span><br><span class="line"><span class="keyword">package</span> cookie</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CookieController <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(con CookieController)</span></span> SetCookie(c *gin.Context) &#123;</span><br><span class="line">  c.SetCookie(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;小鸟&quot;</span>, <span class="number">3600</span>, <span class="string">&quot;/&quot;</span>, <span class="string">&quot;localhost&quot;</span>, <span class="literal">false</span>, <span class="literal">false</span>)</span><br><span class="line">  c.String(<span class="number">200</span>, <span class="string">&quot;设置cookie成功&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(con CookieController)</span></span> GetCookie(c *gin.Context) &#123;</span><br><span class="line">  str, _ := c.Cookie(<span class="string">&quot;username&quot;</span>)</span><br><span class="line"></span><br><span class="line">  c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">    <span class="string">&quot;username&quot;</span>: str,</span><br><span class="line">    <span class="string">&quot;success&quot;</span>:  <span class="literal">true</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// cookieRouters.go</span></span><br><span class="line"><span class="keyword">package</span> routers</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;project/controllers/cookie&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CookieRouterInit</span><span class="params">(r *gin.Engine)</span></span> &#123;</span><br><span class="line">  r.GET(<span class="string">&quot;/setcookie&quot;</span>, cookie.CookieController&#123;&#125;.SetCookie)</span><br><span class="line">  r.GET(<span class="string">&quot;/getcookie&quot;</span>, cookie.CookieController&#123;&#125;.GetCookie)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.go</span></span><br><span class="line"></span><br><span class="line">routers.CookieRouterInit(r)</span><br></pre></td></tr></table></figure><h2 id="Gin的Session相关">Gin的Session相关</h2><h3 id="什么是Session">什么是Session</h3><p>session 是另一种记录客户状态的机制，不同的是 Cookie 保存在客户端浏览器中，而 session保存在服务器上。</p><h3 id="Session的工作流程">Session的工作流程</h3><p>当客户端浏览器第一次访问服务器并发送请求时，服务器端会创建一个 session 对象，生成一个类似于 key,value 的键值对，然后将 value 保存到服务器 将 key(cookie)返回到浏览器(客户)端。浏览器下次访问时会携带 key(cookie)，找到对应的 session(value)。</p><h3 id="Gin中使用Session">Gin中使用Session</h3><p>Gin 官方没有给我们提供 Session 相关的文档，这个时候我们可以使用第三方的 Session 中间件来实现</p><blockquote><p><a href="https://github.com/gin-contrib/sessions">https://github.com/gin-contrib/sessions</a><br>gin-contrib/sessions 中间件支持的存储引擎：<br>cookie<br>memestore<br>redis<br>memcached<br>mongodb</p></blockquote><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="built_in">get</span> -<span class="keyword">u</span> github.<span class="keyword">com</span>/gin-contrib/sessions</span><br></pre></td></tr></table></figure><h3 id="基于Cookie存储Session">基于Cookie存储Session</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建基于 cookie 的存储引擎，secret11111 参数是用于加密的密钥</span></span><br><span class="line">  store := cookie.NewStore([]<span class="type">byte</span>(<span class="string">&quot;secret11111&quot;</span>))</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置 session 中间件，参数 mysession，指的是 session 的名字，也是 cookie 的名字</span></span><br><span class="line">  <span class="comment">// 配置中间件 store 是前面创建的存储引擎，我们可以替换成其他存储引擎</span></span><br><span class="line">  r.Use(sessions.Sessions(<span class="string">&quot;mysession&quot;</span>, store))</span><br><span class="line"></span><br><span class="line">  r.GET(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 初始化 session对象</span></span><br><span class="line">    session := sessions.Default(c)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置过期时间</span></span><br><span class="line">    session.Options(sessions.Options&#123;</span><br><span class="line">      MaxAge: <span class="number">3600</span> * <span class="number">6</span>,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置一个keyvalue</span></span><br><span class="line">    session.Set(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;张三&quot;</span>)</span><br><span class="line"></span><br><span class="line">    session.Save()</span><br><span class="line"></span><br><span class="line">    c.String(<span class="number">200</span>, <span class="string">&quot;session设置成功&quot;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  r.GET(<span class="string">&quot;/getsession&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 初始化session对象</span></span><br><span class="line">    session := sessions.Default(c)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取value</span></span><br><span class="line">    username := session.Get(<span class="string">&quot;username&quot;</span>)</span><br><span class="line">    c.String(<span class="number">200</span>, <span class="string">&quot;username: %s&quot;</span>, username)</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h3 id="基于Redis存储Session">基于Redis存储Session</h3><ul><li>一般用于分布式集群环境来共享数据</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化基于 redis 的存储引擎</span></span><br><span class="line">  <span class="comment">// 参数说明：</span></span><br><span class="line">  <span class="comment">// 第 1 个参数 - redis 最大的空闲连接数</span></span><br><span class="line">  <span class="comment">// 第 2 个参数 - 数通信协议 tcp 或者 udp</span></span><br><span class="line">  <span class="comment">// 第 3 个参数 - redis 地址, 格式，host:port</span></span><br><span class="line">  <span class="comment">// 第 4 个参数 - redis 密码</span></span><br><span class="line">  <span class="comment">// 第 5 个参数 - session 加密密钥</span></span><br><span class="line">  store1, _ := redis.NewStore(<span class="number">10</span>, <span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:6379&quot;</span>, <span class="string">&quot;&quot;</span>, []<span class="type">byte</span>(<span class="string">&quot;secret&quot;</span>))</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化 session 中间件，musession是会话名称</span></span><br><span class="line">  r.Use(sessions.Sessions(<span class="string">&quot;mysession&quot;</span>, store1))</span><br><span class="line">  r.GET(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    session := sessions.Default(c)</span><br><span class="line">    <span class="comment">// 这是标识一个用户的用户名(cookie)</span></span><br><span class="line">    session.Set(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;李四&quot;</span>)</span><br><span class="line">    session.Save()</span><br><span class="line">    c.JSON(<span class="number">200</span>, gin.H&#123;<span class="string">&quot;username&quot;</span>: session.Get(<span class="string">&quot;username&quot;</span>)&#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  r.GET(<span class="string">&quot;/user&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 初始化 session 对象</span></span><br><span class="line">    session := sessions.Default(c)</span><br><span class="line">    <span class="comment">// 通过 session.Get 读取 session 值</span></span><br><span class="line">    username := session.Get(<span class="string">&quot;username&quot;</span>)</span><br><span class="line">    c.JSON(<span class="number">200</span>, gin.H&#123;<span class="string">&quot;username&quot;</span>: username&#125;)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h3 id="总结-2">总结</h3><p>session中间件的使用方法是:</p><ol><li>创建一个存储引擎，比如基于cookie的存储引擎，或者基于redis的存储引擎(使用xxx.NewStore())</li><li>设置session中间件，参数是session的名字（也是浏览器的cookie），以及存储引擎(使用r.Use(sessions.Sessions(“mysession”, store)))</li><li>使用session中间件，通过session.Get()或者session.Set()来设置并使用session.Save()来保存或者获取session的值(具体看业务需求)</li></ol><h2 id="gin中使用go-ini来加载-ini配置文件">gin中使用go-ini来加载.ini配置文件</h2><h3 id="go-ini介绍">go-ini介绍</h3><ul><li>go-ini 官方介绍，go-ini 是地表 最强大、最方便 和 最流行 的 Go 语言 INI 文件操作库。</li><li>Github 地址：<a href="https://github.com/go-ini/ini">https://github.com/go-ini/ini</a></li><li>官方文档:<a href="https://ini.unknwon.io/">https://ini.unknwon.io/</a></li></ul><h3 id="go-ini使用">go-ini使用</h3>]]></content>
    
    
    <summary type="html">go的Web的轻量级框架Gin的使用</summary>
    
    
    
    <category term="Go" scheme="https://pigcanstudy.github.io/categories/Go/"/>
    
    
    <category term="Gin" scheme="https://pigcanstudy.github.io/tags/Gin/"/>
    
    <category term="Go" scheme="https://pigcanstudy.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>muduo网络库学习</title>
    <link href="https://pigcanstudy.github.io/posts/4389eda5.html"/>
    <id>https://pigcanstudy.github.io/posts/4389eda5.html</id>
    <published>2024-07-25T01:43:31.000Z</published>
    <updated>2024-11-29T09:14:30.740Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p><a href="#目录">目录</a></p><ul><li><a href="#Reactor">Reactor</a></li><li><p><a href="#muduo库三大核心组件之Channel类">muduo库三大核心组件之Channel类</a></p><ul><li><a href="#Channel头文件">Channel头文件</a></li><li><a href="#Channel实现">Channel实现</a></li><li><a href="#重要设计">重要设计</a></li></ul></li><li><a href="#muduo库三大核心组件之EventLoop类">muduo库三大核心组件之EventLoop类</a><ul><li><a href="#重要成员变量">重要成员变量</a></li><li><a href="#重要成员函数">重要成员函数</a></li><li><a href="#其中的巧妙设计">其中的巧妙设计</a></li></ul></li><li><p><a href="#muduo库三大核心组件之 Poller/EpollPoller类">muduo库三大核心组件之 Poller/EpollPoller类</a></p><ul><li><a href="#重要成员变量">poller/Epollpoller重要成员变量</a></li><li><a href="#重要成员函数">poller/Epollpoller重要成员函数</a></li></ul></li><li><a href="#muduo库Acceptor类">muduo库Acceptor类</a><ul><li><a href="#Acceptor重要成员变量">Acceptor重要成员变量</a></li><li><a href="#Acceptor重要成员函数">Acceptor重要成员函数</a></li><li><a href="#比较好的设计">比较好的设计</a></li></ul></li><li><a href="#muduo库Buffer类">muduo库Buffer类</a><ul><li><a href="#为什么需要buffer类">为什么需要buffer类?</a></li><li><a href="#Buffer设计思想">Buffer设计思想</a></li><li><a href="#Buffer重要成员变量">Buffer重要成员变量</a></li><li><a href="#Buffer重要成员函数">Buffer重要成员函数</a></li><li><a href="#iovec结构体定义">iovec结构体定义</a></li></ul></li><li><p><a href="#muduo库TcpConnection类">muduo库TcpConnection类</a></p><ul><li><p><a href="#设计思想以及一些感悟">设计思想以及一些感悟</a></p></li><li><p><a href="#TcpConnection重要成员变量">TcpConnection重要成员变量</a></p></li><li><a href="#TcpConnection重要成员函数">TcpConnection重要成员函数</a></li></ul></li><li><p><a href="#muduo库TcpServer">muduo库TcpServer</a></p><ul><li><a href="#TcpServer重要成员变量">TcpServer重要成员变量</a></li><li><a href="#TcpServer重要成员函数">TcpServer重要成员函数</a></li></ul></li><li><p><a href="#muduo库Thread类]">muduo库Thread类</a></p><ul><li><a href="#Thread重要成员变量">Thread重要成员变量</a></li><li><a href="#Thread重要成员函数">Thread重要成员函数</a></li></ul></li><li><p><a href="#muduo库EventLoopThread类">muduo库EventLoopThread类</a></p><ul><li><a href="#EventLoopThread重要成员变量">EventLoopThread重要成员变量</a></li><li><a href="#EventLoopThread重要成员函数">EventLoopThread重要成员函数</a></li></ul></li><li><p><a href="#muduo库EventLoopThreadPool类">muduo库EventLoopThreadPool类</a></p><ul><li><a href="#EventLoopThreadPool重要成员变量">EventLoopThreadPool重要成员变量</a></li><li><a href="#EventLoopThreadPool重要成员函数">EventLoopThreadPool重要成员函数</a></li></ul></li><li><a href="#EchoServer之建立">利用muduo库建立一个简单的EchoServer</a></li><li><a href="#muduo库中的定时器类">muduo库中的定时器类</a><ul><li><a href="#Timer类">Timer类</a><ul><li><a href="#Timer重要成员变量">Timer重要成员变量</a></li><li><a href="#Timer重要成员函数">Timer重要成员函数</a></li><li><a href="#Timer设计思想">Timer设计思想</a></li></ul></li><li><a href="#TimerId类">TimerId类</a><ul><li><a href="#TimerId重要成员变量">TimerId重要成员变量</a></li></ul></li><li><a href="#TimerQueue类">TimerQueue类</a><ul><li><a href="#TimerQueue重要成员变量">TimerQueue重要成员变量</a></li><li><a href="#TimerQueue重要成员函数">TimerQueue重要成员函数</a><ul><li><a href="#取消定时器逻辑">取消定时器逻辑</a></li><li><a href="#加入定时器逻辑">加入定时器逻辑</a></li><li><a href="#处理定时器过期逻辑">处理定时器过期逻辑</a></li><li><a href="#"></a></li></ul></li></ul></li></ul></li></ul></li></ul><h1 id="Reactor"><a href="#Reactor" class="headerlink" title="Reactor"></a>Reactor</h1><ul><li><p>Muduo库是基于Reactor模式实现的TCP网络编程库。其中的重要组件是由<strong>Event(事件)、Reactor(反应堆)、Demultiplex(事件分发器)和Evanthandler(事件处理器)</strong>四部分构成的，其相互关系如下图所示：</p><p><img src="../assets/2024-07-25-muduo网络库学习/20240725-180441.jpg" alt="image-20240725100624027"></p><ul><li>首先，将事件Event注册到反应堆Reactor上，即将应用程序感兴趣的事件注册到反应堆上，请求反应堆帮助监听，若事件发生，反应堆调用应用程序预制的回调(handler)，一个event对应一个handler；</li><li>反应堆Reactor相当于是一个事件以及事件处理的集合，通过相应的方法在事件分发器Demultiplex里做一个相应的调整（add/mod/del event），然后启动事件循环（epoll_wait），服务器处于阻塞状态等待新用户的连接，或者已连接用户的读写事件；</li><li>如果epoll_wait监听到有新事件产生，分发器返回事件给反应堆，反应堆调用相应的事件处理器eventhandler；</li><li>eventhandler中读取用户的请求，解码，处理，打包，发送。</li></ul></li><li><p>在muduo库的Reactor模型上：</p><ul><li>Poller和EPollPoller就是Demultiplex</li><li>Channel封装了Event，里面存在fd，events，revents，以及相应的回调函数callbacks，其中有两种channel，acceptorChannel以及connectionChannel分别对应listenfd以及connfd</li><li>EventLoop就是Reactor</li></ul></li><li><p>这也就看出<strong>muduo库的三个核心组件是：Channel类、Poller/EpollPoller类以及EventLoop类</strong>这三个组件之间的关系如下图所示：</p><p><img src="../assets/2024-07-25-muduo网络库学习/20240725-180505.jpg" alt="image-20240725101825823"></p></li></ul><h1 id="muduo库三大核心组件之Channel类"><a href="#muduo库三大核心组件之Channel类" class="headerlink" title="muduo库三大核心组件之Channel类"></a>muduo库三大核心组件之Channel类</h1><ul><li><strong>Channel</strong>类封装了一个 fd 、fd感兴趣事件events、该fd实际发生的事件revents。同时Channel类还提供了设置该fd的感兴趣事件，以及相应的回调函数。</li></ul><h2 id="channel头文件"><a href="#channel头文件" class="headerlink" title="channel头文件"></a>channel头文件</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Socket.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">理清楚 EventLoop Channel，Poller之间的关系 他们在Reactor上面对应的Demultiplex</span></span><br><span class="line"><span class="comment">Channel 理解为通道，封装了sockfd和其感兴趣的event，如EPOLLIN  EPOLLOUT事件</span></span><br><span class="line"><span class="comment">还绑定了poller返回的具体事件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EventLoop</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TimeStamp</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个监听端口和一个epoll即为一个channel</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Channel</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> EventCallback = std::function&lt;<span class="built_in">void</span>()&gt;;</span><br><span class="line">    <span class="keyword">using</span> ReadEventCallback = std::function&lt;<span class="built_in">void</span>(TimeStamp)&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Channel</span>(<span class="type">int</span> fd, EventLoop* event_loop);</span><br><span class="line">    <span class="built_in">Channel</span>(<span class="type">const</span> Channel&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Channel&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Channel&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    ~<span class="built_in">Channel</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="comment">//返回fd_</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fd</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 采用边缘触发</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">usetET</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置inepoll成员为true</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setinepoll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置revents成员的值为参数ev</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setrevents</span><span class="params">(<span class="type">uint32_t</span> ev)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 eventsl成员</span></span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">events</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 inepoll成员</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">inepoll</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 revents成员</span></span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">revents</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理epoll_wait返回的事件</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleevent</span><span class="params">(TimeStamp receiveTime)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止当channel被手动remove掉，channel还在执行回调操作时失效</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">tie</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;<span class="type">void</span>&gt;&amp; obj)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置fd相应的状态 update()相当于调用epoll_ctl</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">enableReading</span><span class="params">()</span> </span>&#123; events_ |= kReadEvent; <span class="built_in">update</span>();&#125; <span class="comment">//相当于把读事件给events相应的位置位了</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">disableReading</span><span class="params">()</span> </span>&#123; events_ &amp;= ~kReadEvent; <span class="built_in">update</span>();&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">enableWriting</span><span class="params">()</span> </span>&#123; events_ |= kWriteEvent; <span class="built_in">update</span>();&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">disableWriting</span><span class="params">()</span> </span>&#123; events_ &amp;= ~kWriteEvent; <span class="built_in">update</span>();&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">disableAll</span><span class="params">()</span> </span>&#123; events_ = kNoneEvent; <span class="built_in">update</span>();&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回fd当前的事件状态</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isNoneEvent</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> events_ == kNoneEvent;&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isReadEvent</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> events_ &amp; kReadEvent;&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isWriteEvent</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> events_ &amp; kWriteEvent;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// one loop per thread</span></span><br><span class="line">    <span class="function">EventLoop* <span class="title">onwerLoop</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> event_loop_;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置写事件回调函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setWriteCallBack</span><span class="params">(EventCallback wcb)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置读事件回调函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setReadCallBack</span><span class="params">(ReadEventCallback rcb)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置连接断开回调函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setCloseCallBack</span><span class="params">(EventCallback rcb)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置连接错误回调函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setErrorCallBack</span><span class="params">(EventCallback rcb)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示没有感兴趣的事件</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> kNoneEvent;</span><br><span class="line">    <span class="comment">// 表示感兴趣的是读事件</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> kReadEvent;</span><br><span class="line">    <span class="comment">// 表示感兴趣的是写事件</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> kWriteEvent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleEventWithGuard</span><span class="params">(TimeStamp receiveTime)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// channel拥有的fd，Channel和fd是一一对应的关系</span></span><br><span class="line">    <span class="type">int</span> fd_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// channel对应的红黑树，channel与EpollLoop是多对一的关系，一个Channel只对应一个EpollLoop</span></span><br><span class="line">    <span class="comment">// 一个EpollLoop可以对应多个Channel</span></span><br><span class="line">    EventLoop* event_loop_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Channel是已经添加到对应的epoll树中，false为未添加，true表示已经添加</span></span><br><span class="line">    <span class="comment">// 如果已经添加用EPOLL_CTL_MOD 否则用 EPOLL_CTL_ADD</span></span><br><span class="line">    <span class="type">bool</span> inepoll_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当客户端正常断开TCP连接，IO事件会触发Channel中的设置的CloseCallback回调</span></span><br><span class="line">    <span class="comment">// 但是用户代码在onClose()中有可能析构Channel对象，导致回调执行到一半的时候，其所属的Channel对象本身被销毁了</span></span><br><span class="line">    <span class="comment">// 为了解决这个问题 考虑延长生命周期，怎么延长？</span></span><br><span class="line">    <span class="comment">// 如果直接在另一个类声明一个强引用，但是这会出现循环引用问题</span></span><br><span class="line">    <span class="comment">// 所以想着使用弱引用，那弱引用该如何延长生命周期呢?</span></span><br><span class="line">    <span class="comment">// 可以在调用函数之前 将它提升为强引用赋值给一个强引用 从而增加引用计数</span></span><br><span class="line">    <span class="comment">// 在调用完某函数之前都不会引用计数变为0，执行完后出作用域，引用计数-1</span></span><br><span class="line"></span><br><span class="line">    std::weak_ptr&lt;<span class="type">void</span>&gt; tie_; <span class="comment">// 一方面这个若引用可以做到避免循环引用的现象，另一方面可以增加引用计数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示当前的 Channel对象 是否和一个生命周期受控的对象（如 `TcpServer` 或 `EventLoop`）关联。</span></span><br><span class="line">    <span class="comment">// 如果 `tied_` 为 `true`，则表示需要检查关联对象的生命周期。</span></span><br><span class="line">    <span class="type">bool</span> tied_;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// fd需要监听的事件，listenfd和clientfd需要监听EPOLLIN，</span></span><br><span class="line">    <span class="comment">// clientfd还可能监听EPOLLOUT事件</span></span><br><span class="line">    <span class="type">uint32_t</span> events_;</span><br><span class="line">    <span class="comment">// fd_中已发生的事件</span></span><br><span class="line">    <span class="type">uint32_t</span> revents_;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为channel可以获得fd最终发生的具体事件revent，所以他负责回调</span></span><br><span class="line">    <span class="comment">// 读事件回调函数</span></span><br><span class="line">    ReadEventCallback readcallback_;</span><br><span class="line">    <span class="comment">// 连接错误回调函数</span></span><br><span class="line">    EventCallback errorcallback_;</span><br><span class="line">    <span class="comment">// 连接断开回调函数</span></span><br><span class="line">    EventCallback closecallback_;</span><br><span class="line">    <span class="comment">// 写事件回调函数</span></span><br><span class="line">    EventCallback writecallback_;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="channel实现"><a href="#channel实现" class="headerlink" title="channel实现"></a>channel实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;TcpServer.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;EPollPoller.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Channel.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;InetAddress.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;logger.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TimeStamp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Channel::kNoneEvent = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Channel::kReadEvent = EPOLLIN | EPOLLPRI;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Channel::kWriteEvent = EPOLLOUT;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Channel::<span class="built_in">Channel</span>(<span class="type">int</span> fd, EventLoop* event_loop)</span><br><span class="line">        : <span class="built_in">fd_</span>(fd)</span><br><span class="line">        , <span class="built_in">event_loop_</span>(event_loop)</span><br><span class="line">        , <span class="built_in">inepoll_</span>(<span class="literal">false</span>)</span><br><span class="line">        , <span class="built_in">tied_</span>(<span class="literal">false</span>)</span><br><span class="line">        , <span class="built_in">events_</span>(<span class="number">0</span>)</span><br><span class="line">        , <span class="built_in">revents_</span>(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Channel::fd</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fd_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Channel::usetET</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    events_ = events_|EPOLLET;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Channel::setinepoll</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    inepoll_ = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Channel::setrevents</span><span class="params">(<span class="type">uint32_t</span> ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    revents_ = ev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">Channel::events</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> events_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Channel::inepoll</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> inepoll_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">Channel::revents</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> revents_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Channel::setReadCallBack</span><span class="params">(ReadEventCallback rcb)</span></span>&#123;</span><br><span class="line">    readcallback_ = std::<span class="built_in">move</span>(rcb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Channel::setCloseCallBack</span><span class="params">(EventCallback rcb)</span> </span>&#123;</span><br><span class="line">    closecallback_ = std::<span class="built_in">move</span>(rcb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Channel::setErrorCallBack</span><span class="params">(EventCallback rcb)</span> </span>&#123;</span><br><span class="line">    errorcallback_ = std::<span class="built_in">move</span>(rcb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Channel::setWriteCallBack</span><span class="params">(EventCallback wcb)</span> </span>&#123;</span><br><span class="line">    writecallback_ = std::<span class="built_in">move</span>(wcb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Channel::handleevent</span><span class="params">(TimeStamp receiveTime)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tied_) &#123;</span><br><span class="line">        std::shared_ptr&lt;<span class="type">void</span>&gt; guard = tie_.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span>(guard) &#123;</span><br><span class="line">            <span class="built_in">handleEventWithGuard</span>(receiveTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">handleEventWithGuard</span>(receiveTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Channel::handleEventWithGuard</span><span class="params">(TimeStamp receiveTime)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;channel handleEvent revents:%d\n&quot;</span>,revents_);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// EPOLLRDHUP 表示对方已经关闭</span></span><br><span class="line">    <span class="keyword">if</span>((revents_ &amp; EPOLLRDHUP) &amp;&amp; !(revents_ &amp; EPOLLIN))&#123;</span><br><span class="line">        <span class="keyword">if</span> (closecallback_) &#123;</span><br><span class="line">            <span class="built_in">closecallback_</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// EPOLLPRI 表示外带数据</span></span><br><span class="line">    <span class="keyword">if</span>(revents_ &amp; (EPOLLIN | EPOLLPRI) ) &#123;</span><br><span class="line">       <span class="keyword">if</span> (readcallback_) &#123;</span><br><span class="line">            <span class="built_in">readcallback_</span>(receiveTime);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;Read callback not set for fd= %d\n&quot;</span>, fd_);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(revents_ &amp; EPOLLOUT)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(writecallback_)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">writecallback_</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(errorcallback_) <span class="built_in">errorcallback_</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Channel::update</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过channel所属的EventLoop，把当前的channel删除掉</span></span><br><span class="line">    event_loop_-&gt;<span class="built_in">updatechannel</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Channel::remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//通过channel所属的EventLoop，调用Poller相应的方法，移除fd的events事件</span></span><br><span class="line">    event_loop_-&gt;<span class="built_in">removechannel</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Channel::tie</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;<span class="type">void</span>&gt; &amp;obj)</span> </span>&#123;</span><br><span class="line">    tie_ = obj;</span><br><span class="line">    tied_ = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="重要设计"><a href="#重要设计" class="headerlink" title="重要设计"></a>重要设计</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="comment">// 当客户端正常断开TCP连接，IO事件会触发Channel中的设置的CloseCallback回调</span></span><br><span class="line">    <span class="comment">// 但是用户代码在onClose()中有可能析构Channel对象，导致回调执行到一半的时候，其所属的Channel对象本身被销毁了</span></span><br><span class="line">    <span class="comment">// 为了解决这个问题 考虑延长生命周期，怎么延长？</span></span><br><span class="line">    <span class="comment">// 如果直接在另一个类声明一个强引用，但是这会出现循环引用问题</span></span><br><span class="line">    <span class="comment">// 所以想着使用弱引用，那弱引用该如何延长生命周期呢?</span></span><br><span class="line">    <span class="comment">// 可以在调用函数之前 将它提升为强引用赋值给一个强引用 从而增加引用计数</span></span><br><span class="line">    <span class="comment">// 在调用完某函数之前都不会引用计数变为0，执行完后出作用域，引用计数-1</span></span><br><span class="line"></span><br><span class="line">    std::weak_ptr&lt;<span class="type">void</span>&gt; tie_; <span class="comment">// 一方面这个若引用可以做到避免循环引用的现象，另一方面可以增加引用计数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示当前的 Channel对象 是否和一个生命周期受控的对象（如 `TcpServer` 或 `EventLoop`）关联。</span></span><br><span class="line">    <span class="comment">// 如果 `tied_` 为 `true`，则表示需要检查关联对象的生命周期。</span></span><br><span class="line">    <span class="type">bool</span> tied_;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Channel::tie</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;<span class="type">void</span>&gt; &amp;obj)</span> </span>&#123;</span><br><span class="line">        tie_ = obj;</span><br><span class="line">        tied_ = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Channel::handleEvent</span><span class="params">(TimeStamp receiveTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(tied_)</span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;<span class="type">void</span>&gt; guard;</span><br><span class="line">        guard = tie_.<span class="built_in">lock</span>(); <span class="comment">//提升</span></span><br><span class="line">        <span class="keyword">if</span>(guard)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">handleEventWithGuard</span>(receiveTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">handleEventWithGuard</span>(receiveTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Channel::handleEventWithGuard</span><span class="params">(TimeStamp receiveTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;channel handleEvent revents:%d\n&quot;</span>,revents_);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接断开，并且fd上没有可读数据（默认水平触发）</span></span><br><span class="line">    <span class="keyword">if</span>((revents_ &amp; EPOLLHUP) &amp;&amp; !(revents_ &amp; EPOLLIN))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(closeCallback_)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">closeCallback_</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(revents_ &amp; EPOLLERR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (errorCallback_)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">errorCallback_</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(revents_ &amp; (EPOLLIN | EPOLLPRI))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(readCallback_)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">readCallback_</span>(receiveTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(revents_ &amp; EPOLLOUT)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(writeCallback_)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">writeCallback_</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong><em>tie</em></strong>这个成员变量的设计：<ol><li>当客户端正常断开TCP连接，IO事件会触发Channel中的设置的CloseCallback回调，但是用户代码在onClose()中有可能析构Channel对象，导致回调执行到一半的时候，其所属的Channel对象本身被销毁了</li><li>为了解决这个问题 考虑延长生命周期，怎么延长？<ol><li>如果直接在另一个类声明一个强引用，但是这会出现循环引用问题</li><li>所以想着使用弱引用，那弱引用该如何延长生命周期呢?</li><li>可以在调用函数之前 将它提升为强引用赋值给一个强引用 从而增加引用计数</li><li>在调用完某函数之前都不会引用计数变为0，执行完后出作用域，引用计数-1</li></ol></li></ol></li></ul><p>​           3. 我们可以看出handleEvent中tie实际上这是一个弱指针，绑定到TcpConnection的共享指针 ，如果可以原来的弱指针，变成了强指针，这时候tie()的作用     就表明了，延长了TcpConnection的生命周期，使之长过Channel::handleEvent()，保证了TcpConnection不被销毁</p><h1 id="muduo库三大核心组件之EventLoop类"><a href="#muduo库三大核心组件之EventLoop类" class="headerlink" title="muduo库三大核心组件之EventLoop类"></a>muduo库三大核心组件之EventLoop类</h1><ul><li>Poller封装了和事件监听有关的方法和成员，调用Poller派生类EpollPoller::poll方法，我们就可以获得发生事件的fd 及其 发生的事件。EventLoop是网络服务器中负责 循环 的重要模块，从而做到持续监听、持续获取监听结果、持续处理监听结果对应的事件。</li><li>也就是说： EventLoop起到一个驱动循环的功能，Poller负责从事件监听器上获取监听结果，Channel类将fd及其相关属性封装，并将fd及其感兴趣事件和发生的事件以及不同事件对应的回调函数封装在一起，这样在各个模块中传递更加方便。接着被EventLoop调用。</li><li>可能上面我画的图不能充分表达三者在muduo库中的角色，下面借用我在地铁站里吃闸机博主的图，可能会让大家看的更加直观。</li></ul><p><img src="https://img-blog.csdnimg.cn/direct/99d171403b4e4e6fafd2ab726ab7d102.png" alt="img"></p><h2 id="重要成员变量"><a href="#重要成员变量" class="headerlink" title="重要成员变量"></a>重要成员变量</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用来存放活跃的channels</span></span><br><span class="line">   ChannelList activeChannels_;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 指向poller 来调用他的API</span></span><br><span class="line">   std::unique_ptr&lt;Poller&gt; poller_;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 标志事件循环是否在执行</span></span><br><span class="line">   std::atomic_bool looping_;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 标志事件循环是否停止</span></span><br><span class="line">   std::atomic_bool quit_;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// poller返回发生事件的channels的时间点</span></span><br><span class="line">   TimeStamp pollReturnTime_;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 用来记录事件循环线程的tid</span></span><br><span class="line">   <span class="type">const</span> <span class="type">pid_t</span> threadId_;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** 这是用来唤醒事件循环线程（就是执行EventLoop.loop()的线程）</span></span><br><span class="line"><span class="comment">   // 其设计思想是当另外一个线程，调用了此EventLoop并往里面加入回调函数的时候，唤醒事件循环线程</span></span><br><span class="line"><span class="comment">   // 会有两种唤醒情况</span></span><br><span class="line"><span class="comment">       * 1. 会唤醒被poller_-&gt;poll(kPollTimeMs,&amp;activeChannels_);阻塞的事件循环线程</span></span><br><span class="line"><span class="comment">       * 2. 事件循环线程正在执行回调函数，当他执行完后，再次调用poller_-&gt;poll(kPollTimeMs,&amp;activeChannels_);</span></span><br><span class="line"><span class="comment">       * 由于有新的事件发生了（eventfd也就是wakeupChannel_有读事件）</span></span><br><span class="line"><span class="comment">       * 就不会被阻塞而继续执行doPendingFunctors();</span></span><br><span class="line"><span class="comment">   **/</span></span><br><span class="line">   <span class="type">int</span> wakeupFd_;</span><br><span class="line">   std::unique_ptr&lt;Channel&gt; wakeupChannel_;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 存放回调函数的所有集合</span></span><br><span class="line">   std::vector&lt;Functor&gt; pendingFunctors_;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 用来标志是否正在处理回调函数</span></span><br><span class="line">   std::atomic_bool pcallingPendingFunctors_;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 用来实现共享数据的互斥访问</span></span><br><span class="line">   std::mutex mutex_;</span><br></pre></td></tr></table></figure><ul><li>poller<em>就不用在多说什么了，通过它会返回给EventLoop发生的事件。</em></li><li><em>wakeupFd</em>是非常重要的一个成员，与之对应的wakeupChannel<em>,起到了一个唤醒loop所在的线程的作用，因为当前线程主要阻塞在poll函数上，唤醒的方法是手动激活这个wakeupChannel</em>， 写入几个字节让Channel变为可读， 当然这个Channel也注册到Pooll中，在下面的成员函数会详细介绍它的实现。</li><li>threadId<em>创建时要保存当前时间循环所在的线程，用于之后运行时判断使用EventLoop的线程是否时EventLoop所属的线程.</em></li><li><em>pollReturnTime</em>保存poll返回的时间，用于计算从激活到调用回调函数的延迟</li><li>activeChannels<em>就是poller返回的所有发生事件的channel列表。</em></li><li><em>callingPendingFunctors</em>标识当前loop是否有需要执行的回调操作</li><li>pendingFunctors<em>存储loop需要执行的所有回调操作，避免本来属于当前线程的回调函数被其他线程调用，应该把这个回调函数添加到属于它所属的线程，等待它属于的线程被唤醒后调用，满足线程安全</em></li><li><em>mutex</em>互斥锁，用来保护vector容器的线程安全操作</li></ul><h2 id="重要成员函数"><a href="#重要成员函数" class="headerlink" title="重要成员函数"></a>重要成员函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Functor = std::function&lt;<span class="built_in">void</span>()&gt;;</span><br><span class="line">    <span class="keyword">using</span> ChannelList = std::vector&lt;Channel*&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">EventLoop</span>();</span><br><span class="line">    ~<span class="built_in">EventLoop</span>();</span><br><span class="line">    <span class="built_in">EventLoop</span>(<span class="type">const</span> EventLoop&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    EventLoop&amp; <span class="keyword">operator</span>=(<span class="type">const</span> EventLoop&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开启事件循环</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//退出事件循环</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">quit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回处理的时间辍</span></span><br><span class="line">    <span class="function">TimeStamp <span class="title">pollReturnTime</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> pollReturnTime_; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//EventLoop的方法=&gt; poller的方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">updatechannel</span><span class="params">(Channel* channel)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removechannel</span><span class="params">(Channel* channel)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasChannel</span><span class="params">(Channel* channel)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往存放回调函数的所有集合加数据</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">queueInLoop</span><span class="params">(<span class="type">const</span> Functor&amp; cb)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">runInLoop</span><span class="params">(<span class="type">const</span> Functor&amp; cb)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用来唤醒事件循环线程</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wakeup</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 证明EventLoop创建时的线程id与当前线程id是否相等</span></span><br><span class="line">    <span class="comment">// 相等表示EventLoop就在所创建他的loop线程里面，可以执行回调</span></span><br><span class="line">    <span class="comment">// 不相等就需要queueInLoop，等待唤醒它自己的线程时，在执行回调</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isInLoopThread</span><span class="params">()</span> <span class="type">const</span></span>&#123; <span class="keyword">return</span> threadId_ == CurrentThread::<span class="built_in">tid</span>();&#125;</span><br><span class="line">    <span class="comment">//[[nodiscard]] EPollPoller* ReturnEPollPoller() const;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//唤醒用的 wake up</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleRead</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行回调函数用</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doPendingFunctors</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>其实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by ubuntu on 24-7-19.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;EventLoop.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Channel.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;logger.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/eventfd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//防止一个线程创建多个EventLoop</span></span><br><span class="line"><span class="comment">//当创建了一个EventLoop对象时，*t_loopInThisThread就指向这个对象</span></span><br><span class="line"><span class="comment">//在一个线程里面在创建EventLoop时，指针不为空就不会创建了</span></span><br><span class="line"><span class="comment">//从而控制了一个线程里面只有一个EventLoop</span></span><br><span class="line">__thread EventLoop *t_loopInThisThread = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义默认的Poller IO复用接口的超时时间</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kPollTimeMs = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建wakeupfd 用来notify唤醒subReactor处理新来的channel</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">createEventfd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//eventfd 计数不为零表示有可读事件发生，read 之后计数会清零，write 则会递增计数器。</span></span><br><span class="line">    <span class="type">int</span> evtfd = ::<span class="built_in">eventfd</span>(<span class="number">0</span>, EFD_NONBLOCK | EFD_CLOEXEC);</span><br><span class="line">    <span class="keyword">if</span> (evtfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_FATAL</span>(<span class="string">&quot;eventfd error:%d \n&quot;</span>,errno);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> evtfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventLoop::<span class="built_in">EventLoop</span>()</span><br><span class="line">    : <span class="built_in">activeChannels_</span>(<span class="number">0</span>)</span><br><span class="line">    , <span class="built_in">poller_</span>(Poller::<span class="built_in">newDefaultPoller</span>(<span class="keyword">this</span>))</span><br><span class="line">    , <span class="built_in">looping_</span>(<span class="literal">false</span>)</span><br><span class="line">    , <span class="built_in">quit_</span>(<span class="literal">false</span>)</span><br><span class="line">    , <span class="built_in">pollReturnTime_</span>(<span class="number">0</span>)</span><br><span class="line">    , <span class="built_in">threadId_</span>(CurrentThread::<span class="built_in">tid</span>())</span><br><span class="line">    , <span class="built_in">wakeupFd_</span>(<span class="built_in">createEventfd</span>())</span><br><span class="line">    , <span class="built_in">wakeupChannel_</span>(std::<span class="built_in">make_unique</span>&lt;Channel&gt;(wakeupFd_, <span class="keyword">this</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;EventLoop created %p in thread %d \n&quot;</span>,<span class="keyword">this</span> threadId_);</span><br><span class="line">    <span class="keyword">if</span>(t_loopInThisThread)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_FATAL</span>(<span class="string">&quot;Another EvnetLoop %p exists in this thread %d \n&quot;</span>,t_loopInThisThread, threadId_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        t_loopInThisThread = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置wakeupfd的事件类型以及发生事件后的回调操作</span></span><br><span class="line">    wakeupChannel_-&gt;<span class="built_in">setReadCallBack</span>(std::<span class="built_in">bind</span>(&amp;EventLoop::handleRead, <span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每一个eventloop都将监听wakeupchannel的EPOLLIN读事件了</span></span><br><span class="line">    <span class="comment">//minreactor通过给subreactor写东西，通知其苏醒</span></span><br><span class="line">    wakeupChannel_-&gt;<span class="built_in">enableReading</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventLoop::~<span class="built_in">EventLoop</span>() &#123;</span><br><span class="line">    wakeupChannel_-&gt;<span class="built_in">disableAll</span>();</span><br><span class="line">    wakeupChannel_-&gt;<span class="built_in">remove</span>();</span><br><span class="line">    <span class="built_in">close</span>(wakeupFd_);</span><br><span class="line">    t_loopInThisThread = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    looping_.<span class="built_in">store</span>(<span class="literal">true</span>);</span><br><span class="line">    quit_.<span class="built_in">store</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;EventLoop %p start looping \n&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!quit_) &#123;</span><br><span class="line">        activeChannels_.<span class="built_in">clear</span>();</span><br><span class="line">        pollReturnTime_ = poller_-&gt;<span class="built_in">poll</span>(kPollTimeMs, activeChannels_);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> activeChannel: activeChannels_) &#123;</span><br><span class="line">            <span class="comment">//poller监听哪些channel发生事件了，然后上报给EventLoop，通知channel处理相应的事件</span></span><br><span class="line">            activeChannel-&gt;<span class="built_in">handleevent</span>(pollReturnTime_);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * IO线程 mainloop accept fd &lt;= channel  subloop</span></span><br><span class="line"><span class="comment">         * mainloop事先注册一个回调cb，需要subloop执行</span></span><br><span class="line"><span class="comment">         * wakeup subloop后执行下面的方法 执行之前mainloop注册的cb回调</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//执行当前EventLoop事件循环需要处理的回调操作</span></span><br><span class="line">        <span class="built_in">doPendingFunctors</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;EventLoop %p stop looping,\n&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">    looping_ = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//退出事件循环</span></span><br><span class="line"><span class="comment">//1. loop在自己的线程中调用quit</span></span><br><span class="line"><span class="comment">//2. 在其他线程中调用的quit（在一个subloop（woker）中，调用了mainloop（IO）的quit）</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">                mainloop</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ****************************** 生产者-消费者的线程安全的队列（no）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    subloop1     subloop2     subloop3</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::quit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    quit_.<span class="built_in">store</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是在其它线程中，调用的quit 在一个subloop(woker)中，调用了mainLoop(IO)的quit</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">isInLoopThread</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">wakeup</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::wakeup</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> one = <span class="number">1</span>;</span><br><span class="line">    <span class="type">ssize_t</span> evnums = <span class="built_in">write</span>(wakeupFd_, &amp;one, <span class="keyword">sizeof</span> one);</span><br><span class="line">    <span class="keyword">if</span>(evnums != <span class="keyword">sizeof</span> one) &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;EventLoop::wakeup() writes %lu bytes instead of 8 \n&quot;</span>,evnums);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::handleRead</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> one&#123;&#125;;</span><br><span class="line">    <span class="type">ssize_t</span> n = <span class="built_in">read</span>(wakeupFd_, &amp;one, <span class="keyword">sizeof</span> one);</span><br><span class="line">    <span class="keyword">if</span>(n != <span class="keyword">sizeof</span> one)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;EventLoop::handleRead() reads %d bytes instead of 8&quot;</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::removechannel</span><span class="params">(Channel* channel)</span> </span>&#123;</span><br><span class="line">    poller_-&gt;<span class="built_in">removeChannel</span>(channel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::updatechannel</span><span class="params">(Channel* channel)</span> </span>&#123;</span><br><span class="line">    poller_-&gt;<span class="built_in">updateChannel</span>(channel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">EventLoop::hasChannel</span><span class="params">(Channel* channel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> poller_-&gt;<span class="built_in">hasChannel</span>(channel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::doPendingFunctors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用一个局部的vector和pendingFunctors_的交换，有两种好处</span></span><br><span class="line">    <span class="comment">// 1. 可以缩小pendingFunctors_的容量, 因为如果只是resize</span></span><br><span class="line">    <span class="comment">// 它只会重新设定大小（size）而不会重新设定容量</span></span><br><span class="line">    <span class="comment">// 2. 最重要的原因：可以最大的减小占用互斥锁的时间，使得其只在swap加锁</span></span><br><span class="line">    <span class="comment">// 在执行回调函数的时候不加锁，可能还能预防在执行回调函数的时候获取锁而死锁</span></span><br><span class="line">    <span class="comment">// 也能在确保执行回调函数的时候，能够往pendingFunctors_里加数据</span></span><br><span class="line">    std::vector&lt;Functor&gt; functors;</span><br><span class="line">    pcallingPendingFunctors_.<span class="built_in">store</span>(<span class="literal">true</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        functors.<span class="built_in">swap</span>(pendingFunctors_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处可以优化，将处理回调函数单独交给一个逻辑系统（线程池）来处理</span></span><br><span class="line">    <span class="comment">// 实现解耦</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> Functor&amp; func: functors) &#123;</span><br><span class="line">        <span class="built_in">func</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pcallingPendingFunctors_.<span class="built_in">store</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来与上处设计比较</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void EventLoop::doPendingFunctors() &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    pcallingPendingFunctors_.store(true);</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        std::lock_guard&lt;std::mutex&gt; lock(mutex_);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        // 此处可以优化，将处理回调函数单独交给一个逻辑系统（线程池）来处理</span></span><br><span class="line"><span class="comment">        // 实现解耦</span></span><br><span class="line"><span class="comment">        for(const Functor&amp; func: functors) &#123;</span></span><br><span class="line"><span class="comment">            func();</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    pcallingPendingFunctors_.store(false);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::runInLoop</span><span class="params">(<span class="type">const</span> Functor &amp;cb)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果调用的线程是事件循环线程直接调用回调函数</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isInLoopThread</span>()) &#123;</span><br><span class="line">        <span class="built_in">cb</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">queueInLoop</span>(cb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::queueInLoop</span><span class="params">(<span class="type">const</span> Functor &amp;cb)</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        pendingFunctors_.<span class="built_in">emplace_back</span>(cb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当出现以下两种情况的时候进行唤醒</span></span><br><span class="line">    <span class="comment">/** 这是用来唤醒事件循环线程（就是执行EventLoop.loop()的线程）</span></span><br><span class="line"><span class="comment">   // 其设计思想是当另外一个线程，调用了此EventLoop并往里面加入回调函数的时候，唤醒事件循环线程</span></span><br><span class="line"><span class="comment">   // 会有两种唤醒情况</span></span><br><span class="line"><span class="comment">       * 1. 会唤醒被poller_-&gt;poll(kPollTimeMs,&amp;activeChannels_);阻塞的事件循环线程</span></span><br><span class="line"><span class="comment">       * 2. 事件循环线程正在执行回调函数，当他执行完后，再次调用poller_-&gt;poll(kPollTimeMs,&amp;activeChannels_);</span></span><br><span class="line"><span class="comment">       * 由于有新的事件发生了（eventfd也就是wakeupChannel_有读事件）</span></span><br><span class="line"><span class="comment">       * 就不会被阻塞而继续执行doPendingFunctors();</span></span><br><span class="line"><span class="comment">   **/</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">isInLoopThread</span>() || pcallingPendingFunctors_.<span class="built_in">load</span>()) &#123;</span><br><span class="line">        <span class="built_in">wakeup</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="其中的巧妙设计"><a href="#其中的巧妙设计" class="headerlink" title="其中的巧妙设计"></a>其中的巧妙设计</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::doPendingFunctors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用一个局部的vector和pendingFunctors_的交换，有两种好处</span></span><br><span class="line">    <span class="comment">// 1. 可以缩小pendingFunctors_的容量, 因为如果只是resize</span></span><br><span class="line">    <span class="comment">// 它只会重新设定大小（size）而不会重新设定容量</span></span><br><span class="line">    <span class="comment">// 2. 最重要的原因：可以最大的减小占用互斥锁的时间，使得其只在swap加锁</span></span><br><span class="line">    <span class="comment">// 在执行回调函数的时候不加锁，可能还能预防在执行回调函数的时候获取锁而死锁</span></span><br><span class="line">    <span class="comment">// 也能在确保执行回调函数的时候，能够往pendingFunctors_里加数据</span></span><br><span class="line">    std::vector&lt;Functor&gt; functors;</span><br><span class="line">    pcallingPendingFunctors_.<span class="built_in">store</span>(<span class="literal">true</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        functors.<span class="built_in">swap</span>(pendingFunctors_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处可以优化，将处理回调函数单独交给一个逻辑系统（线程池）来处理</span></span><br><span class="line">    <span class="comment">// 实现解耦</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> Functor&amp; func: functors) &#123;</span><br><span class="line">        <span class="built_in">func</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pcallingPendingFunctors_.<span class="built_in">store</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个与上面比较</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::doPendingFunctors</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    pcallingPendingFunctors_.<span class="built_in">store</span>(<span class="literal">true</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此处可以优化，将处理回调函数单独交给一个逻辑系统（线程池）来处理</span></span><br><span class="line">        <span class="comment">// 实现解耦</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">const</span> Functor&amp; func: functors) &#123;</span><br><span class="line">            <span class="built_in">func</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pcallingPendingFunctors_.<span class="built_in">store</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><em>第一个比较巧妙的思想就是，使用一个局部的<code>vector</code>和<code>pendingFunctors_</code>的交换:</em></strong><ul><li><strong>可以缩小pendingFunctors_的容量, 因为如果只是resize, 它只会重新设定大小（size）而不会重新设定容量</strong></li><li><strong>最重要的原因：可以最大的减小占用互斥锁的时间，使得其只在swap加锁, 在执行回调函数的时候不加锁，可能还能预防在执行回调函数的时候获取锁而死锁,也能在确保执行回调函数的时候，能够往pendingFunctors_里加数据</strong></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::wakeup</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> one = <span class="number">1</span>;</span><br><span class="line">    <span class="type">ssize_t</span> evnums = <span class="built_in">write</span>(wakeupFd_, &amp;one, <span class="keyword">sizeof</span> one);</span><br><span class="line">    <span class="keyword">if</span>(evnums != <span class="keyword">sizeof</span> one) &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;EventLoop::wakeup() writes %lu bytes instead of 8 \n&quot;</span>,evnums);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::handleRead</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> one&#123;&#125;;</span><br><span class="line">    <span class="type">ssize_t</span> n = <span class="built_in">read</span>(wakeupFd_, &amp;one, <span class="keyword">sizeof</span> one);</span><br><span class="line">    <span class="keyword">if</span>(n != <span class="keyword">sizeof</span> one)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;EventLoop::handleRead() reads %d bytes instead of 8&quot;</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::runInLoop</span><span class="params">(<span class="type">const</span> Functor &amp;cb)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果调用的线程是事件循环线程直接调用回调函数</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isInLoopThread</span>()) &#123;</span><br><span class="line">        <span class="built_in">cb</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">queueInLoop</span>(cb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::queueInLoop</span><span class="params">(<span class="type">const</span> Functor &amp;cb)</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        pendingFunctors_.<span class="built_in">emplace_back</span>(cb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当出现以下两种情况的时候进行唤醒</span></span><br><span class="line">    <span class="comment">/** 这是用来唤醒事件循环线程（就是执行EventLoop.loop()的线程）</span></span><br><span class="line"><span class="comment">   // 其设计思想是当另外一个线程，调用了此EventLoop并往里面加入回调函数的时候，唤醒事件循环线程</span></span><br><span class="line"><span class="comment">   // 会有两种唤醒情况</span></span><br><span class="line"><span class="comment">       * 1. 会唤醒被poller_-&gt;poll(kPollTimeMs,&amp;activeChannels_);阻塞的事件循环线程</span></span><br><span class="line"><span class="comment">       * 2. 事件循环线程正在执行回调函数，当他执行完后，再次调用poller_-&gt;poll(kPollTimeMs,&amp;activeChannels_);</span></span><br><span class="line"><span class="comment">       * 由于有新的事件发生了（eventfd也就是wakeupChannel_有读事件）</span></span><br><span class="line"><span class="comment">       * 就不会被阻塞而继续执行doPendingFunctors();</span></span><br><span class="line"><span class="comment">   **/</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">isInLoopThread</span>() || pcallingPendingFunctors_.<span class="built_in">load</span>()) &#123;</span><br><span class="line">        <span class="built_in">wakeup</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><em>第二个比较巧妙的设计就是，使用<code>wakeupFd_</code>，这是最巧妙的</em></strong><ul><li>传统的进程/线程间唤醒办法是用pipe或者socketpair，IO线程始终监视管道上的可读事件，在需要唤醒的时候，其他线程向管道中写一个字节，这样IO线程就从IO multiplexing阻塞调用中返回。pipe和socketpair都需要一对文件描述符，且pipe只能单向通信，socketpair可以双向通信。一方面它比 pipe 少用一个 fd，节省了资源；另一方面，wakeupFd<em>的缓冲区管理也简单得多，全部buffer只有定长8 bytes，不像 pipe 那样可能有不定长的真正 buffer。muduo库也没有采用生产者消费者的模型，采用了wakeupFd</em>这种巧妙的思想，在今后的学习中，我们也可以进一步的使用它。</li><li>什么是<strong>eventfd</strong>，他是用来记录有多少的事件可读，其有两个函数read 清空计数，write类加技术（具体请参考:<a href="https://blog.csdn.net/EDDYCJY/article/details/118980819）">https://blog.csdn.net/EDDYCJY/article/details/118980819）</a></li><li>他可以用来跨线程通知</li><li>会有两种唤醒情况<pre><code>1. 会唤醒被poller_-&gt;poll(kPollTimeMs,&amp;activeChannels_);阻塞的事件循环线程1.  事件循环线程正在执行回调函数，当他执行完后，再次调用&#39;poller_-&gt;poll(kPollTimeMs,&amp;activeChannels_);&#39;由于有新的事件发生了（eventfd也就是wakeupChannel_有读事件），就不会被阻塞而继续执行doPendingFunctors();</code></pre></li></ul></li></ul><h1 id="muduo库三大核心组件之-Poller-EpollPoller类"><a href="#muduo库三大核心组件之-Poller-EpollPoller类" class="headerlink" title="muduo库三大核心组件之 Poller/EpollPoller类"></a>muduo库三大核心组件之 Poller/EpollPoller类</h1><p><img src="../assets/2024-07-25-muduo网络库学习/20240725-180512.jpg" alt="image-20240725101825823"></p><p><strong>Poller</strong>负责监听<a href="https://so.csdn.net/so/search?q=文件描述符&amp;spm=1001.2101.3001.7020">文件描述符</a>事件是否触发以及返回发生事件的文件描述符以及具体事件。在 muduo 中，使用抽象基类 Poller ，并由EpollPoller和PollPoller派生基类中继承实现 epoll 和 poll</p><h2 id="重要成员变量-1"><a href="#重要成员变量-1" class="headerlink" title="重要成员变量"></a>重要成员变量</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//poller.h</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">//map的key表示 sockfd  value表示所属的channel通道类型</span></span><br><span class="line">    <span class="keyword">using</span> ChannelMap = std::unordered_map&lt;<span class="type">int</span>, Channel*&gt;;</span><br><span class="line">    ChannelMap channels_;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 定义Poller所属的事件循环EventLoop</span></span><br><span class="line">    EventLoop* owernLoop_;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// EpollPoller</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">using</span> EventList = std::vector&lt;epoll_event&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//epoll_event初始的长度</span></span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> kInitEventListSize = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//epoll 的句柄</span></span><br><span class="line">    <span class="type">int</span> epollfd_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存放epoll返回的事件的容器</span></span><br><span class="line">    EventList events_;</span><br></pre></td></tr></table></figure><ul><li>详情见注释</li></ul><h2 id="重要成员函数-1"><a href="#重要成员函数-1" class="headerlink" title="重要成员函数"></a>重要成员函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Poller.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Channel.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">Poller::<span class="built_in">Poller</span>(EventLoop* loop):<span class="built_in">owernLoop_</span>(loop) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Poller::hasChannel</span><span class="params">(Channel* channel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = channels_.<span class="built_in">find</span>(channel-&gt;<span class="built_in">fd</span>());</span><br><span class="line">    <span class="keyword">return</span> it != channels_.<span class="built_in">end</span>() &amp;&amp; it-&gt;second == channel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//============== EpollPoller==============</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;EPollPoller.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;logger.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TimeStamp.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Channel.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">EPollPoller::<span class="built_in">EPollPoller</span>(EventLoop* loop)</span><br><span class="line">    : <span class="built_in">Poller</span>(loop)</span><br><span class="line">    , <span class="built_in">epollfd_</span>(<span class="built_in">epoll_create1</span>(EPOLL_CLOEXEC))</span><br><span class="line">    , <span class="built_in">events_</span>(kInitEventListSize)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (epollfd_ == <span class="number">-1</span>) &#123;</span><br><span class="line">       <span class="built_in">LOG_FATAL</span>(<span class="string">&quot;epoll_create error:%d \n&quot;</span>, errno);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="built_in">LOG_INFO</span>(<span class="string">&quot;epoll_create() successed&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EPollPoller::~<span class="built_in">EPollPoller</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">close</span>(epollfd_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过epoll_wait将发生事件的channel通过activeChannels告知给EventLoop</span></span><br><span class="line"><span class="function">TimeStamp <span class="title">EPollPoller::poll</span><span class="params">(<span class="type">int</span> timeoutMs, ChannelList &amp;activeChannels)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;func=%s =&gt; fd total count:%lu \n&quot;</span>,__FUNCTION__, channels_.<span class="built_in">size</span>());</span><br><span class="line">    <span class="comment">//events_是vector类型，</span></span><br><span class="line">    <span class="comment">//events_.begin()返回首元素的地址，</span></span><br><span class="line">    <span class="comment">//*events_.begin()为首元素的值</span></span><br><span class="line">    <span class="comment">//&amp;*events_.begin()存放首元素的地址</span></span><br><span class="line">    <span class="comment">//这就得到了vector底层首元素的起始地址</span></span><br><span class="line">    <span class="type">int</span> EventNums = <span class="built_in">epoll_wait</span>(epollfd_, &amp;*events_.<span class="built_in">begin</span>(), <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(events_.<span class="built_in">size</span>()), timeoutMs);</span><br><span class="line">    <span class="comment">//记录最开始poll里面的错误值</span></span><br><span class="line">    <span class="type">int</span> saveErrno = errno;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取发生事件的时间</span></span><br><span class="line">    <span class="function">TimeStamp <span class="title">now</span><span class="params">(TimeStamp::now())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(EventNums &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">&quot;%d events happended!\n&quot;</span>, EventNums);</span><br><span class="line">        <span class="built_in">fillActiveChannels</span>(EventNums, activeChannels);</span><br><span class="line">        <span class="comment">// 为了防止频繁开辟空间，选择提前开辟</span></span><br><span class="line">        <span class="keyword">if</span>(EventNums == events_.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            events_.<span class="built_in">resize</span>(events_.<span class="built_in">size</span>() * <span class="number">2</span>);</span><br><span class="line">            <span class="comment">//说明当前发生的事件可能多于vector能存放的 ，需要扩容，等待下一轮处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(EventNums == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;%s timeout! \n&quot;</span>,__FUNCTION__);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(saveErrno != EINTR) <span class="comment">//不是外部中断引起的</span></span><br><span class="line">        &#123;</span><br><span class="line">            errno = saveErrno;</span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;EPollPoller::poll() errno!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EPollPoller::fillActiveChannels</span><span class="params">(<span class="type">int</span> numEvents, ChannelList &amp;activeChannels)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; numEvents; i ++) &#123;</span><br><span class="line">        Channel *channel = <span class="built_in">static_cast</span>&lt;Channel*&gt;(events_[i].data.ptr);</span><br><span class="line">        <span class="comment">// 设置channel的返回事件</span></span><br><span class="line">        channel-&gt;<span class="built_in">setrevents</span>(events_[i].events);</span><br><span class="line">        <span class="comment">// EventLoop就拿到了他的poller给他返回的所有发生事件的channel列表了</span></span><br><span class="line">        activeChannels.<span class="built_in">push_back</span>(channel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//channel update remove =&gt; EventLoop updateChannel removeChannel =&gt;Poller updateChannel removeChannel</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *             EventLoop =&gt; poller.poll</span></span><br><span class="line"><span class="comment"> *   ChannelList          Poller</span></span><br><span class="line"><span class="comment"> *                     ChannelMap &lt;fd,channel*&gt;   epollfd</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EPollPoller::updateChannel</span><span class="params">(Channel* channel)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;func=%s =&gt; fd=%d  events=%d\n&quot;</span>,__FUNCTION__, channel-&gt;<span class="built_in">fd</span>(),channel-&gt;<span class="built_in">events</span>());</span><br><span class="line">    <span class="comment">// false 表示不再epoll的红黑树中</span></span><br><span class="line">    <span class="keyword">if</span>(!channel-&gt;<span class="built_in">inepoll</span>()) &#123;</span><br><span class="line">        <span class="built_in">update</span>(EPOLL_CTL_ADD, channel);</span><br><span class="line">        channels_[channel-&gt;<span class="built_in">fd</span>()] = channel;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(channel-&gt;<span class="built_in">isNoneEvent</span>()) &#123;</span><br><span class="line">            <span class="built_in">update</span>(EPOLL_CTL_DEL, channel);</span><br><span class="line">            channels_.<span class="built_in">erase</span>(channel-&gt;<span class="built_in">fd</span>());</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">update</span>(EPOLL_CTL_MOD,channel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EPollPoller::removeChannel</span><span class="params">(Channel* channel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!channel-&gt;<span class="built_in">inepoll</span>()) &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;channel not in epoll&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        channels_.<span class="built_in">erase</span>(channel-&gt;<span class="built_in">fd</span>());</span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">&quot;func=%s =&gt; fd=%d  \n&quot;</span>,__FUNCTION__, channel-&gt;<span class="built_in">fd</span>());</span><br><span class="line">        <span class="built_in">update</span>(EPOLL_CTL_DEL, channel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// operation分别是epoll_(ADD/MOD/DEL)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EPollPoller::update</span><span class="params">(<span class="type">int</span> operation, Channel* channel)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    epoll_event event&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    event.data.ptr = channel;</span><br><span class="line">    <span class="comment">// 把感兴趣的事件加入到events中</span></span><br><span class="line">    event.events = channel-&gt;<span class="built_in">events</span>();</span><br><span class="line">    event.data.fd = channel-&gt;<span class="built_in">fd</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">epoll_ctl</span>(epollfd_, operation, channel-&gt;<span class="built_in">fd</span>(), &amp;event) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(operation == EPOLL_CTL_DEL)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;epoll_ctl del error:%d\n&quot;</span>,errno);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">LOG_FATAL</span>(<span class="string">&quot;epoll_ctl add/mod error:%d\n&quot;</span>,errno);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="muduo库Acceptor类"><a href="#muduo库Acceptor类" class="headerlink" title="muduo库Acceptor类"></a>muduo库Acceptor类</h1><h2 id="Acceptor重要成员变量"><a href="#Acceptor重要成员变量" class="headerlink" title="Acceptor重要成员变量"></a>Acceptor重要成员变量</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Socket acceptSocket_;</span><br><span class="line">Channel acceptChannel_;</span><br><span class="line">std::shared_ptr&lt;EventLoop&gt; event_loop_;</span><br><span class="line">NewConnectionCallBack connectionCallBack_;</span><br><span class="line"><span class="type">bool</span> listening_;</span><br><span class="line"><span class="type">int</span> idlefd_;</span><br></pre></td></tr></table></figure><ul><li><p>event<em>loop__监听套接字的fd由哪个EventLoop负责循环监听以及处理相应事件，其实这个EventLoop就是main EventLoop。</em></p></li><li><p><em>acceptSocket</em> 服务器监听套接字的文件描述符</p></li><li><p>acceptChannel<em>把acceptSocket</em>及其感兴趣事件和事件对应的处理函数进行封装。</p></li><li><p>newConnetionCallback<em>这个是最重要的一个成员了，它的类型是using NewConnectionCallback = std::function<void(int sockfd, const InetAddress&)>;，在TcpServer构造函数中通过acceptor</em>-&gt;setNewConnetionCallback(std::bind(&amp;TcpServer::newConnection, this, std::placeholders::<em>1,std::placeholders::_2));将 TcpServer::newConnection函数注册给了这个成员变量。这个 TcpServer::newConnection函数的功能是通过轮询EventLoop *ioLoop = threadPool</em>-&gt;getNextLoop();选择一个subEventLoop，并把已经接受的连接分发给这个subEventLoop。_</p></li><li><p><em>listenning</em>是一个标志位</p></li><li><p>idlefd_是用来防止底层一直通知有事件以及为了优雅地处理文件描述符耗尽的情况，确保系统在高负载下仍能稳定工作</p><h2 id="Acceptor重要成员函数"><a href="#Acceptor重要成员函数" class="headerlink" title="Acceptor重要成员函数"></a>Acceptor重要成员函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by ubuntu on 24-7-19.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Acceptor.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Connection.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;logger.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/fcntl-linux.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">createNonblocking</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sockfd = ::<span class="built_in">socket</span>(AF_INET, SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sockfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_FATAL</span>(<span class="string">&quot;%s:%s:%d listen socket create err:%d \n&quot;</span>, __FILE__,__FUNCTION__,__LINE__,errno);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Acceptor::<span class="built_in">Acceptor</span>(std::shared_ptr&lt;EventLoop&gt; event_loop, <span class="type">const</span> InetAddress&amp; address, <span class="type">bool</span> resuseport)</span><br><span class="line">    : <span class="built_in">acceptSocket_</span>(<span class="built_in">createNonblocking</span>())</span><br><span class="line">    , <span class="built_in">acceptChannel_</span>(acceptSocket_.<span class="built_in">fd</span>(),event_loop)</span><br><span class="line">    , <span class="built_in">event_loop_</span>(event_loop)</span><br><span class="line">    , <span class="built_in">listening_</span>(<span class="literal">false</span>)</span><br><span class="line">    , <span class="built_in">idlefd_</span>(::<span class="built_in">open</span>(<span class="string">&quot;/dev/null&quot;</span>, O_RDONLY | O_CLOEXEC)) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(idlefd_ &gt;= <span class="number">0</span>);</span><br><span class="line">    acceptSocket_.<span class="built_in">SetReuseaddr</span>(<span class="literal">true</span>);</span><br><span class="line">    acceptSocket_.<span class="built_in">SetReuseport</span>(resuseport);</span><br><span class="line">    acceptSocket_.<span class="built_in">bind</span>(address);</span><br><span class="line">    <span class="built_in">setNewConnectionCallBack</span>(std::<span class="built_in">bind</span>(&amp;Acceptor::handleread, <span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Acceptor::~<span class="built_in">Acceptor</span>() &#123;</span><br><span class="line">    acceptChannel_.<span class="built_in">disableAll</span>();</span><br><span class="line">    acceptChannel_.<span class="built_in">remove</span>();</span><br><span class="line">    <span class="built_in">close</span>(idlefd_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Acceptor::listen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    acceptChannel_.<span class="built_in">enableReading</span>();</span><br><span class="line">    listening_ = <span class="literal">true</span>;</span><br><span class="line">    acceptSocket_.<span class="built_in">listen</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Acceptor::handleread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    InetAddress clientAddress&#123;&#125;;</span><br><span class="line">    <span class="type">int</span> connfd = acceptSocket_.<span class="built_in">accept</span>(clientAddress);</span><br><span class="line">    <span class="keyword">if</span>(connfd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(connectionCallBack_) &#123;</span><br><span class="line">            <span class="built_in">connectionCallBack_</span>(connfd, clientAddress);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">close</span>(connfd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;in Acceptor::handleRead&quot;</span>);</span><br><span class="line">        <span class="comment">// 由于采用了LT，为了防止一直通知，使用idlefd_来接受读事件</span></span><br><span class="line">        <span class="comment">//`idleFd_`的设计是为了优雅地处理文件描述符耗尽的情况，确保系统在高负载下仍能稳定工作。</span></span><br><span class="line">        <span class="comment">//通过预先打开一个文件描述符（`/dev/null`），在文件描述符耗尽时释放它来接受新连接，</span></span><br><span class="line">        <span class="comment">//然后再重新打开`/dev/null`，这种机制可以有效避免程序因无法分配文件描述符而崩溃。</span></span><br><span class="line">        <span class="keyword">if</span> (errno == EMFILE)</span><br><span class="line">        &#123;</span><br><span class="line">            ::<span class="built_in">close</span>(idlefd_);</span><br><span class="line">            idlefd_ = ::<span class="built_in">accept</span>(acceptSocket_.<span class="built_in">fd</span>(), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">            ::<span class="built_in">close</span>(idlefd_);</span><br><span class="line">            idlefd_ = ::<span class="built_in">open</span>(<span class="string">&quot;/dev/null&quot;</span>, O_RDONLY | O_CLOEXEC);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>其中值得一提的是handleread的实现:</p><p>这里主要是建立连接，通过调用Socket的accept函数，底层调用系统的accept函数，返回一个已连接的socket描述字，这样连接就建立了。同时内部还调用了成员变量newConnectionCallback<em>保存的函数，当mainLoop监听到acceptChannel</em>上发生了可读事件时（新用户连接事件），就是调用这个handleRead( )方法,内部调用newConnetionCallback_，也就是TcpServer设置的一个回调函数setNewConnetionCallback，绑定了TcpServer::newConnection，通过 轮询算法，选择一个subloop，分发当前的新客户端的Channel，并且绑定了一些回调。</p></li></ul><h2 id="比较好的设计"><a href="#比较好的设计" class="headerlink" title="比较好的设计"></a>比较好的设计</h2><ul><li>idlefd：</li><li>这个思想也是很巧妙的，在调用accept的过程中，如果已用文件描述符过多，accept会返回-1，构造函数中注册的idleFd<em>就派上用场了。当前文件描述符过多，无法接收新的连接。但是由于我们采用LT模式，如果无法接收，可读事件会一直触发。那么在这个地方的处理机制就是，关掉之前创建的空的idleFd</em>，然后去accept，这样进行了连接，让这个事件不会一直触发，然后再关掉该文件描述符，重新将它设置为空文件描述符。这样就优雅的解决 EMFIFE 问题，也就是为了优雅地处理文件描述符耗尽的情况，确保系统在高负载下仍能稳定工作。</li></ul><h1 id="muduo库Buffer类"><a href="#muduo库Buffer类" class="headerlink" title="muduo库Buffer类"></a>muduo库Buffer类</h1><p>(本文参考链接：<a href="https://blog.csdn.net/m0_73537205/article/details/138665904">https://blog.csdn.net/m0_73537205/article/details/138665904</a>)</p><h2 id="为什么需要buffer类？"><a href="#为什么需要buffer类？" class="headerlink" title="为什么需要buffer类？"></a>为什么需要buffer类？</h2><ul><li>首先是为什么要有 <code>Buffer</code>？为什么不能直接接收和发送呢，如果直接使用 read()、write() 系统调用进行操作，就可以直接将应用层数据发送出去或者将内核数据读取到应用层，加上 <code>Buffer</code> 以后，相当于在应用层数据和内核缓冲区之间又多了一层，会不会造成负面影响呢？[2] 中明确，应用层的缓冲区是必要的，因为非阻塞 IO 的核心就是避免阻塞以在 read() 和 write() 为代表的系统调用上。 </li><li>对于发送来说，假设应用程序需要发送 40KB 数据，但是操作系统的 TCP 发送缓冲区只有 25KB  剩余空间，如果等待内核缓冲区可用，就会阻塞当前线程，因为不知道对方什么时候收到并读取数据。因此网络库应该把这 15KB 数据先缓存起来，等 fd 变得可写的时候立刻发送数据，这样操作才不会造成阻塞。需要注意，如果应用程序随后又要发送 50KB  数据，而此时发送缓冲区中尚有未发送的数据，那么网络库应该将这 50KB 数据追加到发送缓冲区的末尾，而不能立刻尝试  write()，因为这样有可能打乱数据的顺序。对于接收来说，假设一次读到的数据不够一个完整的数据包，那么这些已经读到的数据应该先暂存在某个地方，等剩余的数据收到之后再一并处理。所以说，发送缓冲区和接收缓冲区的存在都是必要的。 </li></ul><h2 id="Buffer设计思想"><a href="#Buffer设计思想" class="headerlink" title="Buffer设计思想"></a>Buffer设计思想</h2><ul><li>muduo的Buffer的定义如下，其内部是 一个 std::vector，且还存在两个size<em>t类型的readerIndex</em>，writerIndex_标识来表示读写的位置。结构图如下：</li></ul><p><img src="../assets/2024-07-25-muduo网络库学习/f8c9c09e6a1b48aea757f936f931ae64.png" alt="img"></p><ul><li><p>readIndex、writeIndex把整个vector内容分为3块：prependable、readable、writable，各块大小关系：</p><ul><li>prependable = readIndex</li><li>readable = writeIndex - readIndex</li><li>writable = buffer.size() - writeIndex</li></ul></li><li><p>Buffer类是可以动态扩容的，在下面的成员函数中，会详细介绍。</p></li></ul><h2 id="Buffer重要成员变量"><a href="#Buffer重要成员变量" class="headerlink" title="Buffer重要成员变量"></a>Buffer重要成员变量</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//缓冲区头部</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">size_t</span> kCheapPrepend = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//缓冲区读写初始大小</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">size_t</span> kInitialSize = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">char</span>&gt; buffer_;</span><br><span class="line"><span class="type">size_t</span> readerIndex_;</span><br><span class="line"><span class="type">size_t</span> writerIndex_;</span><br></pre></td></tr></table></figure><ul><li>其中readerIndex_指向的可读地区的起始地址</li><li>writerIndec_指向的是可写位置的起始地址</li></ul><h2 id="Buffer重要成员函数"><a href="#Buffer重要成员函数" class="headerlink" title="Buffer重要成员函数"></a>Buffer重要成员函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回可读的缓冲区大小</span></span><br><span class="line">    [[nodiscard]] <span class="function"><span class="type">size_t</span> <span class="title">readAbleBytes</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> writerIndex_ - readerIndex_;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回可写的缓冲区大小</span></span><br><span class="line">    [[nodiscard]] <span class="function"><span class="type">size_t</span> <span class="title">writeAbleBytes</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> buffer_.<span class="built_in">size</span>() - writerIndex_;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回缓冲区头部大小</span></span><br><span class="line">    [[nodiscard]] <span class="function"><span class="type">size_t</span> <span class="title">prependAbleBytes</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> readerIndex_;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回缓冲区中可读数据的起始地址</span></span><br><span class="line">    [[nodiscard]] <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">peek</span><span class="params">()</span> <span class="type">const</span></span>&#123; <span class="keyword">return</span> <span class="built_in">begin</span>() + readerIndex_;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回缓冲区可以写的起始地址</span></span><br><span class="line">    [[nodiscard]] <span class="function"><span class="type">char</span>* <span class="title">beginWrite</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">begin</span>() + writerIndex_; &#125;</span><br><span class="line"></span><br><span class="line">    [[nodiscard]] <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">beginWrite</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">begin</span>() + writerIndex_; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回数据的首地址</span></span><br><span class="line">    [[nodiscard]] <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">//it.operator*() 首元素  it.operator*().operator&amp;() 首元素的地址</span></span><br><span class="line">        <span class="keyword">return</span> &amp;*buffer_.<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [[nodiscard]] <span class="function"><span class="type">char</span>* <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//it.operator*() 首元素  it.operator*().operator&amp;() 首元素的地址</span></span><br><span class="line">        <span class="keyword">return</span> &amp;*buffer_.<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>这几个代码功能如注释所示</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="comment">// 把[data ,data+len]内存上的数据，添加到writeable缓冲区当中</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">append</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* data, <span class="type">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确定是否可以写入</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ensureWriterableBytes</span><span class="params">(<span class="type">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容操作</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">makespace</span><span class="params">(<span class="type">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//===================================以下为对应实现============================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 考虑两种扩容情况</span></span><br><span class="line"><span class="comment">// 1. 预留空间 加上 可写空间不足的的话 就直接扩容</span></span><br><span class="line"><span class="comment">// 2. 否则 就不直接扩容，而是重新分配下 内部结构</span></span><br><span class="line"><span class="comment">// 这样可以避免内存空间的浪费</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::makespace</span><span class="params">(<span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">prependAbleBytes</span>() + <span class="built_in">writeAbleBytes</span>() &lt; len + kCheapPrepend) &#123;</span><br><span class="line">        buffer_.<span class="built_in">resize</span>(writerIndex_ + len);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">size_t</span> readable = <span class="built_in">readAbleBytes</span>();</span><br><span class="line">        std::<span class="built_in">copy</span>(<span class="built_in">begin</span>() + readerIndex_, <span class="built_in">begin</span>() + writerIndex_, <span class="built_in">begin</span>() + kCheapPrepend);</span><br><span class="line">        readerIndex_ = kCheapPrepend;</span><br><span class="line">        writerIndex_ = readerIndex_ + readable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::ensureWriterableBytes</span><span class="params">(<span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不够写就扩容</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">writeAbleBytes</span>() &lt; len) &#123;</span><br><span class="line">        <span class="built_in">makespace</span>(len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::append</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *data, <span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ensureWriterableBytes</span>(len);</span><br><span class="line">    std::<span class="built_in">copy</span>(data, data + len, <span class="built_in">beginWrite</span>());</span><br><span class="line">    writerIndex_ += len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong><em>比较巧妙的思想是:</em></strong>在进行扩容的时候考虑两种扩容情况</p><ol><li>预留空间 加上 可写空间（prependableBytes() + writerableBytes()）不足的的话 就直接扩容</li><li>否则 就不直接扩容，而是重新分配下 内部结构</li></ol><p>这样可以避免内存空间的浪费（<strong>因为更新可读与可写地区的时候是通过移动两个Index实现的，可能readerIndex会一直往右移，导致空间预留空间越来越大，如果直接扩容会导致内存空间的浪费</strong>）</p></li></ul><p><img src="../assets/2024-07-25-muduo网络库学习/buffer扩容演示.jpg" alt="img"></p><p><img src="../assets/2024-07-25-muduo网络库学习/扩容演示.png" alt="在这里插入图片描述"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 读len长的数据，并进行移动位置</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">retrieve</span><span class="params">(<span class="type">size_t</span> len)</span></span>; <span class="comment">//len表示已经读了的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果都读完了</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">retrieveAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把onMessage函数上报的Buffer数据，转成string类型的数据返回</span></span><br><span class="line">    <span class="function">std::string <span class="title">retrieveAllAsString</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从起始位置读len长</span></span><br><span class="line">    <span class="function">std::string <span class="title">retrieveAsString</span><span class="params">(<span class="type">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//===================================以下为对应实现============================================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::retrieve</span><span class="params">(<span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(len &lt; <span class="built_in">readAbleBytes</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//已经读的小于可读的，只读了一部分len</span></span><br><span class="line">        <span class="comment">//还剩readerIndex_ += len 到 writerIndex_</span></span><br><span class="line">        readerIndex_ += len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//len == readableBytes()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">retrieveAll</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::retrieveAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    readerIndex_ = writerIndex_ = kCheapPrepend;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">Buffer::retrieveAllAsString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">retrieveAsString</span>(<span class="built_in">readAbleBytes</span>());<span class="comment">//应用可读取数据的长度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">Buffer::retrieveAsString</span><span class="params">(<span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从起始位置读len长</span></span><br><span class="line">    std::string result&#123;<span class="built_in">peek</span>(), len&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上面一句吧缓冲区可读的数据读出来，这里对缓冲区进行复位操作</span></span><br><span class="line">    <span class="built_in">retrieve</span>(len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这部分函数是对读数据操作的函数，其功能见注释</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//从fd上读取数据</span></span><br><span class="line">    <span class="function"><span class="type">ssize_t</span> <span class="title">readFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span>* saveErrno)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过fd发送数据</span></span><br><span class="line">    <span class="function"><span class="type">ssize_t</span> <span class="title">writeFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span>* saveErrno)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// ===========================其对应实现===================================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">Buffer::readFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> *saveErrno)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 栈上的临时空间，分配64K</span></span><br><span class="line">    <span class="type">char</span> extrabuf[<span class="number">65536</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">iovec</span> vec[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// buffer底层缓冲区剩余可以写的空间</span></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> writable = <span class="built_in">writeAbleBytes</span>();</span><br><span class="line">    vec[<span class="number">0</span>].iov_base = <span class="built_in">begin</span>() + writerIndex_;</span><br><span class="line">    vec[<span class="number">0</span>].iov_len = writable;</span><br><span class="line"></span><br><span class="line">    vec[<span class="number">1</span>].iov_base = extrabuf;</span><br><span class="line">    vec[<span class="number">1</span>].iov_len = <span class="keyword">sizeof</span> extrabuf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// writable &lt; sizeof extrabuf就选2块，否则一块就够用</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> iovcnt = (writable &lt; <span class="keyword">sizeof</span> extrabuf)? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">ssize_t</span> n = <span class="built_in">readv</span>(fd, vec, iovcnt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *saveErrno = errno;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n &lt;= writable) <span class="comment">//buffer可写的缓冲区已经够存储读取出来的数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        writerIndex_ += n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//extrabufl里面也写入了数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        writerIndex_ = buffer_.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//writerIndex_ 开始写n-writable的数据</span></span><br><span class="line">        <span class="built_in">append</span>(extrabuf,n-writable);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">Buffer::writeFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> *saveErrno)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">ssize_t</span> n = <span class="built_in">write</span>(fd, <span class="built_in">peek</span>(), <span class="built_in">readAbleBytes</span>());</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *saveErrno = errno;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><em>读数据的设计思想:</em></strong><ul><li>我们在读数据的时候，不知道数据的最终大小是多少，所以采用了如下的方法：<ol><li>首先会在栈区开一个64k的空间，利用栈的好处是可以自动的释放，并计算出目前剩余可写的空间大小；</li><li>利用结构体 iovec 指定了两块缓冲区，一块是目前剩余的可写的Buffer，一个是临时的缓冲区，指定了起始位置以及缓冲区的大小；</li><li>const int iovcnt = (writable &lt; sizeof extrabuf) ? 2 : 1; 如果writable &lt; sizeof extrabuf就选2块内存readv，否则一块就够用；</li><li>读数据const ssize_t n = ::readv(fd, vec, iovcnt);</li><li>若读取的数据超过现有内部buffer<em>的writable空间大小时, 启用备用的extrabuf 64KB空间, 并将这些数据添加到内部buffer</em>的末尾。</li></ol></li></ul></li></ul><h3 id="iovec结构体定义"><a href="#iovec结构体定义" class="headerlink" title="iovec结构体定义"></a>iovec结构体定义</h3><p>​    </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iovec</span> &#123;</span><br><span class="line">    <span class="type">ptr_t</span> iov_base; <span class="comment">/* Starting address */</span></span><br><span class="line">    <span class="type">size_t</span> iov_len; <span class="comment">/* Length in bytes */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>struct iovec定义了一个向量元素。通常，这个结构用作一个多元素的数组。对于每一个传输的元素，指针成员iov_base指向一个缓冲区，这个缓冲区是存放的是readv所接收的数据或是writev将要发送的数据。成员iov_len在各种情况下分别确定了接收的最大长度以及实际写入的长度。</li><li>其中<strong>readv函数</strong>可以一次性向多个缓冲区读数据，而不用挨个调用，减少系统调用次数，writev同理</li></ul><h1 id="muduo库TcpConnection类"><a href="#muduo库TcpConnection类" class="headerlink" title="muduo库TcpConnection类"></a>muduo库TcpConnection类</h1><h2 id="设计思想以及一些感悟"><a href="#设计思想以及一些感悟" class="headerlink" title="设计思想以及一些感悟"></a>设计思想以及一些感悟</h2><ul><li><p><strong><em>在学习此网络库之前我并不知道到底什么时候该用智能指针，什么时候不该用，在一些情况下使用智能指针会带来额外的性能开销，所以不能无脑梭哈，所以不知道该如何权衡使用它们，但是学习之后我得到了一些启发</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******** Callbacks.h  ********/</span></span><br><span class="line"><span class="keyword">using</span> TcpConnectionPtr = std::shared_ptr&lt;TcpConnection&gt;;</span><br><span class="line"><span class="comment">/******** TcpServer.cc ********/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpServer::newConnection</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> InetAddress &amp;peerAddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    代码省略</span><br><span class="line"><span class="function">TcpConnectionPtr <span class="title">conn</span><span class="params">(<span class="keyword">new</span> TcpConnection(ioLoop, connName, sockfd, localAddr, peerAddr))</span></span>;</span><br><span class="line">    connections_[connName] = conn;</span><br><span class="line">    代码省略</span><br><span class="line">    ioLoop-&gt;<span class="built_in">runInLoop</span>(<span class="built_in">bind</span>(&amp;TcpConnection::connectEstablished, conn));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>在TcpServer::newConnection()函数中，当接受了一个新用户连接，就要把这个Tcp连接封装成一个TcpConnection对象，也就是上面代码中的new TcpConnection(…)。然后用一个共享型智能指针来管理这个对象。<strong>所以为什么这里要把TcpConnection用智能指针来管理？</strong></p></li><li><p>这里使用智能指针管理TcpConnetion的最重要原因<strong>在于防止指针悬空</strong>，而指针悬空可能会来自以下这三个方面：</p><ul><li><p>考虑一种情况，如果在通信的时候，用户手贱将TcpConnection给删除了，删除了之后，程序内部还要好几处地方都在使用TcpConnection对象。结果这个对象的内存突然消失了，服务器访问非法内存崩溃。我们不能防止用户做这些事情，所以<strong>编程设计不可以依赖用户行为，一定要尽可能地封死用户的误操作。所以这里用了共享智能指针。</strong></p></li><li><p>但是单单只使用一个shared_ptr还不足以解决上述问题，还需要配合weak_ptr来实现生命周期的延长，在muduo中就有这样的设计，这个设计非常的好，值得学习，以下为具体内容</p></li></ul></li></ul><pre><code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TcpConnection</span> : noncopyable,<span class="keyword">public</span> std::enable_shared_from_this&lt;TcpConnection&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">TcpConnection</span>(EventLoop *loop,</span><br><span class="line">            <span class="type">const</span> std::string &amp;name,</span><br><span class="line">            <span class="type">int</span> sockfd,</span><br><span class="line">            <span class="type">const</span> InetAddress &amp;localAddr,</span><br><span class="line">            <span class="type">const</span> InetAddress &amp;peerAddr);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/***** TcpConnection.cpp *****/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::connectEstablished</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">setState</span>(kConnected);</span><br><span class="line">    channel_-&gt;<span class="built_in">tie</span>(<span class="built_in">shared_from_this</span>());</span><br><span class="line">    channel_-&gt;<span class="built_in">enableReading</span>(); <span class="comment">//向poller注册channel的epollin事件</span></span><br><span class="line">    <span class="comment">//新连接建立，执行回调</span></span><br><span class="line">    <span class="built_in">connectionCallback_</span>(<span class="built_in">shared_from_this</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>- Tcpconnection设计的时候继承了enable_shared_from_this，这使得能通过调用shared_from_this,获得一个共享指针- 假如我们在TcpConnection对象（我们管这个对象叫TCA）中的成员函数中调用了shared_from_this()，该函数可以返回一个shared_ptr，并且这个shared_ptr指向的对象是TCA。- 接着这个shared_ptr就作为channel_的Channel::tie()函数的函数参数。- 再根据上述Channel专栏中讲的[重要设计](#重要设计)，可知使用智能指针的好处</code></pre><ul><li><p>考虑第二种情况，<strong>TcpConnection对象的多线程安全问题：</strong></p><ul><li>假如服务器要关闭了这个时候MainEventLoop线程中的TcpServer::~TcpServer()函数开始把所有TcpConnection对象都删掉。那么其他线程还在使用这个TcpConnection对象，如果你把它的内存空间都释放了，其他线程访问了非法内存，会直接崩溃。</li><li>你可能会觉得，反正我都要把服务器给关了，崩就崩了吧。这种想法是错的！因为可能在你关闭服务器的时候，其他线程正在处理TcpConnection的发送消息任务，这个时候你应该等它发完才释放TcpConnection对象的内存才对！</li><li>使用智能指针就很好的解决了这个问题，即使在一个线程中删除一个TcpConnection，也只是删除了引用，而只要引用技术不为0就不会删除掉</li></ul></li></ul><h2 id="TcpConnection重要成员变量"><a href="#TcpConnection重要成员变量" class="headerlink" title="TcpConnection重要成员变量"></a>TcpConnection重要成员变量</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个subloop</span></span><br><span class="line">   EventLoop *loop_;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Connection的名字</span></span><br><span class="line">   <span class="type">const</span> std::string name_;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//Connection的状态</span></span><br><span class="line">   std::atomic_int state_;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 是否正在读</span></span><br><span class="line">   <span class="type">bool</span> reading_;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Connection对应的socket</span></span><br><span class="line">   std::unique_ptr&lt;Socket&gt; socket_;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Connection对应的channel</span></span><br><span class="line">   std::unique_ptr&lt;Channel&gt; channel_;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 本地的地址</span></span><br><span class="line">   InetAddress localAddr_;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 对端的地址</span></span><br><span class="line">   InetAddress peerAddr_;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下三个回调都是用户设置给TcpServer=&gt;（传给）TcpConnection=&gt;Channel=&gt;Poller=&gt;notify channel调用回调</span></span><br><span class="line">   ConnectionCallback connectionCallback_; <span class="comment">//有新连接时的回调</span></span><br><span class="line">   MessageCallback messageCallback_; <span class="comment">//有读写消息时的回调</span></span><br><span class="line">   WriteCompleteCallback writeCompleteCallback_; <span class="comment">//消息发送完成以后的回调</span></span><br><span class="line">   CloseCallback closeCallback_; <span class="comment">// 关闭回调</span></span><br><span class="line">   HighWaterMarkCallback highWaterMarkCallback_; <span class="comment">// 高水位回调</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 水位的阀值</span></span><br><span class="line">   <span class="type">size_t</span> highWaterMark_;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 接受数据的缓冲区</span></span><br><span class="line">   Buffer inputBuffer_;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 发送数据的缓冲区</span></span><br><span class="line">   Buffer outputBuffer_;</span><br></pre></td></tr></table></figure><ul><li>具体含义见注释</li><li>其中两个输入输出缓冲区，在输出缓冲区是用于暂存那些暂时发送不出去的待发送数据。因为Tcp发送缓冲区是有大小限制的，假如达到了高水位线，就没办法把发送的数据通过send()直接拷贝到Tcp发送缓冲区，而是暂存在这个outputBuffer<em>中，等TCP发送缓冲区有空间了，触发可写事件了，再把outputBuffer</em>中的数据拷贝到Tcp发送缓冲区中。</li></ul><h2 id="TcpConnection重要成员函数"><a href="#TcpConnection重要成员函数" class="headerlink" title="TcpConnection重要成员函数"></a>TcpConnection重要成员函数</h2><ul><li><p>首先来看下构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> EventLoop *<span class="title">CheckLoopNotNull</span><span class="params">(EventLoop* loop)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(loop == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_FATAL</span>(<span class="string">&quot;%s:%s:%d TcpConnection loop is null! \n&quot;</span>,__FILE__,__FUNCTION__,__LINE__);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> loop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TcpConnection::<span class="built_in">TcpConnection</span>(EventLoop *loop,</span><br><span class="line">            <span class="type">const</span> std::string &amp;nameArg,</span><br><span class="line">            <span class="type">int</span> sockfd,</span><br><span class="line">            <span class="type">const</span> InetAddress &amp;localAddr,</span><br><span class="line">            <span class="type">const</span> InetAddress &amp;peerAddr)</span><br><span class="line">        : <span class="built_in">loop_</span>(<span class="built_in">CheckLoopNotNull</span>(loop))</span><br><span class="line">        , <span class="built_in">name_</span>(nameArg)</span><br><span class="line">        , <span class="built_in">state_</span>(kConnecting)</span><br><span class="line">        , <span class="built_in">reading_</span>(<span class="literal">true</span>)</span><br><span class="line">        , <span class="built_in">socket_</span>(std::<span class="built_in">make_unique</span>&lt;Socket&gt;(sockfd))</span><br><span class="line">        , <span class="built_in">channel_</span>(std::<span class="built_in">make_unique</span>&lt;Channel&gt;(sockfd, loop))</span><br><span class="line">        , <span class="built_in">localAddr_</span>(localAddr)</span><br><span class="line">        , <span class="built_in">peerAddr_</span>(peerAddr)</span><br><span class="line">        , <span class="built_in">highWaterMark_</span>(<span class="number">64</span>*<span class="number">1024</span>*<span class="number">1024</span>) <span class="comment">//64M</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//下面给channel设置相应的回调函数</span></span><br><span class="line">            <span class="comment">//poller给channel通知感兴趣的事件发生了</span></span><br><span class="line">            <span class="comment">//channel会回调相应的操作函数</span></span><br><span class="line">            <span class="comment">//将TcpConnection自己的成员函数注册给当前accept返回的connfd对应的Channel对象上</span></span><br><span class="line">            channel_-&gt;<span class="built_in">setReadCallBack</span>(std::<span class="built_in">bind</span>(&amp;TcpConnection::handleRead,<span class="keyword">this</span>,std::placeholders::_1));</span><br><span class="line">            channel_-&gt;<span class="built_in">setWriteCallBack</span>(std::<span class="built_in">bind</span>(&amp;TcpConnection::handleWrite,<span class="keyword">this</span>));</span><br><span class="line">            channel_-&gt;<span class="built_in">setCloseCallBack</span>(std::<span class="built_in">bind</span>(&amp;TcpConnection::handleClose,<span class="keyword">this</span>));</span><br><span class="line">            channel_-&gt;<span class="built_in">setErrorCallBack</span>(std::<span class="built_in">bind</span>(&amp;TcpConnection::handleError,<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">            <span class="built_in">LOG_INFO</span>(<span class="string">&quot;TcpConnection::ctor[%s] at fd=%d\n&quot;</span>,name_.<span class="built_in">c_str</span>(),sockfd);</span><br><span class="line">            <span class="comment">//开启Tcp/Ip层的心跳包检测</span></span><br><span class="line">            socket_-&gt;<span class="built_in">SetKeepalive</span>(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><ul><li>其功能是创建一个TcpConnection，初始化一些变量，并且设置一些回调函数以及开启心跳包检测</li></ul></li><li><p>接着我们看看发送数据相关的函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">/ 发送数据</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::send</span><span class="params">(<span class="type">const</span> std::string &amp;buf)</span> <span class="comment">//直接引用buffer</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 先检查是否处于连接状态</span></span><br><span class="line">    <span class="keyword">if</span>(state_ == kConnected)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 判断处理的线程是否是事件循环线程</span></span><br><span class="line">        <span class="keyword">if</span>(loop_-&gt;<span class="built_in">isInLoopThread</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//string.c_str是Borland封装的String类中的一个函数，它返回当前字符串的首字符地址。</span></span><br><span class="line">            <span class="built_in">sendInLoop</span>(buf.<span class="built_in">c_str</span>(),buf.<span class="built_in">size</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            loop_-&gt;<span class="built_in">runInLoop</span>(std::<span class="built_in">bind</span>(&amp;TcpConnection::sendInLoop</span><br><span class="line">                                , <span class="keyword">this</span></span><br><span class="line">                                , buf.<span class="built_in">c_str</span>()</span><br><span class="line">                                , buf.<span class="built_in">size</span>()</span><br><span class="line">            ));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送数据，应用写得快，内核发送数据慢，</span></span><br><span class="line"><span class="comment"> * 需要把待发送的数据写入缓冲区</span></span><br><span class="line"><span class="comment"> * 且设置了水位回调，防止发送太快</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::sendInLoop</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* data, <span class="type">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">ssize_t</span> nwrote = <span class="number">0</span>; <span class="comment">// 已经写了多少数据</span></span><br><span class="line">    <span class="type">size_t</span> remaining = len; <span class="comment">//未发送的数据</span></span><br><span class="line">    <span class="type">bool</span> faultError = <span class="literal">false</span>; <span class="comment">//记录是否产生错误</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//之前调用过connection的shutdown 不能在发送了</span></span><br><span class="line">    <span class="keyword">if</span>(state_ == kDisconnected)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;disconnected,give up writing!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//channel 第一次开始写数据，且缓冲区没有待发送数据</span></span><br><span class="line">    <span class="keyword">if</span>(!channel_-&gt;<span class="built_in">isWriteEvent</span>() &amp;&amp; outputBuffer_.<span class="built_in">readAbleBytes</span>() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        nwrote = ::<span class="built_in">write</span>(channel_-&gt;<span class="built_in">fd</span>(),data,len);</span><br><span class="line">        <span class="keyword">if</span>(nwrote &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 更新剩余数据</span></span><br><span class="line">            remaining = len - nwrote;</span><br><span class="line">            <span class="keyword">if</span>(remaining == <span class="number">0</span> &amp;&amp; writeCompleteCallback_)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//一次性数据全部发送完成，就不要再给channel设置epollout事件了</span></span><br><span class="line">                loop_-&gt;<span class="built_in">queueInLoop</span>(</span><br><span class="line">                    std::<span class="built_in">bind</span>(writeCompleteCallback_,<span class="built_in">shared_from_this</span>()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            nwrote = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(errno != EWOULDBLOCK) <span class="comment">//用于非阻塞模式，不需要重新读或者写</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;TcpConnection::sendInLoop&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span>(errno == EPIPE || errno == ECONNRESET) <span class="comment">//SIGPIPE RESET</span></span><br><span class="line">                &#123;</span><br><span class="line">                    faultError = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 说明当前这一次write ，并没有把数据全发送出去，剩余的数据</span></span><br><span class="line">    <span class="comment">// 需要保存到缓冲区当中，给channel注册epollout事件</span></span><br><span class="line">    <span class="comment">// poller发现tcp发送缓冲区有空间，会通知相应的socket-channel</span></span><br><span class="line">    <span class="comment">// 调用相应的writeCallback（）回调方法</span></span><br><span class="line">    <span class="comment">// 也就是调用TcpConnection::handleWrite，把发送缓冲区中数据全部发送出去</span></span><br><span class="line">    <span class="keyword">if</span>(!faultError &amp;&amp; remaining &gt; <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//目前发送缓冲区剩余的待发送数据的长度</span></span><br><span class="line">        <span class="type">size_t</span> oldlen = outputBuffer_.<span class="built_in">readAbleBytes</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(oldlen + remaining &gt;= highWaterMark_ </span><br><span class="line">            &amp;&amp; oldlen &lt; highWaterMark_</span><br><span class="line">            &amp;&amp; highWaterMark_)</span><br><span class="line">            &#123;</span><br><span class="line">                loop_-&gt;<span class="built_in">queueInLoop</span>(</span><br><span class="line">                    std::<span class="built_in">bind</span>(highWaterMarkCallback_,<span class="built_in">shared_from_this</span>(),oldlen + remaining)</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 把未发送的数据加入到发送缓冲区</span></span><br><span class="line">            outputBuffer_.<span class="built_in">append</span>((<span class="type">char</span>*)data + nwrote,remaining);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!channel_-&gt;<span class="built_in">isWriteEvent</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                channel_-&gt;<span class="built_in">enableWriting</span>(); <span class="comment">//注册channel写事件，否则poller不会向channel通知epollout</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>为了秉持一个线程占用一个eventloop所以我们要确保执行发送任务的时候是发生在事件循环线程中 所以要进行一次判断，如果不是得投放到任务容器里等待被唤醒</li><li>发送数据的时候，会有两种情况，一种是第一次发送直接全部发送完了，这时候将它放入事件循环的处理函数容器，并唤醒对应线程处理，第二种情况是第一次没发完，这时就需要将未发完的数据存入outputBuffer里，存入的时候需要进行比较oldlen + remaining &gt;= highWaterMark<em> &amp;&amp; oldlen &lt; highWaterMark</em>&amp;&amp; highWaterMark_，如果满足就进行高水位回调（这有助于防止发送方发送过多数据，导致接收方无法及时处理。）</li><li>剩余的数据保存到缓冲区当中，要给给channel注册epollout事件(切记，一定要注册channel的写事件，否则poller不会向channel通知epollout)，这样poller发现tcp发送缓冲区有空间，会通知相应的socket-channel调用相应的writeCallback（）回调方法，也就是调用TcpConnection::handleWrite，把发送缓冲区中数据全部发送出去。</li></ul></li><li><p>一系列的回调函数处理</p><ul><li>handleread</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::handleRead</span><span class="params">(TimeStamp receiveTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> savedErrno = <span class="number">0</span>;</span><br><span class="line">    <span class="type">ssize_t</span> n = inputBuffer_.<span class="built_in">readFd</span>(channel_-&gt;<span class="built_in">fd</span>(),&amp;savedErrno);</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 已建立连接的用户，有可读事件发生了，调用用户传入的回调操作onMessage</span></span><br><span class="line">        <span class="comment">// shared_from_this()获取了当前TcpConnection对象的智能指针</span></span><br><span class="line">        <span class="built_in">messageCallback_</span>(<span class="built_in">shared_from_this</span>(),&amp;inputBuffer_,receiveTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="comment">//客户端断开</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">handleClose</span>();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        errno = savedErrno;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;TcpConnection::hanleRead&quot;</span>);</span><br><span class="line">        <span class="built_in">handleError</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::handleWrite</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(channel_-&gt;<span class="built_in">isWriteEvent</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> savedErrno = <span class="number">0</span>;</span><br><span class="line">        <span class="type">ssize_t</span> n = outputBuffer_.<span class="built_in">writeFd</span>(channel_-&gt;<span class="built_in">fd</span>(),&amp;savedErrno);</span><br><span class="line">        <span class="keyword">if</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            outputBuffer_.<span class="built_in">retrieve</span>(n); <span class="comment">//处理了n个</span></span><br><span class="line">            <span class="keyword">if</span>(outputBuffer_.<span class="built_in">readAbleBytes</span>() == <span class="number">0</span>) <span class="comment">//发送完成</span></span><br><span class="line">            &#123;</span><br><span class="line">                channel_-&gt;<span class="built_in">disableWriting</span>(); <span class="comment">//不可写了</span></span><br><span class="line">                <span class="keyword">if</span>(writeCompleteCallback_)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//唤醒loop对应的thread线程，执行回调</span></span><br><span class="line">                    loop_-&gt;<span class="built_in">queueInLoop</span>(</span><br><span class="line">                        std::<span class="built_in">bind</span>(writeCompleteCallback_,<span class="built_in">shared_from_this</span>())</span><br><span class="line">                    );</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(state_ == kDisconnecting)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">shutdownInLoop</span>();<span class="comment">// 在当前loop中删除TcpConnection</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;TcpConnection::handleWrite&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;TcpConnection fd=%d is down, no more writing \n&quot;</span>,channel_-&gt;<span class="built_in">fd</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><ul><li>关于readFd在Buffer类中我们已经剖析过了<a href="#muduo库Buffer类">Buffer类</a>，接着已建立连接的用户，有可读事件发生了，调用用户传入的回调操作<code>onMessage</code>，<code>shared_from_this()</code>获取了当前TcpConnection对象的智能指针.</li></ul></li></ul></li></ul><ul><li><p>handlewirte</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::handleWrite</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(channel_-&gt;<span class="built_in">isWriteEvent</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> savedErrno = <span class="number">0</span>;</span><br><span class="line">        <span class="type">ssize_t</span> n = outputBuffer_.<span class="built_in">writeFd</span>(channel_-&gt;<span class="built_in">fd</span>(),&amp;savedErrno);</span><br><span class="line">        <span class="keyword">if</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            outputBuffer_.<span class="built_in">retrieve</span>(n); <span class="comment">//处理了n个</span></span><br><span class="line">            <span class="keyword">if</span>(outputBuffer_.<span class="built_in">readAbleBytes</span>() == <span class="number">0</span>) <span class="comment">//发送完成</span></span><br><span class="line">            &#123;</span><br><span class="line">                channel_-&gt;<span class="built_in">disableWriting</span>(); <span class="comment">//不可写了</span></span><br><span class="line">                <span class="keyword">if</span>(writeCompleteCallback_)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//唤醒loop对应的thread线程，执行回调</span></span><br><span class="line">                    loop_-&gt;<span class="built_in">queueInLoop</span>(</span><br><span class="line">                        std::<span class="built_in">bind</span>(writeCompleteCallback_,<span class="built_in">shared_from_this</span>())</span><br><span class="line">                    );</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(state_ == kDisconnecting)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">shutdownInLoop</span>();<span class="comment">// 在当前loop中删除TcpConnection</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;TcpConnection::handleWrite&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;TcpConnection fd=%d is down, no more writing \n&quot;</span>,channel_-&gt;<span class="built_in">fd</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果可写，通过fd发送数据，直到发送完成</p></li><li>设置不可写，如果writeCompleteCallback_，唤醒loop对应的thread线程，执行回调</li><li>当前TCP正在断开连接，调用<code>shutdownInLoop</code>，在当前loop中删除TcpConnection</li></ul><ul><li><p>handleclose</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Poller =&gt; Channel::closeCallback =&gt; TcpConnection::handlerClose</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::handleClose</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;TcpConnection::handleClose fd=%d state=%d \n&quot;</span>,channel_-&gt;<span class="built_in">fd</span>(),(<span class="type">int</span>)state_);</span><br><span class="line">    <span class="built_in">setState</span>(kDisconnected);</span><br><span class="line">    channel_-&gt;<span class="built_in">disableAll</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">TcpConnectionPtr <span class="title">connPtr</span><span class="params">(shared_from_this())</span></span>;</span><br><span class="line">    <span class="built_in">connectionCallback_</span>(connPtr); <span class="comment">//执行连接关闭的回调</span></span><br><span class="line">    <span class="built_in">closeCallback_</span>(connPtr); <span class="comment">//关闭连接的回调 TcpServer =&gt; TcpServer::removeConnection</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>处理逻辑就是将这个TcpConnection对象中的channel<em>从事件监听器中移除。然后调用connectionCallback</em>和closeCallback<em>保存的回调函数。closeCallback</em>在TcpServer::newConnection()为新连接新建TcpConnection时，已设为TcpServer::removeConnection()，而removeConnection()最终会调用TcpConnection::connectDestroyed()来销毁连接资源。</p></li></ul><ul><li><p>handleerror</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::handleError</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> optval;</span><br><span class="line">    <span class="type">socklen_t</span> optlen = <span class="keyword">sizeof</span> optval;</span><br><span class="line">    <span class="type">int</span> err = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(::<span class="built_in">getsockopt</span>(channel_-&gt;<span class="built_in">fd</span>(),SOL_SOCKET,SO_ERROR,&amp;optval,&amp;optlen) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        err = errno;        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        err = optval;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;TcpConnection::handleError name:%s - SO_ERROR:%d \n&quot;</span>,name_.<span class="built_in">c_str</span>(),err);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li>关闭写端函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//关闭连接</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::shutdown</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(state_ == kConnected)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">setState</span>(kDisconnecting);</span><br><span class="line">        loop_-&gt;<span class="built_in">runInLoop</span>(</span><br><span class="line">            std::<span class="built_in">bind</span>(&amp;TcpConnection::shutdownInLoop,<span class="keyword">this</span>)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::shutdownInLoop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!channel_-&gt;<span class="built_in">isWriteEvent</span>()) <span class="comment">//说明当前outputBuffer中的数据已经全部发送完成</span></span><br><span class="line">    &#123;</span><br><span class="line">        socket_-&gt;<span class="built_in">shutDownWrite</span>(); <span class="comment">// 关闭写端</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>注意</strong>： 为什么是关闭了写端呢？在TcpConnection::shutdownInLoop()中，我们会发现它调用了Socket的shutdowmWrite，这里并没有使用close，<strong><em>陈硕大佬原话是这样的：Muduo TcpConnection 没有提供 close，而只提供 shutdown ，这么做是为了收发数据的完整性。因为TCP 是一个全双工协议，同一个文件描述符既可读又可写， shutdownWrite() 关闭了“写”方向的连接，保留了“读”方向，这称为 TCP half-close。如果直接 close(socket_fd)，那么 socket_fd 就不能读或写了。用 shutdown 而不用 close 的效果是，如果对方已经发送了数据，这些数据还“在路上”，那么 muduo 不会漏收这些数据。换句话说，muduo 在 TCP 这一层面解决了“当你打算关闭网络连接的时候，如何得知对方有没有发了一些数据而你还没有收到？”这一问题。当然，这个问题也可以在上面的协议层解决，双方商量好不再互发数据，就可以直接断开连接。等于说 muduo 把“主动关闭连接”这件事情分成两步来做，如果要主动关闭连接，它会先关本地“写”端，等对方关闭之后，再关本地“读”端。</em></strong></li><li>另外如果当前outputbuffer里面还有数据尚未发出的话，Muduo也不会立刻调用shutwownWrite，而是等到数据发送完毕再shutdown，可以避免对方漏收数据。</li><li><p>关闭连接事件很重要，涉及到TcpConnection和Channel的生命周期以及是否能合理销毁，用了智能指针来管理和控制生命周期。下面我们就来分析一下断开流程中<strong>TcpConnection的引用计数问题</strong>：</p><ol><li>首先连接到来创建TcpConnection，并存入容器。引用计数+1 总数：1</li><li>客户端断开连接，在Channel的handleEvent函数中会将Channel中的TcpConnection弱指针提升,引用计数+1 总数：2</li><li>触发HandleRead ，可读字节0，进而触发HandleClose,HandleClose函数中栈上的TcpConnectionPtr guardThis会继续将引用计数+1 总数：3</li><li>触发HandleClose的回调函数 在TcpServer::removeConnection结束后(回归主线程队列)，释放HandleClose的栈指针，以及Channel里提升的指针引用计数-2 总数：1</li><li>主线程执行回调removeConnectionInLoop，在函数内部将tcpconnection从TcpServer中保存连接容器中erase掉。但在removeConnectionInLoop结用conn为参数构造了bind。引用计数不变 总数：1</li><li>回归次线程处理connectDestroyed事件，结束完释放参数传递的最后一个shard_ptr，释放TcpConnection。引用计数-1 总数：0</li></ol></li><li><p>连接建立与删除函数</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//建立连接</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::connectEstablished</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">setState</span>(kConnected);</span><br><span class="line">    channel_-&gt;<span class="built_in">tie</span>(<span class="built_in">shared_from_this</span>());</span><br><span class="line">    channel_-&gt;<span class="built_in">enableReading</span>(); <span class="comment">//向poller注册channel的epollin事件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//新连接建立 执行回调</span></span><br><span class="line">    <span class="built_in">connectionCallback_</span>(<span class="built_in">shared_from_this</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁连接</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::connectDestroyed</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(state_ == kConnected)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">setState</span>(kDisconnected);</span><br><span class="line">        channel_-&gt;<span class="built_in">disableAll</span>(); <span class="comment">//把channel所有感兴趣的事件，从poller中del掉</span></span><br><span class="line">        <span class="built_in">connectionCallback_</span>(<span class="built_in">shared_from_this</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    channel_-&gt;<span class="built_in">remove</span>();<span class="comment">//把channel从poller中删除掉</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="muduo库TcpServer类"><a href="#muduo库TcpServer类" class="headerlink" title="muduo库TcpServer类"></a>muduo库TcpServer类</h1><ul><li>TcpServer与用户打交道，用户可以传入读回调函数，写完成回调等函数给TcpConnection</li><li>TcpServer 发送逻辑给Acceptor或者TcpConnection,进行相应处理</li></ul><h2 id="TcpServer重要成员变量"><a href="#TcpServer重要成员变量" class="headerlink" title="TcpServer重要成员变量"></a>TcpServer重要成员变量</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//baseloop_用户定义的loop</span></span><br><span class="line">    EventLoop *loop_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 本地ip端口</span></span><br><span class="line">    <span class="type">const</span> std::string ipPort_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 名称</span></span><br><span class="line">    std::string name_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用来连接新到的客户端</span></span><br><span class="line">    std::unique_ptr&lt;Acceptor&gt; acceptor_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向一个线程池</span></span><br><span class="line">    std::shared_ptr&lt;EventLoopThreadPool&gt; threadPool_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有新连接时的回调</span></span><br><span class="line">    ConnectionCallback connectionCallback_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有读写消息时的回调</span></span><br><span class="line">    MessageCallback messageCallback_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消息发送完成以后的回调</span></span><br><span class="line">    WriteCompleteCallback writeCompleteCallback_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//LOOP线程初始化的回调 std::function类型 调用者，调用回调函数</span></span><br><span class="line">    ThreadInitCallback threadInitCallback_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//防止一个TcpServer对象被start多次</span></span><br><span class="line">    std::atomic_int started_;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> nextConnId_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用来存储Connection的map</span></span><br><span class="line">    ConnectionMap connMap_;</span><br></pre></td></tr></table></figure><ul><li>详解见注释</li></ul><h2 id="TcpServer重要成员函数"><a href="#TcpServer重要成员函数" class="headerlink" title="TcpServer重要成员函数"></a>TcpServer重要成员函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TcpServer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;TcpConnection.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;logger.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> EventLoop* <span class="title">CheckLoopNotNull</span><span class="params">(EventLoop* loop)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(loop == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_FATAL</span>(<span class="string">&quot;%s:%s:%d mainloop is null! \n&quot;</span>,__FILE__,__FUNCTION__,__LINE__);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> loop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TcpServer::<span class="built_in">TcpServer</span>(EventLoop *loop, <span class="type">const</span> InetAddress &amp;listenAddr, <span class="type">const</span> std::string &amp;nameArg, Option option)</span><br><span class="line">    : <span class="built_in">loop_</span>(<span class="built_in">CheckLoopNotNull</span>(loop))</span><br><span class="line">    , <span class="built_in">ipPort_</span>(listenAddr.<span class="built_in">toIpPort</span>())</span><br><span class="line">    , <span class="built_in">name_</span>(nameArg)</span><br><span class="line">    , <span class="built_in">acceptor_</span>(std::<span class="built_in">make_unique</span>&lt;Acceptor&gt;(loop, listenAddr, option == kReusePort))</span><br><span class="line">    , <span class="built_in">threadPool_</span>(std::<span class="built_in">make_shared</span>&lt;EventLoopThreadPool&gt;(loop, nameArg))</span><br><span class="line">    , <span class="built_in">messageCallback_</span>()</span><br><span class="line">    , <span class="built_in">writeCompleteCallback_</span>()</span><br><span class="line">    , <span class="built_in">started_</span>(<span class="number">0</span>)</span><br><span class="line">    , <span class="built_in">nextConnId_</span>(<span class="number">0</span>)</span><br><span class="line">    , <span class="built_in">connMap_</span>()</span><br><span class="line">&#123;</span><br><span class="line">    acceptor_-&gt;<span class="built_in">setNewConnectionCallBack</span>(std::<span class="built_in">bind</span>(&amp;TcpServer::newConnection, <span class="keyword">this</span>,</span><br><span class="line">        std::placeholders::_1, std::placeholders::_2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历connMap_, 挨个删除map中的内容，并将TcpConnection::connectDestroyed投递到conn的loop中</span></span><br><span class="line">TcpServer::~<span class="built_in">TcpServer</span>() &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; item: connMap_) &#123;</span><br><span class="line">        <span class="comment">//这个局部的shared_ptr智能指针对象，出右括号</span></span><br><span class="line">        <span class="comment">//可以自动释放new出来的TcpConnetion对象资源</span></span><br><span class="line">        <span class="function">TcpConnectionPtr <span class="title">conn</span><span class="params">(item.second)</span></span>;</span><br><span class="line">        item.second.<span class="built_in">reset</span>();</span><br><span class="line">        <span class="comment">//销毁连接</span></span><br><span class="line">        conn-&gt;<span class="built_in">getLoop</span>()-&gt;<span class="built_in">runInLoop</span>(</span><br><span class="line">            std::<span class="built_in">bind</span>(&amp;TcpConnection::connectDestroyed,conn)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpServer::newConnection</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> InetAddress &amp;peerAddr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.先用轮询算法选出一个subloop</span></span><br><span class="line">    EventLoop* ioLoop = threadPool_-&gt;<span class="built_in">getNextLoop</span>();</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">64</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span> buf,<span class="string">&quot;-%s#%d&quot;</span>,ipPort_.<span class="built_in">c_str</span>(),nextConnId_);</span><br><span class="line">    ++nextConnId_;</span><br><span class="line">    std::string connName = name_ + buf;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;TcpServer::newConnection [%s] - new connection [%s] from %s \n&quot;</span>,</span><br><span class="line">                name_.<span class="built_in">c_str</span>(),connName.<span class="built_in">c_str</span>(),peerAddr.<span class="built_in">toIpPort</span>().<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.通过socket获取其绑定的本机的ip地址和端口信息</span></span><br><span class="line">    sockaddr_in local;</span><br><span class="line">    ::<span class="built_in">bzero</span>(&amp;local,<span class="keyword">sizeof</span> local);</span><br><span class="line">    <span class="type">socklen_t</span> addrlen = <span class="keyword">sizeof</span> local;</span><br><span class="line">    <span class="keyword">if</span>(::<span class="built_in">getsockname</span>(sockfd,(sockaddr*) &amp;local,&amp;addrlen) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;sockets::getLocalAddr&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">InetAddress <span class="title">localAddr</span><span class="params">(local)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.根据连接成功的sockfd，创建 TcpConnection连接对象conn</span></span><br><span class="line">    TcpConnectionPtr conn = std::<span class="built_in">make_shared</span>&lt;TcpConnection&gt;(</span><br><span class="line">        ioLoop, connName, sockfd, localAddr, peerAddr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.下面的回调都是用户设置给TcpServer=&gt;TcpConnection=&gt;Channel=&gt;Poller=&gt;notify channel调用回调</span></span><br><span class="line">    connMap_[connName] = conn;</span><br><span class="line">    conn-&gt;<span class="built_in">setConnectionCallback</span>(connectionCallback_);</span><br><span class="line">    conn-&gt;<span class="built_in">setMessageCallback</span>(messageCallback_);</span><br><span class="line">    conn-&gt;<span class="built_in">setWriteCompleteCallback</span>(writeCompleteCallback_);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.设置了如何关闭连接的回调 conn-&gt;shutdown</span></span><br><span class="line">    conn-&gt;<span class="built_in">setCloseCallback</span>(</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;TcpServer::removeConnection,<span class="keyword">this</span>,std::placeholders::_1)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.直接调用TcpConnection::connectEstablished</span></span><br><span class="line">    ioLoop-&gt;<span class="built_in">runInLoop</span>(std::<span class="built_in">bind</span>(&amp;TcpConnection::connectEstablished,conn));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动线程池，并把Acceptor监听加到事件循环中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpServer::start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//防止一个TcpServer对象被start多次</span></span><br><span class="line">    <span class="keyword">if</span>(started_++ == <span class="number">0</span>) &#123;</span><br><span class="line">        threadPool_-&gt;<span class="built_in">start</span>(threadInitCallback_);</span><br><span class="line">        loop_-&gt;<span class="built_in">runInLoop</span>(std::<span class="built_in">bind</span>(&amp;Acceptor::listen, acceptor_.<span class="built_in">get</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置threadPool_的线程数量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpServer::setThreadNums</span><span class="params">(<span class="type">const</span> <span class="type">int</span> threadNums)</span> </span>&#123;</span><br><span class="line">    threadPool_-&gt;<span class="built_in">setThreadNums</span>(threadNums);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将删除操作投递到事件循环中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpServer::removeConnection</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn)</span> </span>&#123;</span><br><span class="line">    loop_-&gt;<span class="built_in">runInLoop</span>(std::<span class="built_in">bind</span>(&amp;TcpServer::removeConnectionInLoop, <span class="keyword">this</span>, conn));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先将connMap里的删掉，在调用TcpConnection的删除函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpServer::removeConnectionInLoop</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;TcpServer::removeConnectionInLoop [%s] - connection \n&quot;</span>,</span><br><span class="line">    name_.<span class="built_in">c_str</span>(),conn-&gt;<span class="built_in">name</span>().<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    connMap_.<span class="built_in">erase</span>(conn-&gt;<span class="built_in">name</span>()); <span class="comment">//从map表中删除</span></span><br><span class="line">    EventLoop *ioLoop = conn-&gt;<span class="built_in">getLoop</span>();</span><br><span class="line">    ioLoop-&gt;<span class="built_in">queueInLoop</span>(</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;TcpConnection::connectDestroyed,conn)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>具体功能见注释</li></ul><h1 id="muduo库Thread类"><a href="#muduo库Thread类" class="headerlink" title="muduo库Thread类"></a>muduo库Thread类</h1><h2 id="Thread重要成员变量"><a href="#Thread重要成员变量" class="headerlink" title="Thread重要成员变量"></a>Thread重要成员变量</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">std::string name_;<span class="comment">//线程名字</span></span><br><span class="line">   <span class="type">bool</span> started_;<span class="comment">//线程是否启动</span></span><br><span class="line">   <span class="type">bool</span> joined_;<span class="comment">//是否被join回收</span></span><br><span class="line">   <span class="type">pid_t</span> tid_;<span class="comment">//是否被join回收</span></span><br><span class="line">   std::shared_ptr&lt;std::thread&gt; thread_; <span class="comment">//用智能指针管理</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 线程要执行的任务</span></span><br><span class="line">   ThreadFunc func_;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 记录线程开辟了多少用于编号</span></span><br><span class="line">   <span class="type">static</span> std::atomic_int numCreated_;</span><br></pre></td></tr></table></figure><ul><li>具体见注释</li></ul><h2 id="Thread重要成员函数"><a href="#Thread重要成员函数" class="headerlink" title="Thread重要成员函数"></a>Thread重要成员函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::atomic_int <span class="title">Thread::numCreated_</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="comment">//静态成员变量 要在类外单独进行初始化</span></span><br><span class="line"></span><br><span class="line">Thread::<span class="built_in">Thread</span>(ThreadFunc func, <span class="type">const</span> std::string &amp;name)</span><br><span class="line">    : <span class="built_in">name_</span>(name)</span><br><span class="line">    , <span class="built_in">started_</span>(<span class="literal">false</span>)</span><br><span class="line">    , <span class="built_in">joined_</span>(<span class="literal">false</span>)</span><br><span class="line">    , <span class="built_in">tid_</span>(<span class="number">0</span>)</span><br><span class="line">    , <span class="built_in">func_</span>(std::<span class="built_in">move</span>(func))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">setDefaultName</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Thread::~<span class="built_in">Thread</span>() &#123;</span><br><span class="line">    <span class="comment">//线程已经运行起来了，并且没有joined_</span></span><br><span class="line">    <span class="keyword">if</span> (started_ &amp;&amp; !joined_)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//thread类提供的分离线程的方法</span></span><br><span class="line">        thread_-&gt;<span class="built_in">detach</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Thread::setDefaultName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = ++numCreated_;</span><br><span class="line">    <span class="keyword">if</span>(name_.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">snprintf</span>(buf,<span class="keyword">sizeof</span> buf,<span class="string">&quot;Thread%d&quot;</span>,num);</span><br><span class="line">        name_=buf;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Thread::start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    started_ = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">sem_t</span> sem;</span><br><span class="line">    <span class="comment">// 初始化一个信号量</span></span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;sem, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    thread_ = std::<span class="built_in">make_shared</span>&lt;std::thread&gt;([<span class="keyword">this</span>, &amp;sem]() &#123;</span><br><span class="line">        ++numCreated_;</span><br><span class="line">        <span class="comment">// 得到当前线程的tid</span></span><br><span class="line">        tid_ = CurrentThread::<span class="built_in">tid</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 信号量 + 1，说明tid_已经有了</span></span><br><span class="line">        <span class="built_in">sem_post</span>(&amp;sem);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行线程任务</span></span><br><span class="line">        <span class="built_in">func_</span>();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待返回线程id</span></span><br><span class="line">    <span class="built_in">sem_wait</span>(&amp;sem);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Thread::join</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    joined_ = <span class="literal">true</span>;</span><br><span class="line">    thread_-&gt;<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>值得注意的是线程并不是在构造函数中创建的，并且必须得创建线程后得到id才能继续运行（因为其他逻辑实现的<strong>one loop per thread</strong>必须要得到tid）</li></ul><ul><li><p>补充一下sem_t变量类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sem_init（）<span class="comment">// sem为指向信号量结构的一个指针；pshared不为０时此信号量在进程间共享，否则只能为当前进程的所有线程共享；value给出了信号量的初始值。</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> sem_init __P ((<span class="type">sem_t</span> *__sem, <span class="type">int</span> __pshared, <span class="type">unsigned</span> <span class="type">int</span> __value));　</span><br><span class="line"></span><br><span class="line"><span class="built_in">sem_wait</span>( <span class="type">sem_t</span> *sem ) <span class="comment">//用来阻塞当前线程直到信号量sem的值大于0，解除阻塞后将sem的值减一，表明公共资源经使用后减少。函数sem_trywait ( sem_t *sem )是函数sem_wait（）的非阻塞版本，它直接将信号量sem的值减一。</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">sem_post</span>( <span class="type">sem_t</span> *sem )<span class="comment">//用来增加信号量的值。当有线程阻塞在这个信号量上时，调用这个函数会使其中的一个线程不在阻塞，选择机制同样是由线程的调度策略决定的。</span></span><br><span class="line"><span class="comment">//sem_post和sem_wait函数配合使用来达到线程同步</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">sem_destroy</span>(<span class="type">sem_t</span> *sem)<span class="comment">//用来释放信号量sem。</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="muduo库EventLoopThread类"><a href="#muduo库EventLoopThread类" class="headerlink" title="muduo库EventLoopThread类"></a>muduo库EventLoopThread类</h1><h2 id="EventLoopThread重要成员变量"><a href="#EventLoopThread重要成员变量" class="headerlink" title="EventLoopThread重要成员变量"></a>EventLoopThread重要成员变量</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EventLoop *loop_;  <span class="comment">//线程内部的eventloop*</span></span><br><span class="line"><span class="type">bool</span> exiting_;     <span class="comment">//线程是否退出</span></span><br><span class="line">Thread thread_;   <span class="comment">//线程</span></span><br><span class="line">std::mutex mutex_; <span class="comment">//互斥锁</span></span><br><span class="line">std::condition_variable cond_; <span class="comment">//条件变量</span></span><br><span class="line">ThreadInitCallBack callback_; <span class="comment">//线程初始化回调函数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>具体见注释</li></ul><h2 id="EventLoopThread重要成员函数"><a href="#EventLoopThread重要成员函数" class="headerlink" title="EventLoopThread重要成员函数"></a>EventLoopThread重要成员函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;EventLoopThread.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">EventLoopThread::<span class="built_in">EventLoopThread</span>(<span class="type">const</span> ThreadInitCallBack &amp;cb, <span class="type">const</span> std::string &amp;name)</span><br><span class="line">    : <span class="built_in">loop_</span>(<span class="literal">nullptr</span>)</span><br><span class="line">    , <span class="built_in">exiting_</span>(<span class="literal">false</span>)</span><br><span class="line">    , <span class="built_in">thread_</span>(std::<span class="built_in">bind</span>(&amp;EventLoopThread::threadFunc, <span class="keyword">this</span>))</span><br><span class="line">    , <span class="built_in">mutex_</span>()</span><br><span class="line">    , <span class="built_in">cond_</span>()</span><br><span class="line">    , <span class="built_in">callback_</span>(cb)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventLoopThread::~<span class="built_in">EventLoopThread</span>() &#123;</span><br><span class="line">    exiting_ = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(loop_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 退出循环</span></span><br><span class="line">        loop_-&gt;<span class="built_in">quit</span>();</span><br><span class="line">        thread_.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">EventLoop *<span class="title">EventLoopThread::startLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建线程, 执行任务</span></span><br><span class="line">    thread_.<span class="built_in">start</span>();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 会调用Thread::start()，然后执行func_(); func_(std::move(func))；</span></span><br><span class="line"><span class="comment">     * 而func就是&amp;EventLoopThread::threadFunc,this 传入的，所以会启动一个新线程</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    EventLoop* loop = <span class="literal">nullptr</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        cond_.<span class="built_in">wait</span>(lock,[<span class="keyword">this</span>]() &#123;</span><br><span class="line">            <span class="keyword">return</span> loop_ != <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        loop = loop_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> loop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoopThread::threadFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    EventLoop loop;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(callback_) &#123;</span><br><span class="line">        <span class="built_in">callback_</span>(&amp;loop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        loop_ = &amp;loop;</span><br><span class="line">        cond_.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    loop.<span class="built_in">loop</span>();</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    loop_=<span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>启动LOOP的过程</p><ol><li>首先，在startLoop中调用了Thread::start()，而这里的thread<em>的线程函数是threadFunc，在上一篇剖析Thread类时，我们在Thread::start()，看到了一个线程函数func</em>()，所以func就是构造函数中&amp;EventLoopThread::threadFunc,this 传入的，所以这里会创建线程调用threadFunc()函数，并且主线程阻塞等待EventLoop对象的创建</li><li>此时有两个线程在运行 一个是调用EventLoopThread::startLoop()的线程，一个是执行EventLoopThread::threadFunc()的线程 IO线程</li><li>threadFunc是在单独的新线程里面运行的，创建一个独立的Eventloop，和上面的线程是一一对应的 one loop per thread</li><li>将IO线程定义好的loop传入回调</li><li>创建好loop了唤醒主线程，并把loop<em>给主线程，主线程返回IO线程创建的EventLoop对象</em></li><li><em>注意开始执行 loop.loop();，也就是EventLoop loop =&gt; Poller.poll，开始一个循环，知道循环结束eventloop析构,把loop</em>设为空。</li></ol></li><li><h6 id="总体来说，EventLoopThread提供了对应eventloop和thread的封装，意为I-O线程类，EventLoopThread可以创建一个IO线程，通过startLoop返回一个IO线程的loop，threadFunc中开启loop循环。"><a href="#总体来说，EventLoopThread提供了对应eventloop和thread的封装，意为I-O线程类，EventLoopThread可以创建一个IO线程，通过startLoop返回一个IO线程的loop，threadFunc中开启loop循环。" class="headerlink" title="总体来说，EventLoopThread提供了对应eventloop和thread的封装，意为I/O线程类，EventLoopThread可以创建一个IO线程，通过startLoop返回一个IO线程的loop，threadFunc中开启loop循环。"></a><strong>总体来说，EventLoopThread提供了对应eventloop和thread的封装，意为I/O线程类，EventLoopThread可以创建一个IO线程，通过startLoop返回一个IO线程的loop，threadFunc中开启loop循环。</strong></h6></li></ul><h1 id="muduo库EventLoopThreadPool类"><a href="#muduo库EventLoopThreadPool类" class="headerlink" title="muduo库EventLoopThreadPool类"></a>muduo库EventLoopThreadPool类</h1><h2 id="EventLoopThreadPool重要成员变量"><a href="#EventLoopThreadPool重要成员变量" class="headerlink" title="EventLoopThreadPool重要成员变量"></a>EventLoopThreadPool重要成员变量</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EventLoop *baseLoop_;  <span class="comment">//主线程loop</span></span><br><span class="line">std::string name_;</span><br><span class="line"><span class="type">bool</span> started_; <span class="comment">//标记当前状态 即IO线程是否开始运行</span></span><br><span class="line"><span class="type">int</span> numThreads_; <span class="comment">//线程池中线程的数量</span></span><br><span class="line"><span class="type">int</span> next_;  <span class="comment">//负载均衡用</span></span><br><span class="line">std::vector&lt;std::unique_ptr&lt;EventLoopThread&gt;&gt; threads_;<span class="comment">//创建事件的线程</span></span><br><span class="line">std::vector&lt;EventLoop*&gt; loops_; <span class="comment">//事件线程里面EventLoop的指针，每个EventLoopThread线程对应的EventLoop保存在loops_中</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>具体含义见注释</li></ul><h2 id="EventLoopThreadPool重要成员函数"><a href="#EventLoopThreadPool重要成员函数" class="headerlink" title="EventLoopThreadPool重要成员函数"></a>EventLoopThreadPool重要成员函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">EventLoopThreadPool</span><span class="params">(EventLoop* baseloop, <span class="type">const</span> std::string&amp; nameArg = std::string&#123;&#125;)</span></span>;</span><br><span class="line">    ~<span class="built_in">EventLoopThreadPool</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线程池子的线程数量</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setThreadNums</span><span class="params">(<span class="type">const</span> <span class="type">signed</span> <span class="type">int</span> threadNums)</span> </span>&#123; threadNums_ = threadNums;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启事件循环线程</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">(<span class="type">const</span> ThreadInitCallBack &amp;cb = ThreadInitCallBack())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//若是多线程，baseLoop_默认以轮询的方式分配channel给subloop</span></span><br><span class="line">    <span class="function">EventLoop* <span class="title">getNextLoop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到所有的EventLoop</span></span><br><span class="line">    <span class="function">std::vector&lt;EventLoop*&gt; <span class="title">getAllLoops</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">started</span><span class="params">()</span> <span class="type">const</span></span>&#123; <span class="keyword">return</span> started_;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> name_;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//===================================对应实现=============================================</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;EventLoopThreadPool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">EventLoopThreadPool::<span class="built_in">EventLoopThreadPool</span>(EventLoop *baseloop, <span class="type">const</span> std::string &amp;nameArg)</span><br><span class="line">    : <span class="built_in">baseLoop_</span>(baseloop)</span><br><span class="line">    , <span class="built_in">started_</span>(<span class="literal">false</span>)</span><br><span class="line">    , <span class="built_in">name_</span>(nameArg)</span><br><span class="line">    , <span class="built_in">threadNums_</span>(std::thread::<span class="built_in">hardware_concurrency</span>())</span><br><span class="line">    , <span class="built_in">next_</span>(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventLoopThreadPool::~<span class="built_in">EventLoopThreadPool</span>() &#123;</span><br><span class="line">    <span class="comment">//  因为子线程的的loop 是栈中分配的所以不需要手动删除</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">EventLoop *<span class="title">EventLoopThreadPool::getNextLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EventLoop* loop = baseLoop_;</span><br><span class="line">    <span class="comment">// 通过轮询，获取下一个处理事件的loop</span></span><br><span class="line">    <span class="keyword">if</span>(!loops_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        loop = loops_[next_];</span><br><span class="line">        ++next_;</span><br><span class="line">        <span class="keyword">if</span>(next_ &gt;= loops_.<span class="built_in">size</span>()) next_ = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> loop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空的时候是单线程</span></span><br><span class="line"><span class="function">std::vector&lt;EventLoop *&gt; <span class="title">EventLoopThreadPool::getAllLoops</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(loops_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::vector&lt;EventLoop*&gt;&#123;baseLoop_&#125;;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> loops_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoopThreadPool::start</span><span class="params">(<span class="type">const</span> ThreadInitCallBack &amp;cb)</span> </span>&#123;</span><br><span class="line">    started_ = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; threadNums_; i ++) &#123;</span><br><span class="line">        <span class="type">char</span> buf[name_.<span class="built_in">size</span>() + <span class="number">32</span>];</span><br><span class="line">        <span class="built_in">snprintf</span>(buf,<span class="keyword">sizeof</span> buf,<span class="string">&quot;%s%d&quot;</span>,name_.<span class="built_in">c_str</span>(),i);</span><br><span class="line">        <span class="keyword">auto</span> t = std::<span class="built_in">make_unique</span>&lt;EventLoopThread&gt;(cb, buf);</span><br><span class="line">        <span class="comment">// 启动循环并创建线程</span></span><br><span class="line">        loops_.<span class="built_in">emplace_back</span>(t-&gt;<span class="built_in">startLoop</span>());</span><br><span class="line">        <span class="comment">// 放入threads</span></span><br><span class="line">        threads_.<span class="built_in">emplace_back</span>(std::<span class="built_in">move</span>(t));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果整个循环就只有一个线程，就让这个主线程来执行回调函数</span></span><br><span class="line">    <span class="keyword">if</span>(threadNums_ == <span class="number">0</span> &amp;&amp; cb) &#123;</span><br><span class="line">        <span class="built_in">cb</span>(baseLoop_);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>启动线程池,实际上创建numThreads个线程,并让每个eventloopthread调用startLoop()<ol><li>设置当前状态为true，根据需要的线程数numThreads<em>，创建线程</em></li><li>_在for循环中，先创建一个EventLoopThread对象，构造线程池内线程集合</li><li><em>调用EventLoopThread::startLoop()，创建线程，绑定一个新的EventLoop，并返回loop地址，放入loops</em>中，loops<em>是一个std::vector<EventLoop*>类型</em></li><li><em>把每个EventLoopThread线程对应的EventLoop保存在loops</em>中。</li><li>如果没有其他线程，只有主线程的话，直接调用callback</li></ol></li></ul><ul><li><p>muduo是支持单线程和多线程的  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EventLoop* loop = baseLoop_;， </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(threadNums_ == <span class="number">0</span> &amp;&amp; cb) &#123;</span><br><span class="line">        <span class="built_in">cb</span>(baseLoop_);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这两块就实现了单线程功能</p></li></ul><h1 id="EchoServer之建立"><a href="#EchoServer之建立" class="headerlink" title="EchoServer之建立"></a>EchoServer之建立</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/TimeStamp.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/InetAddress.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/TcpConnection.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/EventLoop.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/TcpServer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/logger.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EchoServer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">EchoServer</span>(EventLoop *loop, <span class="type">const</span> InetAddress &amp;listenAddr, <span class="type">const</span> std::string &amp;nameArg)</span><br><span class="line">        : <span class="built_in">loop_</span>(loop)</span><br><span class="line">        , <span class="built_in">tcpServer_</span>(loop, listenAddr, nameArg)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Start</span>();</span><br><span class="line">        <span class="comment">//注册回调函数</span></span><br><span class="line">        tcpServer_.<span class="built_in">setConnectionCallback</span>(</span><br><span class="line">            std::<span class="built_in">bind</span>(&amp;EchoServer::onConnection,<span class="keyword">this</span>,std::placeholders::_1)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        tcpServer_.<span class="built_in">setMessageCallback</span>(</span><br><span class="line">            std::<span class="built_in">bind</span>(&amp;EchoServer::onMessage,<span class="keyword">this</span>,</span><br><span class="line">                std::placeholders::_1, std::placeholders::_2, std::placeholders::_3)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置合适的loop线程数量 loopThread</span></span><br><span class="line">        tcpServer_.<span class="built_in">setThreadNums</span>(std::thread::<span class="built_in">hardware_concurrency</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        tcpServer_.<span class="built_in">start</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可读写事件回调</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onMessage</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn,</span></span></span><br><span class="line"><span class="params"><span class="function">                Buffer *buf,</span></span></span><br><span class="line"><span class="params"><span class="function">                TimeStamp time)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::string msg = buf-&gt;<span class="built_in">retrieveAllAsString</span>();</span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">&quot;%s recv %d bytes at &quot;</span>, conn-&gt;<span class="built_in">name</span>(), msg.<span class="built_in">size</span>(),time.<span class="built_in">to_string</span>());</span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="string">&quot;exit\n&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            conn-&gt;<span class="built_in">send</span>(<span class="string">&quot;bye\n&quot;</span>);</span><br><span class="line">            conn-&gt;<span class="built_in">shutdown</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="string">&quot;quit\n&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            loop_-&gt;<span class="built_in">quit</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        conn-&gt;<span class="built_in">send</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接建立或者断开的回调</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onConnection</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(conn-&gt;<span class="built_in">connected</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">LOG_INFO</span>(<span class="string">&quot;Connection UP : %s&quot;</span>,conn-&gt;<span class="built_in">peerAddress</span>().<span class="built_in">toIpPort</span>().<span class="built_in">c_str</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">LOG_INFO</span>(<span class="string">&quot;Connection DOWN : %s&quot;</span>,conn-&gt;<span class="built_in">peerAddress</span>().<span class="built_in">toIpPort</span>().<span class="built_in">c_str</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EventLoop* loop_;</span><br><span class="line">    TcpServer tcpServer_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    EventLoop loop;</span><br><span class="line">    <span class="function">InetAddress <span class="title">addr</span><span class="params">(<span class="number">8000</span>)</span></span>;</span><br><span class="line">    <span class="comment">//Acceptor non-blocking listenfd create bind</span></span><br><span class="line">    <span class="function">EchoServer <span class="title">server</span><span class="params">(&amp;loop,addr,<span class="string">&quot;EchoServer-01&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">//listen loopthread listenfd =&gt; acceptChannel =&gt; mainLoop =&gt; subloop</span></span><br><span class="line">    server.<span class="built_in">Start</span>();</span><br><span class="line">    loop.<span class="built_in">loop</span>(); <span class="comment">//启动mainloop的底层pooler</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>具体执行逻辑可以看代码或者访问<a href="https://blog.csdn.net/T_Solotov/article/details/124044175这篇大佬的文章">https://blog.csdn.net/T_Solotov/article/details/124044175这篇大佬的文章</a></p><h1 id="muduo库中的定时器类"><a href="#muduo库中的定时器类" class="headerlink" title="muduo库中的定时器类"></a>muduo库中的定时器类</h1><h2 id="Timer类"><a href="#Timer类" class="headerlink" title="Timer类"></a>Timer类</h2><h3 id="Timer重要成员变量"><a href="#Timer重要成员变量" class="headerlink" title="Timer重要成员变量"></a>Timer重要成员变量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定时到期需要执行的任务</span></span><br><span class="line">   TimerCallback timerCaLLBack_;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 何时到期</span></span><br><span class="line">   TimeStamp expiration_;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 距离下次启动的时间间隔，如果不是重复定时器，其值为0</span></span><br><span class="line">   <span class="type">double</span> interval_;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 标志是否是重复定时器</span></span><br><span class="line">   <span class="type">bool</span> repeat_;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 定时器的唯一ID</span></span><br><span class="line">   std::<span class="type">int64_t</span> sequence_;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 定时器开辟的数量</span></span><br><span class="line">   <span class="type">static</span> std::<span class="type">atomic_int64_t</span> numCreated_;</span><br></pre></td></tr></table></figure><ul><li>具体逻辑见注释</li></ul><h3 id="Timer重要成员函数"><a href="#Timer重要成员函数" class="headerlink" title="Timer重要成员函数"></a>Timer重要成员函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">using</span> TimerCallback = std::function&lt;<span class="built_in">void</span>()&gt;;</span><br><span class="line">    <span class="built_in">Timer</span>(TimerCallback timercallback, TimeStamp when, <span class="type">double</span> interval);</span><br><span class="line">    ~<span class="built_in">Timer</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">TimeStamp <span class="title">expiration</span><span class="params">()</span> <span class="type">const</span>  </span>&#123; <span class="keyword">return</span> expiration_; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">repeat</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> repeat_; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int64_t</span> <span class="title">sequence</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> sequence_; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="built_in">timerCaLLBack_</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">restart</span><span class="params">(TimeStamp now)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int64_t</span> <span class="title">numCreated</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> numCreated_; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ================================其实现================================</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Timer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TimeStamp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">std::<span class="type">atomic_int64_t</span> Timer::numCreated_ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Timer::<span class="built_in">Timer</span>(TimerCallback timercallback, TimeStamp when, <span class="type">double</span> interval)</span><br><span class="line">    : <span class="built_in">timerCaLLBack_</span>(timercallback)</span><br><span class="line">    , <span class="built_in">expiration_</span>(when)</span><br><span class="line">    , <span class="built_in">interval_</span>(interval)</span><br><span class="line">    , <span class="built_in">repeat_</span>(interval &gt; <span class="number">0.0</span>)</span><br><span class="line">    , <span class="built_in">sequence_</span>(++ numCreated_)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Timer::restart</span><span class="params">(TimeStamp now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (repeat_)</span><br><span class="line">    &#123;</span><br><span class="line">        expiration_ = TimeStamp::<span class="built_in">addTime</span>(now, interval_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        expiration_ = TimeStamp::<span class="built_in">invaild</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>restart函数判断是否重复定时器构造到期时间,如果是重复就设置到期时间为设定的时间，否则为0</li></ul><h3 id="Timer设计思想"><a href="#Timer设计思想" class="headerlink" title="Timer设计思想"></a>Timer设计思想</h3><ul><li>首先需要到期时需要执行的任务，然后需要存储到期时间以及是否是重复定时器，以及定时器的唯一id</li></ul><h2 id="TimerId类"><a href="#TimerId类" class="headerlink" title="TimerId类"></a>TimerId类</h2><h3 id="TimerId重要成员变量"><a href="#TimerId重要成员变量" class="headerlink" title="TimerId重要成员变量"></a>TimerId重要成员变量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdint&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Timer</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TimerId</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TimerId</span>()</span><br><span class="line">      : <span class="built_in">timer_</span>(<span class="literal">NULL</span>),</span><br><span class="line">        <span class="built_in">sequence_</span>(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">TimerId</span>(Timer* timer, <span class="type">int64_t</span> seq)</span><br><span class="line">      : <span class="built_in">timer_</span>(timer),</span><br><span class="line">        <span class="built_in">sequence_</span>(seq)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">TimerId</span>(<span class="type">const</span> TimerId&amp; timerid) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    TimerId&amp; <span class="keyword">operator</span>=(<span class="type">const</span> TimerId&amp; timerid) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">TimerQueue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 指向一个定时器</span></span><br><span class="line">    Timer* timer_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该定时器对应编号</span></span><br><span class="line">    <span class="type">int64_t</span> sequence_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="TimerQueue类"><a href="#TimerQueue类" class="headerlink" title="TimerQueue类"></a>TimerQueue类</h2><h3 id="TimerQueue重要成员变量"><a href="#TimerQueue重要成员变量" class="headerlink" title="TimerQueue重要成员变量"></a>TimerQueue重要成员变量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">EventLoop* loop_;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// timerfd的描述符</span></span><br><span class="line">   <span class="type">int</span> timerfd_;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 与timer描述符相对应的channel</span></span><br><span class="line">   Channel timerfdChannel_;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 定时器任务列表，以触发时间排序，小的在前</span></span><br><span class="line">   TimerList timers_;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 待处理的定时器列表</span></span><br><span class="line">   ActiverTimerSet activeTimers_;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 标记是否正在执行要过期的定时器</span></span><br><span class="line">   std::atomic_bool callingExpiredTimers_;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 暂存正要过期的定时器列表</span></span><br><span class="line">   ActiverTimerSet cancleTimers_;</span><br></pre></td></tr></table></figure><ul><li>具体见注释</li></ul><h3 id="TimerQueue重要成员函数"><a href="#TimerQueue重要成员函数" class="headerlink" title="TimerQueue重要成员函数"></a>TimerQueue重要成员函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> TimerCallback = std::function&lt;<span class="built_in">void</span>()&gt;;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">TimerQueue</span><span class="params">(EventLoop* loop)</span></span>;</span><br><span class="line">    ~<span class="built_in">TimerQueue</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加定时器任务</span></span><br><span class="line">    <span class="function">TimerId <span class="title">addTimer</span><span class="params">(TimerCallback cb,</span></span></span><br><span class="line"><span class="params"><span class="function">                   TimeStamp when,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="type">double</span> interval)</span></span>;</span><br><span class="line">    <span class="comment">// 取消定时器任务</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">cancel</span><span class="params">(TimerId timerId)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">using</span> ActiverTimer = std::pair&lt;Timer *, <span class="type">int64_t</span>&gt;;</span><br><span class="line">    <span class="keyword">using</span> ActiverTimerSet = std::set&lt;ActiverTimer&gt;;</span><br><span class="line">    <span class="keyword">using</span> Entry = std::pair&lt;TimeStamp, Timer*&gt;;</span><br><span class="line">    <span class="keyword">using</span> TimerList = std::set&lt;Entry&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消定时器任务</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">cancelInLoop</span><span class="params">(TimerId timerid)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理readfd的读事件，得到过期的定时器，并且执行对应任务，并设置下一个要发生的定时器</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleRead</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把过期的定时器从timers_和activeTimer_中删掉 并返回所有过期的定时器集合</span></span><br><span class="line">    <span class="function">std::vector&lt;Entry&gt; <span class="title">getExpired</span><span class="params">(TimeStamp now)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加入到容器中，加入时候要注意是否更新了最早触发任务</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addTimerInLoop</span><span class="params">(Timer* timer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有重复的定时器就重新设置，否则就直接删除，获取过期时间最早的定时器的时间，并将它设置到timerfd中</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(<span class="type">const</span> std::vector&lt;Entry&gt;&amp; expired, TimeStamp now)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入到ActiveTimeSet和timers，同时注意是否会影响一个要发生的定时器时间</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(Timer* timer)</span></span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment">// =====================================其实现===============================</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TimerQueue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;logger.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/timerfd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">timespec <span class="title">howMuchTimeFromNow</span><span class="params">(TimeStamp when)</span> </span>&#123;</span><br><span class="line">    <span class="type">int64_t</span> microseconds = when.<span class="built_in">microSecondsSinceEpoch</span>()</span><br><span class="line">                         - TimeStamp::<span class="built_in">now</span>().<span class="built_in">microSecondsSinceEpoch</span>();</span><br><span class="line">    <span class="keyword">if</span> (microseconds &lt; <span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        microseconds = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timespec</span> ts;</span><br><span class="line">    ts.tv_sec = <span class="built_in">static_cast</span>&lt;<span class="type">time_t</span>&gt;(</span><br><span class="line">        microseconds / TimeStamp::kMicroSecondsPerSecond);</span><br><span class="line">    ts.tv_nsec = <span class="built_in">static_cast</span>&lt;<span class="type">long</span>&gt;(</span><br><span class="line">        (microseconds % TimeStamp::kMicroSecondsPerSecond) * <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> ts;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">createTimerfd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> timerfd = <span class="built_in">timerfd_create</span>(CLOCK_MONOTONIC, TFD_NONBLOCK | TFD_CLOEXEC);</span><br><span class="line">    <span class="keyword">if</span>(timerfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;timerfd_create failed!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> timerfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">resetTimerfd</span><span class="params">(<span class="type">int</span> timerfd, TimeStamp expiration)</span> </span>&#123;</span><br><span class="line">    itimerspec newValue&#123;&#125;;</span><br><span class="line">    itimerspec oldValue&#123;&#125;;</span><br><span class="line">    <span class="comment">// 定时的间隔时间</span></span><br><span class="line">    newValue.it_value =  <span class="built_in">howMuchTimeFromNow</span>(expiration);</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">timerfd_settime</span>(timerfd, <span class="number">0</span>, &amp;newValue, &amp;oldValue);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;timerfd_settime failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">readTimerfd</span><span class="params">(<span class="type">int</span> timerfd, TimeStamp now)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> howmany;</span><br><span class="line">    <span class="type">ssize_t</span> n = ::<span class="built_in">read</span>(timerfd, &amp;howmany, <span class="keyword">sizeof</span> howmany);</span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;TimerQueue::handleRead() %lu at %s&quot;</span>, howmany, now.<span class="built_in">to_string</span>().<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">if</span> (n != <span class="keyword">sizeof</span> howmany)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;TimerQueue::handleRead() reads %ld bytes instead of 8&quot;</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TimerQueue::<span class="built_in">TimerQueue</span>(EventLoop *loop)</span><br><span class="line">    : <span class="built_in">loop_</span>(loop)</span><br><span class="line">    , <span class="built_in">timerfd_</span>(<span class="built_in">createTimerfd</span>())</span><br><span class="line">    , <span class="built_in">timerfdChannel_</span>(timerfd_, loop)</span><br><span class="line">    , <span class="built_in">timers_</span>()</span><br><span class="line">    , <span class="built_in">activeTimers_</span>()</span><br><span class="line">    , <span class="built_in">callingExpiredTimers_</span>(<span class="literal">false</span>)</span><br><span class="line">    , <span class="built_in">cancleTimers_</span>()</span><br><span class="line">&#123;</span><br><span class="line">    timerfdChannel_.<span class="built_in">setReadCallBack</span>(std::<span class="built_in">bind</span>(&amp;TimerQueue::handleRead, <span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置可读 并且让loop监听读事件</span></span><br><span class="line">    timerfdChannel_.<span class="built_in">enableReading</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TimerQueue::~<span class="built_in">TimerQueue</span>() &#123;</span><br><span class="line">    timerfdChannel_.<span class="built_in">disableAll</span>();</span><br><span class="line">    timerfdChannel_.<span class="built_in">remove</span>();</span><br><span class="line">    <span class="built_in">close</span>(timerfd_);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; t: timers_) &#123;</span><br><span class="line">        <span class="keyword">delete</span> t.second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TimerId <span class="title">TimerQueue::addTimer</span><span class="params">(TimerCallback cb, TimeStamp when, <span class="type">double</span> interval)</span> </span>&#123;</span><br><span class="line">    Timer* timer = <span class="keyword">new</span> <span class="built_in">Timer</span>(std::<span class="built_in">move</span>(cb), when, interval);</span><br><span class="line">    loop_-&gt;<span class="built_in">runInLoop</span>(std::<span class="built_in">bind</span>(std::<span class="built_in">bind</span>(&amp;TimerQueue::addTimerInLoop, <span class="keyword">this</span>, timer)));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">TimerId</span>(timer, timer-&gt;<span class="built_in">sequence</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TimerQueue::addTimerInLoop</span><span class="params">(Timer *timer)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> earliestChanged = <span class="built_in">insert</span>(timer);</span><br><span class="line">    <span class="keyword">if</span>(earliestChanged) &#123;</span><br><span class="line">        <span class="built_in">resetTimerfd</span>(timerfd_, timer-&gt;<span class="built_in">expiration</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TimerQueue::insert</span><span class="params">(Timer *timer)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> earliestChanged = <span class="literal">false</span>;</span><br><span class="line">    TimeStamp when = timer-&gt;<span class="built_in">expiration</span>();</span><br><span class="line">    TimerList::iterator it = timers_.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">if</span>(it == timers_.<span class="built_in">end</span>() || when &lt; it-&gt;first) &#123;</span><br><span class="line">        earliestChanged = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        std::pair&lt;TimerList::iterator, <span class="type">bool</span>&gt; result</span><br><span class="line">          = timers_.<span class="built_in">insert</span>(<span class="built_in">Entry</span>(when, timer));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        std::pair&lt;ActiverTimerSet::iterator, <span class="type">bool</span>&gt; result</span><br><span class="line">          = activeTimers_.<span class="built_in">insert</span>(<span class="built_in">ActiverTimer</span>(timer, timer-&gt;<span class="built_in">sequence</span>()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> earliestChanged;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TimerQueue::cancel</span><span class="params">(TimerId timerId)</span> </span>&#123;</span><br><span class="line">    loop_-&gt;<span class="built_in">runInLoop</span>(</span><br><span class="line">      std::<span class="built_in">bind</span>(&amp;TimerQueue::cancelInLoop, <span class="keyword">this</span>, timerId));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TimerQueue::cancelInLoop</span><span class="params">(TimerId timerid)</span> </span>&#123;</span><br><span class="line">    <span class="function">ActiverTimer <span class="title">atimer</span><span class="params">(timerid.timer_, timerid.sequence_)</span></span>;</span><br><span class="line">    ActiverTimerSet::iterator it = activeTimers_.<span class="built_in">find</span>(atimer);</span><br><span class="line">    <span class="keyword">if</span> (it != activeTimers_.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">size_t</span> n = timers_.<span class="built_in">erase</span>(<span class="built_in">Entry</span>(it-&gt;first-&gt;<span class="built_in">expiration</span>(), it-&gt;first));</span><br><span class="line">        (<span class="type">void</span>)n;</span><br><span class="line">        <span class="keyword">delete</span> it-&gt;first; <span class="comment">// <span class="doctag">FIXME:</span> no delete please</span></span><br><span class="line">        activeTimers_.<span class="built_in">erase</span>(it);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (callingExpiredTimers_)</span><br><span class="line">    &#123;</span><br><span class="line">        cancleTimers_.<span class="built_in">insert</span>(atimer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;TimerQueue::Entry&gt; <span class="title">TimerQueue::getExpired</span><span class="params">(TimeStamp now)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;TimerQueue::Entry&gt; expired;</span><br><span class="line">    <span class="comment">// 这是一个哨兵</span></span><br><span class="line">    <span class="function">Entry <span class="title">sentry</span><span class="params">(now, <span class="keyword">reinterpret_cast</span>&lt;Timer*&gt;(UINTPTR_MAX))</span></span>;</span><br><span class="line">    <span class="comment">// 找到第一个大于或等于的定时器</span></span><br><span class="line">    <span class="keyword">auto</span> end = timers_.<span class="built_in">lower_bound</span>(sentry);</span><br><span class="line">    std::<span class="built_in">copy</span>(timers_.<span class="built_in">begin</span>(), end, <span class="built_in">back_inserter</span>(expired));</span><br><span class="line">    timers_.<span class="built_in">erase</span>(timers_.<span class="built_in">begin</span>(), end);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> Entry&amp; it : expired) &#123;</span><br><span class="line">        <span class="function">ActiverTimer <span class="title">timer</span><span class="params">(it.second, it.second-&gt;sequence())</span></span>;</span><br><span class="line">        <span class="type">size_t</span> n = activeTimers_.<span class="built_in">erase</span>(timer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">move</span>(expired);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TimerQueue::handleRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">TimeStamp <span class="title">now</span><span class="params">(TimeStamp::now())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">readTimerfd</span>(timerfd_, now);</span><br><span class="line"></span><br><span class="line">    std::vector&lt;Entry&gt; expired = <span class="built_in">getExpired</span>(now);</span><br><span class="line"></span><br><span class="line">    callingExpiredTimers_ = <span class="literal">true</span>;</span><br><span class="line">    cancleTimers_.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> Entry&amp; it : expired)</span><br><span class="line">    &#123;</span><br><span class="line">        it.second-&gt;<span class="built_in">run</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    callingExpiredTimers_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">reset</span>(expired, now);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TimerQueue::reset</span><span class="params">(<span class="type">const</span> std::vector&lt;Entry&gt; &amp;expired, TimeStamp now)</span> </span>&#123;</span><br><span class="line">    TimeStamp nextExpire;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> Entry&amp; it : expired) &#123;</span><br><span class="line">        <span class="function">ActiverTimer <span class="title">timer</span><span class="params">(it.second, it.second-&gt;sequence())</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (it.second-&gt;<span class="built_in">repeat</span>()</span><br><span class="line">            &amp;&amp; cancleTimers_.<span class="built_in">find</span>(timer) == cancleTimers_.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            it.second-&gt;<span class="built_in">restart</span>(now);</span><br><span class="line">            <span class="built_in">insert</span>(it.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> it.second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!timers_.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        nextExpire = timers_.<span class="built_in">begin</span>()-&gt;second-&gt;<span class="built_in">expiration</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nextExpire.<span class="built_in">valid</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">resetTimerfd</span>(timerfd_, nextExpire);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="取消定时器的逻辑"><a href="#取消定时器的逻辑" class="headerlink" title="取消定时器的逻辑"></a>取消定时器的逻辑</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TimerQueue::cancel</span><span class="params">(TimerId timerId)</span> </span>&#123;</span><br><span class="line">    loop_-&gt;<span class="built_in">runInLoop</span>(</span><br><span class="line">      std::<span class="built_in">bind</span>(&amp;TimerQueue::cancelInLoop, <span class="keyword">this</span>, timerId));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TimerQueue::cancelInLoop</span><span class="params">(TimerId timerid)</span> </span>&#123;</span><br><span class="line">    <span class="function">ActiverTimer <span class="title">atimer</span><span class="params">(timerid.timer_, timerid.sequence_)</span></span>;</span><br><span class="line">    ActiverTimerSet::iterator it = activeTimers_.<span class="built_in">find</span>(atimer);</span><br><span class="line">    <span class="keyword">if</span> (it != activeTimers_.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">size_t</span> n = timers_.<span class="built_in">erase</span>(<span class="built_in">Entry</span>(it-&gt;first-&gt;<span class="built_in">expiration</span>(), it-&gt;first));</span><br><span class="line">        (<span class="type">void</span>)n;</span><br><span class="line">        <span class="keyword">delete</span> it-&gt;first; <span class="comment">// <span class="doctag">FIXME:</span> no delete please</span></span><br><span class="line">        activeTimers_.<span class="built_in">erase</span>(it);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (callingExpiredTimers_)</span><br><span class="line">    &#123;</span><br><span class="line">        cancleTimers_.<span class="built_in">insert</span>(atimer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>该功能是提供给用户手动取消不想要的定时器任务，其实现逻辑是根据用户传入的TimerId将其从activeTimer（活跃定时器中删除）以及timers<em>（存储定时器的列表）中删除，如果它并没有被触发就直接删除，否则就判断是否正在处理别的定时器任务，是的话现暂存在cancleTimers</em>取消定时器列表中（<strong>因为这样可以防止别的定时器会调用这个定时器而导致未定义行为</strong>），cancleTimers这个列表的东西会在准备开始处理下次的一组过期任务的时候被删除</li></ul><h4 id="加入定时器的逻辑"><a href="#加入定时器的逻辑" class="headerlink" title="加入定时器的逻辑"></a>加入定时器的逻辑</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">readTimerfd</span><span class="params">(<span class="type">int</span> timerfd, TimeStamp now)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> howmany;</span><br><span class="line">    <span class="type">ssize_t</span> n = ::<span class="built_in">read</span>(timerfd, &amp;howmany, <span class="keyword">sizeof</span> howmany);</span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;TimerQueue::handleRead() %lu at %s&quot;</span>, howmany, now.<span class="built_in">to_string</span>().<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">if</span> (n != <span class="keyword">sizeof</span> howmany)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;TimerQueue::handleRead() reads %ld bytes instead of 8&quot;</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TimerId <span class="title">TimerQueue::addTimer</span><span class="params">(TimerCallback cb, TimeStamp when, <span class="type">double</span> interval)</span> </span>&#123;</span><br><span class="line">    Timer* timer = <span class="keyword">new</span> <span class="built_in">Timer</span>(std::<span class="built_in">move</span>(cb), when, interval);</span><br><span class="line">    loop_-&gt;<span class="built_in">runInLoop</span>(std::<span class="built_in">bind</span>(std::<span class="built_in">bind</span>(&amp;TimerQueue::addTimerInLoop, <span class="keyword">this</span>, timer)));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">TimerId</span>(timer, timer-&gt;<span class="built_in">sequence</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TimerQueue::addTimerInLoop</span><span class="params">(Timer *timer)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> earliestChanged = <span class="built_in">insert</span>(timer);</span><br><span class="line">    <span class="keyword">if</span>(earliestChanged) &#123;</span><br><span class="line">        <span class="built_in">resetTimerfd</span>(timerfd_, timer-&gt;<span class="built_in">expiration</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入到ActiveTimeSet和timers，同时注意是否会影响一个要发生的定时器时间</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TimerQueue::insert</span><span class="params">(Timer *timer)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> earliestChanged = <span class="literal">false</span>;</span><br><span class="line">    TimeStamp when = timer-&gt;<span class="built_in">expiration</span>();</span><br><span class="line">    TimerList::iterator it = timers_.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">if</span>(it == timers_.<span class="built_in">end</span>() || when &lt; it-&gt;first) &#123;</span><br><span class="line">        earliestChanged = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        std::pair&lt;TimerList::iterator, <span class="type">bool</span>&gt; result</span><br><span class="line">          = timers_.<span class="built_in">insert</span>(<span class="built_in">Entry</span>(when, timer));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        std::pair&lt;ActiverTimerSet::iterator, <span class="type">bool</span>&gt; result</span><br><span class="line">          = activeTimers_.<span class="built_in">insert</span>(<span class="built_in">ActiverTimer</span>(timer, timer-&gt;<span class="built_in">sequence</span>()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> earliestChanged;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>加入新的定时器的时候，需要判断新加入的定时器过期时间会不会是最早的(这是通过set红黑数实现的)，也就是下一次会先执行，如果是的话 要更新下一次过期时间给timerfd（调用resettimerfd），然后不管是不是都要加入到对应的存储容器中</li></ul><h4 id="处理定时器过期逻辑"><a href="#处理定时器过期逻辑" class="headerlink" title="处理定时器过期逻辑"></a>处理定时器过期逻辑</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TimerQueue::handleRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">TimeStamp <span class="title">now</span><span class="params">(TimeStamp::now())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">readTimerfd</span>(timerfd_, now);</span><br><span class="line"></span><br><span class="line">    std::vector&lt;Entry&gt; expired = <span class="built_in">getExpired</span>(now);</span><br><span class="line"></span><br><span class="line">    callingExpiredTimers_ = <span class="literal">true</span>;</span><br><span class="line">    cancleTimers_.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> Entry&amp; it : expired)</span><br><span class="line">    &#123;</span><br><span class="line">        it.second-&gt;<span class="built_in">run</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    callingExpiredTimers_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">reset</span>(expired, now);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;TimerQueue::Entry&gt; <span class="title">TimerQueue::getExpired</span><span class="params">(TimeStamp now)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;TimerQueue::Entry&gt; expired;</span><br><span class="line">    <span class="comment">// 这是一个哨兵</span></span><br><span class="line">    <span class="function">Entry <span class="title">sentry</span><span class="params">(now, <span class="keyword">reinterpret_cast</span>&lt;Timer*&gt;(UINTPTR_MAX))</span></span>;</span><br><span class="line">    <span class="comment">// 找到第一个大于或等于的定时器</span></span><br><span class="line">    <span class="keyword">auto</span> end = timers_.<span class="built_in">lower_bound</span>(sentry);</span><br><span class="line">    std::<span class="built_in">copy</span>(timers_.<span class="built_in">begin</span>(), end, <span class="built_in">back_inserter</span>(expired));</span><br><span class="line">    timers_.<span class="built_in">erase</span>(timers_.<span class="built_in">begin</span>(), end);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> Entry&amp; it : expired) &#123;</span><br><span class="line">        <span class="function">ActiverTimer <span class="title">timer</span><span class="params">(it.second, it.second-&gt;sequence())</span></span>;</span><br><span class="line">        <span class="type">size_t</span> n = activeTimers_.<span class="built_in">erase</span>(timer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">move</span>(expired);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TimerQueue::reset</span><span class="params">(<span class="type">const</span> std::vector&lt;Entry&gt; &amp;expired, TimeStamp now)</span> </span>&#123;</span><br><span class="line">    TimeStamp nextExpire;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> Entry&amp; it : expired) &#123;</span><br><span class="line">        <span class="function">ActiverTimer <span class="title">timer</span><span class="params">(it.second, it.second-&gt;sequence())</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (it.second-&gt;<span class="built_in">repeat</span>()</span><br><span class="line">            &amp;&amp; cancleTimers_.<span class="built_in">find</span>(timer) == cancleTimers_.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            it.second-&gt;<span class="built_in">restart</span>(now);</span><br><span class="line">            <span class="built_in">insert</span>(it.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> it.second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!timers_.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        nextExpire = timers_.<span class="built_in">begin</span>()-&gt;second-&gt;<span class="built_in">expiration</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nextExpire.<span class="built_in">valid</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">resetTimerfd</span>(timerfd_, nextExpire);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">resetTimerfd</span><span class="params">(<span class="type">int</span> timerfd, TimeStamp expiration)</span> </span>&#123;</span><br><span class="line">    itimerspec newValue&#123;&#125;;</span><br><span class="line">    itimerspec oldValue&#123;&#125;;</span><br><span class="line">    <span class="comment">// 定时的间隔时间</span></span><br><span class="line">    newValue.it_value =  <span class="built_in">howMuchTimeFromNow</span>(expiration);</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">timerfd_settime</span>(timerfd, <span class="number">0</span>, &amp;newValue, &amp;oldValue);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;timerfd_settime failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">readTimerfd</span><span class="params">(<span class="type">int</span> timerfd, TimeStamp now)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> howmany;</span><br><span class="line">    <span class="type">ssize_t</span> n = ::<span class="built_in">read</span>(timerfd, &amp;howmany, <span class="keyword">sizeof</span> howmany);</span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;TimerQueue::handleRead() %lu at %s&quot;</span>, howmany, now.<span class="built_in">to_string</span>().<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">if</span> (n != <span class="keyword">sizeof</span> howmany)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;TimerQueue::handleRead() reads %ld bytes instead of 8&quot;</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>由于使用了timerfd，所以定时器过期后会有read事件，接收到后会调用读处理函数，读处理函数中会先读取Timerfd，然后获取过期定时器列表(通过一个哨兵，使用二分找到lower_bound找到第一个大于或等于的位置，执行对应删除)，获取后执行对应任务，最后重新设置下次过期时间以达到循环目的</li><li>重新设置的时候需要判断过期任务列表中是否有重复定时器，有的话重新设定，并且更新下一次过期时间给timerfd</li></ul><h4 id="Timerfd的使用"><a href="#Timerfd的使用" class="headerlink" title="Timerfd的使用"></a>Timerfd的使用</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">createTimerfd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> timerfd = <span class="built_in">timerfd_create</span>(CLOCK_MONOTONIC, TFD_NONBLOCK | TFD_CLOEXEC);</span><br><span class="line">    <span class="keyword">if</span>(timerfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;timerfd_create failed!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> timerfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">resetTimerfd</span><span class="params">(<span class="type">int</span> timerfd, TimeStamp expiration)</span> </span>&#123;</span><br><span class="line">    itimerspec newValue&#123;&#125;;</span><br><span class="line">    itimerspec oldValue&#123;&#125;;</span><br><span class="line">    <span class="comment">// 定时的间隔时间</span></span><br><span class="line">    newValue.it_value =  <span class="built_in">howMuchTimeFromNow</span>(expiration);</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">timerfd_settime</span>(timerfd, <span class="number">0</span>, &amp;newValue, &amp;oldValue);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;timerfd_settime failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">readTimerfd</span><span class="params">(<span class="type">int</span> timerfd, TimeStamp now)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> howmany;</span><br><span class="line">    <span class="type">ssize_t</span> n = ::<span class="built_in">read</span>(timerfd, &amp;howmany, <span class="keyword">sizeof</span> howmany);</span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;TimerQueue::handleRead() %lu at %s&quot;</span>, howmany, now.<span class="built_in">to_string</span>().<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">if</span> (n != <span class="keyword">sizeof</span> howmany)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;TimerQueue::handleRead() reads %ld bytes instead of 8&quot;</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>timerfd 这个名字拆开来看，就是 timer fd，所谓定时器 fd 类型，那么它的可读可写事件一定是跟时间有关系。timerfd 被 new 出来之后 （ <code>timerfd_create</code> ），可以设置超时时间（ <code>timerfd_setting</code> ），超时之后，该句柄可读，读出来的是<strong>超时的次数</strong>。</p></li><li><p>他有三个用法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 timerfd 句柄</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">timerfd_create</span><span class="params">(<span class="type">int</span> clockid, <span class="type">int</span> flags)</span></span>;</span><br><span class="line"><span class="comment">// 启动或关闭 timerfd 对应的定时器,会返回上次设定时间给传入的参数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">timerfd_settime</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> flags, <span class="type">const</span> <span class="keyword">struct</span> itimerspec *new_value, <span class="keyword">struct</span> itimerspec *old_value)</span></span>;</span><br><span class="line"><span class="comment">// 获取指定 timerfd 距离下一次超时还剩的时间</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">timerfd_gettime</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> itimerspec *curr_value)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>两个需要用得到结构体</p><ul><li>timespec</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// timespec 结构体用于表示时间，其定义如下：</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">timespec</span> &#123;</span><br><span class="line">    <span class="type">time_t</span> tv_sec;        <span class="comment">/* 秒 */</span></span><br><span class="line">    <span class="type">long</span>   tv_nsec;       <span class="comment">/* 纳秒 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>itimespec</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// itimerspec 结构体用于定义定时器的设置值和剩余时间，</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">itimerspec</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timespec</span> it_interval; <span class="comment">/* 重复周期 */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timespec</span> it_value;    <span class="comment">/* 首次触发时间 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>用法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">timer_t</span> timerid;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">create_timer</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">itimerspec</span> new_value;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">itimerspec</span> curr_value;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">timer_create</span>(CLOCK_REALTIME, <span class="literal">NULL</span>, &amp;timerid) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;timer_create&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">memset</span>(&amp;new_value, <span class="number">0</span>, <span class="built_in">sizeof</span>(new_value));</span><br><span class="line">    new_value.it_value.tv_sec = <span class="number">5</span>;</span><br><span class="line">    new_value.it_interval.tv_sec = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">timer_settime</span>(timerid, <span class="number">0</span>, &amp;new_value, <span class="literal">NULL</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;timer_settime&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">signal_handler</span><span class="params">(<span class="type">int</span> sig, <span class="type">siginfo_t</span> *si, <span class="type">void</span> *uc)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">itimerspec</span> curr_value;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Signal handler called - count: %d\n&quot;</span>, count);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">timer_gettime</span>(timerid, &amp;curr_value) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;timer_gettime&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sigaction</span> sa;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">memset</span>(&amp;sa, <span class="number">0</span>, <span class="built_in">sizeof</span>(sa));</span><br><span class="line">    sa.sa_flags = SA_SIGINFO;</span><br><span class="line">    sa.sa_sigaction = signal_handler;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sigaction</span>(SIGRTMIN, &amp;sa, <span class="literal">NULL</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;sigaction&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">create_timer</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">pause</span>();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
    <summary type="html">剖析muduo网络库核心部分、设计思想</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>C++asio网络编程</title>
    <link href="https://pigcanstudy.github.io/posts/9724705.html"/>
    <id>https://pigcanstudy.github.io/posts/9724705.html</id>
    <published>2024-07-18T02:49:00.000Z</published>
    <updated>2024-07-18T02:50:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li><a href="#目录">目录</a><ul><li><a href="#网络编程的基本流程">网络编程的基本流程</a><ul><li><a href="#终端节点的创建">终端节点的创建</a><ul><li><a href="#客户端之终端节点的创建">客户端之终端节点的创建</a></li><li><a href="#服务端之终端节点的创建">服务端之终端节点的创建</a></li></ul></li><li><a href="#创建socket">创建socket</a><ul><li><a href="#服务端与客户端之创建socket">服务端与客户端之创建socket</a></li><li><a href="#服务端之接收链接请求的socket对应accept">服务端之接收链接请求的socket（对应accept）</a></li></ul></li><li><a href="#绑定acceptor">绑定acceptor</a></li><li><a href="#可以把端口绑定和acceptor的传建合起来写">可以把端口绑定和acceptor的传建合起来写</a></li><li><a href="#链接指定的端点">链接指定的端点</a></li><li><a href="#服务器接收来连接">服务器接收来连接</a><ul><li><a href="#创建acceptor的几种方法">创建acceptor的几种方法</a></li></ul></li><li><a href="#关于buffer">关于buffer</a><ul><li><a href="#字符串的buffer">字符串的buffer</a></li><li><a href="#数组的buffer">数组的buffer</a></li><li><a href="#流式的buffer">流式的buffer</a></li><li><a href="#容器的buffer">容器的buffer</a></li><li><a href="#指向缓冲区的指针的buffer">指向缓冲区的指针的buffer</a></li></ul></li></ul></li><li><a href="#同步读写">同步读写</a><ul><li><a href="#同步写-write_some">同步写 write_some</a></li><li><a href="#同步写-send">同步写 send</a></li><li><a href="#同步写-write">同步写 write</a></li><li><a href="#同步读-read_some">同步读 read_some</a></li><li><a href="#同步读-receive">同步读 receive</a></li><li><a href="#同步读-read">同步读 read</a></li><li><a href="#读取直到指定字符">读取直到指定字符</a></li></ul></li><li><a href="#同步读写的客户端与服务端">同步读写的客户端与服务端</a><ul><li><a href="#客户端的设计">客户端的设计</a></li><li><a href="#服务端设计">服务端设计</a><ul><li><a href="#session函数">session函数</a></li><li><a href="#server函数">server函数</a></li><li><a href="#完整服务端代码">完整服务端代码</a></li></ul></li><li><a href="#同步读写的优劣">同步读写的优劣</a></li></ul></li><li><a href="#asio异步读写操作及注意事项">asio异步读写操作及注意事项</a><ul><li><a href="#异步写操作">异步写操作</a></li><li><a href="#异步读操作">异步读操作</a></li><li><a href="#总结-完整代码">总结 完整代码</a><ul><li><a href="#sessionh头文件">Session.h头文件</a></li><li><a href="#sessioncpp">Session.cpp</a></li></ul></li></ul></li><li><a href="#asio官方案例存在的隐患">asio官方案例存在的隐患</a><ul><li><a href="#session类">Session类</a></li><li><a href="#server类">Server类</a><ul><li><a href="#server实现">Server实现</a></li></ul></li><li><a href="#隐患">隐患</a></li><li><a href="#总结">总结</a></li><li><a href="#完整代码">完整代码</a><ul><li><a href="#头文件">头文件</a></li><li><a href="#实现">实现</a></li></ul></li></ul></li><li><a href="#使用伪闭包实现连接的安全回收">使用伪闭包实现连接的安全回收</a><ul><li><a href="#智能指针管理session">智能指针管理Session</a></li><li><a href="#session的uuid">Session的uuid</a></li><li><a href="#隐患1">隐患1</a></li><li><a href="#如何实现伪闭包">如何实现伪闭包</a></li><li><a href="#完整的代码">完整的代码</a><ul><li><a href="#实现1">实现1</a></li><li><a href="#头文件1">头文件1</a></li></ul></li></ul></li><li><a href="#封装服务器发送队列">封装服务器发送队列</a><ul><li><a href="#数据节点设计">数据节点设计</a></li><li><a href="#封装发送接口">封装发送接口</a></li></ul></li><li><a href="#修改读回调">修改读回调</a><ul><li><a href="#该节总结">该节总结</a></li><li><a href="#封装后完整代码">封装后完整代码</a><ul><li><a href="#msgnode">msgNode</a></li><li><a href="#csession">CSession</a></li><li><a href="#cserver">CServer</a></li></ul></li></ul></li><li><a href="#处理网络粘包问题">处理网络粘包问题</a><ul><li><a href="#什么是粘包">什么是粘包</a></li><li><a href="#粘包原因">粘包原因</a></li><li><a href="#处理粘包">处理粘包</a></li><li><a href="#完善消息节点">完善消息节点</a></li><li><a href="#csession类完善">CSession类完善</a></li><li><a href="#完善接收逻辑">完善接收逻辑</a></li><li><a href="#服务端完整代码">服务端完整代码</a><ul><li><a href="#csession头文件">CSession头文件</a></li><li><a href="#csession-实现">CSession 实现</a></li><li><a href="#cserver头文件">CServer头文件</a></li><li><a href="#cserver实现">CServer实现</a></li><li><a href="#msgnode-1">MsgNode</a></li></ul></li><li><a href="#客户端修改">客户端修改</a></li><li><a href="#粘包测试">粘包测试</a></li><li><a href="#目前服务端通信流程图">目前服务端通信流程图</a></li><li><a href="#io_context">io_context</a></li></ul></li><li><a href="#字节序处理和发送队列控制">字节序处理和发送队列控制</a><ul><li><a href="#字节序问题">字节序问题</a></li><li><a href="#如何区分本机字节序">如何区分本机字节序</a></li><li><a href="#服务器使用网络字节序">服务器使用网络字节序</a></li><li><a href="#消息队列控制">消息队列控制</a></li></ul></li><li><a href="#protobuf配置和使用">protobuf配置和使用</a><ul><li><a href="#portobuf简介">portobuf简介</a></li><li><a href="#生成pb文件">生成pb文件</a></li><li><a href="#在网络编程中的应用">在网络编程中的应用</a></li></ul></li><li><a href="#jsoncpp的使用与配置">jsoncpp的使用与配置</a><ul><li><a href="#简介">简介</a></li><li><a href="#配置参考我的csdn收藏">配置参考我的csdn收藏</a></li><li><a href="#测试">测试</a></li><li><a href="#网络编程中的应用">网络编程中的应用</a></li><li><a href="#新版json库-nlohmannjson">新版JSON库 nlohmann/json</a></li></ul></li><li><a href="#asio粘包处理的简单方式">asio粘包处理的简单方式</a><ul><li><a href="#简单方式">简单方式</a></li><li><a href="#获取头部数据">获取头部数据</a></li><li><a href="#获取消息体">获取消息体</a></li></ul></li><li><a href="#服务器逻辑层设计和消息完善">服务器逻辑层设计和消息完善</a><ul><li><a href="#简介1">简介1</a></li><li><a href="#服务器架构设计">服务器架构设计</a></li><li><a href="#消息头完善">消息头完善</a><ul><li><a href="#我们将上述结构定义在msgnodeh中">我们将上述结构定义在MsgNode.h中</a></li><li><a href="#实现msgnode">实现MsgNode</a></li></ul></li><li><a href="#session类改写">Session类改写</a><ul><li><a href="#完整的代码2">完整的代码2</a><ul><li><a href="#sessionh">Session.h</a></li><li><a href="#sessioncpp-1">Session.cpp</a></li></ul></li></ul></li></ul></li><li><a href="#单例模式实现逻辑层设计">单例模式实现逻辑层设计</a><ul><li><a href="#单例模板类">单例模板类</a></li><li><a href="#logicsystem单例类">LogicSystem单例类</a><ul><li><a href="#logicsystem-完整代码">LogicSystem 完整代码</a><ul><li><a href="#头文件-1">头文件</a></li><li><a href="#实现-1">实现</a></li></ul></li></ul></li></ul></li><li><a href="#服务器优雅退出">服务器优雅退出</a><ul><li><a href="#退出方式1开辟线程让服务器运行在线程中并接受退出信号退出">退出方式1：开辟线程，让服务器运行在线程中并接受退出信号退出</a></li><li><a href="#退出方式2使用asio底层异步等待函数">退出方式2：使用asio底层异步等待函数</a></li><li><a href="#总结-1">总结</a></li></ul></li><li><a href="#asio多线程模型ioservicepool">asio多线程模型IOServicePool</a><ul><li><a href="#简介-1">简介</a></li><li><a href="#单线程和多线程对比">单线程和多线程对比</a></li><li><a href="#ioservicepool实现">IOServicePool实现</a><ul><li><a href="#ioservicepool的声明">IOServicePool的声明:</a></li><li><a href="#实现-2">实现</a></li></ul></li><li><a href="#优雅退出">优雅退出</a></li></ul></li><li><a href="#asio多线程模式iothreadpool">asio多线程模式IOThreadPool</a><ul><li><a href="#结构图">结构图</a></li><li><a href="#先实现iothreadpool">先实现IOThreadPool</a><ul><li><a href="#iothreadpool-头文件">IOThreadPool 头文件</a></li><li><a href="#iothreadpool-实现">IOThreadPool 实现</a><ul><li><a href="#iocp的流程是这样的">iocp的流程是这样的</a></li><li><a href="#epoll流程是这样的">epoll流程是这样的</a></li></ul></li></ul></li><li><a href="#隐患-1">隐患</a></li><li><a href="#利用strand改进">利用strand改进</a></li><li><a href="#csession代码">CSession代码</a></li><li><a href="#性能对比">性能对比</a></li><li><a href="#取舍">取舍</a></li></ul></li><li><a href="#boostasio协程实现并发服务器">boost::asio协程实现并发服务器</a><ul><li><a href="#简介-2">简介</a></li><li><a href="#协程案例">协程案例</a></li><li><a href="#完整并发服务器">完整并发服务器</a><ul><li><a href="#asiioservicepool">AsiIOServicePool</a><ul><li><a href="#asioioservicepool头文件">AsioIOServicePool头文件</a></li><li><a href="#asioioservicepool实现">AsioIOServicePool实现</a></li></ul></li><li><a href="#cosnth">cosnt.h</a></li><li><a href="#cserver-1">CServer</a><ul><li><a href="#cserver头文件-1">CServer头文件</a></li><li><a href="#cserver实现-1">CServer实现</a></li></ul></li><li><a href="#csession-1">CSession</a><ul><li><a href="#csessionh">CSession.h</a></li><li><a href="#csession实现">CSession实现</a></li></ul></li><li><a href="#logicsystem">LogicSystem</a><ul><li><a href="#logicsystem头文件">LogicSystem头文件</a></li><li><a href="#logicsystem实现">LogicSystem实现</a></li></ul></li><li><a href="#msgnode-2">MsgNode</a><ul><li><a href="#msgnode头文件">MsgNode头文件</a></li><li><a href="#msgnode-实现">MsgNode 实现</a></li></ul></li></ul></li></ul></li><li><a href="#使用asio实现http服务器">使用asio实现http服务器</a><ul><li><a href="#简介-3">简介</a></li><li><a href="#http包头信息">Http包头信息</a><ul><li><a href="#http请求头">HTTP请求头</a></li><li><a href="#http响应头">HTTP响应头</a></li></ul></li></ul></li><li><a href="#使用beast网络库实现http服务器">使用beast网络库实现http服务器</a><ul><li><a href="#简介-4">简介</a></li><li><a href="#连接类">连接类</a></li><li><a href="#完整代码-1">完整代码</a></li></ul></li><li><a href="#beast网络库实现websocket服务器">beast网络库实现websocket服务器</a><ul><li><a href="#简介-5">简介</a></li><li><a href="#构造websocket">构造websocket</a></li><li><a href="#开发的websocket代码">开发的websocket代码</a><ul><li><a href="#connectionh">Connection.h</a></li><li><a href="#connectioncpp">Connection.cpp</a></li><li><a href="#connectionmgrh">ConnectionMgr.h</a></li><li><a href="#connectionmgrcpp">ConnectionMgr.cpp</a></li><li><a href="#websocketserverh">WebSocketServer.h</a></li><li><a href="#websocketservercpp">WebSocketServer.cpp</a></li><li><a href="#maincpp">main.cpp</a></li><li><a href="#总结-2">总结</a></li></ul></li></ul></li><li><a href="#grpc的使用">gRPC的使用</a><ul><li><a href="#grpc客户端">gRPC客户端</a></li><li><a href="#grpc服务端">gRPC服务端</a></li></ul></li></ul></li></ul><h2 id="网络编程的基本流程"><a href="#网络编程的基本流程" class="headerlink" title="网络编程的基本流程"></a>网络编程的基本流程</h2><ul><li>网络编程的基本流程对于服务端是这样的</li><li><p>服务端<br>1）socket——创建socket对象。<br>2）bind——绑定本机ip+port。<br>3）listen——监听来电，若在监听到来电，则建立起连接<br>4）accept——再创建一个socket对象给其收发消息。原因是现实中服务端都是面对多个客户端，那么为了区分各个客户端，则每个客户端都需再分配一个socket对象进行收发消息。<br>5）read、write——就是收发消息了。</p></li><li><p>对于客户端是这样的</p></li><li><p>客户端<br>1）socket——创建socket对象。<br>2）connect——根据服务端ip+port，发起连接请求。<br>3）write、read——建立连接后，就可发收消息了。</p></li><li><p>图示如下</p></li></ul><p><img src="../assets/C++asio网络编程/image.png" alt="示例图片" style="zoom:100%;" /></p><ul><li>了解了解 Reactor模式以及proactor模式</li></ul><h3 id="终端节点的创建"><a href="#终端节点的创建" class="headerlink" title="终端节点的创建"></a>终端节点的创建</h3><ul><li>所谓终端节点就是用来通信的端对端的节点，可以通过ip地址和端口构造，其它节点可以连接这个终端节点做通信。</li></ul><h4 id="客户端之终端节点的创建"><a href="#客户端之终端节点的创建" class="headerlink" title="客户端之终端节点的创建"></a>客户端之终端节点的创建</h4><ul><li>如果我们是客户端，我们可以通过对端的ip和端口构造一个endpoint，用这个endpoint和其通信。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;endpoint.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">client_end_point</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> std::string raw_ip_address = <span class="string">&quot;127.4.8.1&quot;</span>;</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">short</span> port_num = <span class="number">8888</span>;</span><br><span class="line">    <span class="comment">// 用来进行错误处理</span></span><br><span class="line"> boost::system::error_code ec;</span><br><span class="line">    <span class="comment">// from_string函数是用来字符串IP地址形式转换为网络地址的表示形式</span></span><br><span class="line"> boost::asio::ip::address ip_address = boost::asio::ip::address::<span class="built_in">from_string</span>(raw_ip_address, ec);</span><br><span class="line"> <span class="keyword">if</span> (ec.<span class="built_in">value</span>() != <span class="number">0</span>) &#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Failed to parse the IP address. Error code = &quot;</span> &lt;&lt; ec.<span class="built_in">value</span>() &lt;&lt; <span class="string">&quot;.Message is&quot;</span> &lt;&lt; ec.<span class="built_in">message</span>();</span><br><span class="line">  <span class="keyword">return</span> ec.<span class="built_in">value</span>();</span><br><span class="line"> &#125;</span><br><span class="line"> boost::asio::ip::<span class="function">tcp::endpoint <span class="title">ep</span><span class="params">(ip_address, port_num)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="服务端之终端节点的创建"><a href="#服务端之终端节点的创建" class="headerlink" title="服务端之终端节点的创建"></a>服务端之终端节点的创建</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">server_end_point</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">short</span> port_num = <span class="number">8888</span>;</span><br><span class="line"> <span class="comment">// 表示可以接收任意IPV4地址</span></span><br><span class="line"> boost::asio::ip::address ip_address = boost::asio::ip::address_v4::<span class="built_in">any</span>();</span><br><span class="line"> boost::asio::ip::<span class="function">tcp::endpoint <span class="title">ep</span><span class="params">(ip_address, port_num)</span></span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建socket"><a href="#创建socket" class="headerlink" title="创建socket"></a>创建socket</h3><ul><li>创建socket分为4步，创建上下文iocontext，选择协议，生成socket，打开socket。</li></ul><h4 id="服务端与客户端之创建socket"><a href="#服务端与客户端之创建socket" class="headerlink" title="服务端与客户端之创建socket"></a>服务端与客户端之创建socket</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">create_tcp_socket</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 创建上下文io_context（旧版本为io_service)</span></span><br><span class="line"> boost::asio::io_context ioc;</span><br><span class="line"> <span class="comment">// 选择协议</span></span><br><span class="line"> boost::asio::ip::tcp protocol = boost::asio::ip::tcp::<span class="built_in">v4</span>();</span><br><span class="line"> <span class="comment">// 创建socket,ioc来管理套接字的创建和销毁</span></span><br><span class="line"> boost::asio::ip::<span class="function">tcp::socket <span class="title">socket</span><span class="params">(ioc)</span></span>;</span><br><span class="line"> <span class="comment">// 用来处理错误信息</span></span><br><span class="line"> boost::system::error_code ec;</span><br><span class="line"> <span class="comment">// 打开socket</span></span><br><span class="line"> socket.<span class="built_in">open</span>(protocol, ec);</span><br><span class="line"> <span class="keyword">if</span> (ec.<span class="built_in">value</span>() != <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// 打开失败</span></span><br><span class="line">  std::cout</span><br><span class="line">   &lt;&lt; <span class="string">&quot;Failed to open the socket! Error code = &quot;</span></span><br><span class="line">   &lt;&lt; ec.<span class="built_in">value</span>() &lt;&lt; <span class="string">&quot;. Message: &quot;</span> &lt;&lt; ec.<span class="built_in">message</span>();</span><br><span class="line">  <span class="keyword">return</span> ec.<span class="built_in">value</span>();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="服务端之接收链接请求的socket（对应accept）"><a href="#服务端之接收链接请求的socket（对应accept）" class="headerlink" title="服务端之接收链接请求的socket（对应accept）"></a>服务端之接收链接请求的socket（对应accept）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">create_acceptor_socket</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="comment">//创建上下文io_context</span></span><br><span class="line"> boost::asio::io_context ioc;</span><br><span class="line"> <span class="comment">// 选择协议</span></span><br><span class="line"> boost::asio::ip::tcp protocol = boost::asio::ip::tcp::<span class="built_in">v4</span>();</span><br><span class="line"> <span class="comment">// 创建socket</span></span><br><span class="line"> boost::asio::ip::<span class="function">tcp::acceptor <span class="title">acceptor</span><span class="params">(ioc)</span></span>;</span><br><span class="line"> <span class="comment">// 用来处理错误信息</span></span><br><span class="line"> boost::system::error_code ec;</span><br><span class="line"> <span class="comment">// 打开socket(打开监听状态)</span></span><br><span class="line"> acceptor.<span class="built_in">open</span>(protocol, ec);</span><br><span class="line">    </span><br><span class="line"> <span class="keyword">if</span> (ec.<span class="built_in">value</span>() != <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// 打开失败</span></span><br><span class="line">  std::cout</span><br><span class="line">   &lt;&lt; <span class="string">&quot;Failed to open the socket! Error code = &quot;</span></span><br><span class="line">   &lt;&lt; ec.<span class="built_in">value</span>() &lt;&lt; <span class="string">&quot;. Message: &quot;</span> &lt;&lt; ec.<span class="built_in">message</span>();</span><br><span class="line">  <span class="keyword">return</span> ec.<span class="built_in">value</span>();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="绑定acceptor"><a href="#绑定acceptor" class="headerlink" title="绑定acceptor"></a>绑定acceptor</h3><ul><li>对于acceptor类型的socket，服务器要将其绑定到指定的断点,所有连接这个端点的连接都可以被接收到。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind_acceptor_socket</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">short</span> port_num = <span class="number">8888</span>;</span><br><span class="line"> boost::asio::ip::<span class="function">tcp::endpoint <span class="title">ep</span><span class="params">(boost::asio::ip::address_v4::any(),</span></span></span><br><span class="line"><span class="params"><span class="function">  port_num)</span></span>;</span><br><span class="line"> boost::asio::io_context ioc;</span><br><span class="line"> boost::asio::ip::<span class="function">tcp::acceptor <span class="title">acceptor</span><span class="params">(ioc, ep.protocol())</span></span>;</span><br><span class="line"> boost::system::error_code ec;</span><br><span class="line">    <span class="comment">//将端点绑定道acceptor这个socket上，与这个端点链接的端点都能被接受到</span></span><br><span class="line"> acceptor.<span class="built_in">bind</span>(ep, ec);</span><br><span class="line"> <span class="keyword">if</span> (ec.<span class="built_in">value</span>() != <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">//打开失败</span></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Failed to bind the acceptor socket.&quot;</span></span><br><span class="line">   &lt;&lt; <span class="string">&quot;Error code = &quot;</span> &lt;&lt; ec.<span class="built_in">value</span>() &lt;&lt; <span class="string">&quot;. Message: &quot;</span></span><br><span class="line">   &lt;&lt; ec.<span class="built_in">message</span>();</span><br><span class="line">  <span class="keyword">return</span> ec.<span class="built_in">value</span>();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可以把端口绑定和acceptor的传建合起来写"><a href="#可以把端口绑定和acceptor的传建合起来写" class="headerlink" title="可以把端口绑定和acceptor的传建合起来写"></a>可以把端口绑定和acceptor的传建合起来写</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新版本的写法,默认绑定了8888的端口</span></span><br><span class="line">boost::asio::ip::<span class="function">tcp::acceptor <span class="title">acceptor</span><span class="params">(ioc,boost::asio::ip::tcp::v4(),<span class="number">8888</span>)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="链接指定的端点"><a href="#链接指定的端点" class="headerlink" title="链接指定的端点"></a>链接指定的端点</h3><ul><li>作为客户端可以连接服务器指定的端点进行连接</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对应客户端发送链接请求</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">connect_to_end</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> std::string raw_ip_address = <span class="string">&quot;192.168.168.124&quot;</span>;</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">short</span> port_num = <span class="number">8888</span>;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  boost::asio::ip::<span class="function">tcp::endpoint <span class="title">ep</span><span class="params">(boost::asio::ip::address::from_string(raw_ip_address),</span></span></span><br><span class="line"><span class="params"><span class="function">   port_num)</span></span>;</span><br><span class="line">  boost::asio::io_context ioc;</span><br><span class="line">  boost::asio::ip::<span class="function">tcp::socket <span class="title">sock</span><span class="params">(ioc, ep.protocol())</span></span>;</span><br><span class="line">  sock.<span class="built_in">connect</span>(ep);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">catch</span> (boost::system::system_error&amp; e) &#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Error occured! Error code = &quot;</span> &lt;&lt; e.<span class="built_in">code</span>()</span><br><span class="line">   &lt;&lt; <span class="string">&quot;. Message: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>();</span><br><span class="line">  <span class="keyword">return</span> e.<span class="built_in">code</span>().<span class="built_in">value</span>();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务器接收来连接"><a href="#服务器接收来连接" class="headerlink" title="服务器接收来连接"></a>服务器接收来连接</h3><ul><li>当有客户端连接时，服务器需要接收连接</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">accept_new_connection</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="comment">//指定连接队列的大小(用来存取未被及时处理的链接)</span></span><br><span class="line"> <span class="type">const</span> <span class="type">int</span> BACKLOG_SIZE = <span class="number">30</span>;</span><br><span class="line"> <span class="comment">//端口</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">short</span> port_num = <span class="number">8888</span>;</span><br><span class="line"> <span class="comment">// 创建端点</span></span><br><span class="line"> boost::asio::ip::<span class="function">tcp::endpoint <span class="title">ep</span><span class="params">(boost::asio::ip::address_v4::any(),</span></span></span><br><span class="line"><span class="params"><span class="function">  port_num)</span></span>;</span><br><span class="line"> boost::asio::io_context ioc;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">/*新版连接方式</span></span><br><span class="line"><span class="comment">        //boost::asio::ip::tcp::acceptor acceptor(io_context, boost::asio::ip::tcp::endpoint(boost::asio::ip::tcp::v4(), port_num));</span></span><br><span class="line"><span class="comment">        //这个可写可不写</span></span><br><span class="line"><span class="comment">        acceptor.listen();</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">  <span class="comment">// 创建指定类型的连接器</span></span><br><span class="line">  boost::asio::ip::<span class="function">tcp::acceptor <span class="title">acceptor</span><span class="params">(ioc, ep.protocol())</span></span>;</span><br><span class="line">  <span class="comment">//绑定端点</span></span><br><span class="line">  acceptor.<span class="built_in">bind</span>(ep);</span><br><span class="line">  <span class="comment">//监听事件</span></span><br><span class="line">  acceptor.<span class="built_in">listen</span>(BACKLOG_SIZE);</span><br><span class="line">  <span class="comment">// 创建一个活跃的sock 用来连接</span></span><br><span class="line">  boost::asio::ip::<span class="function">tcp::socket <span class="title">sock</span><span class="params">(ioc)</span></span>;</span><br><span class="line">  <span class="comment">// 连接</span></span><br><span class="line">  acceptor.<span class="built_in">accept</span>(sock);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">catch</span> (boost::system::system_error&amp; e) &#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Error occured! Error code = &quot;</span> &lt;&lt; e.<span class="built_in">code</span>()</span><br><span class="line">   &lt;&lt; <span class="string">&quot;. Message: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>();</span><br><span class="line">  <span class="keyword">return</span> e.<span class="built_in">code</span>().<span class="built_in">value</span>();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>在早期版本的 Boost.Asio 中，在使用 ip::tcp::acceptor 对象之前，通常需要调用 bind 函数将 acceptor 绑定到特定的地址和端口上，并调用 listen 函数开始监听连接请求。</p></li><li><p>但在较新的版本中，Boost.Asio 已经做了一些改进，使得在创建 ip::tcp::acceptor 对象时可以通过构造函数直接指定绑定地址和端口，并且开始监听连接请求。这样可以简化代码，并且提供了更方便的接口。</p></li></ul><h4 id="创建acceptor的几种方法"><a href="#创建acceptor的几种方法" class="headerlink" title="创建acceptor的几种方法"></a>创建acceptor的几种方法</h4><p>当使用 Boost.Asio 创建 TCP 服务器时，通常有以下几种方法来创建 acceptor 对象：</p><p>使用端点对象创建 acceptor：</p><p>这是最常见的方法。你首先创建一个 TCP 端点对象（boost::asio::ip::tcp::endpoint），指定要监听的特定地址和端口。然后，使用这个端点对象来创建 acceptor 对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">boost::asio::ip::<span class="function">tcp::endpoint <span class="title">endpoint</span><span class="params">(boost::asio::ip::address_v4::any(), <span class="number">8888</span>)</span></span>;</span><br><span class="line">boost::asio::io_context io_context;</span><br><span class="line">boost::asio::ip::<span class="function">tcp::acceptor <span class="title">acceptor</span><span class="params">(io_context, endpoint)</span></span>;</span><br></pre></td></tr></table></figure><p>使用协议对象创建 acceptor：</p><ul><li>你也可以直接使用 TCP 协议对象（boost::asio::ip::tcp::v4() 或 boost::asio::ip::tcp::v6()）来创建 acceptor 对象。在这种情况下，acceptor 将监听服务器上的所有网络接口。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">boost::asio::io_context io_context;</span><br><span class="line">boost::asio::ip::<span class="function">tcp::acceptor <span class="title">acceptor</span><span class="params">(io_context, boost::asio::ip::tcp::v4(), <span class="number">8888</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>延迟绑定端口：</p><ul><li>有时你可能希望在创建 acceptor 对象后，稍后再将其绑定到指定的地址和端口上。这样的话，在创建 acceptor 时不需要传递端点对象或协议对象。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">boost::asio::io_context io_context;</span><br><span class="line">boost::asio::ip::<span class="function">tcp::acceptor <span class="title">acceptor</span><span class="params">(io_context)</span></span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">boost::asio::ip::<span class="function">tcp::endpoint <span class="title">endpoint</span><span class="params">(boost::asio::ip::address_v4::any(), <span class="number">8888</span>)</span></span>;</span><br><span class="line">acceptor.<span class="built_in">bind</span>(endpoint);</span><br></pre></td></tr></table></figure><ul><li>总的来说，创建 acceptor 对象的方法取决于你的需求。如果你想监听特定的地址和端口，则使用端点对象或协议对象；如果你希望在稍后再绑定端口，则延迟绑定端口。</li></ul><h3 id="关于buffer"><a href="#关于buffer" class="headerlink" title="关于buffer"></a>关于buffer</h3><ul><li>任何网络库都有提供buffer的数据结构，所谓buffer就是接收和发送数据时缓存数据的结构。</li><li>boost::asio提供了<strong>asio::mutable_buffer</strong> 和 <strong>asio::const_buffer</strong>这两个结构，他们是一段连续的空间，首字节存储了后续数据的长度。</li><li>asio::mutable_buffer用于写服务，asio::const_buffer用于读服务。但是这两个结构都没有被asio的api直接使用。</li><li>对于api的buffer参数，asio提出了MutableBufferSequence和ConstBufferSequence概念，他们是由多个asio::mutable_buffer和asio::const_buffer组成的。也就是说boost::asio为了节省空间，将一部分连续的空间组合起来，作为参数交给api使用。</li><li>我们可以理解为MutableBufferSequence的数据结构为<strong>std::vector<asio::mutable_buffer></strong><br>结构如下</li></ul><p><img src="../assets/C++asio网络编程/image-1.png" alt="示例图片" style="zoom:100%;" /></p><ul><li>每个vector存储的都是mutable_buffer的地址，每个mutable_buffer的第一个字节表示数据的长度，后面跟着数据内容。</li><li>这么复杂的结构交给用户使用并不合适，所以asio提出了buffer()函数，该函数接收多种形式的字节流，该函数返回asio::mutable_buffers_1 o或者asio::const_buffers_1结构的对象。</li><li>如果传递给buffer()的参数是一个只读类型，则函数返回asio::const_buffers_1 类型对象。</li><li>如果传递给buffer()的参数是一个可写类型，则返回asio::mutable_buffers_1 类型对象。</li><li><strong>asio::const_buffers_1</strong>和<strong>asio::mutable_buffers_1</strong>是asio::mutable_buffer和asio::const_buffer的适配器，提供了符合MutableBufferSequence和ConstBufferSequence概念的接口，所以他们可以作为boost::asio的api函数的参数使用。</li><li>简单概括一下，我们可以用buffer()函数生成我们要用的缓存存储数据。<br>比如boost的发送接口send要求的参数为ConstBufferSequence类型</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ConstBufferSequence&gt;</span></span><br><span class="line"><span class="function">std::<span class="type">size_t</span> <span class="title">send</span><span class="params">(<span class="type">const</span> ConstBufferSequence &amp; buffers)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>我们需要手动转换</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟构造const_buffer的结构,这样写非常的麻烦</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_const_buffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> std::string buf = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"> boost::<span class="function">asio::const_buffer <span class="title">asio_buf</span><span class="params">(buf.c_str(), buf.length())</span></span>;</span><br><span class="line"> std::vector&lt;boost::asio::const_buffer&gt; buffers_sequence;</span><br><span class="line"> buffers_sequence.<span class="built_in">push_back</span>(asio_buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="字符串的buffer"><a href="#字符串的buffer" class="headerlink" title="字符串的buffer"></a>字符串的buffer</h4><ul><li>最终buffers_sequence就是可以传递给发送接口send的类型。但是这太复杂了，可以直接用buffer函数转化为send需要的参数类型</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 他会自动模拟上述操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_buffer_str</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> boost::asio::const_buffers_1 output_buffer = boost::asio::<span class="built_in">buffer</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>output_buf可以直接传递给该send接口。我们也可以将数组转化为send接受的类型</li></ul><h4 id="数组的buffer"><a href="#数组的buffer" class="headerlink" title="数组的buffer"></a>数组的buffer</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_buffer_array</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="type">const</span> <span class="type">size_t</span> BUF_SIZE_BYTES = <span class="number">20</span>;</span><br><span class="line"> <span class="function">std::unique_ptr&lt;<span class="type">char</span>[]&gt; <span class="title">buf</span><span class="params">(<span class="keyword">new</span> <span class="type">char</span>[BUF_SIZE_BYTES])</span></span>;</span><br><span class="line"> <span class="keyword">auto</span> input_buf = boost::asio::<span class="built_in">buffer</span>(<span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(buf.<span class="built_in">get</span>()), BUF_SIZE_BYTES);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>其中可以不强制转换为void*</li></ul><h4 id="流式的buffer"><a href="#流式的buffer" class="headerlink" title="流式的buffer"></a>流式的buffer</h4><ul><li>对于流式操作，我们可以用streambuf，将输入输出流和streambuf绑定，可以实现流式输入和输出。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_stream_buffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    boost::asio::streambuf buf;</span><br><span class="line">    <span class="function">std::ostream <span class="title">output</span><span class="params">(&amp;buf)</span></span>;</span><br><span class="line">    <span class="comment">// Writing the message to the stream-based buffer.</span></span><br><span class="line">    output &lt;&lt; <span class="string">&quot;Message1\nMessage2&quot;</span>;</span><br><span class="line">    <span class="comment">// Now we want to read all data from a streambuf</span></span><br><span class="line">    <span class="comment">// until &#x27;\n&#x27; delimiter.</span></span><br><span class="line">    <span class="comment">// Instantiate an input stream which uses our </span></span><br><span class="line">    <span class="comment">// stream buffer.</span></span><br><span class="line">    <span class="function">std::istream <span class="title">input</span><span class="params">(&amp;buf)</span></span>;</span><br><span class="line">    <span class="comment">// We&#x27;ll read data into this string.</span></span><br><span class="line">    std::string message1;</span><br><span class="line">    std::<span class="built_in">getline</span>(input, message1);</span><br><span class="line">    <span class="comment">// Now message1 string contains &#x27;Message1&#x27;.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="容器的buffer"><a href="#容器的buffer" class="headerlink" title="容器的buffer"></a>容器的buffer</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">char</span>&gt; data = &#123; <span class="comment">/* 初始化数据 */</span> &#125;;</span><br><span class="line">boost::asio::const_buffer buffer = boost::asio::<span class="built_in">buffer</span>(data);</span><br></pre></td></tr></table></figure><h4 id="指向缓冲区的指针的buffer"><a href="#指向缓冲区的指针的buffer" class="headerlink" title="指向缓冲区的指针的buffer"></a>指向缓冲区的指针的buffer</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> data[<span class="number">1024</span>];</span><br><span class="line">boost::asio::mutable_buffer buffer = boost::asio::<span class="built_in">buffer</span>(data, <span class="built_in">sizeof</span>(data));</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="同步读写"><a href="#同步读写" class="headerlink" title="同步读写"></a>同步读写</h2><h3 id="同步写-write-some"><a href="#同步写-write-some" class="headerlink" title="同步写 write_some"></a>同步写 write_some</h3><ul><li>boost::asio提供了几种同步写的api，write_some可以每次向指定的空间写入固定的字节数，如果写缓冲区满了，就只写一部分，返回写入的字节数。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_to_socket</span><span class="params">(boost::asio::ip::tcp::socket&amp; sock)</span> </span>&#123;</span><br><span class="line"> std::string buf = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line"> std::<span class="type">size_t</span> total_bytes_written = <span class="number">0</span>;</span><br><span class="line"> <span class="comment">//循环发送</span></span><br><span class="line">    <span class="comment">//write_some返回每次写入的字节数</span></span><br><span class="line">    <span class="comment">//total_bytes_written是已经发送的字节数。</span></span><br><span class="line">    <span class="comment">//每次发送buf.length()- total_bytes_written)字节数据</span></span><br><span class="line"> <span class="keyword">while</span> (total_bytes_written != buf.<span class="built_in">length</span>()) &#123;</span><br><span class="line">  total_bytes_written += sock.<span class="built_in">write_some</span>(boost::asio::<span class="built_in">buffer</span>(</span><br><span class="line">   buf.<span class="built_in">c_str</span>() + total_bytes_written, buf.<span class="built_in">length</span>() - total_bytes_written));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">send_data_by_write_some</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  std::string raw_ip_address = <span class="string">&quot;192.168.168.123&quot;</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> port_nums = <span class="number">8888</span>;</span><br><span class="line">  boost::asio::ip::<span class="function">tcp::endpoint <span class="title">ep</span><span class="params">(boost::asio::ip::address::from_string(raw_ip_address), port_nums)</span></span>;</span><br><span class="line">  boost::asio::io_context ioc;</span><br><span class="line">  boost::asio::ip::<span class="function">tcp::socket <span class="title">sock</span><span class="params">(ioc, ep.protocol())</span></span>;</span><br><span class="line">  sock.<span class="built_in">connect</span>(ep);</span><br><span class="line">  <span class="built_in">write_to_socket</span>(sock);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">catch</span> (boost::system::system_error&amp; e) &#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Error occured! Error code = &quot;</span> &lt;&lt; e.<span class="built_in">code</span>()</span><br><span class="line">   &lt;&lt; <span class="string">&quot;. Message: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="同步写-send"><a href="#同步写-send" class="headerlink" title="同步写 send"></a>同步写 send</h3><ul><li>write_some使用起来比较麻烦，需要多次调用，asio提供了send函数。send函数会一次性将buffer中的内容发送给对端，如果有部分字节因为发送缓冲区满无法发送，则阻塞等待，直到发送缓冲区可用，则继续发送完成。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">send_data_by_send</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  std::string raw_ip_address = <span class="string">&quot;192.168.168.123&quot;</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> port_nums = <span class="number">8888</span>;</span><br><span class="line">  boost::asio::ip::<span class="function">tcp::endpoint <span class="title">ep</span><span class="params">(boost::asio::ip::address::from_string(raw_ip_address), port_nums)</span></span>;</span><br><span class="line">  boost::asio::io_context ioc;</span><br><span class="line">  boost::asio::ip::<span class="function">tcp::socket <span class="title">sock</span><span class="params">(ioc, ep.protocol())</span></span>;</span><br><span class="line">  sock.<span class="built_in">connect</span>(ep);</span><br><span class="line">  std::string buf = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">  <span class="comment">// send表示发完你要发的所有数据为止才返回</span></span><br><span class="line">  <span class="comment">//三种放回值 &lt;0 表示系统级错误 =0 对端关闭</span></span><br><span class="line">  <span class="comment">// &gt;0 必为发送的长度</span></span><br><span class="line">  <span class="type">int</span> send_length = sock.<span class="built_in">send</span>(boost::asio::<span class="built_in">buffer</span>(buf.<span class="built_in">c_str</span>(), buf.<span class="built_in">length</span>());</span><br><span class="line">  </span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">catch</span> (boost::system::system_error&amp; e) &#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Error occured! Error code = &quot;</span> &lt;&lt; e.<span class="built_in">code</span>()</span><br><span class="line">   &lt;&lt; <span class="string">&quot;. Message: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="同步写-write"><a href="#同步写-write" class="headerlink" title="同步写 write"></a>同步写 write</h3><ul><li>类似send方法，asio还提供了一个write函数，可以一次性将所有数据发送给对端，如果发送缓冲区满了则阻塞，直到发送缓冲区可用，将数据发送完成。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">send_data_by_write</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  std::string raw_ip_address = <span class="string">&quot;192.168.168.123&quot;</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> port_nums = <span class="number">8888</span>;</span><br><span class="line">  boost::asio::ip::<span class="function">tcp::endpoint <span class="title">ep</span><span class="params">(boost::asio::ip::address::from_string(raw_ip_address), port_nums)</span></span>;</span><br><span class="line">  boost::asio::io_context ioc;</span><br><span class="line">  boost::asio::ip::<span class="function">tcp::socket <span class="title">sock</span><span class="params">(ioc, ep.protocol())</span></span>;</span><br><span class="line">  sock.<span class="built_in">connect</span>(ep);</span><br><span class="line">  std::string buf = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">  <span class="comment">// send表示发完你要发的所有数据为止才返回</span></span><br><span class="line">  <span class="comment">//三种放回值 &lt;0 表示系统级错误 =0 对端关闭</span></span><br><span class="line">  <span class="comment">// &gt;0 必为发送的长度</span></span><br><span class="line">  <span class="type">int</span> send_length = boost::asio::<span class="built_in">write</span>(sock, boost::asio::<span class="built_in">buffer</span>(buf.<span class="built_in">c_str</span>(), buf.<span class="built_in">length</span>());</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">catch</span> (boost::system::system_error&amp; e) &#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Error occured! Error code = &quot;</span> &lt;&lt; e.<span class="built_in">code</span>()</span><br><span class="line">   &lt;&lt; <span class="string">&quot;. Message: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="同步读-read-some"><a href="#同步读-read-some" class="headerlink" title="同步读 read_some"></a>同步读 read_some</h3><ul><li>同步读和同步写类似，提供了读取指定字节数的接口read_some</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">read_from_socket</span><span class="params">(boost::asio::ip::tcp::socket&amp; sock)</span> </span>&#123;</span><br><span class="line"> <span class="type">const</span> <span class="type">unsigned</span> <span class="type">short</span> MESSAGE_SIZE = <span class="number">7</span>;</span><br><span class="line"> <span class="type">char</span> buf[MESSAGE_SIZE];</span><br><span class="line"> std::<span class="type">size_t</span> total_bytes_read = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">while</span> (total_bytes_read != MESSAGE_SIZE) &#123;</span><br><span class="line">  total_bytes_read += sock.<span class="built_in">read_some</span>(boost::asio::<span class="built_in">buffer</span>(buf + total_bytes_read, MESSAGE_SIZE - total_bytes_read));</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> std::<span class="built_in">string</span>(buf,total_bytes_read);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_data_by_read_some</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> std::string raw_ip_address = <span class="string">&quot;192.168.168.132&quot;</span>;</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">short</span> port_num = <span class="number">888</span>;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  boost::asio::ip::<span class="function">tcp::endpoint <span class="title">ep</span><span class="params">(boost::asio::ip::address::from_string(raw_ip_address), port_num)</span></span>;</span><br><span class="line">  boost::asio::io_context ioc;</span><br><span class="line">  boost::asio::ip::<span class="function">tcp::socket <span class="title">sock</span><span class="params">(ioc, ep.protocol())</span></span>;</span><br><span class="line">  sock.<span class="built_in">connect</span>(ep);</span><br><span class="line">  <span class="built_in">read_from_socket</span>(sock);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">catch</span> (boost::system::system_error&amp; e) &#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Error occured! Error code = &quot;</span> &lt;&lt; e.<span class="built_in">code</span>()</span><br><span class="line">   &lt;&lt; <span class="string">&quot;. Message: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>();</span><br><span class="line">  <span class="comment">//return e.code().value();</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="同步读-receive"><a href="#同步读-receive" class="headerlink" title="同步读 receive"></a>同步读 receive</h3><ul><li>可以一次性同步接收对方发送的数据</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">read_data_by_receive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string raw_ip_address = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> port_num = <span class="number">3333</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        boost::asio::ip::<span class="function">tcp::endpoint</span></span><br><span class="line"><span class="function">            <span class="title">ep</span><span class="params">(boost::asio::ip::address::from_string(raw_ip_address),</span></span></span><br><span class="line"><span class="params"><span class="function">                port_num)</span></span>;</span><br><span class="line">        boost::asio::io_service ios;</span><br><span class="line">        boost::asio::ip::<span class="function">tcp::socket <span class="title">sock</span><span class="params">(ios, ep.protocol())</span></span>;</span><br><span class="line">        sock.<span class="built_in">connect</span>(ep);</span><br><span class="line">        <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> BUFF_SIZE = <span class="number">7</span>;</span><br><span class="line">         <span class="type">char</span> buffer_receive[BUFF_SIZE];</span><br><span class="line">        <span class="type">int</span> receive_length =  sock.<span class="built_in">receive</span>(boost::asio::<span class="built_in">buffer</span>(buffer_receive, BUFF_SIZE));</span><br><span class="line">        <span class="keyword">if</span> (receive_length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;receive failed&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (boost::system::system_error&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Error occured! Error code = &quot;</span> &lt;&lt; e.<span class="built_in">code</span>()</span><br><span class="line">            &lt;&lt; <span class="string">&quot;. Message: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>();</span><br><span class="line">        <span class="keyword">return</span> e.<span class="built_in">code</span>().<span class="built_in">value</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="同步读-read"><a href="#同步读-read" class="headerlink" title="同步读 read"></a>同步读 read</h3><ul><li>可以一次性同步读取对方发送的数据</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">read_data_by_read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string raw_ip_address = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> port_num = <span class="number">3333</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        asio::ip::<span class="function">tcp::endpoint</span></span><br><span class="line"><span class="function">            <span class="title">ep</span><span class="params">(asio::ip::address::from_string(raw_ip_address),</span></span></span><br><span class="line"><span class="params"><span class="function">                port_num)</span></span>;</span><br><span class="line">        asio::io_service ios;</span><br><span class="line">        asio::ip::<span class="function">tcp::socket <span class="title">sock</span><span class="params">(ios, ep.protocol())</span></span>;</span><br><span class="line">        sock.<span class="built_in">connect</span>(ep);</span><br><span class="line">        <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> BUFF_SIZE = <span class="number">7</span>;</span><br><span class="line">        <span class="type">char</span> buffer_receive[BUFF_SIZE];</span><br><span class="line">        <span class="type">int</span> receive_length = asio::<span class="built_in">read</span>(sock, asio::<span class="built_in">buffer</span>(buffer_receive, BUFF_SIZE));</span><br><span class="line">        <span class="keyword">if</span> (receive_length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;receive failed&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (system::system_error&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Error occured! Error code = &quot;</span> &lt;&lt; e.<span class="built_in">code</span>()</span><br><span class="line">            &lt;&lt; <span class="string">&quot;. Message: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>();</span><br><span class="line">        <span class="keyword">return</span> e.<span class="built_in">code</span>().<span class="built_in">value</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="读取直到指定字符"><a href="#读取直到指定字符" class="headerlink" title="读取直到指定字符"></a>读取直到指定字符</h3><ul><li>我们可以一直读取，直到读取指定字符结束</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string  <span class="title">read_data_by_until</span><span class="params">(asio::ip::tcp::socket&amp; sock)</span> </span>&#123;</span><br><span class="line">    asio::streambuf buf;</span><br><span class="line">    <span class="comment">// Synchronously read data from the socket until</span></span><br><span class="line">    <span class="comment">// &#x27;\n&#x27; symbol is encountered.  </span></span><br><span class="line">    asio::<span class="built_in">read_until</span>(sock, buf, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    std::string message;</span><br><span class="line">    <span class="comment">// Because buffer &#x27;buf&#x27; may contain some other data</span></span><br><span class="line">    <span class="comment">// after &#x27;\n&#x27; symbol, we have to parse the buffer and</span></span><br><span class="line">    <span class="comment">// extract only symbols before the delimiter. </span></span><br><span class="line">    <span class="function">std::istream <span class="title">input_stream</span><span class="params">(&amp;buf)</span></span>;</span><br><span class="line">    std::<span class="built_in">getline</span>(input_stream, message);</span><br><span class="line">    <span class="keyword">return</span> message;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="同步读写的客户端与服务端"><a href="#同步读写的客户端与服务端" class="headerlink" title="同步读写的客户端与服务端"></a>同步读写的客户端与服务端</h2><ul><li>前面我们介绍了boost::asio同步读写的api函数，现在将前面的api串联起来，做一个能跑起来的客户端和服务器。</li><li>客户端和服务器采用阻塞的同步读写方式完成通信</li></ul><h3 id="客户端的设计"><a href="#客户端的设计" class="headerlink" title="客户端的设计"></a>客户端的设计</h3><ul><li>客户端设计基本思路是根据服务器对端的ip和端口创建一个endpoint，然后创建socket连接这个endpoint，之后就可以用同步读写的方式发送和接收数据了。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::asio::ip;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MAX_LENGTH = <span class="number">1024</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//创建上下文</span></span><br><span class="line">        boost::asio::io_context ioc;</span><br><span class="line">        <span class="comment">//构造终端端点</span></span><br><span class="line">        <span class="function">tcp::endpoint <span class="title">ep</span><span class="params">(address::from_string(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="number">8888</span>)</span></span>;</span><br><span class="line">        <span class="comment">//创建socket</span></span><br><span class="line">        <span class="function">tcp::socket <span class="title">sock</span><span class="params">(ioc, ep.protocol())</span></span>;</span><br><span class="line">        <span class="comment">//声明错误</span></span><br><span class="line">        boost::system::error_code error = boost::asio::error::host_not_found;</span><br><span class="line">        <span class="comment">//建立连接</span></span><br><span class="line">        sock.<span class="built_in">connect</span>(ep, error);</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;connect failed, code is&quot;</span></span><br><span class="line">                &lt;&lt; error.<span class="built_in">value</span>() &lt;&lt; <span class="string">&quot;message is &quot;</span> &lt;&lt; error.<span class="built_in">message</span>() &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Enter message: &quot;</span>;</span><br><span class="line">        <span class="type">char</span> request[MAX_LENGTH];</span><br><span class="line">        std::cin.<span class="built_in">getline</span>(request, MAX_LENGTH);</span><br><span class="line">        <span class="type">size_t</span> request_length = std::<span class="built_in">strlen</span>(request);</span><br><span class="line">        boost::asio::<span class="built_in">write</span>(sock, boost::asio::<span class="built_in">buffer</span>(request, request_length));</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> reply[MAX_LENGTH];</span><br><span class="line">        <span class="type">size_t</span> reply_length = boost::asio::<span class="built_in">read</span>(sock, boost::asio::<span class="built_in">buffer</span>(reply, request_length));</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;reply is &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout.<span class="built_in">write</span>(reply, reply_length);</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Exception&quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务端设计"><a href="#服务端设计" class="headerlink" title="服务端设计"></a>服务端设计</h3><h4 id="session函数"><a href="#session函数" class="headerlink" title="session函数"></a>session函数</h4><ul><li>创建session函数，该函数为服务器处理客户端请求，每当我们获取客户端连接后就调用该函数。在session函数里里进行echo方式的读写，所谓echo就是应答式的处理</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">session</span><span class="params">(socket_ptr sock)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">   <span class="type">char</span> data[max_length];</span><br><span class="line">   <span class="built_in">memset</span>(data, <span class="string">&#x27;\0&#x27;</span>, max_length);</span><br><span class="line">   boost::system::error_code error;</span><br><span class="line">   <span class="comment">//size_t length = boost::asio::read(sock, boost::asio::buffer(data, max_length), error);</span></span><br><span class="line">   <span class="type">size_t</span> length = sock-&gt;<span class="built_in">read_some</span>(boost::asio::<span class="built_in">buffer</span>(data, max_length), error);</span><br><span class="line">   <span class="keyword">if</span> (error == boost::asio::error::eof) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;connection closed by peer&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (error) &#123;</span><br><span class="line">    <span class="keyword">throw</span> boost::system::<span class="built_in">system_error</span>(error);</span><br><span class="line">   &#125;</span><br><span class="line">   std::cout &lt;&lt; <span class="string">&quot;receive from &quot;</span> &lt;&lt; sock-&gt;<span class="built_in">remote_endpoint</span>().<span class="built_in">address</span>().<span class="built_in">to_string</span>() &lt;&lt; std::endl;</span><br><span class="line">   std::cout &lt;&lt; <span class="string">&quot;receive message is &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">   <span class="comment">//回传给对方</span></span><br><span class="line">   boost::asio::<span class="built_in">write</span>(*sock, boost::asio::<span class="built_in">buffer</span>(data, length));</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">  std::cerr &lt;&lt; <span class="string">&quot;Exception in thread: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="server函数"><a href="#server函数" class="headerlink" title="server函数"></a>server函数</h4><ul><li>server函数根据服务器ip和端口创建服务器acceptor用来接收数据，用socket接收新的连接，然后为这个socket创建session。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">server</span><span class="params">(boost::asio::io_context&amp; io_context, <span class="type">unsigned</span> <span class="type">short</span> port)</span> </span>&#123;</span><br><span class="line"> <span class="comment">// boost::asio::ip::address_v4::any()第一个参数与这个效果一样</span></span><br><span class="line"> <span class="function">tcp::endpoint <span class="title">ep</span><span class="params">(tcp::v4(), port)</span></span>;</span><br><span class="line"> <span class="function">tcp::acceptor <span class="title">a</span><span class="params">(io_context, ep)</span></span>;</span><br><span class="line"> <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="function">socket_ptr <span class="title">sock</span><span class="params">(<span class="keyword">new</span> tcp::socket(io_context))</span></span>;</span><br><span class="line">  a.<span class="built_in">accept</span>(*sock);</span><br><span class="line">  <span class="keyword">auto</span> t = std::<span class="built_in">make_shared</span>&lt;std::thread&gt;(session, sock);</span><br><span class="line">  thread_set.<span class="built_in">insert</span>(t);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>创建线程调用session函数可以分配独立的线程用于socket的读写，保证acceptor不会因为socket的读写而阻塞。</li></ul><h4 id="完整服务端代码"><a href="#完整服务端代码" class="headerlink" title="完整服务端代码"></a>完整服务端代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::asio::ip;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> max_length = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::shared_ptr&lt;tcp::socket&gt; socket_ptr;</span><br><span class="line">std::set&lt;std::shared_ptr&lt;std::thread&gt;&gt; thread_set;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">session</span><span class="params">(socket_ptr sock)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">   <span class="type">char</span> data[max_length];</span><br><span class="line">   <span class="built_in">memset</span>(data, <span class="string">&#x27;\0&#x27;</span>, max_length);</span><br><span class="line">   boost::system::error_code error;</span><br><span class="line">   <span class="comment">//size_t length = boost::asio::read(sock, boost::asio::buffer(data, max_length), error);</span></span><br><span class="line">   <span class="type">size_t</span> length = sock-&gt;<span class="built_in">read_some</span>(boost::asio::<span class="built_in">buffer</span>(data, max_length), error);</span><br><span class="line">   <span class="keyword">if</span> (error == boost::asio::error::eof) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;connection closed by peer&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (error) &#123;</span><br><span class="line">    <span class="keyword">throw</span> boost::system::<span class="built_in">system_error</span>(error);</span><br><span class="line">   &#125;</span><br><span class="line">   std::cout &lt;&lt; <span class="string">&quot;receive from &quot;</span> &lt;&lt; sock-&gt;<span class="built_in">remote_endpoint</span>().<span class="built_in">address</span>().<span class="built_in">to_string</span>() &lt;&lt; std::endl;</span><br><span class="line">   std::cout &lt;&lt; <span class="string">&quot;receive message is &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">   <span class="comment">//回传给对方</span></span><br><span class="line">   boost::asio::<span class="built_in">write</span>(*sock, boost::asio::<span class="built_in">buffer</span>(data, length));</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">  std::cerr &lt;&lt; <span class="string">&quot;Exception in thread: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">server</span><span class="params">(boost::asio::io_context&amp; io_context, <span class="type">unsigned</span> <span class="type">short</span> port)</span> </span>&#123;</span><br><span class="line"> <span class="comment">// boost::asio::ip::address_v4::any()第一个参数与这个效果一样</span></span><br><span class="line"> <span class="function">tcp::endpoint <span class="title">ep</span><span class="params">(tcp::v4(), port)</span></span>;</span><br><span class="line"> <span class="function">tcp::acceptor <span class="title">a</span><span class="params">(io_context, ep)</span></span>;</span><br><span class="line"> <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="function">socket_ptr <span class="title">sock</span><span class="params">(<span class="keyword">new</span> tcp::socket(io_context))</span></span>;</span><br><span class="line">  a.<span class="built_in">accept</span>(*sock);</span><br><span class="line">  <span class="keyword">auto</span> t = std::<span class="built_in">make_shared</span>&lt;std::thread&gt;(session, sock);</span><br><span class="line">  thread_set.<span class="built_in">insert</span>(t);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  boost::asio::io_context ioc;</span><br><span class="line">  <span class="built_in">server</span>(ioc, <span class="number">8888</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; td : thread_set) &#123;</span><br><span class="line">   <span class="keyword">if</span> (td-&gt;<span class="built_in">joinable</span>()) &#123;</span><br><span class="line">    td-&gt;<span class="built_in">join</span>();</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="同步读写的优劣"><a href="#同步读写的优劣" class="headerlink" title="同步读写的优劣"></a>同步读写的优劣</h3><ol><li>同步读写的缺陷在于读写是阻塞的，如果客户端对端不发送数据服务器的read操作是阻塞的，这将导致服务器处于阻塞等待状态。</li><li>可以通过开辟新的线程为新生成的连接处理读写，但是一个进程开辟的线程是有限的，约为2048个线程，在Linux环境可以通过unlimit增加一个进程开辟的线程数，但是线程过多也会导致切换消耗的时间片较多。</li><li>该服务器和客户端为应答式，实际场景为全双工通信模式，发送和接收要独立分开。</li><li>该服务器和客户端未考虑粘包处理。</li></ol><ul><li>综上所述，是我们这个服务器和客户端存在的问题，为解决上述问题，我们在接下里的文章里做不断完善和改进，主要以异步读写改进上述方案。<br>当然同步读写的方式也有其优点，比如客户端连接数不多，而且服务器并发性不高的场景，可以使用同步读写的方式。使用同步读写能简化编码难度。</li></ul><h2 id="asio异步读写操作及注意事项"><a href="#asio异步读写操作及注意事项" class="headerlink" title="asio异步读写操作及注意事项"></a>asio异步读写操作及注意事项</h2><ul><li>我们定义一个session类，这个session类表示服务器处理客户端连接的管理类</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Session</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">Session</span>(std::shared_ptr&lt;boost::asio::ip::tcp::socket&gt; socket);</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">Connect</span><span class="params">(<span class="type">const</span> boost::asio::ip::tcp::endpoint&amp; ep)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> std::shared_ptr&lt;boost::asio::ip::tcp::socket&gt; sock;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Session.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Session::<span class="built_in">Session</span>(std::shared_ptr&lt;boost::asio::ip::tcp::socket&gt; socket): <span class="built_in">sock</span>(socket)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::Connect</span><span class="params">(<span class="type">const</span> boost::asio::ip::tcp::endpoint&amp; ep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> sock-&gt;<span class="built_in">connect</span>(ep);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="异步写操作"><a href="#异步写操作" class="headerlink" title="异步写操作"></a>异步写操作</h3><ul><li>在写操作前，我们先封装一个Node结构，用来管理要发送和接收的数据，该结构包含数据域首地址，数据的总长度，以及已经处理的长度(已读的长度或者已写的长度)</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MsgNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//用来构造写节点</span></span><br><span class="line"> <span class="built_in">MsgNode</span>(<span class="type">const</span> <span class="type">char</span>* msg, <span class="type">int</span> total_len) : _total_len(total_len), _cur_len(<span class="number">0</span>) &#123;</span><br><span class="line">  _msg = <span class="keyword">new</span> <span class="type">char</span>[total_len];</span><br><span class="line">  <span class="built_in">memcpy</span>(_msg, msg, total_len);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用来构造读节点</span></span><br><span class="line"> <span class="built_in">MsgNode</span>(<span class="type">int</span> total_len) :_total_len(total_len), _cur_len(<span class="number">0</span>) &#123;</span><br><span class="line">  _msg = <span class="keyword">new</span> <span class="type">char</span>[total_len];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> ~<span class="built_in">MsgNode</span>() &#123;</span><br><span class="line">  <span class="keyword">delete</span>[] _msg;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要发送的总长度</span></span><br><span class="line"><span class="type">int</span> _total_len;</span><br><span class="line"><span class="comment">// 当前已经发送了多少长度</span></span><br><span class="line"><span class="type">int</span> _cur_len;</span><br><span class="line"><span class="comment">// 指向数据的指针</span></span><br><span class="line"><span class="type">char</span>* _msg;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>写了两个构造函数，两个参数的负责构造写节点，一个参数的负责构造读节点。</p></li><li><p>接下来为Session添加异步写操作和负责发送写数据的节点</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Session</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">Session</span>(std::shared_ptr&lt;boost::asio::ip::tcp::socket&gt; socket);</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">Connect</span><span class="params">(<span class="type">const</span> boost::asio::ip::tcp::endpoint&amp; ep)</span></span>;</span><br><span class="line"><span class="comment">//第一个参数错误码，第二个参数当前准备发送的长度，第三个参数为占位符用来增加引用</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">WriteCallBackErr</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec, std::<span class="type">size_t</span> bytes_transferred, </span></span></span><br><span class="line"><span class="params"><span class="function">  std::shared_ptr&lt;MsgNode&gt;)</span></span>;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">WriteToSocketErr</span><span class="params">(<span class="type">const</span> std::string buf)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> std::shared_ptr&lt;boost::asio::ip::tcp::socket&gt; sock;</span><br><span class="line"> std::shared_ptr&lt;MsgNode&gt; _send_node;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>WriteToSocketErr函数为我们封装的写操作，WriteCallBackErr为异步写操作回调的函数，为什么会有三个参数呢，</li><li>我们可以看一下asio源码</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BOOST_ASIO_COMPLETION_TOKEN_FOR</span>(<span class="built_in">void</span> (boost::system::error_code,</span><br><span class="line">        std::<span class="type">size_t</span>)) <span class="function">WriteToken</span></span><br><span class="line"><span class="function">          <span class="title">BOOST_ASIO_DEFAULT_COMPLETION_TOKEN_TYPE</span><span class="params">(executor_type)</span>&gt;</span></span><br><span class="line"><span class="function">  <span class="title">BOOST_ASIO_INITFN_AUTO_RESULT_TYPE_PREFIX</span><span class="params">(WriteToken,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">void</span> (boost::system::error_code, std::<span class="type">size_t</span>))</span></span></span><br><span class="line"><span class="function">  <span class="title">async_write_some</span><span class="params">(<span class="type">const</span> ConstBufferSequence&amp; buffers,</span></span></span><br><span class="line"><span class="params"><span class="function">      BOOST_ASIO_MOVE_ARG(WriteToken)token</span></span></span><br><span class="line"><span class="params"><span class="function">        BOOST_ASIO_DEFAULT_COMPLETION_TOKEN(executor_type))</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure><ul><li>sync_write_some是异步写的函数，这个异步写函数有两个参数，第一个参数为ConstBufferSequence常引用类型的buffers，</li><li>第二个参数为WriteToken类型，而WriteToken在上面定义了，是一个函数对象类型，返回值为void，参数为error_code和size_t，</li><li>所以我们为了调用async_write_some函数也要传入一个符合WriteToken定义的函数，就是我们声明的WriteCallBackErr函数，</li><li><p>前两个参数为WriteToken规定的参数，第三个参数为MsgNode的智能指针，这样通过智能指针保证我们发送的Node生命周期延长。</p></li><li><p>我们看一下WriteToSocketErr函数的具体实现</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::WriteToSocketErr</span><span class="params">(<span class="type">const</span> std::string buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">//定义你要写的数据节点</span></span><br><span class="line"> _send_node = std::<span class="built_in">make_shared</span>&lt;MsgNode&gt;(buf.<span class="built_in">c_str</span>(), buf.<span class="built_in">length</span>());</span><br><span class="line"> <span class="comment">//通过socket官方异步写发送数据</span></span><br><span class="line"> <span class="keyword">this</span>-&gt;sock-&gt;<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_send_node-&gt;_msg, _send_node-&gt;_total_len),</span><br><span class="line">  std::<span class="built_in">bind</span>(&amp;Session::WriteCallBackErr, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2,</span><br><span class="line">   _send_node));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>因为WriteCallBackErr函数为三个参数且为成员函数，而async_write_some需要的回调函数为两个参数，所以我们通过bind将三个参数转换为两个参数的普通函数。</p></li><li><p>我们看看回调函数的实现</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::WriteCallBackErr</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec, std::<span class="type">size_t</span> bytes_transferred, std::shared_ptr&lt;MsgNode&gt; msg_node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">//当前要转发的数据加上已经转发的数据 与 发送总数据做比较</span></span><br><span class="line"> <span class="keyword">if</span> (bytes_transferred + msg_node-&gt;_cur_len &lt; msg_node-&gt;_total_len) &#123;</span><br><span class="line">  <span class="comment">//更新当前已发送的数据</span></span><br><span class="line">  _send_node-&gt;_cur_len += bytes_transferred;</span><br><span class="line">  <span class="comment">// 递归调用继续发送未发送玩的数据</span></span><br><span class="line">  <span class="keyword">this</span>-&gt;sock-&gt;<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_send_node-&gt;_msg</span><br><span class="line">   + _send_node-&gt;_cur_len, _send_node-&gt;_total_len - _send_node-&gt;_cur_len),</span><br><span class="line">   std::<span class="built_in">bind</span>(&amp;Session::WriteCallBackErr, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2,</span><br><span class="line">    _send_node));</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在WriteCallBackErr函数里判断如果已经发送的字节数没有达到要发送的总字节数，那么就更新节点已经发送的长度，然后计算剩余要发送的长度，如果有数据未发送完，再次调用async_write_some函数异步发送。</li><li><strong>但是这个函数并不能投入实际应用，因为async_write_some回调函数返回已发送的字节数可能并不是全部长度。比如TCP发送缓存区总大小为8字节，但是有3字节未发送(上一次未发送完)，这样剩余空间为5字节</strong></li></ul><p><img src="../assets/C++asio网络编程/image-2.png" alt="示例图片" style="zoom:100%;" /></p><ul><li>此时我们调用async_write_some发送hello world!实际发送的长度就是为5，也就是只发送了hello，剩余world!通过我们的回调继续发送。</li><li><p>而实际开发的场景用户是不清楚底层tcp的多路复用调用情况的，用户想发送数据的时候就调用WriteToSocketErr,或者循环调用WriteToSocketErr，<strong>很可能在一次没发送完数据还未调用回调函数时再次调用WriteToSocketErr</strong>，因为boost::asio封装的是epoll和iocp等多路复用模型，当写事件就绪后就发数据，发送的数据按照async_write_some调用的顺序发送，所以回调函数内调用的async_write_some可能并没有被及时调用。</p></li><li><p>比如如下代码：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用户发送数据</span></span><br><span class="line"><span class="built_in">WriteToSocketErr</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line"><span class="comment">//用户无感知下层调用情况又一次发送了数据</span></span><br><span class="line"><span class="built_in">WriteToSocketErr</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>那么很可能第一次只发送了Hello，后面的数据没发完，第二次发送了Hello World!之后又发送了World!</li><li><p>所以对端收到的数据很可能是”HelloHello World! World!”</p></li><li><p>那怎么解决这个问题呢，<strong>我们可以通过队列保证应用层的发送顺序</strong>。我们在Session中定义一个发送队列，然后重新定义正确的异步发送函数和回调处理</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Session</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">Session</span>(std::shared_ptr&lt;boost::asio::ip::tcp::socket&gt; socket);</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">Connect</span><span class="params">(<span class="type">const</span> boost::asio::ip::tcp::endpoint&amp; ep)</span></span>;</span><br><span class="line"> <span class="comment">//第一个参数错误码，第二个参数当前准备发送的长度，第三个参数为占位符用来增加引用</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">WriteCallBackErr</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec, std::<span class="type">size_t</span> bytes_transferred, </span></span></span><br><span class="line"><span class="params"><span class="function">  std::shared_ptr&lt;MsgNode&gt; msg_node)</span></span>;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">WriteToSocketErr</span><span class="params">(<span class="type">const</span> std::string buf)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//正确的处理方式</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">WriteCallBack</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec, std::<span class="type">size_t</span> bytes_transferred)</span></span>;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">WriteToSocket</span><span class="params">(<span class="type">const</span> std::string buf)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="comment">//用来装要发送的数据</span></span><br><span class="line"> std::queue&lt;std::shared_ptr&lt;MsgNode&gt;&gt; _send_queue;</span><br><span class="line"> std::shared_ptr&lt;boost::asio::ip::tcp::socket&gt; sock;</span><br><span class="line"> std::shared_ptr&lt;MsgNode&gt; _send_node;</span><br><span class="line"> <span class="comment">//标记是否有数据未发送完</span></span><br><span class="line"> <span class="type">bool</span> _send_pending;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>定义了bool变量_send_pending，该变量为true表示一个节点还未发送完。</li><li><p>_send_queue用来缓存要发送的消息节点，是一个队列。</p></li><li><p>我们实现异步发送功能</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::WriteCallBack</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec, std::<span class="type">size_t</span> bytes_transferred)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (ec.<span class="built_in">value</span>() != <span class="number">0</span>) &#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Error , code is &quot;</span> &lt;&lt; ec.<span class="built_in">value</span>() &lt;&lt; <span class="string">&quot; . Message is &quot;</span> &lt;&lt; ec.<span class="built_in">message</span>();</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//取出队首元素即当前未发送完数据</span></span><br><span class="line"> <span class="keyword">auto</span>&amp; send_data = _send_queue.<span class="built_in">front</span>();</span><br><span class="line"> send_data-&gt;_cur_len += bytes_transferred;</span><br><span class="line"> <span class="comment">//数据未发送完， 则继续发送</span></span><br><span class="line"> <span class="keyword">if</span> (send_data-&gt;_cur_len &lt; send_data-&gt;_total_len) &#123;</span><br><span class="line">  <span class="keyword">this</span>-&gt;sock-&gt;<span class="built_in">async_write_some</span>(boost::asio::<span class="built_in">buffer</span>(send_data-&gt;_msg + send_data-&gt;_cur_len, send_data-&gt;_total_len - send_data-&gt;_cur_len),</span><br><span class="line">   std::<span class="built_in">bind</span>(&amp;Session::WriteCallBack,</span><br><span class="line">    <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2));</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//如果发送完，则pop出队首元素</span></span><br><span class="line"> _send_queue.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line"> <span class="comment">//如果队列为空，则说明所有数据都发送完,将pending设置为false</span></span><br><span class="line"> <span class="keyword">if</span> (_send_queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">  _send_pending = <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//如果队列不是空，则继续将队首元素发送</span></span><br><span class="line"> <span class="keyword">if</span> (!_send_queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">  <span class="keyword">auto</span>&amp; send_data = _send_queue.<span class="built_in">front</span>();</span><br><span class="line">  <span class="keyword">this</span>-&gt;sock-&gt;<span class="built_in">async_write_some</span>(boost::asio::<span class="built_in">buffer</span>(send_data-&gt;_msg + send_data-&gt;_cur_len, send_data-&gt;_total_len - send_data-&gt;_cur_len),</span><br><span class="line">   std::<span class="built_in">bind</span>(&amp;Session::WriteCallBack,</span><br><span class="line">    <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2));</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::WriteToSocket</span><span class="params">(<span class="type">const</span> std::string buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">//将数据放入队列中</span></span><br><span class="line"> _send_queue.<span class="built_in">emplace</span>(<span class="keyword">new</span> <span class="built_in">MsgNode</span>(buf.<span class="built_in">c_str</span>(), buf.<span class="built_in">length</span>()));</span><br><span class="line"> <span class="comment">//如果还有数据未发送完，直接返回</span></span><br><span class="line"> <span class="keyword">if</span> (_send_pending) &#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//异步发送数据，因为异步所以不会一下发送完</span></span><br><span class="line"> <span class="keyword">this</span>-&gt;sock-&gt;<span class="built_in">async_write_some</span>(boost::asio::<span class="built_in">buffer</span>(buf), std::<span class="built_in">bind</span>(&amp;Session::WriteCallBack, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2));</span><br><span class="line"> _send_pending = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>async_write_some函数不能保证每次回调函数触发时发送的长度为要总长度，这样我们每次都要在回调函数判断发送数据是否完成，asio提供了一个更简单的发送函数<strong>async_send</strong>，这个函数在发送的长度<strong>未达到我们要求的长度时就不会触发回调</strong>，所以触发回调函数时要么时<strong>发送出错了</strong>要么是<strong>发送完成</strong>了,其<strong>内部的实现原理</strong>就是帮我们<strong>不断的调用async_write_some直到完成发送</strong>，所以<strong>async_send不能和async_write_some混合使用</strong>，我们基于async_send封装另外一个发送函数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个回调函数被调用并且没有异常肯定是发完了一个数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::WriteAllCallBack</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec, std::<span class="type">size_t</span> bytes_transferred)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (ec.<span class="built_in">value</span>() != <span class="number">0</span>) &#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Error occured! Error code = &quot;</span></span><br><span class="line">   &lt;&lt; ec.<span class="built_in">value</span>()</span><br><span class="line">   &lt;&lt; <span class="string">&quot;. Message: &quot;</span> &lt;&lt; ec.<span class="built_in">message</span>();</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//如果发送完，则pop出队首元素</span></span><br><span class="line"> _send_queue.<span class="built_in">pop</span>();</span><br><span class="line"> <span class="comment">//如果队列为空，则说明所有数据都发送完,将pending设置为false</span></span><br><span class="line"> <span class="keyword">if</span> (_send_queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">  _send_pending = <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//如果队列不是空，则继续将队首元素发送</span></span><br><span class="line"> <span class="keyword">if</span> (!_send_queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">  <span class="keyword">auto</span>&amp; send_data = _send_queue.<span class="built_in">front</span>();</span><br><span class="line">        <span class="comment">//send的时候由于使用的是async_send所以这可以不使用数据偏移，而直接发送buf，boost::asio::buffer(buf)</span></span><br><span class="line">  <span class="keyword">this</span>-&gt;sock-&gt;<span class="built_in">async_send</span>(boost::asio::<span class="built_in">buffer</span>(send_data-&gt;_msg + send_data-&gt;_cur_len, send_data-&gt;_total_len - send_data-&gt;_cur_len),</span><br><span class="line">   std::<span class="built_in">bind</span>(&amp;Session::WriteAllCallBack,</span><br><span class="line">    <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2));</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不能与async_write_some混合使用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::WriteAllToSocket</span><span class="params">(<span class="type">const</span> std::string buf)</span> </span>&#123;</span><br><span class="line"> <span class="comment">//插入发送队列</span></span><br><span class="line"> _send_queue.<span class="built_in">emplace</span>(<span class="keyword">new</span> <span class="built_in">MsgNode</span>(buf.<span class="built_in">c_str</span>(), buf.<span class="built_in">length</span>()));</span><br><span class="line"> <span class="comment">//pending状态说明上一次有未发送完的数据</span></span><br><span class="line"> <span class="keyword">if</span> (_send_pending) &#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//异步发送数据，因为异步所以不会一下发送完</span></span><br><span class="line"> <span class="keyword">this</span>-&gt;sock-&gt;<span class="built_in">async_send</span>(boost::asio::<span class="built_in">buffer</span>(buf),</span><br><span class="line">  std::<span class="built_in">bind</span>(&amp;Session::WriteAllCallBack, <span class="keyword">this</span>,</span><br><span class="line">   std::placeholders::_1, std::placeholders::_2));</span><br><span class="line"> _send_pending = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异步读操作"><a href="#异步读操作" class="headerlink" title="异步读操作"></a>异步读操作</h3><ul><li><p>接下来介绍异步读操作，异步读操作和异步的写操作类似同样又async_read_some和async_receive函数，前者触发的回调函数获取的读数据的长度可能会小于要求读取的总长度，后者触发的回调函数读取的数据长度等于读取的总长度。</p></li><li><p>先基于async_read_some封装一个读取的函数ReadFromSocket，同样在Session类的声明中添加一些变量</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::ReadFromSocket</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (_recv_pending) &#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//可以调用构造函数直接构造，但不可用已经构造好的智能指针赋值</span></span><br><span class="line"> <span class="comment">/*auto _recv_nodez = std::make_unique&lt;MsgNode&gt;(RECVSIZE);</span></span><br><span class="line"><span class="comment"> _recv_node = _recv_nodez;*/</span></span><br><span class="line"> _recv_node = std::<span class="built_in">make_shared</span>&lt;MsgNode&gt;(RECVSIZE);</span><br><span class="line">    <span class="comment">//发送要读的数据</span></span><br><span class="line"> sock-&gt;<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_recv_node-&gt;_msg, _recv_node-&gt;_total_len), std::<span class="built_in">bind</span>(&amp;Session::ReadCallBack, <span class="keyword">this</span>,</span><br><span class="line">  std::placeholders::_1, std::placeholders::_2));</span><br><span class="line"> _recv_pending = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::ReadCallBack</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec, std::<span class="type">size_t</span> bytes_transferred)</span> </span>&#123;</span><br><span class="line"> _recv_node-&gt;_cur_len += bytes_transferred;</span><br><span class="line"> <span class="comment">//没读完继续读</span></span><br><span class="line"> <span class="keyword">if</span> (_recv_node-&gt;_cur_len &lt; _recv_node-&gt;_total_len) &#123;</span><br><span class="line">        <span class="comment">//要加上数据的偏移</span></span><br><span class="line">  sock-&gt;<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_recv_node-&gt;_msg + _recv_node-&gt;_cur_len,</span><br><span class="line">   _recv_node-&gt;_total_len - _recv_node-&gt;_cur_len), std::<span class="built_in">bind</span>(&amp;Session::ReadCallBack, <span class="keyword">this</span>,</span><br><span class="line">    std::placeholders::_1, std::placeholders::_2));</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//将数据投递到队列里交给逻辑线程处理，此处略去</span></span><br><span class="line"> <span class="comment">//如果读完了则将标记置为false</span></span><br><span class="line"> _recv_pending = <span class="literal">false</span>;</span><br><span class="line"> <span class="comment">//指针置空</span></span><br><span class="line"> _recv_node = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>我们基于async_receive再封装一个接收数据的函数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::ReadAllFromSocket</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (_recv_pending) &#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//可以调用构造函数直接构造，但不可用已经构造好的智能指针赋值</span></span><br><span class="line"> <span class="comment">/*auto _recv_nodez = std::make_unique&lt;MsgNode&gt;(RECVSIZE);</span></span><br><span class="line"><span class="comment"> _recv_node = _recv_nodez;*/</span></span><br><span class="line"> _recv_node = std::<span class="built_in">make_shared</span>&lt;MsgNode&gt;(RECVSIZE);</span><br><span class="line"> sock-&gt;<span class="built_in">async_receive</span>(boost::asio::<span class="built_in">buffer</span>(_recv_node-&gt;_msg, _recv_node-&gt;_total_len), std::<span class="built_in">bind</span>(&amp;Session::ReadAllCallBack, <span class="keyword">this</span>,</span><br><span class="line">  std::placeholders::_1, std::placeholders::_2));</span><br><span class="line"> _recv_pending = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::ReadAllCallBack</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec, std::<span class="type">size_t</span> bytes_transferred)</span> </span>&#123;</span><br><span class="line"> _recv_node-&gt;_cur_len += bytes_transferred;</span><br><span class="line"> <span class="comment">//将数据投递到队列里交给逻辑线程处理，此处略去</span></span><br><span class="line"> <span class="comment">//如果读完了则将标记置为false</span></span><br><span class="line"> _recv_pending = <span class="literal">false</span>;</span><br><span class="line"> <span class="comment">//指针置空</span></span><br><span class="line"> _recv_node = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-完整代码"><a href="#总结-完整代码" class="headerlink" title="总结 完整代码"></a>总结 完整代码</h3><h4 id="Session-h头文件"><a href="#Session-h头文件" class="headerlink" title="Session.h头文件"></a>Session.h头文件</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="comment">//最大报文接收大小</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> RECVSIZE = <span class="number">1024</span>; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MsgNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">MsgNode</span>(<span class="type">const</span> <span class="type">char</span>* msg, <span class="type">int</span> total_len) : _total_len(total_len), _cur_len(<span class="number">0</span>) &#123;</span><br><span class="line">  _msg = <span class="keyword">new</span> <span class="type">char</span>[total_len];</span><br><span class="line">  <span class="built_in">memcpy</span>(_msg, msg, total_len);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">MsgNode</span>(<span class="type">int</span> total_len) :_total_len(total_len), _cur_len(<span class="number">0</span>) &#123;</span><br><span class="line">  _msg = <span class="keyword">new</span> <span class="type">char</span>[total_len];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> ~<span class="built_in">MsgNode</span>() &#123;</span><br><span class="line">  <span class="keyword">delete</span>[] _msg;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 要发送的总长度</span></span><br><span class="line"> <span class="type">int</span> _total_len;</span><br><span class="line"> <span class="comment">// 当前发送了多少长度</span></span><br><span class="line"> <span class="type">int</span> _cur_len;</span><br><span class="line"> <span class="comment">// 指向数据的指针</span></span><br><span class="line"> <span class="type">char</span>* _msg;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Session</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">Session</span>(std::shared_ptr&lt;boost::asio::ip::tcp::socket&gt; socket);</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">Connect</span><span class="params">(<span class="type">const</span> boost::asio::ip::tcp::endpoint&amp; ep)</span></span>;</span><br><span class="line"> <span class="comment">//第一个参数错误码，第二个参数当前准备发送的长度，第三个参数为占位符用来增加引用</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">WriteCallBackErr</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec, std::<span class="type">size_t</span> bytes_transferred, </span></span></span><br><span class="line"><span class="params"><span class="function">  std::shared_ptr&lt;MsgNode&gt; msg_node)</span></span>;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">WriteToSocketErr</span><span class="params">(<span class="type">const</span> std::string buf)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//正确的处理方式</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">WriteCallBack</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec, std::<span class="type">size_t</span> bytes_transferred)</span></span>;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">WriteToSocket</span><span class="params">(<span class="type">const</span> std::string buf)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">WriteAllCallBack</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec, std::<span class="type">size_t</span> bytes_transferred)</span></span>;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">WriteAllToSocket</span><span class="params">(<span class="type">const</span> std::string buf)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">ReadFromSocket</span><span class="params">()</span></span>;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">ReadCallBack</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec, std::<span class="type">size_t</span> bytes_transferred)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">ReadAllFromSocket</span><span class="params">()</span></span>;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">ReadAllCallBack</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec, std::<span class="type">size_t</span> bytes_transferred)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="comment">//用来装要发送的数据</span></span><br><span class="line"> std::queue&lt;std::shared_ptr&lt;MsgNode&gt;&gt; _send_queue;</span><br><span class="line"> std::shared_ptr&lt;boost::asio::ip::tcp::socket&gt; sock;</span><br><span class="line"> std::shared_ptr&lt;MsgNode&gt; _send_node;</span><br><span class="line"> <span class="comment">//标记是否有数据未发送完</span></span><br><span class="line"> <span class="type">bool</span> _send_pending;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//读取节点</span></span><br><span class="line"> std::shared_ptr&lt;MsgNode&gt; _recv_node;</span><br><span class="line"> <span class="comment">//标记数据是否接收完全</span></span><br><span class="line"> <span class="type">bool</span> _recv_pending;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Session-cpp"><a href="#Session-cpp" class="headerlink" title="Session.cpp"></a>Session.cpp</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Session.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Session::<span class="built_in">Session</span>(std::shared_ptr&lt;boost::asio::ip::tcp::socket&gt; socket): <span class="built_in">sock</span>(socket), _send_pending(<span class="literal">false</span>),_recv_pending(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::Connect</span><span class="params">(<span class="type">const</span> boost::asio::ip::tcp::endpoint&amp; ep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> sock-&gt;<span class="built_in">connect</span>(ep);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::WriteCallBackErr</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec, std::<span class="type">size_t</span> bytes_transferred, std::shared_ptr&lt;MsgNode&gt; msg_node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">//当前要转发的数据加上已经转发的数据 与 发送总数据做比较</span></span><br><span class="line"> <span class="keyword">if</span> (bytes_transferred + msg_node-&gt;_cur_len &lt; msg_node-&gt;_total_len) &#123;</span><br><span class="line">  <span class="comment">//更新当前已发送的数据</span></span><br><span class="line">  _send_node-&gt;_cur_len += bytes_transferred;</span><br><span class="line">  <span class="comment">// 递归调用继续发送未发送玩的数据</span></span><br><span class="line">  <span class="keyword">this</span>-&gt;sock-&gt;<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_send_node-&gt;_msg</span><br><span class="line">   + _send_node-&gt;_cur_len, _send_node-&gt;_total_len - _send_node-&gt;_cur_len),</span><br><span class="line">   std::<span class="built_in">bind</span>(&amp;Session::WriteCallBackErr, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2,</span><br><span class="line">    _send_node));</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::WriteToSocketErr</span><span class="params">(<span class="type">const</span> std::string buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">//定义你要写的数据节点</span></span><br><span class="line"> _send_node = std::<span class="built_in">make_shared</span>&lt;MsgNode&gt;(buf.<span class="built_in">c_str</span>(), buf.<span class="built_in">length</span>());</span><br><span class="line"> <span class="comment">//通过socket官方异步写发送数据</span></span><br><span class="line"> <span class="keyword">this</span>-&gt;sock-&gt;<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_send_node-&gt;_msg, _send_node-&gt;_total_len),</span><br><span class="line">  std::<span class="built_in">bind</span>(&amp;Session::WriteCallBackErr, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2,</span><br><span class="line">   _send_node));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::WriteCallBack</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec, std::<span class="type">size_t</span> bytes_transferred)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (ec.<span class="built_in">value</span>() != <span class="number">0</span>) &#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Error , code is &quot;</span> &lt;&lt; ec.<span class="built_in">value</span>() &lt;&lt; <span class="string">&quot; . Message is &quot;</span> &lt;&lt; ec.<span class="built_in">message</span>();</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//取出队首元素即当前未发送完数据</span></span><br><span class="line"> <span class="keyword">auto</span>&amp; send_data = _send_queue.<span class="built_in">front</span>();</span><br><span class="line"> send_data-&gt;_cur_len += bytes_transferred;</span><br><span class="line"> <span class="comment">//数据未发送完， 则继续发送</span></span><br><span class="line"> <span class="keyword">if</span> (send_data-&gt;_cur_len &lt; send_data-&gt;_total_len) &#123;</span><br><span class="line">  <span class="keyword">this</span>-&gt;sock-&gt;<span class="built_in">async_write_some</span>(boost::asio::<span class="built_in">buffer</span>(send_data-&gt;_msg + send_data-&gt;_cur_len, send_data-&gt;_total_len - send_data-&gt;_cur_len),</span><br><span class="line">   std::<span class="built_in">bind</span>(&amp;Session::WriteCallBack,</span><br><span class="line">    <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2));</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//如果发送完，则pop出队首元素</span></span><br><span class="line"> _send_queue.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line"> <span class="comment">//如果队列为空，则说明所有数据都发送完,将pending设置为false</span></span><br><span class="line"> <span class="keyword">if</span> (_send_queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">  _send_pending = <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//如果队列不是空，则继续将队首元素发送</span></span><br><span class="line"> <span class="keyword">if</span> (!_send_queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">  <span class="keyword">auto</span>&amp; send_data = _send_queue.<span class="built_in">front</span>();</span><br><span class="line">  <span class="keyword">this</span>-&gt;sock-&gt;<span class="built_in">async_write_some</span>(boost::asio::<span class="built_in">buffer</span>(send_data-&gt;_msg + send_data-&gt;_cur_len, send_data-&gt;_total_len - send_data-&gt;_cur_len),</span><br><span class="line">   std::<span class="built_in">bind</span>(&amp;Session::WriteCallBack,</span><br><span class="line">    <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2));</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::WriteToSocket</span><span class="params">(<span class="type">const</span> std::string buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">//将数据放入队列中</span></span><br><span class="line"> _send_queue.<span class="built_in">emplace</span>(<span class="keyword">new</span> <span class="built_in">MsgNode</span>(buf.<span class="built_in">c_str</span>(), buf.<span class="built_in">length</span>()));</span><br><span class="line"> <span class="comment">//如果还有数据未发送完，直接返回</span></span><br><span class="line"> <span class="keyword">if</span> (_send_pending) &#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//异步发送数据，因为异步所以不会一下发送完</span></span><br><span class="line"> <span class="keyword">this</span>-&gt;sock-&gt;<span class="built_in">async_write_some</span>(boost::asio::<span class="built_in">buffer</span>(buf), std::<span class="built_in">bind</span>(&amp;Session::WriteCallBack, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2));</span><br><span class="line"> _send_pending = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个回调函数被调用并且没有异常肯定是发完了一个数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::WriteAllCallBack</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec, std::<span class="type">size_t</span> bytes_transferred)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (ec.<span class="built_in">value</span>() != <span class="number">0</span>) &#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Error occured! Error code = &quot;</span></span><br><span class="line">   &lt;&lt; ec.<span class="built_in">value</span>()</span><br><span class="line">   &lt;&lt; <span class="string">&quot;. Message: &quot;</span> &lt;&lt; ec.<span class="built_in">message</span>();</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//如果发送完，则pop出队首元素</span></span><br><span class="line"> _send_queue.<span class="built_in">pop</span>();</span><br><span class="line"> <span class="comment">//如果队列为空，则说明所有数据都发送完,将pending设置为false</span></span><br><span class="line"> <span class="keyword">if</span> (_send_queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">  _send_pending = <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//如果队列不是空，则继续将队首元素发送</span></span><br><span class="line"> <span class="keyword">if</span> (!_send_queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">  <span class="keyword">auto</span>&amp; send_data = _send_queue.<span class="built_in">front</span>();</span><br><span class="line">  <span class="keyword">this</span>-&gt;sock-&gt;<span class="built_in">async_send</span>(boost::asio::<span class="built_in">buffer</span>(send_data-&gt;_msg + send_data-&gt;_cur_len, send_data-&gt;_total_len - send_data-&gt;_cur_len),</span><br><span class="line">   std::<span class="built_in">bind</span>(&amp;Session::WriteAllCallBack,</span><br><span class="line">    <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2));</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不能与async_write_some混合使用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::WriteAllToSocket</span><span class="params">(<span class="type">const</span> std::string buf)</span> </span>&#123;</span><br><span class="line"> <span class="comment">//插入发送队列</span></span><br><span class="line"> _send_queue.<span class="built_in">emplace</span>(<span class="keyword">new</span> <span class="built_in">MsgNode</span>(buf.<span class="built_in">c_str</span>(), buf.<span class="built_in">length</span>()));</span><br><span class="line"> <span class="comment">//pending状态说明上一次有未发送完的数据</span></span><br><span class="line"> <span class="keyword">if</span> (_send_pending) &#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//异步发送数据，因为异步所以不会一下发送完</span></span><br><span class="line"> <span class="keyword">this</span>-&gt;sock-&gt;<span class="built_in">async_send</span>(boost::asio::<span class="built_in">buffer</span>(buf),</span><br><span class="line">  std::<span class="built_in">bind</span>(&amp;Session::WriteAllCallBack, <span class="keyword">this</span>,</span><br><span class="line">   std::placeholders::_1, std::placeholders::_2));</span><br><span class="line"> _send_pending = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::ReadFromSocket</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (_recv_pending) &#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//可以调用构造函数直接构造，但不可用已经构造好的智能指针赋值</span></span><br><span class="line"> <span class="comment">/*auto _recv_nodez = std::make_unique&lt;MsgNode&gt;(RECVSIZE);</span></span><br><span class="line"><span class="comment"> _recv_node = _recv_nodez;*/</span></span><br><span class="line"> _recv_node = std::<span class="built_in">make_shared</span>&lt;MsgNode&gt;(RECVSIZE);</span><br><span class="line"> sock-&gt;<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_recv_node-&gt;_msg, _recv_node-&gt;_total_len), std::<span class="built_in">bind</span>(&amp;Session::ReadCallBack, <span class="keyword">this</span>,</span><br><span class="line">  std::placeholders::_1, std::placeholders::_2));</span><br><span class="line"> _recv_pending = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::ReadCallBack</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec, std::<span class="type">size_t</span> bytes_transferred)</span> </span>&#123;</span><br><span class="line"> _recv_node-&gt;_cur_len += bytes_transferred;</span><br><span class="line"> <span class="comment">//没读完继续读</span></span><br><span class="line"> <span class="keyword">if</span> (_recv_node-&gt;_cur_len &lt; _recv_node-&gt;_total_len) &#123;</span><br><span class="line">  sock-&gt;<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_recv_node-&gt;_msg + _recv_node-&gt;_cur_len,</span><br><span class="line">   _recv_node-&gt;_total_len - _recv_node-&gt;_cur_len), std::<span class="built_in">bind</span>(&amp;Session::ReadCallBack, <span class="keyword">this</span>,</span><br><span class="line">    std::placeholders::_1, std::placeholders::_2));</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//将数据投递到队列里交给逻辑线程处理，此处略去</span></span><br><span class="line"> <span class="comment">//如果读完了则将标记置为false</span></span><br><span class="line"> _recv_pending = <span class="literal">false</span>;</span><br><span class="line"> <span class="comment">//指针置空</span></span><br><span class="line"> _recv_node = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::ReadAllFromSocket</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (_recv_pending) &#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//可以调用构造函数直接构造，但不可用已经构造好的智能指针赋值</span></span><br><span class="line"> <span class="comment">/*auto _recv_nodez = std::make_unique&lt;MsgNode&gt;(RECVSIZE);</span></span><br><span class="line"><span class="comment"> _recv_node = _recv_nodez;*/</span></span><br><span class="line"> _recv_node = std::<span class="built_in">make_shared</span>&lt;MsgNode&gt;(RECVSIZE);</span><br><span class="line"> sock-&gt;<span class="built_in">async_receive</span>(boost::asio::<span class="built_in">buffer</span>(_recv_node-&gt;_msg, _recv_node-&gt;_total_len), std::<span class="built_in">bind</span>(&amp;Session::ReadAllCallBack, <span class="keyword">this</span>,</span><br><span class="line">  std::placeholders::_1, std::placeholders::_2));</span><br><span class="line"> _recv_pending = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::ReadAllCallBack</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec, std::<span class="type">size_t</span> bytes_transferred)</span> </span>&#123;</span><br><span class="line"> _recv_node-&gt;_cur_len += bytes_transferred;</span><br><span class="line"> <span class="comment">//将数据投递到队列里交给逻辑线程处理，此处略去</span></span><br><span class="line"> <span class="comment">//如果读完了则将标记置为false</span></span><br><span class="line"> _recv_pending = <span class="literal">false</span>;</span><br><span class="line"> <span class="comment">//指针置空</span></span><br><span class="line"> _recv_node = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>发送的时候推荐使用 <strong>asyc_send</strong> 而接受的时候 推荐使用 <strong>asyc_rend_some 函数</strong></li></ul><h2 id="asio官方案例存在的隐患"><a href="#asio官方案例存在的隐患" class="headerlink" title="asio官方案例存在的隐患"></a>asio官方案例存在的隐患</h2><h3 id="Session类"><a href="#Session类" class="headerlink" title="Session类"></a>Session类</h3><ul><li>Session类主要是处理客户端消息收发的会话类，为了简单起见，我们不考虑粘包问题，也不考虑支持手动调用发送的接口，只以应答的方式发送和接收固定长度(1024字节长度)的数据。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Session</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">Session</span>(boost::asio::io_context&amp; ioc) :<span class="built_in">sock</span>(ioc) &#123;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> boost::asio::ip::<span class="function">tcp::socket&amp; <span class="title">Socket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sock;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">handle_read</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">size_t</span> bytes_transferred)</span></span>;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">handle_write</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec)</span></span>;</span><br><span class="line"> boost::asio::ip::tcp::socket sock;</span><br><span class="line"> <span class="keyword">enum</span>&#123;max_length = <span class="number">1024</span>&#125;;</span><br><span class="line"> <span class="type">char</span> _data[max_length];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>_data用来接收客户端传递的数据</li><li>socket为单独处理客户端读写的socket。</li><li>handle_read和handle_write分别为读回调函数和写回调函数。</li></ol><ul><li>接下来我们实现Session类</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Session.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::Start</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="built_in">memset</span>(_data, <span class="number">0</span>, max_length);</span><br><span class="line"> sock.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, max_length),</span><br><span class="line">  std::<span class="built_in">bind</span>(&amp;Session::handle_read, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::handle_read</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error,</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="type">size_t</span> bytes_transferred)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;server receive data is &quot;</span> &lt;&lt; _data &lt;&lt; std::endl;</span><br><span class="line">        boost::asio::<span class="built_in">async_write</span>(sock, boost::asio::<span class="built_in">buffer</span>(_data, bytes_transfered),</span><br><span class="line">            std::<span class="built_in">bind</span>(&amp;Session::handle_write, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;read error&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::handle_write</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!error)&#123;</span><br><span class="line">    <span class="built_in">memset</span>(_data, <span class="number">0</span>, max_length);</span><br><span class="line">    sock.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, max_length), std::<span class="built_in">bind</span>(&amp;Session::handle_read,</span><br><span class="line">        <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2));</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在Start方法中我们调用异步读操作，监听对端发送的消息。当对端发送数据后，触发handle_read函数</li><li>handle_read函数内将收到的数据发送给对端，当发送完成后触发handle_write回调函数。</li><li>handle_write函数内又一次监听了读事件，如果对端有数据发送过来则触发handle_read，我们再将收到的数据发回去。从而达到应答式服务的效果。</li></ul><h3 id="Server类"><a href="#Server类" class="headerlink" title="Server类"></a>Server类</h3><ul><li>Server类为服务器接收连接的管理类</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">Server</span>(boost::asio::io_context&amp; ioc, <span class="type">unsigned</span> <span class="type">short</span> port);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">start_accept</span><span class="params">()</span></span>;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">handle_accept</span><span class="params">(Session* new_session, <span class="type">const</span> boost::system::error_code&amp; error)</span></span>;</span><br><span class="line"> boost::asio::io_context&amp; _ioc;</span><br><span class="line"> boost::asio::ip::tcp::acceptor _acceptor;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Server实现"><a href="#Server实现" class="headerlink" title="Server实现"></a>Server实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Server::<span class="built_in">Server</span>(boost::asio::io_context&amp; ioc, <span class="type">unsigned</span> <span class="type">short</span> port) : _ioc(ioc), _acceptor(ioc, boost::asio::ip::tcp::<span class="built_in">endpoint</span>(boost::asio::ip::tcp::<span class="built_in">v4</span>(), port)) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Server start success, on port: &quot;</span> &lt;&lt; port &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">start_accept</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Server::start_accept</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Session* new_session = <span class="keyword">new</span> <span class="built_in">Session</span>(_ioc);</span><br><span class="line">    _acceptor.<span class="built_in">async_accept</span>(new_session-&gt;<span class="built_in">Socket</span>(),</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;Server::handle_accept, <span class="keyword">this</span>, new_session, std::placeholders::_1));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Server::handle_accept</span><span class="params">(Session* new_session, <span class="type">const</span> boost::system::error_code&amp; error)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        new_session-&gt;<span class="built_in">Start</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;accept error&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">delete</span> new_session;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理完事件后继续监听连接</span></span><br><span class="line">    <span class="built_in">start_accept</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="隐患"><a href="#隐患" class="headerlink" title="隐患"></a>隐患</h3><ul><li>该demo示例为仿照asio官网编写的，其中存在隐患，<strong>就是当服务器即将发送数据前(调用async_write前)，此刻客户端中断</strong>，服务器此时调用async_write会触发发送回调函数，判断ec为非0进而执行<strong>delete this逻辑回收session</strong>。但要注意的是客户端关闭后，在tcp层面会触发读就绪事件，服务器会触发读事件回调函数。在读事件回调函数中判断错误码ec为非0，<strong>进而再次执行delete操作，从而造成二次析构，这是极度危险的。</strong></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>本文介绍了异步的应答服务器设计，但是这种服务器并不会在实际生产中使用，主要有两个原因:</li></ul><ol><li>因为该服务器的发送和接收以应答的方式交互，而并不能做到应用层想随意发送的目的，也就是未做到完全的收发分离(全双工逻辑)。</li><li>该服务器未处理粘包，序列化，以及逻辑和收发线程解耦等问题。</li><li>该服务器存在二次析构的风险。</li></ol><ul><li>对于官方案例，他考虑到了这个二次析构问题，所以它只会在读成功后进行写，这就保证了同一时期只有一个读取或者写(单工)，但是这依然是一个隐患。</li></ul><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><h4 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Session</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">Session</span>(boost::asio::io_context&amp; ioc) :<span class="built_in">sock</span>(ioc) &#123;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> boost::asio::ip::<span class="function">tcp::socket&amp; <span class="title">Socket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sock;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">handle_read</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">size_t</span> bytes_transferred)</span></span>;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">handle_write</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec)</span></span>;</span><br><span class="line"> boost::asio::ip::tcp::socket sock;</span><br><span class="line"> <span class="keyword">enum</span>&#123;max_length = <span class="number">1024</span>&#125;;</span><br><span class="line"> <span class="type">char</span> _data[max_length];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">Server</span>(boost::asio::io_context&amp; ioc, <span class="type">unsigned</span> <span class="type">short</span> port);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">start_accept</span><span class="params">()</span></span>;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">handle_accept</span><span class="params">(Session* new_session, <span class="type">const</span> boost::system::error_code&amp; error)</span></span>;</span><br><span class="line"> boost::asio::io_context&amp; _ioc;</span><br><span class="line"> boost::asio::ip::tcp::acceptor _acceptor;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Session.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::Start</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="built_in">memset</span>(_data, <span class="number">0</span>, max_length);</span><br><span class="line"> sock.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, max_length),</span><br><span class="line">  std::<span class="built_in">bind</span>(&amp;Session::handle_read, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::handle_read</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error,</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="type">size_t</span> bytes_transferred)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;server receive data is &quot;</span> &lt;&lt; _data &lt;&lt; std::endl;</span><br><span class="line">        boost::asio::<span class="built_in">async_write</span>(sock, boost::asio::<span class="built_in">buffer</span>(_data, bytes_transferred),</span><br><span class="line">            std::<span class="built_in">bind</span>(&amp;Session::handle_write, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;read error&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::handle_write</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!error)&#123;</span><br><span class="line">    <span class="built_in">memset</span>(_data, <span class="number">0</span>, max_length);</span><br><span class="line">    sock.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, max_length), std::<span class="built_in">bind</span>(&amp;Session::handle_read,</span><br><span class="line">        <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2));</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Server::<span class="built_in">Server</span>(boost::asio::io_context&amp; ioc, <span class="type">unsigned</span> <span class="type">short</span> port) : _ioc(ioc), _acceptor(ioc, boost::asio::ip::tcp::<span class="built_in">endpoint</span>(boost::asio::ip::tcp::<span class="built_in">v4</span>(), port)) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Server start success, on port: &quot;</span> &lt;&lt; port &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">start_accept</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Server::start_accept</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Session* new_session = <span class="keyword">new</span> <span class="built_in">Session</span>(_ioc);</span><br><span class="line">    _acceptor.<span class="built_in">async_accept</span>(new_session-&gt;<span class="built_in">Socket</span>(),</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;Server::handle_accept, <span class="keyword">this</span>, new_session, std::placeholders::_1));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Server::handle_accept</span><span class="params">(Session* new_session, <span class="type">const</span> boost::system::error_code&amp; error)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        new_session-&gt;<span class="built_in">Start</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;accept error&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">delete</span> new_session;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理完事件后继续监听连接</span></span><br><span class="line">    <span class="built_in">start_accept</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用伪闭包实现连接的安全回收"><a href="#使用伪闭包实现连接的安全回收" class="headerlink" title="使用伪闭包实现连接的安全回收"></a>使用伪闭包实现连接的安全回收</h2><ul><li>之前的异步服务器为echo模式，但其存在安全隐患，就是在极端情况下客户端关闭导致触发写和读回调函数，二者都进入错误处理逻辑，进而造成二次析构的问题。</li><li>下面我们介绍通过C11智能指针构造成一个伪闭包的状态延长session的生命周期。</li></ul><h3 id="智能指针管理Session"><a href="#智能指针管理Session" class="headerlink" title="智能指针管理Session"></a>智能指针管理Session</h3><ul><li>我们可以通过智能指针的方式管理Session类，将acceptor接收的链接保存在Session类型的智能指针里。由于智能指针会在引用计数为0时自动析构，所以为了防止其被自动回收，也方便Server管理Session，因为我们后期会做一些重连踢人等业务逻辑，我们在Server类中添加成员变量，该变量为一个map类型，key为Session的uid，value为该Session的智能指针。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CServer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CServer</span>(<span class="type">const</span> boost::asio::io_context&amp; io_context, <span class="type">short</span> port);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ClearSession</span><span class="params">(std::string)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">HandleAccept</span><span class="params">(std::shared_ptr&lt;CSession&gt;, <span class="type">const</span> boost::system::error_code&amp; error)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">StartAccept</span><span class="params">()</span></span>;</span><br><span class="line">    boost::asio::io_context&amp; _io_context;</span><br><span class="line">    <span class="type">short</span> _port;</span><br><span class="line">    boost::asio::ip::tcp::acceptor _acceptor;</span><br><span class="line">    std::map&lt;std::string, std::shared_ptr&lt;CSession&gt;&gt; _sessions;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>通过Server中的_sessions这个map管理链接，可以增加Session智能指针的引用计数，只有当Session从这个map中移除后，Session才会被释放。</p></li><li><p>所以在接收连接的逻辑里将Session放入map</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CServer::StartAccept</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;CSession&gt; new_session = std::<span class="built_in">make_shared</span>&lt;CSession&gt;(_ioc, <span class="keyword">this</span>);</span><br><span class="line">    _acceptor.<span class="built_in">async_accept</span>(new_session-&gt;<span class="built_in">GetSocket</span>(), std::<span class="built_in">bind</span>(&amp;CServer::HandleAccept, <span class="keyword">this</span>, new_session, std::placeholders::_1));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CServer::HandleAccept</span><span class="params">(std::shared_ptr&lt;CSession&gt; new_session, <span class="type">const</span> boost::system::error_code&amp; error)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        new_session-&gt;<span class="built_in">Start</span>();</span><br><span class="line">        <span class="comment">//将session加入map</span></span><br><span class="line">        _sessions.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(new_session-&gt;<span class="built_in">GetUuid</span>(), new_session));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;session accept failed, error is &quot;</span> &lt;&lt; error.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">StartAccept</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>StartAccept函数中虽然new_session是一个局部变量，但是我们通过bind操作，将new_session作为数值传递给bind函数，而bind函数返回的函数对象内部引用了该new_session所以引用计数增加1，这样保证了new_session不会被释放。</li><li><p>在HandleAccept函数里调用session的start函数监听对端收发数据，并将session放入map中，保证session不被自动释放。</p></li><li><p>此外，需要封装一个释放函数，将session从map中移除，当其引用计数为0则自动释放</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CServer::ClearSession</span><span class="params">(std::string&amp; uuid)</span> </span>&#123;</span><br><span class="line">    _sessions.<span class="built_in">erase</span>(uuid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Session的uuid"><a href="#Session的uuid" class="headerlink" title="Session的uuid"></a>Session的uuid</h3><ul><li>关于session的uuid可以通过boost提供的生成唯一id的函数获得，当然你也可以自己实现雪花算法。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CSession</span>(boost::asio::io_context&amp; ioc, CServer* server) :<span class="built_in">sock</span>(ioc),_server(server) &#123;</span><br><span class="line"> boost::uuids::uuid a_uuid = boost::uuids::<span class="built_in">random_generator</span>()();</span><br><span class="line"> _uuid = boost::uuids::<span class="built_in">to_string</span>(a_uuid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>另外我们修改Session中读写回调函数关于错误的处理，当读写出错的时候清除连接</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::Start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(_data, <span class="number">0</span>, max_length);</span><br><span class="line">    <span class="comment">// 错误用法, 因为会生成两个shared_ptr来管理同一块内存，他们两的引用计数可能不同</span></span><br><span class="line">  <span class="comment">/*  sock.async_read_some(boost::asio::buffer(_data, max_length),</span></span><br><span class="line"><span class="comment">        std::bind(&amp;CSession::handle_read, this, std::placeholders::_1, std::placeholders::_2, std::shared_ptr&lt;CSession&gt;(this)));*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//正确用法，使用 std::shared_from_this()需要继承std::enable_shared_from_this&lt;CSession&gt; 模板类</span></span><br><span class="line">    <span class="comment">//shared_from_this()内部实现是返回一个智能指针，和存在的智能指针去同步</span></span><br><span class="line">    sock.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, max_length),</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;CSession::handle_read, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, <span class="built_in">shared_from_this</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::handle_read</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">size_t</span> bytes_transferred, std::shared_ptr&lt;CSession&gt; _self_shared)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;server receive data is &quot;</span> &lt;&lt; _data &lt;&lt; std::endl;</span><br><span class="line">        boost::asio::<span class="built_in">async_write</span>(sock, boost::asio::<span class="built_in">buffer</span>(_data, bytes_transferred),</span><br><span class="line">            std::<span class="built_in">bind</span>(&amp;CSession::handle_write, <span class="keyword">this</span>, std::placeholders::_1, _self_shared));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;read error&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        _server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::handle_write</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, std::shared_ptr&lt;CSession&gt; _self_shared)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(_data, <span class="number">0</span>, max_length);</span><br><span class="line">        sock.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, max_length), std::<span class="built_in">bind</span>(&amp;CSession::handle_read,</span><br><span class="line">            <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, _self_shared));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;write error&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        _server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="隐患1"><a href="#隐患1" class="headerlink" title="隐患1"></a>隐患1</h3><ul><li>正常情况下上述服务器运行不会出现问题，但是当我们像上次一样模拟，在服务器要发送数据前打个断点，此时关闭客户端，在服务器就会先触发写回调函数的错误处理，再触发读回调函数的错误处理，这样session就会两次从map中移除，因为map中key唯一，所以第二次map判断没有session的key就不做移除操作了。</li><li>但是这么做还是会有崩溃问题，因为第一次在session写回调函数中移除session，session的引用计数就为0了，调用了session的析构函数，这样在触发session读回调函数时此时session的内存已经被回收了自然会出现崩溃的问题。解决这个问题可以利用智能指针引用计数和bind的特性，实现一个伪闭包的机制延长session的生命周期。</li></ul><h3 id="如何实现伪闭包"><a href="#如何实现伪闭包" class="headerlink" title="如何实现伪闭包"></a>如何实现伪闭包</h3><p>思路：</p><ol><li>利用智能指针被复制或使用引用计数加一的原理保证内存不被回收</li><li>bind操作可以将值绑定在一个函数对象上生成新的函数对象，如果将智能指针作为参数绑定给函数对象，那么智能指针就以值的方式被新函数对象使用，那么智能指针的生命周期将和新生成的函数对象一致，从而达到延长生命的效果。</li></ol><ul><li>以HandleWrite举例,在<strong>bind时传递_self_shared指针增加其引用计数</strong>，这样_self_shared的生命周期就和async_write的第二个参数(也就是asio要求的回调函数对象)生命周期一致了。</li><li>除此之外，我们也要在第一次绑定读写回调函数的时候传入智能指针的值,但是要注意传入的方式，不能用两个智能指针管理同一块内存，如下用法是错误的。</li><li>shared_ptr<CSession>(this)生成的新智能指针和this之前绑定的智能指针并不共享引用计数，所以要通过shared_from_this()函数返回智能指针，该智能指针和其他管理这块内存的智能指针共享引用计数。</li><li>shared_from_this()函数并不是session的成员函数，要使用这个函数需要继承std::enable_shared_from_this<Session></li></ul><h3 id="完整的代码"><a href="#完整的代码" class="headerlink" title="完整的代码"></a>完整的代码</h3><h4 id="实现1"><a href="#实现1" class="headerlink" title="实现1"></a>实现1</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Session.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CServer::StartAccept</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;CSession&gt; new_session = std::<span class="built_in">make_shared</span>&lt;CSession&gt;(_ioc, <span class="keyword">this</span>);</span><br><span class="line">    _acceptor.<span class="built_in">async_accept</span>(new_session-&gt;<span class="built_in">GetSocket</span>(), std::<span class="built_in">bind</span>(&amp;CServer::HandleAccept, <span class="keyword">this</span>, new_session, std::placeholders::_1));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CServer::HandleAccept</span><span class="params">(std::shared_ptr&lt;CSession&gt; new_session, <span class="type">const</span> boost::system::error_code&amp; error)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        new_session-&gt;<span class="built_in">Start</span>();</span><br><span class="line">        <span class="comment">//将session加入map</span></span><br><span class="line">        _sessions.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(new_session-&gt;<span class="built_in">GetUuid</span>(), new_session));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;session accept failed, error is &quot;</span> &lt;&lt; error.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">StartAccept</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CServer::ClearSession</span><span class="params">(std::string&amp; uuid)</span> </span>&#123;</span><br><span class="line">    _sessions.<span class="built_in">erase</span>(uuid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CServer::<span class="built_in">CServer</span>(boost::asio::io_context&amp; ioc, <span class="type">unsigned</span> <span class="type">short</span> port) : _ioc(ioc), _acceptor(ioc, boost::asio::ip::tcp::<span class="built_in">endpoint</span>(boost::asio::ip::tcp::<span class="built_in">v4</span>(), port)) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Server start success, on port: &quot;</span> &lt;&lt; port &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">StartAccept</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::Start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(_data, <span class="number">0</span>, max_length);</span><br><span class="line">    <span class="comment">// 错误用法, 因为会生成两个shared_ptr来管理同一块内存，他们两的引用计数可能不同</span></span><br><span class="line">  <span class="comment">/*  sock.async_read_some(boost::asio::buffer(_data, max_length),</span></span><br><span class="line"><span class="comment">        std::bind(&amp;CSession::handle_read, this, std::placeholders::_1, std::placeholders::_2, std::shared_ptr&lt;CSession&gt;(this)));*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//正确用法，使用 std::shared_from_this()需要继承std::enable_shared_from_this&lt;CSession&gt; 模板类</span></span><br><span class="line">    <span class="comment">//shared_from_this()内部实现是返回一个智能指针，和存在的智能指针去同步</span></span><br><span class="line">    sock.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, max_length),</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;CSession::handle_read, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, <span class="built_in">shared_from_this</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::handle_read</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">size_t</span> bytes_transferred, std::shared_ptr&lt;CSession&gt; _self_shared)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;server receive data is &quot;</span> &lt;&lt; _data &lt;&lt; std::endl;</span><br><span class="line">        boost::asio::<span class="built_in">async_write</span>(sock, boost::asio::<span class="built_in">buffer</span>(_data, bytes_transferred),</span><br><span class="line">            std::<span class="built_in">bind</span>(&amp;CSession::handle_write, <span class="keyword">this</span>, std::placeholders::_1, _self_shared));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;read error&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        _server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::handle_write</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, std::shared_ptr&lt;CSession&gt; _self_shared)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(_data, <span class="number">0</span>, max_length);</span><br><span class="line">        sock.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, max_length), std::<span class="built_in">bind</span>(&amp;CSession::handle_read,</span><br><span class="line">            <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, _self_shared));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;write error&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        _server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="头文件1"><a href="#头文件1" class="headerlink" title="头文件1"></a>头文件1</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/uuid/uuid_generators.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/uuid/uuid_io.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CServer</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CSession</span>: <span class="keyword">public</span> std::enable_shared_from_this&lt;CSession&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">CSession</span>(boost::asio::io_context&amp; ioc, CServer* server) :<span class="built_in">sock</span>(ioc),_server(server) &#123;</span><br><span class="line">  boost::uuids::uuid a_uuid = boost::uuids::<span class="built_in">random_generator</span>()();</span><br><span class="line">  _uuid = boost::uuids::<span class="built_in">to_string</span>(a_uuid);</span><br><span class="line"> &#125;</span><br><span class="line"> boost::asio::ip::<span class="function">tcp::socket&amp; <span class="title">GetSocket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sock;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function">std::string&amp; <span class="title">GetUuid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> _uuid;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">handle_read</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">size_t</span> bytes_transferred, std::shared_ptr&lt;CSession&gt; _self_shared)</span></span>;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">handle_write</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec, std::shared_ptr&lt;CSession&gt; _self_shared)</span></span>;</span><br><span class="line"> boost::asio::ip::tcp::socket sock;</span><br><span class="line"> <span class="keyword">enum</span> &#123; max_length = <span class="number">1024</span> &#125;;</span><br><span class="line"> <span class="type">char</span> _data[max_length];</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 存储唯一标识</span></span><br><span class="line"> std::string _uuid;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 指向CServer的指针</span></span><br><span class="line"> CServer* _server;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CServer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CServer</span>(boost::asio::io_context&amp; ioc, <span class="type">unsigned</span> <span class="type">short</span> port);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ClearSession</span><span class="params">(std::string&amp; uuid)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">HandleAccept</span><span class="params">(std::shared_ptr&lt;CSession&gt;, <span class="type">const</span> boost::system::error_code&amp; error)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">StartAccept</span><span class="params">()</span></span>;</span><br><span class="line"> boost::asio::io_context&amp; _ioc;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> port;</span><br><span class="line">    boost::asio::ip::tcp::acceptor _acceptor;</span><br><span class="line">    std::map&lt;std::string, std::shared_ptr&lt;CSession&gt;&gt; _sessions;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="封装服务器发送队列"><a href="#封装服务器发送队列" class="headerlink" title="封装服务器发送队列"></a>封装服务器发送队列</h2><ul><li><strong>封装发送队列来保证发送数据的有序性</strong></li></ul><h3 id="数据节点设计"><a href="#数据节点设计" class="headerlink" title="数据节点设计"></a>数据节点设计</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MsgNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="comment">//用来构造发送节点</span></span><br><span class="line"> <span class="built_in">MsgNode</span>(<span class="type">char</span>* msg, <span class="type">int</span> max_len):_total_len(max_len), _cur_len(<span class="number">0</span>) &#123;</span><br><span class="line">  _data = <span class="keyword">new</span> <span class="type">char</span>[max_len];</span><br><span class="line">  <span class="built_in">memcpy</span>(_data, msg, max_len);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> ~<span class="built_in">MsgNode</span>() &#123;</span><br><span class="line">  <span class="keyword">delete</span>[] _data;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="comment">//已发送的数据</span></span><br><span class="line"> <span class="type">int</span> _cur_len;</span><br><span class="line"> <span class="comment">//总共需要发送的数据</span></span><br><span class="line"> <span class="type">int</span> _total_len;</span><br><span class="line"> <span class="comment">//存取数据的数组</span></span><br><span class="line"> <span class="type">char</span>* _data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>_cur_len表示数据当前已处理的长度(已经发送的数据或者已经接收的数据长度)，因为一个数据包存在未发送完或者未接收完的情况。</li><li>_max_len表示数据的总长度。</li><li>_data表示数据域，已接收或者已发送的数据都放在此空间内。</li></ol><h3 id="封装发送接口"><a href="#封装发送接口" class="headerlink" title="封装发送接口"></a>封装发送接口</h3><ul><li><p>首先在CSession类里新增一个队列存储要发送的数据，因为我们不能保证每次调用发送接口的时候上一次数据已经发送完，就要把要发送的数据放入队列中，通过回调函数不断地发送。而且我们不能保证发送的接口和回调函数的接口在一个线程，所以要增加一个锁保证发送队列安全性。</p></li><li><p>我们新增一个发送接口Send</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送接口</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Send</span><span class="params">(<span class="type">char</span>* msg, <span class="type">int</span> max_length)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 发送队列</span></span><br><span class="line">std::queue&lt;std::shared_ptr&lt;MsgNode&gt;&gt; _send_que;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保证多线程的安全性</span></span><br><span class="line">std::mutex _send_lock;</span><br></pre></td></tr></table></figure><ul><li>实现发送接口</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::Send</span><span class="params">(<span class="type">char</span>* msg, <span class="type">int</span> max_length)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//pending 为false表示发送缓冲区是空的</span></span><br><span class="line">    <span class="type">bool</span> pending = <span class="literal">false</span>;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_send_lock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!_send_que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        pending = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _send_que.<span class="built_in">push</span>(std::<span class="built_in">make_shared</span>&lt;MsgNode&gt;(msg, max_length));</span><br><span class="line">    <span class="keyword">if</span> (pending) <span class="keyword">return</span>;</span><br><span class="line">    boost::asio::<span class="built_in">async_write</span>(sock, boost::asio::<span class="built_in">buffer</span>(msg, max_length),</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;CSession::HandleWrite, <span class="keyword">this</span>, std::placeholders::_1, <span class="built_in">shared_from_this</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>发送接口里判断发送队列是否为空，如果不为空说明有数据未发送完，需要将数据放入队列，然后返回。如果发送队列为空，则说明当前没有未发送完的数据，将要发送的数据放入队列并调用async_write函数发送数据。</p></li><li><p>回调函数的实现</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::HandleWrite</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, std::shared_ptr&lt;CSession&gt; _self_shared)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_send_lock)</span></span>;</span><br><span class="line">        <span class="comment">//因为使用的是async_write，数据一定被发送玩所以可以直接出队</span></span><br><span class="line">        _send_que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (!_send_que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span>&amp; msgnode = _send_que.<span class="built_in">front</span>();</span><br><span class="line">            boost::asio::<span class="built_in">async_write</span>(sock, boost::asio::<span class="built_in">buffer</span>(msgnode-&gt;_data, msgnode-&gt;_total_len),</span><br><span class="line">                std::<span class="built_in">bind</span>(&amp;CSession::HandleWrite, <span class="keyword">this</span>, std::placeholders::_1, _self_shared));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;handle write failed, error is &quot;</span> &lt;&lt; error.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">        _server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>判断发送队列是否为空，为空则发送完，否则不断取出队列数据调用async_write发送，直到队列为空。</li></ul><h2 id="修改读回调"><a href="#修改读回调" class="headerlink" title="修改读回调"></a>修改读回调</h2><ul><li>因为我们要一直监听对端发送的数据，所以要在每次收到数据后继续绑定监听事件</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::HandleRead</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">size_t</span> bytes_transferred, std::shared_ptr&lt;CSession&gt; _self_shared)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;server receive data is &quot;</span> &lt;&lt; _data &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">Send</span>(_data, bytes_transferred);</span><br><span class="line">        <span class="built_in">memset</span>(_data, <span class="number">0</span>, max_length);</span><br><span class="line">        sock.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, max_length),</span><br><span class="line">            std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, _self_shared));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;read error&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        _server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="该节总结"><a href="#该节总结" class="headerlink" title="该节总结"></a>该节总结</h3><ul><li>虽然实现了全双工，但是未处理粘包问题</li></ul><h3 id="封装后完整代码"><a href="#封装后完整代码" class="headerlink" title="封装后完整代码"></a>封装后完整代码</h3><h4 id="msgNode"><a href="#msgNode" class="headerlink" title="msgNode"></a>msgNode</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MsgNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="comment">//用来构造发送节点</span></span><br><span class="line"> <span class="built_in">MsgNode</span>(<span class="type">char</span>* msg, <span class="type">int</span> max_len):_total_len(max_len), _cur_len(<span class="number">0</span>) &#123;</span><br><span class="line">  _data = <span class="keyword">new</span> <span class="type">char</span>[max_len];</span><br><span class="line">  <span class="built_in">memcpy</span>(_data, msg, max_len);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> ~<span class="built_in">MsgNode</span>() &#123;</span><br><span class="line">  <span class="keyword">delete</span>[] _data;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//已发送的数据</span></span><br><span class="line"> <span class="type">int</span> _cur_len;</span><br><span class="line"> <span class="comment">//总共需要发送的数据</span></span><br><span class="line"> <span class="type">int</span> _total_len;</span><br><span class="line"> <span class="comment">//存取数据的数组</span></span><br><span class="line"> <span class="type">char</span>* _data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="CSession"><a href="#CSession" class="headerlink" title="CSession"></a>CSession</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/uuid/uuid_generators.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/uuid/uuid_io.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MsgNode.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CServer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CServer</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CSession</span>: <span class="keyword">public</span> std::enable_shared_from_this&lt;CSession&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">CSession</span>(boost::asio::io_context&amp; ioc, CServer* server) :<span class="built_in">sock</span>(ioc),_server(server) &#123;</span><br><span class="line">  boost::uuids::uuid a_uuid = boost::uuids::<span class="built_in">random_generator</span>()();</span><br><span class="line">  _uuid = boost::uuids::<span class="built_in">to_string</span>(a_uuid);</span><br><span class="line"> &#125;</span><br><span class="line"> boost::asio::ip::<span class="function">tcp::socket&amp; <span class="title">GetSocket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sock;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function">std::string&amp; <span class="title">GetUuid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> _uuid;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 发送接口</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">Send</span><span class="params">(<span class="type">char</span>* msg, <span class="type">int</span> max_length)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">HandleRead</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">size_t</span> bytes_transferred, std::shared_ptr&lt;CSession&gt; _self_shared)</span></span>;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">HandleWrite</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec, std::shared_ptr&lt;CSession&gt; _self_shared)</span></span>;</span><br><span class="line"> boost::asio::ip::tcp::socket sock;</span><br><span class="line"> <span class="keyword">enum</span> &#123; max_length = <span class="number">1024</span> &#125;;</span><br><span class="line"> <span class="type">char</span> _data[max_length];</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 存储唯一标识</span></span><br><span class="line"> std::string _uuid;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 指向CServer的指针</span></span><br><span class="line"> CServer* _server;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 发送队列</span></span><br><span class="line"> std::queue&lt;std::shared_ptr&lt;MsgNode&gt;&gt; _send_que;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//保证多线程的安全性</span></span><br><span class="line"> std::mutex _send_lock;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CSession.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::Send</span><span class="params">(<span class="type">char</span>* msg, <span class="type">int</span> max_length)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//pending 为false表示发送缓冲区是空的</span></span><br><span class="line">    <span class="type">bool</span> pending = <span class="literal">false</span>;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_send_lock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!_send_que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        pending = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _send_que.<span class="built_in">push</span>(std::<span class="built_in">make_shared</span>&lt;MsgNode&gt;(msg, max_length));</span><br><span class="line">    <span class="keyword">if</span> (pending) <span class="keyword">return</span>;</span><br><span class="line">    boost::asio::<span class="built_in">async_write</span>(sock, boost::asio::<span class="built_in">buffer</span>(msg, max_length),</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;CSession::HandleWrite, <span class="keyword">this</span>, std::placeholders::_1, <span class="built_in">shared_from_this</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::Start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(_data, <span class="number">0</span>, max_length);</span><br><span class="line">    <span class="comment">// 错误用法, 因为会生成两个shared_ptr来管理同一块内存，他们两的引用计数可能不同</span></span><br><span class="line">  <span class="comment">/*  sock.async_read_some(boost::asio::buffer(_data, max_length),</span></span><br><span class="line"><span class="comment">        std::bind(&amp;CSession::handle_read, this, std::placeholders::_1, std::placeholders::_2, std::shared_ptr&lt;CSession&gt;(this)));*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//正确用法，使用 std::shared_from_this()需要继承std::enable_shared_from_this&lt;CSession&gt; 模板类</span></span><br><span class="line">    <span class="comment">//shared_from_this()内部实现是返回一个智能指针，和存在的智能指针去同步</span></span><br><span class="line">    sock.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, max_length),</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, <span class="built_in">shared_from_this</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::HandleRead</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">size_t</span> bytes_transferred, std::shared_ptr&lt;CSession&gt; _self_shared)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;server receive data is &quot;</span> &lt;&lt; _data &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">Send</span>(_data, bytes_transferred);</span><br><span class="line">        <span class="built_in">memset</span>(_data, <span class="number">0</span>, max_length);</span><br><span class="line">        sock.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, max_length),</span><br><span class="line">            std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, _self_shared));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;read error&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        _server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::HandleWrite</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, std::shared_ptr&lt;CSession&gt; _self_shared)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_send_lock)</span></span>;</span><br><span class="line">        <span class="comment">//因为使用的是async_write，数据一定被发送玩所以可以直接出队</span></span><br><span class="line">        _send_que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (!_send_que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span>&amp; msgnode = _send_que.<span class="built_in">front</span>();</span><br><span class="line">            boost::asio::<span class="built_in">async_write</span>(sock, boost::asio::<span class="built_in">buffer</span>(msgnode-&gt;_data, msgnode-&gt;_total_len),</span><br><span class="line">                std::<span class="built_in">bind</span>(&amp;CSession::HandleWrite, <span class="keyword">this</span>, std::placeholders::_1, _self_shared));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;handle write failed, error is &quot;</span> &lt;&lt; error.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">        _server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CServer"><a href="#CServer" class="headerlink" title="CServer"></a>CServer</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CSession.h&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CSession</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CServer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CServer</span>(boost::asio::io_context&amp; ioc, <span class="type">unsigned</span> <span class="type">short</span> port);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ClearSession</span><span class="params">(std::string&amp; uuid)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">HandleAccept</span><span class="params">(std::shared_ptr&lt;CSession&gt;, <span class="type">const</span> boost::system::error_code&amp; error)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">StartAccept</span><span class="params">()</span></span>;</span><br><span class="line">    boost::asio::io_context&amp; _ioc;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> port;</span><br><span class="line">    boost::asio::ip::tcp::acceptor _acceptor;</span><br><span class="line">    std::map&lt;std::string, std::shared_ptr&lt;CSession&gt;&gt; _sessions;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CServer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CServer::StartAccept</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;CSession&gt; new_session = std::<span class="built_in">make_shared</span>&lt;CSession&gt;(_ioc, <span class="keyword">this</span>);</span><br><span class="line">    _acceptor.<span class="built_in">async_accept</span>(new_session-&gt;<span class="built_in">GetSocket</span>(), std::<span class="built_in">bind</span>(&amp;CServer::HandleAccept, <span class="keyword">this</span>, new_session, std::placeholders::_1));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CServer::HandleAccept</span><span class="params">(std::shared_ptr&lt;CSession&gt; new_session, <span class="type">const</span> boost::system::error_code&amp; error)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        new_session-&gt;<span class="built_in">Start</span>();</span><br><span class="line">        <span class="comment">//将session加入map</span></span><br><span class="line">        _sessions.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(new_session-&gt;<span class="built_in">GetUuid</span>(), new_session));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;session accept failed, error is &quot;</span> &lt;&lt; error.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">StartAccept</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CServer::ClearSession</span><span class="params">(std::string&amp; uuid)</span> </span>&#123;</span><br><span class="line">    _sessions.<span class="built_in">erase</span>(uuid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CServer::<span class="built_in">CServer</span>(boost::asio::io_context&amp; ioc, <span class="type">unsigned</span> <span class="type">short</span> port) : _ioc(ioc), _acceptor(ioc, boost::asio::ip::tcp::<span class="built_in">endpoint</span>(boost::asio::ip::tcp::<span class="built_in">v4</span>(), port)) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Server start success, on port: &quot;</span> &lt;&lt; port &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">StartAccept</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="处理网络粘包问题"><a href="#处理网络粘包问题" class="headerlink" title="处理网络粘包问题"></a>处理网络粘包问题</h2><h3 id="什么是粘包"><a href="#什么是粘包" class="headerlink" title="什么是粘包"></a>什么是粘包</h3><ul><li>粘包问题是服务器收发数据常遇到的一个现象，当客户端发送多个数据包给服务器时，服务器底层的tcp接收缓冲区收到的数据为粘连在一起的，如下图所示：</li></ul><p><img src="../assets/C++asio网络编程/image-3.png" alt="示例图片" style="zoom:100%;" /></p><ul><li>当客户端发送两个Hello World！给服务器，服务器TCP接收缓冲区接收了两次，一次是Hello World!Hello, 第二次是World！。</li></ul><h3 id="粘包原因"><a href="#粘包原因" class="headerlink" title="粘包原因"></a>粘包原因</h3><ul><li>因为TCP底层通信是面向字节流的，TCP只保证发送数据的准确性和顺序性，字节流以字节为单位，客户端每次发送N个字节给服务端，N取决于当前客户端的发送缓冲区是否有数据，比如发送缓冲区总大小为10个字节，当前有5个字节数据(上次要发送的数据比如’loveu’)未发送完，那么此时只有5个字节空闲空间，我们调用发送接口发送hello world！其实就是只能发送Hello给服务器，那么服务器一次性读取到的数据就很可能是loveuhello。而剩余的world！只能留给下一次发送，下一次服务器接收到的就是world！如下图：</li></ul><p><img src="../assets/C++asio网络编程/image-4.png" alt="示例图片" style="zoom:100%;" /></p><ul><li>这是最好理解的粘包问题的产生原因。还有一些其他的原因比如<ol><li>客户端的发送频率远高于服务器的接收频率，就会导致数据在服务器的tcp接收缓冲区滞留形成粘连，比如客户端1s内连续发送了两个hello world！,服务器过了2s才接收数据，那一次性读出两个hello world！。</li><li>tcp底层的安全和效率机制不允许字节数特别少的小包发送频率过高，tcp会在底层累计数据长度到一定大小才一起发送，比如连续发送1字节的数据要累计到多个字节才发送，可以了解下tcp底层的Nagle算法。</li><li>再就是我们提到的最简单的情况，发送端缓冲区有上次未发送完的数据或者接收端的缓冲区里有未取出的数据导致数据粘连。</li></ol></li></ul><h3 id="处理粘包"><a href="#处理粘包" class="headerlink" title="处理粘包"></a>处理粘包</h3><ul><li>处理粘包的方式主要采用应用层定义收发包格式的方式，这个过程俗称切包处理，常用的协议被称为tlv协议(消息id+消息长度+消息内容)，如下图：</li></ul><p><img src="../assets/C++asio网络编程/image-5.png" alt="示例图片" style="zoom:100%;" /></p><ul><li>为保证大家容易理解，我们先简化发送的格式，格式变为消息长度+消息内容的方式，之后再完善为tlv格式。</li><li>简化后的结构如下图：</li></ul><p><img src="../assets/C++asio网络编程/image-6.png" alt="示例图片" style="zoom:100%;" /></p><h3 id="完善消息节点"><a href="#完善消息节点" class="headerlink" title="完善消息节点"></a>完善消息节点</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/uuid/uuid_io.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/uuid/uuid_generators.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MAX_LENGTH = <span class="number">1024</span> * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> HEAD_LENGTH = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MsgNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//用来构造发送节点</span></span><br><span class="line"><span class="built_in">MsgNode</span>(<span class="type">char</span>* msg, <span class="type">short</span> max_len):_total_len(max_len + HEAD_LENGTN), _cur_len(<span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 要多留一个空间存/0</span></span><br><span class="line">_data = <span class="keyword">new</span> <span class="type">char</span>[_total_len + <span class="number">1</span>];</span><br><span class="line"><span class="comment">// 将前两个字节赋值为长度</span></span><br><span class="line"><span class="built_in">memcpy</span>(_data, &amp;max_len, HEAD_LENGTN);</span><br><span class="line"><span class="comment">//偏移两个字节存数据长度</span></span><br><span class="line"><span class="built_in">memcpy</span>(_data + HEAD_LENGTN, msg, max_len);</span><br><span class="line">_data[_total_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">MsgNode</span>(<span class="type">short</span> max_len):_total_len(max_len), _cur_len(<span class="number">0</span>) &#123;</span><br><span class="line">_data = <span class="keyword">new</span> <span class="type">char</span>[_total_len + <span class="number">1</span>]();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">MsgNode</span>() &#123;</span><br><span class="line"><span class="keyword">delete</span>[] _data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">::<span class="built_in">memset</span>(_data, <span class="number">0</span>, _total_len);</span><br><span class="line">_cur_len = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//已发送的数据</span></span><br><span class="line"><span class="type">int</span> _cur_len;</span><br><span class="line"><span class="comment">//总共需要发送的数据</span></span><br><span class="line"><span class="type">int</span> _total_len;</span><br><span class="line"><span class="comment">//存取数据的数组</span></span><br><span class="line"><span class="type">char</span>* _data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>两个参数的构造函数做了完善，之前的构造函数通过消息首地址和长度构造节点数据，现在需要在构造节点的同时把长度信息也写入节点,该构造函数主要用来发送数据时构造发送信息的节点。</li><li>一个参数的构造函数为较上次新增的，主要根据消息的长度构造消息节点，该构造函数主要是接收对端数据时构造接收节点调用的。</li><li>新增一个Clear函数清除消息节点的数据，主要是避免多次构造节点造成开销。</li></ol><ul><li>数据这么传输</li></ul><p><img src="../assets/C++asio网络编程/image-7.png" alt="示例图片" style="zoom:100%;" /></p><h3 id="CSession类完善"><a href="#CSession类完善" class="headerlink" title="CSession类完善"></a>CSession类完善</h3><ul><li>为能够对收到的数据切包处理，需要定义一个消息接收节点，一个bool类型的变量表示头部是否解析完成，以及将处理好的头部先缓存起来的结构。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//收到的消息结构</span></span><br><span class="line">std::shared_ptr&lt;MsgNode&gt; _recv_msg_node;</span><br><span class="line"><span class="comment">// 表示头部结构是否接收完</span></span><br><span class="line"><span class="type">bool</span> _b_head_parse;</span><br><span class="line"><span class="comment">//收到的头部结构</span></span><br><span class="line">std::shared_ptr&lt;MsgNode&gt; _recv_head_node;</span><br></pre></td></tr></table></figure><ul><li>_recv_msg_node用来存储接受的消息体信息</li><li>_recv_head_node用来存储接收的头部信息</li><li><p>_b_head_parse表示是否处理完头部信息</p></li><li><p>同时我们新增一个HEAD_LENGTH变量表示数据包头部的大小，修改原消息最大长度为1024*2</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MAX_LENGTH = <span class="number">1024</span> * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> HEAD_LENGTN = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><ul><li>修改完后的头文件</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/uuid/uuid_generators.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/uuid/uuid_io.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MsgNode.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CServer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CServer</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CSession</span>: <span class="keyword">public</span> std::enable_shared_from_this&lt;CSession&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">CSession</span>(boost::asio::io_context&amp; ioc, CServer* server);</span><br><span class="line"></span><br><span class="line">~<span class="built_in">CSession</span>();</span><br><span class="line"></span><br><span class="line">boost::asio::ip::<span class="function">tcp::socket&amp; <span class="title">GetSocket</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> sock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string&amp; <span class="title">GetUuid</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> _uuid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Close</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">std::shared_ptr&lt;CSession&gt; <span class="title">SharedSelf</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送接口</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Send</span><span class="params">(<span class="type">char</span>* msg, <span class="type">int</span> max_length)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HandleRead</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">size_t</span> bytes_transferred, std::shared_ptr&lt;CSession&gt; _self_shared)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HandleWrite</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec, std::shared_ptr&lt;CSession&gt; _self_shared)</span></span>;</span><br><span class="line">boost::asio::ip::tcp::socket sock;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个为socket接收数据时候先存入的</span></span><br><span class="line"><span class="type">char</span> _data[MAX_LENGTH];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储唯一标识</span></span><br><span class="line">std::string _uuid;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指向CServer的指针</span></span><br><span class="line">CServer* _server;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送队列</span></span><br><span class="line">std::queue&lt;std::shared_ptr&lt;MsgNode&gt;&gt; _send_que;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保证多线程的安全性</span></span><br><span class="line">std::mutex _send_lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">//收到的消息结构，也就是完整的数据</span></span><br><span class="line">std::shared_ptr&lt;MsgNode&gt; _recv_msg_node;</span><br><span class="line"><span class="comment">// 表示头部结构是否接收完</span></span><br><span class="line"><span class="type">bool</span> _b_head_parse;</span><br><span class="line"><span class="comment">//收到的头部结构，也就是完整的数据长度</span></span><br><span class="line">std::shared_ptr&lt;MsgNode&gt; _recv_head_node;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于标记是否关闭</span></span><br><span class="line"><span class="type">bool</span> _b_close;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="完善接收逻辑"><a href="#完善接收逻辑" class="headerlink" title="完善接收逻辑"></a>完善接收逻辑</h3><ul><li>需要修改HandleRead函数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第二个参数为你接收到的需要读的字节数，第三个参数增加引用计数，防止未处理为就被析构以及二次析构问题</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::HandleRead</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, <span class="type">size_t</span>  bytes_transferred, std::shared_ptr&lt;CSession&gt; shared_self)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        <span class="comment">//已经存入数组的字符数</span></span><br><span class="line">        <span class="type">int</span> copy_len = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 需要读的字节数大于0</span></span><br><span class="line">        <span class="keyword">while</span> (bytes_transferred &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 头部结构未被处理完</span></span><br><span class="line">            <span class="keyword">if</span> (!_b_head_parse) &#123;</span><br><span class="line">                <span class="comment">//收到的数据不足头部大小（待接收的数据字节数加上当前接收完的字节数小于头部结构（两字节））</span></span><br><span class="line">                <span class="keyword">if</span> (bytes_transferred + _recv_head_node-&gt;_cur_len &lt; HEAD_LENGTH) &#123;</span><br><span class="line">                    <span class="comment">//拷贝接收到的头部大小</span></span><br><span class="line">                    <span class="built_in">memcpy</span>(_recv_head_node-&gt;_data + _recv_head_node-&gt;_cur_len, _data + copy_len, bytes_transferred);</span><br><span class="line">                    <span class="comment">//更新已经接收到的字节数</span></span><br><span class="line">                    _recv_head_node-&gt;_cur_len += bytes_transferred;</span><br><span class="line">                    <span class="comment">//将接收数组清空</span></span><br><span class="line">                    ::<span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);</span><br><span class="line">                    <span class="comment">//继续监听读事件</span></span><br><span class="line">                    sock.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, MAX_LENGTH),</span><br><span class="line">                        std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//收到的数据比头部多</span></span><br><span class="line">                <span class="comment">//头部剩余未复制的长度，剩余可能为0 可能&gt;0，不可能&lt;0</span></span><br><span class="line">                <span class="type">int</span> head_remain = HEAD_LENGTH - _recv_head_node-&gt;_cur_len;</span><br><span class="line">                <span class="comment">//将头部补充完整</span></span><br><span class="line">                <span class="built_in">memcpy</span>(_recv_head_node-&gt;_data + _recv_head_node-&gt;_cur_len, _data + copy_len, head_remain);</span><br><span class="line">                <span class="comment">//更新已处理的data长度和剩余未处理的长度</span></span><br><span class="line">                copy_len += head_remain;</span><br><span class="line">                bytes_transferred -= head_remain;</span><br><span class="line">                <span class="comment">//获取头部数据</span></span><br><span class="line">                <span class="type">short</span> data_len = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">//把两字节的数据拷贝出来，得到实际数据的长度</span></span><br><span class="line">                <span class="built_in">memcpy</span>(&amp;data_len, _recv_head_node-&gt;_data, HEAD_LENGTH);</span><br><span class="line"></span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;data_len is &quot;</span> &lt;&lt; data_len &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//头部长度非法</span></span><br><span class="line">                <span class="keyword">if</span> (data_len &gt; MAX_LENGTH) &#123;</span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot;invalid data length is &quot;</span> &lt;&lt; data_len &lt;&lt; std::endl;</span><br><span class="line">                    <span class="comment">//断开连接</span></span><br><span class="line">                    _server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//头部长度合法的话继续执行，接收一个short，构造一个接收节点</span></span><br><span class="line">                _recv_msg_node = std::<span class="built_in">make_shared</span>&lt;MsgNode&gt;(data_len);</span><br><span class="line">                <span class="comment">//消息的长度小于头部规定的长度，说明数据未收全，则先将部分消息放到接收节点里</span></span><br><span class="line">                <span class="keyword">if</span> (bytes_transferred &lt; data_len) &#123;</span><br><span class="line">                    <span class="comment">//先缓存数据道接收节点里</span></span><br><span class="line">                    <span class="built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, bytes_transferred);</span><br><span class="line">                    _recv_msg_node-&gt;_cur_len += bytes_transferred;</span><br><span class="line">                    ::<span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);</span><br><span class="line">                    <span class="comment">//继续监听读事件</span></span><br><span class="line">                    sock.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, MAX_LENGTH),</span><br><span class="line">                        std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));</span><br><span class="line">                    <span class="comment">//头部处理完成</span></span><br><span class="line">                    _b_head_parse = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//消息的长度大于等于头部规定的长度，说明数据粘包了，并且由于进入此逻辑时，头部节点刚被处理完，剩下的一定是接收的数据且能一次性读完</span></span><br><span class="line">                <span class="built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, data_len);</span><br><span class="line"></span><br><span class="line">                _recv_msg_node-&gt;_cur_len += data_len;</span><br><span class="line">                copy_len += data_len;</span><br><span class="line">                bytes_transferred -= data_len;</span><br><span class="line">                _recv_msg_node-&gt;_data[_recv_msg_node-&gt;_total_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;receive data is &quot;</span> &lt;&lt; _recv_msg_node-&gt;_data &lt;&lt; std::endl;</span><br><span class="line">                <span class="comment">//此处可以调用Send发送测试</span></span><br><span class="line">                <span class="built_in">Send</span>(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//继续轮询剩余未处理数据，也就是处理粘包的数据</span></span><br><span class="line">                _b_head_parse = <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">//清空接收节点</span></span><br><span class="line">                _recv_head_node-&gt;<span class="built_in">Clear</span>();</span><br><span class="line">                <span class="comment">//如果待接收的数据字节数小于等于0，也就是处理完了接收到的所有数据</span></span><br><span class="line">                <span class="keyword">if</span> (bytes_transferred &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//清空接收数据的数组</span></span><br><span class="line">                    ::<span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);</span><br><span class="line">                    sock.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, MAX_LENGTH),</span><br><span class="line">                        std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//继续循环</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//已经处理完头部，处理上次未接受完的消息数据</span></span><br><span class="line">            <span class="comment">//得到剩余未处理的数据总字节数</span></span><br><span class="line">            <span class="type">int</span> remain_msg = _recv_msg_node-&gt;_total_len - _recv_msg_node-&gt;_cur_len;</span><br><span class="line">            <span class="comment">//待接收的数据小于剩余数据总量，bytes_trabsferred就是表示_data里数据剩余未读取的数据</span></span><br><span class="line">            <span class="keyword">if</span> (bytes_transferred &lt; remain_msg) &#123;</span><br><span class="line">                <span class="comment">//继续装数据</span></span><br><span class="line">                <span class="built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, bytes_transferred);</span><br><span class="line">                <span class="comment">//更新当前已经缓冲的数据量</span></span><br><span class="line">                _recv_msg_node-&gt;_cur_len += bytes_transferred;</span><br><span class="line">                <span class="comment">//因为此时已经处理完_data里的数据了 所以可以直接清零，继续处理</span></span><br><span class="line">                ::<span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);</span><br><span class="line">                sock.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, MAX_LENGTH),</span><br><span class="line">                    std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//待接收的数据大于等于剩余数据总量的话，也就是说此次处理后，仍有剩余数据未被缓存，出现了粘包问题</span></span><br><span class="line">            <span class="built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, remain_msg);</span><br><span class="line">            _recv_msg_node-&gt;_cur_len += remain_msg;</span><br><span class="line">            bytes_transferred -= remain_msg;</span><br><span class="line">            <span class="comment">//更新_data里被读取的位置</span></span><br><span class="line">            copy_len += remain_msg;</span><br><span class="line">            <span class="comment">//数据已经接收完整，此时节点里存的是完整数据可以发送</span></span><br><span class="line">            _recv_msg_node-&gt;_data[_recv_msg_node-&gt;_total_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;receive data is &quot;</span> &lt;&lt; _recv_msg_node-&gt;_data &lt;&lt; std::endl;</span><br><span class="line">            <span class="comment">//此处可以调用Send发送测试</span></span><br><span class="line">            <span class="built_in">Send</span>(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len);</span><br><span class="line">            <span class="comment">//继续轮询剩余未处理数据</span></span><br><span class="line">            _b_head_parse = <span class="literal">false</span>;</span><br><span class="line">            _recv_head_node-&gt;<span class="built_in">Clear</span>();</span><br><span class="line">            <span class="keyword">if</span> (bytes_transferred &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                ::<span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);</span><br><span class="line">                sock.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, MAX_LENGTH),</span><br><span class="line">                    std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;handle read failed, error is &quot;</span> &lt;&lt; error.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">//Close();</span></span><br><span class="line">        _server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>copy_len记录的是已经处理过数据的长度，因为存在一次接收多个包的情况，所以copy_len用来做已经处理的数据长度的。</li><li>首先判断_b_head_parse是否为false，如果为false则说明头部未处理，先判断接收的数据是否小于头部, 如果小于头部大小则将接收到的数据放入_recv_head_node节点保存，然后继续调用读取函数监听对端发送数据。否则进入步骤3.</li><li>如果收到的数据比头部多，可能是多个逻辑包，所以要做切包处理。根据之前保留在_recv_head_node的长度，计算出剩余未取出的头部长度，然后取出剩余的头部长度保存在_recv_head_node节点，然后通过memcpy方式从节点拷贝出数据写入short类型的data_len里，进而获取消息的长度。接下来继续处理包体，也就是消息体，判断接收到的数据未处理部分的长度和总共要接收的数据长度大小，如果小于总共要接受的长度，说明消息体没接收完，则将未处理部分先写入_recv_msg_node里，并且继续监听读事件。否则说明消息体接收完全，进入步骤4</li><li>将消息体数据接收到_recv_msg_node中，接受完全后返回给对端。当然存在多个逻辑包粘连，此时要判断bytes_transferred是否小于等于0，如果是说明只有一个逻辑包，我们处理完了，继续监听读事件，就直接返回即可。否则说明有多个数据包粘连，就继续执行上述操作。</li><li>因为存在_b_head_parse为true，也就是包头接收并处理完的情况，但是包体未接受完，再次触发HandleRead，此时要继续处理上次未接受完的消息体，大体逻辑和3，4一样。</li></ol><ul><li>以上就是处理粘包的过程，我们绘制流程图更明了一些</li></ul><p><img src="../assets/C++asio网络编程/image-8.png" alt="示例图片" style="zoom:100%;" /></p><h3 id="服务端完整代码"><a href="#服务端完整代码" class="headerlink" title="服务端完整代码"></a>服务端完整代码</h3><h4 id="CSession头文件"><a href="#CSession头文件" class="headerlink" title="CSession头文件"></a>CSession头文件</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/uuid/uuid_generators.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/uuid/uuid_io.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MsgNode.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CServer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CServer</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CSession</span>: <span class="keyword">public</span> std::enable_shared_from_this&lt;CSession&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">CSession</span>(boost::asio::io_context&amp; ioc, CServer* server);</span><br><span class="line"></span><br><span class="line">~<span class="built_in">CSession</span>();</span><br><span class="line"></span><br><span class="line">boost::asio::ip::<span class="function">tcp::socket&amp; <span class="title">GetSocket</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> sock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string&amp; <span class="title">GetUuid</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> _uuid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Close</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">std::shared_ptr&lt;CSession&gt; <span class="title">SharedSelf</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送接口</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Send</span><span class="params">(<span class="type">char</span>* msg, <span class="type">int</span> max_length)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HandleRead</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">size_t</span> bytes_transferred, std::shared_ptr&lt;CSession&gt; _self_shared)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HandleWrite</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec, std::shared_ptr&lt;CSession&gt; _self_shared)</span></span>;</span><br><span class="line">boost::asio::ip::tcp::socket sock;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个为socket接收数据时候先存入的</span></span><br><span class="line"><span class="type">char</span> _data[MAX_LENGTH];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储唯一标识</span></span><br><span class="line">std::string _uuid;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指向CServer的指针</span></span><br><span class="line">CServer* _server;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送队列</span></span><br><span class="line">std::queue&lt;std::shared_ptr&lt;MsgNode&gt;&gt; _send_que;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保证多线程的安全性</span></span><br><span class="line">std::mutex _send_lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">//收到的消息结构，也就是完整的数据</span></span><br><span class="line">std::shared_ptr&lt;MsgNode&gt; _recv_msg_node;</span><br><span class="line"><span class="comment">// 表示头部结构是否接收完</span></span><br><span class="line"><span class="type">bool</span> _b_head_parse;</span><br><span class="line"><span class="comment">//收到的头部结构，也就是完整的数据长度</span></span><br><span class="line">std::shared_ptr&lt;MsgNode&gt; _recv_head_node;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于标记是否关闭</span></span><br><span class="line"><span class="type">bool</span> _b_close;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="CSession-实现"><a href="#CSession-实现" class="headerlink" title="CSession 实现"></a>CSession 实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CSession.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line">CSession::<span class="built_in">CSession</span>(boost::asio::io_context&amp; io_context, CServer* server) :</span><br><span class="line">    <span class="built_in">sock</span>(io_context), _server(server), _b_close(<span class="literal">false</span>), _b_head_parse(<span class="literal">false</span>) &#123;</span><br><span class="line">    boost::uuids::uuid  a_uuid = boost::uuids::<span class="built_in">random_generator</span>()();</span><br><span class="line">    _uuid = boost::uuids::<span class="built_in">to_string</span>(a_uuid);</span><br><span class="line">    _recv_head_node = std::<span class="built_in">make_shared</span>&lt;MsgNode&gt;(HEAD_LENGTH);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CSession::~<span class="built_in">CSession</span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;~CSession destruct &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::Send</span><span class="params">(<span class="type">char</span>* msg, <span class="type">int</span> max_length)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//pending 为false表示发送缓冲区是空的</span></span><br><span class="line">    <span class="type">bool</span> pending = <span class="literal">false</span>;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_send_lock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!_send_que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        pending = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _send_que.<span class="built_in">push</span>(std::<span class="built_in">make_shared</span>&lt;MsgNode&gt;(msg, max_length));</span><br><span class="line">    <span class="keyword">if</span> (pending) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">auto</span>&amp; msgnode = _send_que.<span class="built_in">front</span>();</span><br><span class="line">    boost::asio::<span class="built_in">async_write</span>(sock, boost::asio::<span class="built_in">buffer</span>(msgnode-&gt;_data, msgnode-&gt;_total_len),</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;CSession::HandleWrite, <span class="keyword">this</span>, std::placeholders::_1, <span class="built_in">shared_from_this</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::Start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);</span><br><span class="line">    <span class="comment">// 错误用法, 因为会生成两个shared_ptr来管理同一块内存，他们两的引用计数可能不同</span></span><br><span class="line">  <span class="comment">/*  sock.async_read_some(boost::asio::buffer(_data, max_length),</span></span><br><span class="line"><span class="comment">        std::bind(&amp;CSession::handle_read, this, std::placeholders::_1, std::placeholders::_2, std::shared_ptr&lt;CSession&gt;(this)));*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//正确用法，使用 std::shared_from_this()需要继承std::enable_shared_from_this&lt;CSession&gt; 模板类</span></span><br><span class="line">    <span class="comment">//shared_from_this()内部实现是返回一个智能指针，和存在的智能指针去同步</span></span><br><span class="line">    sock.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, MAX_LENGTH),</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, <span class="built_in">shared_from_this</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::Close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//关闭套接字</span></span><br><span class="line">    sock.<span class="built_in">close</span>();</span><br><span class="line">    _b_close = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::shared_ptr&lt;CSession&gt; <span class="title">CSession::SharedSelf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">shared_from_this</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二个参数为你接收到的需要读的字节数，第三个参数增加引用计数，防止未处理为就被析构以及二次析构问题</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::HandleRead</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, <span class="type">size_t</span>  bytes_transferred, std::shared_ptr&lt;CSession&gt; shared_self)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        <span class="comment">//已经存入数组的字符数</span></span><br><span class="line">        <span class="type">int</span> copy_len = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 需要读的字节数大于0</span></span><br><span class="line">        <span class="keyword">while</span> (bytes_transferred &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 头部结构未被处理完</span></span><br><span class="line">            <span class="keyword">if</span> (!_b_head_parse) &#123;</span><br><span class="line">                <span class="comment">//收到的数据不足头部大小（待接收的数据字节数加上当前接收完的字节数小于头部结构（两字节））</span></span><br><span class="line">                <span class="keyword">if</span> (bytes_transferred + _recv_head_node-&gt;_cur_len &lt; HEAD_LENGTH) &#123;</span><br><span class="line">                    <span class="comment">//拷贝接收到的头部大小</span></span><br><span class="line">                    <span class="built_in">memcpy</span>(_recv_head_node-&gt;_data + _recv_head_node-&gt;_cur_len, _data + copy_len, bytes_transferred);</span><br><span class="line">                    <span class="comment">//更新已经接收到的字节数</span></span><br><span class="line">                    _recv_head_node-&gt;_cur_len += bytes_transferred;</span><br><span class="line">                    <span class="comment">//将接收数组清空</span></span><br><span class="line">                    ::<span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);</span><br><span class="line">                    <span class="comment">//继续监听读事件</span></span><br><span class="line">                    sock.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, MAX_LENGTH),</span><br><span class="line">                        std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//收到的数据比头部多</span></span><br><span class="line">                <span class="comment">//头部剩余未复制的长度，剩余可能为0 可能&gt;0，不可能&lt;0</span></span><br><span class="line">                <span class="type">int</span> head_remain = HEAD_LENGTH - _recv_head_node-&gt;_cur_len;</span><br><span class="line">                <span class="comment">//将头部补充完整</span></span><br><span class="line">                <span class="built_in">memcpy</span>(_recv_head_node-&gt;_data + _recv_head_node-&gt;_cur_len, _data + copy_len, head_remain);</span><br><span class="line">                <span class="comment">//更新已处理的data长度和剩余未处理的长度</span></span><br><span class="line">                copy_len += head_remain;</span><br><span class="line">                bytes_transferred -= head_remain;</span><br><span class="line">                <span class="comment">//获取头部数据</span></span><br><span class="line">                <span class="type">short</span> data_len = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">//把两字节的数据拷贝出来，得到实际数据的长度</span></span><br><span class="line">                <span class="built_in">memcpy</span>(&amp;data_len, _recv_head_node-&gt;_data, HEAD_LENGTH);</span><br><span class="line"></span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;data_len is &quot;</span> &lt;&lt; data_len &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//头部长度非法</span></span><br><span class="line">                <span class="keyword">if</span> (data_len &gt; MAX_LENGTH) &#123;</span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot;invalid data length is &quot;</span> &lt;&lt; data_len &lt;&lt; std::endl;</span><br><span class="line">                    <span class="comment">//断开连接</span></span><br><span class="line">                    _server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//头部长度合法的话继续执行，接收一个short，构造一个接收节点</span></span><br><span class="line">                _recv_msg_node = std::<span class="built_in">make_shared</span>&lt;MsgNode&gt;(data_len);</span><br><span class="line">                <span class="comment">//消息的长度小于头部规定的长度，说明数据未收全，则先将部分消息放到接收节点里</span></span><br><span class="line">                <span class="keyword">if</span> (bytes_transferred &lt; data_len) &#123;</span><br><span class="line">                    <span class="comment">//先缓存数据道接收节点里</span></span><br><span class="line">                    <span class="built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, bytes_transferred);</span><br><span class="line">                    _recv_msg_node-&gt;_cur_len += bytes_transferred;</span><br><span class="line">                    ::<span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);</span><br><span class="line">                    <span class="comment">//继续监听读事件</span></span><br><span class="line">                    sock.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, MAX_LENGTH),</span><br><span class="line">                        std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));</span><br><span class="line">                    <span class="comment">//头部处理完成</span></span><br><span class="line">                    _b_head_parse = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//消息的长度大于等于头部规定的长度，说明数据粘包了，并且由于进入此逻辑时，头部节点刚被处理完，剩下的一定是接收的数据且能一次性读完</span></span><br><span class="line">                <span class="built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, data_len);</span><br><span class="line"></span><br><span class="line">                _recv_msg_node-&gt;_cur_len += data_len;</span><br><span class="line">                copy_len += data_len;</span><br><span class="line">                bytes_transferred -= data_len;</span><br><span class="line">                _recv_msg_node-&gt;_data[_recv_msg_node-&gt;_total_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;receive data is &quot;</span> &lt;&lt; _recv_msg_node-&gt;_data &lt;&lt; std::endl;</span><br><span class="line">                <span class="comment">//此处可以调用Send发送测试</span></span><br><span class="line">                <span class="built_in">Send</span>(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//继续轮询剩余未处理数据，也就是处理粘包的数据</span></span><br><span class="line">                _b_head_parse = <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">//清空接收节点</span></span><br><span class="line">                _recv_head_node-&gt;<span class="built_in">Clear</span>();</span><br><span class="line">                <span class="comment">//如果待接收的数据字节数小于等于0，也就是处理完了接收到的所有数据</span></span><br><span class="line">                <span class="keyword">if</span> (bytes_transferred &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//清空接收数据的数组</span></span><br><span class="line">                    ::<span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);</span><br><span class="line">                    sock.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, MAX_LENGTH),</span><br><span class="line">                        std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//继续循环</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//已经处理完头部，处理上次未接受完的消息数据</span></span><br><span class="line">            <span class="comment">//得到剩余未处理的数据总字节数</span></span><br><span class="line">            <span class="type">int</span> remain_msg = _recv_msg_node-&gt;_total_len - _recv_msg_node-&gt;_cur_len;</span><br><span class="line">            <span class="comment">//待接收的数据小于剩余数据总量，bytes_trabsferred就是表示_data里数据剩余未读取的数据</span></span><br><span class="line">            <span class="keyword">if</span> (bytes_transferred &lt; remain_msg) &#123;</span><br><span class="line">                <span class="comment">//继续装数据</span></span><br><span class="line">                <span class="built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, bytes_transferred);</span><br><span class="line">                <span class="comment">//更新当前已经缓冲的数据量</span></span><br><span class="line">                _recv_msg_node-&gt;_cur_len += bytes_transferred;</span><br><span class="line">                <span class="comment">//因为此时已经处理完_data里的数据了 所以可以直接清零，继续处理</span></span><br><span class="line">                ::<span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);</span><br><span class="line">                sock.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, MAX_LENGTH),</span><br><span class="line">                    std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//待接收的数据大于等于剩余数据总量的话，也就是说此次处理后，仍有剩余数据未被缓存，出现了粘包问题</span></span><br><span class="line">            <span class="built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, remain_msg);</span><br><span class="line">            _recv_msg_node-&gt;_cur_len += remain_msg;</span><br><span class="line">            bytes_transferred -= remain_msg;</span><br><span class="line">            <span class="comment">//更新_data里被读取的位置</span></span><br><span class="line">            copy_len += remain_msg;</span><br><span class="line">            <span class="comment">//数据已经接收完整，此时节点里存的是完整数据可以发送</span></span><br><span class="line">            _recv_msg_node-&gt;_data[_recv_msg_node-&gt;_total_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;receive data is &quot;</span> &lt;&lt; _recv_msg_node-&gt;_data &lt;&lt; std::endl;</span><br><span class="line">            <span class="comment">//此处可以调用Send发送测试</span></span><br><span class="line">            <span class="built_in">Send</span>(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len);</span><br><span class="line">            <span class="comment">//继续轮询剩余未处理数据</span></span><br><span class="line">            _b_head_parse = <span class="literal">false</span>;</span><br><span class="line">            _recv_head_node-&gt;<span class="built_in">Clear</span>();</span><br><span class="line">            <span class="keyword">if</span> (bytes_transferred &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                ::<span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);</span><br><span class="line">                sock.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, MAX_LENGTH),</span><br><span class="line">                    std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;handle read failed, error is &quot;</span> &lt;&lt; error.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">//Close();</span></span><br><span class="line">        _server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::HandleWrite</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, std::shared_ptr&lt;CSession&gt; _self_shared)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_send_lock)</span></span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;send data &quot;</span> &lt;&lt; _send_que.<span class="built_in">front</span>()-&gt;_data + HEAD_LENGTH &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">//因为使用的是async_write，数据一定被发送玩所以可以直接出队</span></span><br><span class="line">        _send_que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (!_send_que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span>&amp; msgnode = _send_que.<span class="built_in">front</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; msgnode-&gt;_total_len; i++) std::cout &lt;&lt; msgnode-&gt;_data[i + <span class="number">2</span>];</span><br><span class="line">            boost::asio::<span class="built_in">async_write</span>(sock, boost::asio::<span class="built_in">buffer</span>(msgnode-&gt;_data, msgnode-&gt;_total_len),</span><br><span class="line">                std::<span class="built_in">bind</span>(&amp;CSession::HandleWrite, <span class="keyword">this</span>, std::placeholders::_1, _self_shared));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;handle write failed, error is &quot;</span> &lt;&lt; error.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">Close</span>();</span><br><span class="line">        _server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CServer头文件"><a href="#CServer头文件" class="headerlink" title="CServer头文件"></a>CServer头文件</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CSession.h&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CSession</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CServer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CServer</span>(boost::asio::io_context&amp; ioc, <span class="type">unsigned</span> <span class="type">short</span> port);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ClearSession</span><span class="params">(std::string&amp; uuid)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">HandleAccept</span><span class="params">(std::shared_ptr&lt;CSession&gt;, <span class="type">const</span> boost::system::error_code&amp; error)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">StartAccept</span><span class="params">()</span></span>;</span><br><span class="line">    boost::asio::io_context&amp; _ioc;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> port;</span><br><span class="line">    boost::asio::ip::tcp::acceptor _acceptor;</span><br><span class="line">    std::map&lt;std::string, std::shared_ptr&lt;CSession&gt;&gt; _sessions;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="CServer实现"><a href="#CServer实现" class="headerlink" title="CServer实现"></a>CServer实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CServer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CServer::StartAccept</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;CSession&gt; new_session = std::<span class="built_in">make_shared</span>&lt;CSession&gt;(_ioc, <span class="keyword">this</span>);</span><br><span class="line">    _acceptor.<span class="built_in">async_accept</span>(new_session-&gt;<span class="built_in">GetSocket</span>(), std::<span class="built_in">bind</span>(&amp;CServer::HandleAccept, <span class="keyword">this</span>, new_session, std::placeholders::_1));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CServer::HandleAccept</span><span class="params">(std::shared_ptr&lt;CSession&gt; new_session, <span class="type">const</span> boost::system::error_code&amp; error)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        new_session-&gt;<span class="built_in">Start</span>();</span><br><span class="line">        <span class="comment">//将session加入map</span></span><br><span class="line">        _sessions.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(new_session-&gt;<span class="built_in">GetUuid</span>(), new_session));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;session accept failed, error is &quot;</span> &lt;&lt; error.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">StartAccept</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CServer::ClearSession</span><span class="params">(std::string&amp; uuid)</span> </span>&#123;</span><br><span class="line">    _sessions.<span class="built_in">erase</span>(uuid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CServer::<span class="built_in">CServer</span>(boost::asio::io_context&amp; ioc, <span class="type">unsigned</span> <span class="type">short</span> port) : _ioc(ioc), _acceptor(ioc, boost::asio::ip::tcp::<span class="built_in">endpoint</span>(boost::asio::ip::tcp::<span class="built_in">v4</span>(), port)) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Server start success, on port: &quot;</span> &lt;&lt; port &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">StartAccept</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="MsgNode"><a href="#MsgNode" class="headerlink" title="MsgNode"></a>MsgNode</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/uuid/uuid_io.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/uuid/uuid_generators.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MAX_LENGTH = <span class="number">1024</span> * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> HEAD_LENGTH = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MsgNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//用来构造发送节点</span></span><br><span class="line"><span class="built_in">MsgNode</span>(<span class="type">char</span>* msg, <span class="type">short</span> max_len):_total_len(max_len + HEAD_LENGTH), _cur_len(<span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 要多留一个空间存/0</span></span><br><span class="line">_data = <span class="keyword">new</span> <span class="type">char</span>[_total_len + <span class="number">1</span>]();</span><br><span class="line"><span class="comment">// 将前两个字节赋值为长度</span></span><br><span class="line"><span class="built_in">memcpy</span>(_data, &amp;max_len, HEAD_LENGTH);</span><br><span class="line"><span class="comment">//偏移两个字节存数据长度</span></span><br><span class="line"><span class="built_in">memcpy</span>(_data + HEAD_LENGTH, msg, max_len);</span><br><span class="line">_data[_total_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用来接收事件</span></span><br><span class="line"><span class="built_in">MsgNode</span>(<span class="type">short</span> max_len):_total_len(max_len), _cur_len(<span class="number">0</span>) &#123;</span><br><span class="line">_data = <span class="keyword">new</span> <span class="type">char</span>[_total_len + <span class="number">1</span>]();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">MsgNode</span>() &#123;</span><br><span class="line"><span class="keyword">delete</span>[] _data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">::<span class="built_in">memset</span>(_data, <span class="number">0</span>, _total_len);</span><br><span class="line">_cur_len = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//已发送的数据</span></span><br><span class="line"><span class="type">short</span> _cur_len;</span><br><span class="line"><span class="comment">//总共需要发送的数据</span></span><br><span class="line"><span class="type">short</span> _total_len;</span><br><span class="line"><span class="comment">//存取数据的数组</span></span><br><span class="line"><span class="type">char</span>* _data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="客户端修改"><a href="#客户端修改" class="headerlink" title="客户端修改"></a>客户端修改</h3><ul><li>客户端的发送也要遵循先发送数据2个字节的数据长度，再发送数据消息的结构。<br>接收时也是先接收两个字节数据获取数据长度，再根据长度接收消息。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::asio::ip;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_LENGTH = <span class="number">1024</span>*<span class="number">2</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> HEAD_LENGTH = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//创建上下文服务</span></span><br><span class="line">boost::asio::io_context   ioc;</span><br><span class="line"><span class="comment">//构造endpoint</span></span><br><span class="line"><span class="function">tcp::endpoint  <span class="title">remote_ep</span><span class="params">(address::from_string(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="number">8888</span>)</span></span>;</span><br><span class="line"><span class="function">tcp::socket  <span class="title">sock</span><span class="params">(ioc)</span></span>;</span><br><span class="line">boost::system::error_code   error = boost::asio::error::host_not_found; ;</span><br><span class="line">sock.<span class="built_in">connect</span>(remote_ep, error);</span><br><span class="line"><span class="keyword">if</span> (error) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;connect failed, code is &quot;</span> &lt;&lt; error.<span class="built_in">value</span>() &lt;&lt; <span class="string">&quot; error msg is &quot;</span> &lt;&lt; error.<span class="built_in">message</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Enter message: &quot;</span>;</span><br><span class="line"><span class="type">char</span> request[MAX_LENGTH];</span><br><span class="line">std::cin.<span class="built_in">getline</span>(request, MAX_LENGTH);</span><br><span class="line"><span class="type">size_t</span> request_length = <span class="built_in">strlen</span>(request);</span><br><span class="line"><span class="type">char</span> send_data[MAX_LENGTH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">memcpy</span>(send_data, &amp;request_length, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(send_data + <span class="number">2</span>, request, request_length);</span><br><span class="line">boost::asio::<span class="built_in">write</span>(sock, boost::asio::<span class="built_in">buffer</span>(send_data, request_length<span class="number">+2</span>));</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> reply_head[HEAD_LENGTH];</span><br><span class="line"><span class="type">size_t</span> reply_length = boost::asio::<span class="built_in">read</span>(sock,boost::asio::<span class="built_in">buffer</span>(reply_head, HEAD_LENGTH));</span><br><span class="line"><span class="type">short</span> msglen = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memcpy</span>(&amp;msglen, reply_head, HEAD_LENGTH);</span><br><span class="line"><span class="type">char</span> msg[MAX_LENGTH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">size_t</span>  msg_length = boost::asio::<span class="built_in">read</span>(sock,boost::asio::<span class="built_in">buffer</span>(msg, msglen));</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Reply is: &quot;</span>;</span><br><span class="line">std::cout.<span class="built_in">write</span>(msg, msglen) &lt;&lt; endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Reply len is &quot;</span> &lt;&lt; msglen;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">std::cerr &lt;&lt; <span class="string">&quot;Exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="粘包测试"><a href="#粘包测试" class="headerlink" title="粘包测试"></a>粘包测试</h3><ul><li><p>为了测试粘包，需要制造粘包产生的现象，可以让客户端发送的频率高一些，服务器接收的频率低一些，这样造成前后端收发数据不一致导致多个数据包在服务器tcp缓冲区滞留产生粘包现象。</p></li><li><p>测试粘包之前，在服务器的CSession类里添加打印二进制数据的函数，便于查看缓冲区的数据</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件#include &lt;iomanip&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::PrintRecvData</span><span class="params">(<span class="type">char</span>* data, <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">    std::stringstream ss;</span><br><span class="line">    std::string result = <span class="string">&quot;0x&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        std::string hexstr;</span><br><span class="line">        ss &lt;&lt; std::hex &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; <span class="built_in">int</span>(data[i]) &lt;&lt; std::endl;</span><br><span class="line">        ss &gt;&gt; hexstr;</span><br><span class="line">        result += hexstr;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;receive raw data is : &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>然后将这个函数放到HandleRead里，每次收到数据就调用这个函数打印接收到的最原始的数据，然后睡眠2秒再进行收发操作，用来延迟接收对端数据制造粘包，之后的逻辑不变</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::HandleRead</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, <span class="type">size_t</span>  bytes_transferred, std::shared_ptr&lt;CSession&gt; shared_self)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        <span class="built_in">PrintRecvData</span>(_data, bytes_transferred);</span><br><span class="line">        std::<span class="function">chrono::milliseconds <span class="title">dura</span><span class="params">(<span class="number">2000</span>)</span></span>;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(dura);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>修改客户端逻辑实现手收发分离</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::asio::ip;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_LENGTH = <span class="number">1024</span>*<span class="number">2</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> HEAD_LENGTH = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//创建上下文服务</span></span><br><span class="line">        boost::asio::io_context   ioc;</span><br><span class="line">        <span class="comment">//构造endpoint</span></span><br><span class="line">        <span class="function">tcp::endpoint  <span class="title">remote_ep</span><span class="params">(address::from_string(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="number">10086</span>)</span></span>;</span><br><span class="line">        <span class="function">tcp::socket  <span class="title">sock</span><span class="params">(ioc)</span></span>;</span><br><span class="line">        boost::system::error_code   error = boost::asio::error::host_not_found; ;</span><br><span class="line">        sock.<span class="built_in">connect</span>(remote_ep, error);</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;connect failed, code is &quot;</span> &lt;&lt; error.<span class="built_in">value</span>() &lt;&lt; <span class="string">&quot; error msg is &quot;</span> &lt;&lt; error.<span class="built_in">message</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//发送数据线程</span></span><br><span class="line">        <span class="function">thread <span class="title">send_thread</span><span class="params">([&amp;sock] &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">for</span> (;;) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="comment">//防止一直占用CPU，使用休眠</span></span></span></span><br><span class="line"><span class="params"><span class="function">                this_thread::sleep_for(std::chrono::milliseconds(<span class="number">2</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">const</span> <span class="type">char</span>* request = <span class="string">&quot;hello world!&quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">size_t</span> request_length = strlen(request);</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">char</span> send_data[MAX_LENGTH] = &#123; <span class="number">0</span> &#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">                memcpy(send_data, &amp;request_length, <span class="number">2</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">                memcpy(send_data + <span class="number">2</span>, request, request_length);</span></span></span><br><span class="line"><span class="params"><span class="function">                boost::asio::write(sock, boost::asio::buffer(send_data, request_length + <span class="number">2</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;)</span></span>;</span><br><span class="line">        <span class="comment">//接收数据线程</span></span><br><span class="line">        <span class="function">thread <span class="title">recv_thread</span><span class="params">([&amp;sock] &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">for</span> (;;) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                this_thread::sleep_for(std::chrono::milliseconds(<span class="number">2</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">                cout &lt;&lt; <span class="string">&quot;begin to receive...&quot;</span> &lt;&lt; endl;</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">char</span> reply_head[HEAD_LENGTH];</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">size_t</span> reply_length = boost::asio::read(sock, boost::asio::buffer(reply_head, HEAD_LENGTH));</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">short</span> msglen = <span class="number">0</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">                memcpy(&amp;msglen, reply_head, HEAD_LENGTH);</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">char</span> msg[MAX_LENGTH] = &#123; <span class="number">0</span> &#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">size_t</span>  msg_length = boost::asio::read(sock, boost::asio::buffer(msg, msglen));</span></span></span><br><span class="line"><span class="params"><span class="function">                std::cout &lt;&lt; <span class="string">&quot;Reply is: &quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">                std::cout.write(msg, msglen) &lt;&lt; endl;</span></span></span><br><span class="line"><span class="params"><span class="function">                std::cout &lt;&lt; <span class="string">&quot;Reply len is &quot;</span> &lt;&lt; msglen;</span></span></span><br><span class="line"><span class="params"><span class="function">                std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;)</span></span>;</span><br><span class="line">        send_thread.<span class="built_in">join</span>();</span><br><span class="line">        recv_thread.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="目前服务端通信流程图"><a href="#目前服务端通信流程图" class="headerlink" title="目前服务端通信流程图"></a>目前服务端通信流程图</h3><p><img src="../assets/C++asio网络编程/image-10.png" alt="示例图片" style="zoom:100%;" /></p><h3 id="io-context"><a href="#io-context" class="headerlink" title="io_context"></a>io_context</h3><ul><li>里面维护了一个队列，会把注册的回调函数以及读写函数写入队列中</li></ul><h2 id="字节序处理和发送队列控制"><a href="#字节序处理和发送队列控制" class="headerlink" title="字节序处理和发送队列控制"></a>字节序处理和发送队列控制</h2><h3 id="字节序问题"><a href="#字节序问题" class="headerlink" title="字节序问题"></a>字节序问题</h3><ul><li><p>在计算机网络中，由于不同的计算机使用的 CPU 架构和字节顺序可能不同，因此在传输数据时需要对数据的字节序进行统一，以保证数据能够正常传输和解析。这就是网络字节序的作用。</p></li><li><p>具体来说，计算机内部存储数据的方式有两种：大端序（Big-Endian）和小端序（Little-Endian）。在大端序中，高位字节存储在低地址处，而低位字节存储在高地址处；在小端序中，高位字节存储在高地址处，而低位字节存储在低地址处。</p></li><li><p>在网络通信过程中，通常使用的是大端序。这是因为早期的网络硬件大多采用了 Motorola 处理器，而 Motorola 处理器使用的是大端序。此外，大多数网络协议规定了网络字节序必须为大端序。</p></li><li><p>因此，在进行网络编程时，需要将主机字节序转换为网络字节序，也就是将数据从本地字节序转换为大端序。可以使用诸如 htonl、htons、ntohl 和 ntohs 等函数来实现字节序转换操作。</p></li><li><p>综上所述，网络字节序的主要作用是统一不同计算机间的数据表示方式，以保证数据在网络中的正确传输和解析。</p></li></ul><h3 id="如何区分本机字节序"><a href="#如何区分本机字节序" class="headerlink" title="如何区分本机字节序"></a>如何区分本机字节序</h3><ul><li>如何区分本机字节序，可以通过判断低地址存储的数据是否为低字节数据，如果是则为小端，否则为大端，下面写一段代码讲述这个逻辑</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 判断当前系统的字节序是大端序还是小端序</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_big_endian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (*(<span class="type">char</span>*)&amp;num == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前系统为小端序</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当前系统为大端序</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0x12345678</span>;</span><br><span class="line">    <span class="type">char</span>* p = (<span class="type">char</span>*)&amp;num;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;原始数据：&quot;</span> &lt;&lt; hex &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">is_big_endian</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;当前系统为大端序&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;字节序为：&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">sizeof</span>(num); i++) &#123;</span><br><span class="line">            cout &lt;&lt; hex &lt;&lt; (<span class="type">int</span>)*(p + i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;当前系统为小端序&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;字节序为：&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">sizeof</span>(num) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            cout &lt;&lt; hex &lt;&lt; (<span class="type">int</span>)*(p + i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>在上述代码中，使用了一个 is_big_endian() 函数来判断当前系统的字节序是否为大端序。该函数通过创建一个整型变量 num，并将其最低位设置为 1，然后通过指针强制转换成字符指针，判断第一个字节是否为 1 来判断当前系统的字节序。</p></li><li><p>在 main 函数中，定义了一个整型变量 num，并将其初始化为 0x12345678。接着，使用 char* 类型的指针 p 来指向 num 的地址。然后，通过判断当前系统的字节序来输出 num 的字节序。</p></li><li><p>如果当前系统为大端序，则按照原始顺序输出各个字节；如果当前系统为小端序，则需要逆序输出各个字节。</p></li><li><p>大端模式</p></li></ul><p><img src="../assets/C++asio网络编程/image-12.png" alt="示例图片" style="zoom:100%;" /></p><ul><li>小端模式</li></ul><p><img src="../assets/C++asio网络编程/image-13.png" alt="示例图片" style="zoom:100%;" /></p><h3 id="服务器使用网络字节序"><a href="#服务器使用网络字节序" class="headerlink" title="服务器使用网络字节序"></a>服务器使用网络字节序</h3><ul><li>为保证字节序一致性，网络传输使用网络字节序，也就是大端模式。<br>在 boost::asio 库中，可以使用 boost::asio::detail::socket_ops::host_to_network_long() 和 boost::asio::detail::socket_ops::host_to_network_short() 函数将主机字节序转换为网络字节序。具体方法如下：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> host_long_value = <span class="number">0x12345678</span>;</span><br><span class="line">    <span class="type">uint16_t</span> host_short_value = <span class="number">0x5678</span>;</span><br><span class="line">    <span class="type">uint32_t</span> network_long_value = boost::asio::detail::socket_ops::<span class="built_in">host_to_network_long</span>(host_long_value);</span><br><span class="line">    <span class="type">uint16_t</span> network_short_value = boost::asio::detail::socket_ops::<span class="built_in">host_to_network_short</span>(host_short_value);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Host long value: 0x&quot;</span> &lt;&lt; std::hex &lt;&lt; host_long_value &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Network long value: 0x&quot;</span> &lt;&lt; std::hex &lt;&lt; network_long_value &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Host short value: 0x&quot;</span> &lt;&lt; std::hex &lt;&lt; host_short_value &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Network short value: 0x&quot;</span> &lt;&lt; std::hex &lt;&lt; network_short_value &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>上述代码中，使用了 boost::asio::detail::socket_ops::host_to_network_long() 和 boost::asio::detail::socket_ops::host_to_network_short() 函数将主机字节序转换为网络字节序。</p></li><li><p>host_to_network_long() 函数将一个 32 位无符号整数从主机字节序转换为网络字节序，返回转换后的结果。host_to_network_short() 函数将一个 16 位无符号整数从主机字节序转换为网络字节序，返回转换后的结果。</p></li><li><p>在上述代码中，分别将 32 位和 16 位的主机字节序数值转换为网络字节序，并输出转换结果。需要注意的是，在使用这些函数时，应该确保输入参数和返回结果都是无符号整数类型，否则可能会出现错误。</p></li><li><p>同样的道理，我们只需要在服务器发送数据时，将数据长度转化为网络字节序，在接收数据时，将长度转为本机字节序。</p></li><li><p>在服务器的HandleRead函数里，添加对data_len的转换，将网络字节转为本地字节序</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取头部数据</span></span><br><span class="line"><span class="type">short</span> data_len = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//把两字节的数据拷贝出来，得到实际数据的长度</span></span><br><span class="line"><span class="built_in">memcpy</span>(&amp;data_len, _recv_head_node-&gt;_data, HEAD_LENGTH);</span><br><span class="line">data_len = boost::asio::detail::socket_ops::<span class="built_in">network_to_host_short</span>(data_len);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;data_len is &quot;</span> &lt;&lt; data_len &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><ul><li>在服务器的发送数据时会构造消息节点，构造消息节点时，将发送长度由本地字节序转化为网络字节序</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用来构造发送节点</span></span><br><span class="line"><span class="built_in">MsgNode</span>(<span class="type">char</span>* msg, <span class="type">short</span> max_len):_total_len(max_len + HEAD_LENGTH), _cur_len(<span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 要多留一个空间存/0</span></span><br><span class="line">_data = <span class="keyword">new</span> <span class="type">char</span>[_total_len + <span class="number">1</span>]();</span><br><span class="line"><span class="comment">//转为网络字节序</span></span><br><span class="line"><span class="type">int</span> max_len_network = boost::asio::detail::socket_ops::<span class="built_in">host_to_network_short</span>(max_len);</span><br><span class="line"><span class="comment">// 将前两个字节赋值为长度</span></span><br><span class="line"><span class="built_in">memcpy</span>(_data, &amp;max_len_network, HEAD_LENGTH);</span><br><span class="line"><span class="comment">//偏移两个字节存数据长度</span></span><br><span class="line"><span class="built_in">memcpy</span>(_data + HEAD_LENGTH, msg, max_len);</span><br><span class="line">_data[_total_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息队列控制"><a href="#消息队列控制" class="headerlink" title="消息队列控制"></a>消息队列控制</h3><ul><li>发送时我们会将发送的消息放入队列里以保证发送的时序性，每个session都有一个发送队列，因为有的时候发送的频率过高会导致队列增大，所以要对队列的大小做限制，当队列大于指定数量的长度时，就丢弃要发送的数据包，以保证消息的快速收发。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::Send</span><span class="params">(<span class="type">char</span>* msg, <span class="type">int</span> max_length)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_send_lock)</span></span>;</span><br><span class="line">    <span class="type">int</span> send_que_size = _send_que.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (send_que_size &gt; MAX_SENDQUE) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;session: &quot;</span> &lt;&lt; _uuid &lt;&lt; <span class="string">&quot; send que fulled, size is &quot;</span> &lt;&lt; MAX_SENDQUE &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _send_que.<span class="built_in">push</span>(<span class="built_in">make_shared</span>&lt;MsgNode&gt;(msg, max_length));</span><br><span class="line">    <span class="keyword">if</span> (send_que_size&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span>&amp; msgnode = _send_que.<span class="built_in">front</span>();</span><br><span class="line">    boost::asio::<span class="built_in">async_write</span>(_socket, boost::asio::<span class="built_in">buffer</span>(msgnode-&gt;_data, msgnode-&gt;_total_len), </span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;CSession::HandleWrite, <span class="keyword">this</span>, std::placeholders::_1, <span class="built_in">SharedSelf</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="protobuf配置和使用"><a href="#protobuf配置和使用" class="headerlink" title="protobuf配置和使用"></a>protobuf配置和使用</h2><h3 id="portobuf简介"><a href="#portobuf简介" class="headerlink" title="portobuf简介"></a>portobuf简介</h3><ul><li><p>Protocol Buffers（简称 Protobuf）是一种轻便高效的序列化数据结构的协议，由 Google 开发。它可以用于将结构化数据序列化到二进制格式，并广泛用于数据存储、通信协议、配置文件等领域。</p></li><li><p>我们的逻辑是有类等抽象数据构成的，而tcp是面向字节流的，我们需要将类结构序列化为字符串来传输。</p></li></ul><h3 id="生成pb文件"><a href="#生成pb文件" class="headerlink" title="生成pb文件"></a>生成pb文件</h3><ul><li>要想使用protobuf的序列化功能，需要生成pb文件，pb文件包含了我们要序列化的类信息。我们先创建一个msg.proto，该文件用来定义我们要发送的类信息</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="comment">//一个类</span></span><br><span class="line">message Book</span><br><span class="line">&#123;</span><br><span class="line">   string name = <span class="number">1</span>;</span><br><span class="line">   int32 pages = <span class="number">2</span>;</span><br><span class="line">   <span class="type">float</span> price = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这个文件定义了一个名为Book的消息类型，包含三个字段：name、pages和price。其中每个字段都有一个数字标识符，用于标识该字段在二进制流中的位置。</li><li>我们使用protoc.exe 基于msg.proto生成我们要用的C++类</li><li>在proto所在文件夹执行如下命令：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --cpp_out=. ./msg.proto</span><br></pre></td></tr></table></figure><ul><li>—cpp_out= 表示指定要生成的pb文件所在的位置<br>./msg.proto 表示msg.proto所在的位置，因为我们是在msg.proto所在文件夹中执行的protoc命令,所以是当前路径即可。</li><li>执行后，会看到当前目录生成了msg.pb.h和msg.pb.cc两个文件，这两个文件就是我们要用到的头文件和cpp文件。</li><li>我们将这两个文件添加到项目里，然后在主函数中包含msg.pb.h，做如下测试</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;msg.pb.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//客户端做的事情</span></span><br><span class="line">    Book book;</span><br><span class="line">    book.<span class="built_in">set_name</span>(<span class="string">&quot;CPP programing&quot;</span>);</span><br><span class="line">    book.<span class="built_in">set_pages</span>(<span class="number">100</span>);</span><br><span class="line">    book.<span class="built_in">set_price</span>(<span class="number">200</span>);</span><br><span class="line">    std::string bookstr;</span><br><span class="line">    <span class="comment">//序列化写到字符串里</span></span><br><span class="line">    book.<span class="built_in">SerializeToString</span>(&amp;bookstr);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;serialize str is &quot;</span> &lt;&lt; bookstr &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//假设以下是服务端做的事情</span></span><br><span class="line">    Book book2;</span><br><span class="line">    <span class="comment">//从字符串中反序列化</span></span><br><span class="line">    book<span class="number">2.</span><span class="built_in">ParseFromString</span>(bookstr);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;book2 name is &quot;</span> &lt;&lt; book<span class="number">2.</span><span class="built_in">name</span>() &lt;&lt; <span class="string">&quot; price is &quot;</span></span><br><span class="line">        &lt;&lt; book<span class="number">2.</span><span class="built_in">price</span>() &lt;&lt; <span class="string">&quot; pages is &quot;</span> &lt;&lt; book<span class="number">2.</span><span class="built_in">pages</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试发现报错了</li></ul><p><img src="../assets/C++asio网络编程/image-14.png" alt="示例图片" style="zoom:100%;" /></p><ul><li>解决办法</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PROTOBUF_USE_DLLS</span><br></pre></td></tr></table></figure><ul><li><p>运行后又发现无法找到dll文件</p></li><li><p>解决办法</p></li><li><p>将缺失的dll文件放在.exe的同级目录下</p></li></ul><h3 id="在网络编程中的应用"><a href="#在网络编程中的应用" class="headerlink" title="在网络编程中的应用"></a>在网络编程中的应用</h3><ul><li>先为服务器定义一个用来通信的proto,根据你设计发送的数据来定</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line">message MsgData</span><br><span class="line">&#123;</span><br><span class="line">   int32  id = <span class="number">1</span>;</span><br><span class="line">   string data = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>id代表消息id，data代表消息内容</li><li>我们用protoc生成对应的pb.h和pb.cc文件,方法见上</li><li><p>将proto,pb.cc,pb.h三个文件复制到我们之前的服务器项目里并且配置。</p></li><li><p>我们修改服务器接收数据和发送数据的逻辑</p></li><li><p>当服务器收到数据后，完成切包处理后，将信息反序列化为具体要使用的结构,打印相关的信息，然后再发送给客户端</p></li><li><p>服务端</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">MsgData msgdata;</span><br><span class="line">  std::string receive_data;</span><br><span class="line">  <span class="comment">//反序列化</span></span><br><span class="line">  msgdata.<span class="built_in">ParseFromString</span>(std::<span class="built_in">string</span>(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len));</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;recevie msg id  is &quot;</span> &lt;&lt; msgdata.<span class="built_in">id</span>() &lt;&lt; <span class="string">&quot; msg data is &quot;</span> &lt;&lt; msgdata.<span class="built_in">data</span>() &lt;&lt; endl;</span><br><span class="line">  std::string return_str = <span class="string">&quot;server has received msg, msg data is &quot;</span> + msgdata.<span class="built_in">data</span>();</span><br><span class="line">  MsgData msgreturn;</span><br><span class="line">  msgreturn.<span class="built_in">set_id</span>(msgdata.<span class="built_in">id</span>());</span><br><span class="line">  msgreturn.<span class="built_in">set_data</span>(return_str);</span><br><span class="line">  <span class="comment">//序列化</span></span><br><span class="line">  msgreturn.<span class="built_in">SerializeToString</span>(&amp;return_str);</span><br><span class="line">  <span class="built_in">Send</span>(return_str);</span><br></pre></td></tr></table></figure><ul><li>客户端</li><li>同样的道理，客户端在发送的时候也利用protobuf进行消息的序列化，然后发给服务器</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MsgData msgdata;</span><br><span class="line">msgdata.<span class="built_in">set_id</span>(<span class="number">1001</span>);</span><br><span class="line">msgdata.<span class="built_in">set_data</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">std::string request;</span><br><span class="line">msgdata.<span class="built_in">SerializeToString</span>(&amp;request);</span><br></pre></td></tr></table></figure><h2 id="jsoncpp的使用与配置"><a href="#jsoncpp的使用与配置" class="headerlink" title="jsoncpp的使用与配置"></a>jsoncpp的使用与配置</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li><p>jsoncpp 是一个 C++ JSON 库，它提供了将 JSON 数据解析为 C++ 对象、将 C++ 对象序列化为 JSON 数据的功能。它支持所有主流操作系统（包括 Windows、Linux、Mac OS X 等），并且可以与常见编译器（包括 Visual Studio、GCC 等）兼容。</p></li><li><p>jsoncpp 库是以源代码的形式发布的，因此使用者需要自己构建和链接库文件。该库文件不依赖于第三方库，只需包含头文件即可使用。</p></li><li><p>jsoncpp 库的特点包括：</p></li></ul><ol><li><p>轻量级：JSON 解析器和序列化器都非常快速，不会占用太多的 CPU 和内存资源；</p></li><li><p>易于使用：提供简单的 API，易于理解和使用；</p></li><li><p>可靠性高：经过广泛测试，已被许多企业和开发者用于生产环境中；</p></li><li><p>开源免费：遵循 MIT 许可证发布，使用和修改均免费。</p></li></ol><ul><li>总之，jsoncpp 是一款优秀的 C++ JSON 库，它可以帮助你轻松地处理 JSON 数据，为你的项目带来便利和高效, 一般在前后端交互中用的多</li></ul><h3 id="配置参考我的csdn收藏"><a href="#配置参考我的csdn收藏" class="headerlink" title="配置参考我的csdn收藏"></a>配置参考我的csdn收藏</h3><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;json/json.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;json/value.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;json/reader.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Json::Value root;</span><br><span class="line">    root[<span class="string">&quot;id&quot;</span>] = <span class="number">1001</span>;</span><br><span class="line">    root[<span class="string">&quot;data&quot;</span>] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    std::string request = root.<span class="built_in">toStyledString</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;request is &quot;</span> &lt;&lt; request &lt;&lt; std::endl;</span><br><span class="line">    Json::Value root2;</span><br><span class="line">    Json::Reader reader;</span><br><span class="line">    reader.<span class="built_in">parse</span>(request, root2);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;msg id is &quot;</span> &lt;&lt; root2[<span class="string">&quot;id&quot;</span>] &lt;&lt; <span class="string">&quot; msg is &quot;</span> &lt;&lt; root2[<span class="string">&quot;data&quot;</span>] &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="../assets/C++asio网络编程/image-15.png" alt="示例图片" style="zoom:100%;" /></p><h3 id="网络编程中的应用"><a href="#网络编程中的应用" class="headerlink" title="网络编程中的应用"></a>网络编程中的应用</h3><ul><li>在客户端发送数据时对发送的数据进行序列化</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Json::Value root;</span><br><span class="line">  root[<span class="string">&quot;id&quot;</span>] = <span class="number">1001</span>;</span><br><span class="line">  root[<span class="string">&quot;data&quot;</span>] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">  std::string request = root.<span class="built_in">toStyledString</span>();</span><br><span class="line">  <span class="type">size_t</span> request_length = request.<span class="built_in">length</span>();</span><br><span class="line">  <span class="type">char</span> send_data[MAX_LENGTH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">  <span class="comment">//转为网络字节序</span></span><br><span class="line">  <span class="type">int</span> request_host_length = boost::asio::detail::socket_ops::<span class="built_in">host_to_network_short</span>(request_length);</span><br><span class="line">  <span class="built_in">memcpy</span>(send_data, &amp;request_host_length, <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">memcpy</span>(send_data + <span class="number">2</span>, request.<span class="built_in">c_str</span>(), request_length);</span><br><span class="line">  boost::asio::<span class="built_in">write</span>(sock, boost::asio::<span class="built_in">buffer</span>(send_data, request_length + <span class="number">2</span>));</span><br></pre></td></tr></table></figure><ul><li>我们可以在服务器收到数据时进行json反序列化</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Json::Reader reader;</span><br><span class="line">    Json::Value root;</span><br><span class="line">    reader.<span class="built_in">parse</span>(std::<span class="built_in">string</span>(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len), root);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;recevie msg id  is &quot;</span> &lt;&lt; root[<span class="string">&quot;id&quot;</span>].<span class="built_in">asInt</span>() &lt;&lt; <span class="string">&quot; msg data is &quot;</span></span><br><span class="line">    &lt;&lt; root[<span class="string">&quot;data&quot;</span>].<span class="built_in">asString</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h3 id="新版JSON库-nlohmann-json"><a href="#新版JSON库-nlohmann-json" class="headerlink" title="新版JSON库 nlohmann/json"></a>新版JSON库 nlohmann/json</h3><h2 id="asio粘包处理的简单方式"><a href="#asio粘包处理的简单方式" class="headerlink" title="asio粘包处理的简单方式"></a>asio粘包处理的简单方式</h2><h3 id="简单方式"><a href="#简单方式" class="headerlink" title="简单方式"></a>简单方式</h3><ul><li>之前我们介绍了通过async_read_some函数监听读事件，并且绑定了读事件的回调函数HandleRead</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_socket.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, MAX_LENGTH), std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, </span><br><span class="line">std::placeholders::_1, std::placeholders::_2, <span class="built_in">SharedSelf</span>()));</span><br></pre></td></tr></table></figure><ul><li>async_read_some 这个函数的特点是只要对端发数据，服务器接收到数据，即使没有收全对端发送的数据也会触发HandleRead函数，所以我们会在HandleRead回调函数里判断接收的字节数，接收的数据可能不满足头部长度，可能大于头部长度但小于消息体的长度，可能大于消息体的长度，还可能大于多个消息体的长度，所以要切包等，这些逻辑写起来很复杂，所以我们可以通过读取指定字节数，直到读完这些字节才触发回调函数，那么可以采用async_read函数，这个函数指定读取指定字节数，只有完全读完才会触发回调函数。</li></ul><h3 id="获取头部数据"><a href="#获取头部数据" class="headerlink" title="获取头部数据"></a>获取头部数据</h3><ul><li>我们可以读取指定的头部长度，大小为HEAD_LENGTH字节数，只有读完HEAD_LENGTH字节才触发HandleReadHead函数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::Start</span><span class="params">()</span></span>&#123;</span><br><span class="line">    _recv_head_node-&gt;<span class="built_in">Clear</span>();</span><br><span class="line">    boost::asio::<span class="built_in">async_read</span>(_socket, boost::asio::<span class="built_in">buffer</span>(_recv_head_node-&gt;_data, HEAD_LENGTH), std::<span class="built_in">bind</span>(&amp;CSession::HandleReadHead, <span class="keyword">this</span>, </span><br><span class="line">        std::placeholders::_1, std::placeholders::_2, <span class="built_in">SharedSelf</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这样我们可以直接在HandleReadHead函数内处理头部信息</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::HandleReadHead</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, <span class="type">size_t</span>  bytes_transferred, std::shared_ptr&lt;CSession&gt; shared_self)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bytes_transferred &lt; HEAD_LENGTH) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;read head lenth error&quot;</span>;</span><br><span class="line">            <span class="built_in">Close</span>();</span><br><span class="line">            _server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//头部接收完，解析头部</span></span><br><span class="line">        <span class="type">short</span> data_len = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;data_len, _recv_head_node-&gt;_data, HEAD_LENGTH);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;data_len is &quot;</span> &lt;&lt; data_len &lt;&lt; endl;</span><br><span class="line">        <span class="comment">//此处省略字节序转换</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">//头部长度非法</span></span><br><span class="line">        <span class="keyword">if</span> (data_len &gt; MAX_LENGTH) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;invalid data length is &quot;</span> &lt;&lt; data_len &lt;&lt; endl;</span><br><span class="line">            _server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _recv_msg_node= <span class="built_in">make_shared</span>&lt;MsgNode&gt;(data_len);</span><br><span class="line">        boost::asio::<span class="built_in">async_read</span>(_socket, boost::asio::<span class="built_in">buffer</span>(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len), </span><br><span class="line">            std::<span class="built_in">bind</span>(&amp;CSession::HandleReadMsg, <span class="keyword">this</span>,</span><br><span class="line">            std::placeholders::_1, std::placeholders::_2, <span class="built_in">SharedSelf</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;handle read failed, error is &quot;</span> &lt;&lt; error.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">Close</span>();</span><br><span class="line">        _server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>接下来根据头部内存储的消息体长度，获取指定长度的消息体数据，所以再次调用async_read，指定读取_recv_msg_node-&gt;_total_len长度，然后触发HandleReadMsg函数</li></ul><h3 id="获取消息体"><a href="#获取消息体" class="headerlink" title="获取消息体"></a>获取消息体</h3><ul><li>HandleReadMsg函数内解析消息体，解析完成后打印收到的消息，接下来继续监听读事件，监听读取指定头部大小字节，触发HandleReadHead函数， 然后再在HandleReadHead内继续监听读事件，获取消息体长度数据后触发HandleReadMsg函数，从而达到循环监听的目的。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::HandleReadMsg</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, <span class="type">size_t</span>  bytes_transferred,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::shared_ptr&lt;CSession&gt; shared_self)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        <span class="built_in">PrintRecvData</span>(_data, bytes_transferred);</span><br><span class="line">        std::<span class="function">chrono::milliseconds <span class="title">dura</span><span class="params">(<span class="number">2000</span>)</span></span>;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(dura);</span><br><span class="line">        _recv_msg_node-&gt;_data[_recv_msg_node-&gt;_total_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;receive data is &quot;</span> &lt;&lt; _recv_msg_node-&gt;_data &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">Send</span>(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len);</span><br><span class="line">        <span class="comment">//再次接收头部数据</span></span><br><span class="line">        _recv_head_node-&gt;<span class="built_in">Clear</span>();</span><br><span class="line">        boost::asio::<span class="built_in">async_read</span>(_socket, boost::asio::<span class="built_in">buffer</span>(_recv_head_node-&gt;_data, HEAD_LENGTH),</span><br><span class="line">            std::<span class="built_in">bind</span>(&amp;CSession::HandleReadHead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2,</span><br><span class="line">                <span class="built_in">SharedSelf</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;handle read msg failed,  error is &quot;</span> &lt;&lt; error.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">Close</span>();</span><br><span class="line">        _server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="服务器逻辑层设计和消息完善"><a href="#服务器逻辑层设计和消息完善" class="headerlink" title="服务器逻辑层设计和消息完善"></a>服务器逻辑层设计和消息完善</h2><h3 id="简介1"><a href="#简介1" class="headerlink" title="简介1"></a>简介1</h3><ul><li>本文概述基于boost::asio实现的服务器逻辑层结构，并且完善之前设计的消息结构。因为为了简化粘包处理，我们简化了发送数据的结构,这次我们给出完整的消息设计，以及服务器架构设计。</li></ul><h3 id="服务器架构设计"><a href="#服务器架构设计" class="headerlink" title="服务器架构设计"></a>服务器架构设计</h3><ul><li>之前我们设计了Session(会话层)，并且给大家讲述了Asio底层的通信过程，如下图</li></ul><p><img src="../assets/C++asio网络编程/image-16.png" alt="示例图片" style="zoom:100%;" /></p><ul><li>我们接下来要设计的服务器结构是这样的</li></ul><p><img src="../assets/C++asio网络编程/image-17.png" alt="示例图片" style="zoom:100%;" /></p><h3 id="消息头完善"><a href="#消息头完善" class="headerlink" title="消息头完善"></a>消息头完善</h3><ul><li>我们之前的消息头仅包含数据域的长度，但是要进行逻辑处理，就需要传递一个id字段表示要处理的消息id，当然可以不在包头传id字段，将id序列化到消息体也是可以的，但是我们为了便于处理也便于回调逻辑层对应的函数，最好是将id写入包头。</li><li>之前我们设计的消息结构是这样的</li></ul><p><img src="../assets/C++asio网络编程/image-18.png" alt="示例图片" style="zoom:100%;" /></p><ul><li>现在改为这样</li></ul><p><img src="../assets/C++asio网络编程/image-19.png" alt="示例图片" style="zoom:100%;" /></p><ul><li><p>为了减少耦合和歧义，我们重新设计消息节点。</p><ol><li>MsgNode表示消息节点的基类，头部的消息用这个结构存储。</li><li>RecvNode表示接收消息的节点。</li><li>SendNode表示发送消息的节点。</li></ol></li></ul><h4 id="我们将上述结构定义在MsgNode-h中"><a href="#我们将上述结构定义在MsgNode-h中" class="headerlink" title="我们将上述结构定义在MsgNode.h中"></a>我们将上述结构定义在MsgNode.h中</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;const.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MsgNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MsgNode</span>(<span class="type">short</span> max_len) :_total_len(max_len), _cur_len(<span class="number">0</span>) &#123;</span><br><span class="line">_data = <span class="keyword">new</span> <span class="type">char</span>[_total_len + <span class="number">1</span>];</span><br><span class="line">_data[_total_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">MsgNode</span>() &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;destruct MsgNode&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(_data, <span class="number">0</span>, _total_len);</span><br><span class="line">_cur_len = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">short</span> _cur_len;</span><br><span class="line"><span class="type">short</span> _total_len;</span><br><span class="line"><span class="type">char</span>* _data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RecvNode</span> :<span class="keyword">public</span> MsgNode &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">RecvNode</span>(<span class="type">short</span> max_len, <span class="type">short</span> msg_id);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">short</span> _msg_id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SendNode</span> : <span class="keyword">public</span> MsgNode &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">SendNode</span>(<span class="type">const</span> <span class="type">char</span>* msg, <span class="type">short</span> max_len, <span class="type">short</span> msg_id);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">short</span> _msg_id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="实现MsgNode"><a href="#实现MsgNode" class="headerlink" title="实现MsgNode"></a>实现MsgNode</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MsgNode.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">RecvNode::<span class="built_in">RecvNode</span>(<span class="type">short</span> max_len, <span class="type">short</span> msg_id):<span class="built_in">MsgNode</span>(max_len),_msg_id(msg_id)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SendNode::<span class="built_in">SendNode</span>(<span class="type">const</span> <span class="type">char</span>* msg, <span class="type">short</span> max_len, <span class="type">short</span> msg_id):<span class="built_in">MsgNode</span>(max_len + HEAD_TOTAL_LENGTH),_msg_id(msg_id)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//先发送id,转成网络字节序，网络字节序为大端</span></span><br><span class="line"><span class="type">short</span> msg_id_network = boost::asio::detail::socket_ops::<span class="built_in">host_to_network_short</span>(msg_id);</span><br><span class="line"><span class="built_in">memcpy</span>(_data, &amp;msg_id_network, HEAD_ID_LEN);</span><br><span class="line"><span class="comment">//在发送长度,转成网络字节序</span></span><br><span class="line"><span class="type">short</span> msg_len_network = boost::asio::detail::socket_ops::<span class="built_in">host_to_network_short</span>(max_len);</span><br><span class="line"><span class="built_in">memcpy</span>(_data + HEAD_ID_LEN, &amp;msg_len_network, HEAD_DATA_LEN);</span><br><span class="line"><span class="comment">//最后发送实际消息,我们传的是protobuf或json序列化的字节流所以不用转字节序</span></span><br><span class="line"><span class="built_in">memcpy</span>(_data + HEAD_TOTAL_LENGTH, msg, max_len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>SendNode发送节点构造时，先将id转为网络字节序，然后写入_data数据域。</li><li>然后将要发送数据的长度转为大端字节序，写入_data数据域，注意要偏移HEAD_ID_LEN长度。</li><li>最后将要发送的数据msg写入_data数据域，注意要偏移HEAD_ID_LEN+HEAD_DATA_LEN</li></ul><h3 id="Session类改写"><a href="#Session类改写" class="headerlink" title="Session类改写"></a>Session类改写</h3><h4 id="完整的代码2"><a href="#完整的代码2" class="headerlink" title="完整的代码2"></a>完整的代码2</h4><h5 id="Session-h"><a href="#Session-h" class="headerlink" title="Session.h"></a>Session.h</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/uuid/uuid_io.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/uuid/uuid_generators.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MsgNode.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;const.h&quot;</span></span></span><br><span class="line"><span class="comment">//避免循环依赖问题使用前置声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CServer</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CSession</span>: <span class="keyword">public</span> std::enable_shared_from_this&lt;CSession&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">CSession</span>(boost::asio::io_context&amp; ioc, CServer* server);</span><br><span class="line">~<span class="built_in">CSession</span>();</span><br><span class="line">boost::asio::ip::<span class="function">tcp::socket&amp; <span class="title">GetSocket</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">std::string&amp; <span class="title">GetUuid</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Send</span><span class="params">(<span class="type">char</span>* msg, <span class="type">short</span> max_len, <span class="type">short</span> msgid)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Send</span><span class="params">(std::string msg, <span class="type">short</span> msgid)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Close</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;CSession&gt; <span class="title">SharedSelf</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HandleRead</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, <span class="type">size_t</span> bytes_transferred, std::shared_ptr&lt;CSession&gt; shared_self)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HandleWrite</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, std::shared_ptr&lt;CSession&gt; shared_self)</span></span>;</span><br><span class="line">boost::asio::ip::tcp::socket _socket;</span><br><span class="line">std::string _uuid;</span><br><span class="line"><span class="type">char</span> _data[MAX_LENGTH];</span><br><span class="line">CServer* _server;</span><br><span class="line"><span class="comment">//标志是否关闭</span></span><br><span class="line"><span class="type">bool</span> _b_close;</span><br><span class="line"><span class="comment">//用于保证发送信息的时序性</span></span><br><span class="line">std::queue&lt;std::shared_ptr&lt;SendNode&gt;&gt; _send_que;</span><br><span class="line"><span class="comment">//对队列加锁</span></span><br><span class="line">std::mutex _send_lock;</span><br><span class="line"><span class="comment">// 收到的消息结构</span></span><br><span class="line">std::shared_ptr&lt;RecvNode&gt; _recv_msg_node;</span><br><span class="line"><span class="comment">//判断头部节点是否构造完成</span></span><br><span class="line"><span class="type">bool</span> _b_head_parse;</span><br><span class="line"><span class="comment">//收到的头部结构,包括消息id与消息体长度</span></span><br><span class="line">std::shared_ptr&lt;MsgNode&gt; _recv_head_node;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="Session-cpp-1"><a href="#Session-cpp-1" class="headerlink" title="Session.cpp"></a>Session.cpp</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CSession.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CServer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;json/json.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;json/value.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;json/reader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">CSession::<span class="built_in">CSession</span>(boost::asio::io_context&amp; ioc, CServer* server):</span><br><span class="line">_socket(ioc), _server(server), _b_close(<span class="literal">false</span>), _b_head_parse(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//创建一个没有重复的id</span></span><br><span class="line">boost::uuids::uuid a_uuid = boost::uuids::<span class="built_in">random_generator</span>()();</span><br><span class="line">_uuid = boost::uuids::<span class="built_in">to_string</span>(a_uuid);</span><br><span class="line"><span class="comment">//不管是收到的信息还是发出的信息都有头部节点，所以放在构造函数中</span></span><br><span class="line">_recv_head_node = std::<span class="built_in">make_shared</span>&lt;MsgNode&gt;(HEAD_TOTAL_LENGTH);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CSession::~<span class="built_in">CSession</span>()</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;~CSession destruct&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">boost::asio::ip::<span class="function">tcp::socket&amp; <span class="title">CSession::GetSocket</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此处插入 return 语句</span></span><br><span class="line"><span class="keyword">return</span> _socket;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string&amp; <span class="title">CSession::GetUuid</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此处插入 return 语句</span></span><br><span class="line"><span class="keyword">return</span> _uuid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对接收数据清零，并且开始异步非阻塞读取</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);</span><br><span class="line">_socket.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, MAX_LENGTH), std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>,</span><br><span class="line">std::placeholders::_1, std::placeholders::_2, <span class="built_in">SharedSelf</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送C++风格的string信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::Send</span><span class="params">(std::string msg, <span class="type">short</span> msgid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//由于需要对队列操作，所以要加锁</span></span><br><span class="line"><span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_send_lock)</span></span>;</span><br><span class="line"><span class="comment">//队列的长度</span></span><br><span class="line"><span class="type">int</span> send_que_size = _send_que.<span class="built_in">size</span>();</span><br><span class="line"><span class="comment">//限制队列长度</span></span><br><span class="line"><span class="keyword">if</span> (send_que_size &gt; MAX_SENDQUE) &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;session: &quot;</span> &lt;&lt; _uuid &lt;&lt; <span class="string">&quot; send que fulled, size is &quot;</span> &lt;&lt; MAX_SENDQUE &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把数据插入队列，保证时序性</span></span><br><span class="line">_send_que.<span class="built_in">push</span>(std::<span class="built_in">make_shared</span>&lt;SendNode&gt;(msg.<span class="built_in">c_str</span>(), msg.<span class="built_in">length</span>(), msgid));</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于多个套接字，只允许当队列长度为1的时候发送数据，因为我们是在插入之前计算的队列长度，所以是判断大于0</span></span><br><span class="line"><span class="keyword">if</span> (send_que_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从队列取出数据，写入发送缓冲区</span></span><br><span class="line"><span class="keyword">auto</span>&amp; msgnode = _send_que.<span class="built_in">front</span>();</span><br><span class="line">boost::asio::<span class="built_in">async_write</span>(_socket, boost::asio::<span class="built_in">buffer</span>(msgnode-&gt;_data, msgnode-&gt;_total_len),</span><br><span class="line">std::<span class="built_in">bind</span>(&amp;CSession::HandleWrite, <span class="keyword">this</span>, std::placeholders::_1, <span class="built_in">SharedSelf</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::Send</span><span class="params">(<span class="type">char</span>* msg, <span class="type">short</span> max_length, <span class="type">short</span> msgid)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_send_lock)</span></span>;</span><br><span class="line"><span class="type">int</span> send_que_size = _send_que.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">if</span> (send_que_size &gt; MAX_SENDQUE) &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;session: &quot;</span> &lt;&lt; _uuid &lt;&lt; <span class="string">&quot; send que fulled, size is &quot;</span> &lt;&lt; MAX_SENDQUE &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_send_que.<span class="built_in">push</span>(std::<span class="built_in">make_shared</span>&lt;SendNode&gt;(msg, max_length, msgid));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (send_que_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span>&amp; msgnode = _send_que.<span class="built_in">front</span>();</span><br><span class="line">boost::asio::<span class="built_in">async_write</span>(_socket, boost::asio::<span class="built_in">buffer</span>(msgnode-&gt;_data, msgnode-&gt;_total_len),</span><br><span class="line">std::<span class="built_in">bind</span>(&amp;CSession::HandleWrite, <span class="keyword">this</span>, std::placeholders::_1, <span class="built_in">SharedSelf</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::Close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">_socket.<span class="built_in">close</span>();</span><br><span class="line">_b_close = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用来让指针同步引用，而不会导致指向一个内存的两个智能指针引用计数不一致问题</span></span><br><span class="line">std::shared_ptr&lt;CSession&gt;CSession::<span class="built_in">SharedSelf</span>() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">shared_from_this</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::HandleWrite</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, std::shared_ptr&lt;CSession&gt; shared_self)</span> </span>&#123;</span><br><span class="line"><span class="comment">//增加异常处理</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (!error) &#123;</span><br><span class="line"><span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_send_lock)</span></span>;</span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;send data &quot; &lt;&lt; _send_que.front()-&gt;_data+HEAD_LENGTH &lt;&lt; endl;</span></span><br><span class="line">_send_que.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果队列不为空，继续发送数据</span></span><br><span class="line"><span class="keyword">if</span> (!_send_que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"><span class="keyword">auto</span>&amp; msgnode = _send_que.<span class="built_in">front</span>();</span><br><span class="line">boost::asio::<span class="built_in">async_write</span>(_socket, boost::asio::<span class="built_in">buffer</span>(msgnode-&gt;_data, msgnode-&gt;_total_len),</span><br><span class="line">std::<span class="built_in">bind</span>(&amp;CSession::HandleWrite, <span class="keyword">this</span>, std::placeholders::_1, shared_self));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;handle write failed, error is &quot;</span> &lt;&lt; error.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">Close</span>();</span><br><span class="line">_server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">std::cerr &lt;&lt; <span class="string">&quot;Exception code : &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::HandleRead</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, <span class="type">size_t</span>  bytes_transferred, std::shared_ptr&lt;CSession&gt; shared_self)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (!error) &#123;</span><br><span class="line"><span class="comment">//已经移动的字符数</span></span><br><span class="line"><span class="type">int</span> copy_len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (bytes_transferred &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!_b_head_parse) &#123;</span><br><span class="line"><span class="comment">//收到的数据不足头部大小</span></span><br><span class="line"><span class="keyword">if</span> (bytes_transferred + _recv_head_node-&gt;_cur_len &lt; HEAD_TOTAL_LENGTH) &#123;</span><br><span class="line"><span class="built_in">memcpy</span>(_recv_head_node-&gt;_data + _recv_head_node-&gt;_cur_len, _data + copy_len, bytes_transferred);</span><br><span class="line">_recv_head_node-&gt;_cur_len += bytes_transferred;</span><br><span class="line">::<span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);</span><br><span class="line">_socket.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, MAX_LENGTH),</span><br><span class="line">std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//收到的数据比头部多</span></span><br><span class="line"><span class="comment">//处理头部剩余未复制的长度</span></span><br><span class="line"><span class="type">int</span> head_remain = HEAD_TOTAL_LENGTH - _recv_head_node-&gt;_cur_len;</span><br><span class="line"><span class="built_in">memcpy</span>(_recv_head_node-&gt;_data + _recv_head_node-&gt;_cur_len, _data + copy_len, head_remain);</span><br><span class="line"><span class="comment">//更新已处理的data长度和剩余未处理的长度</span></span><br><span class="line">copy_len += head_remain;</span><br><span class="line">bytes_transferred -= head_remain;</span><br><span class="line"><span class="comment">//获取头部MSGID数据</span></span><br><span class="line"><span class="type">short</span> msg_id = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memcpy</span>(&amp;msg_id, _recv_head_node-&gt;_data, HEAD_ID_LEN);</span><br><span class="line"><span class="comment">//网络字节序转化为本地字节序</span></span><br><span class="line">msg_id = boost::asio::detail::socket_ops::<span class="built_in">network_to_host_short</span>(msg_id);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;msg_id is &quot;</span> &lt;&lt; msg_id &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">//id非法</span></span><br><span class="line"><span class="keyword">if</span> (msg_id &gt; MAX_LENGTH) &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;invalid msg_id is &quot;</span> &lt;&lt; msg_id &lt;&lt; std::endl;</span><br><span class="line">_server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">short</span> msg_len = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memcpy</span>(&amp;msg_len, _recv_head_node-&gt;_data + HEAD_ID_LEN, HEAD_DATA_LEN);</span><br><span class="line"><span class="comment">//网络字节序转化为本地字节序</span></span><br><span class="line">msg_len = boost::asio::detail::socket_ops::<span class="built_in">network_to_host_short</span>(msg_len);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;msg_len is &quot;</span> &lt;&lt; msg_len &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">//id非法</span></span><br><span class="line"><span class="keyword">if</span> (msg_len &gt; MAX_LENGTH) &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;invalid data length is &quot;</span> &lt;&lt; msg_len &lt;&lt; std::endl;</span><br><span class="line">_server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_recv_msg_node = std::<span class="built_in">make_shared</span>&lt;RecvNode&gt;(msg_len, msg_id);</span><br><span class="line"></span><br><span class="line"><span class="comment">//消息的长度小于头部规定的长度，说明数据未收全，则先将部分消息放到接收节点里</span></span><br><span class="line"><span class="keyword">if</span> (bytes_transferred &lt; msg_len) &#123;</span><br><span class="line"><span class="built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, bytes_transferred);</span><br><span class="line">_recv_msg_node-&gt;_cur_len += bytes_transferred;</span><br><span class="line">::<span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);</span><br><span class="line">_socket.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, MAX_LENGTH),</span><br><span class="line">std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));</span><br><span class="line"><span class="comment">//头部处理完成</span></span><br><span class="line">_b_head_parse = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消息的长度大于等于头部规定的长度，说明数据收全，解析消息体</span></span><br><span class="line"><span class="built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, msg_len);</span><br><span class="line">_recv_msg_node-&gt;_cur_len += msg_len;</span><br><span class="line">copy_len += msg_len;</span><br><span class="line">bytes_transferred -= msg_len;</span><br><span class="line">_recv_msg_node-&gt;_data[_recv_msg_node-&gt;_total_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;receive data is &quot; &lt;&lt; _recv_msg_node-&gt;_data &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//此处可以调用Send发送测试</span></span><br><span class="line">Json::Reader reader;</span><br><span class="line">Json::Value root;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析成json对象</span></span><br><span class="line">reader.<span class="built_in">parse</span>(std::<span class="built_in">string</span>(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len), root);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将json格式转换为不同格式</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;recevie msg id is &quot;</span> &lt;&lt; root[<span class="string">&quot;id&quot;</span>].<span class="built_in">asInt</span>() &lt;&lt; <span class="string">&quot; msg data is &quot;</span></span><br><span class="line">&lt;&lt; root[<span class="string">&quot;data&quot;</span>].<span class="built_in">asString</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">root[<span class="string">&quot;data&quot;</span>] = <span class="string">&quot;server has received msg, msg data is &quot;</span> + root[<span class="string">&quot;data&quot;</span>].<span class="built_in">asString</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//反序列化成字符串</span></span><br><span class="line">std::string return_str = root.<span class="built_in">toStyledString</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送接受的消息</span></span><br><span class="line"><span class="built_in">Send</span>(return_str, root[<span class="string">&quot;id&quot;</span>].<span class="built_in">asInt</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">//继续轮询剩余未处理数据</span></span><br><span class="line">_b_head_parse = <span class="literal">false</span>;</span><br><span class="line">_recv_head_node-&gt;<span class="built_in">Clear</span>();</span><br><span class="line"><span class="keyword">if</span> (bytes_transferred &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">::<span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);</span><br><span class="line">_socket.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, MAX_LENGTH),</span><br><span class="line">std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//已经处理完头部，处理上次未接受完的消息数据</span></span><br><span class="line"><span class="comment">//接收的数据仍不足剩余未处理的</span></span><br><span class="line"><span class="type">int</span> remain_msg = _recv_msg_node-&gt;_total_len - _recv_msg_node-&gt;_cur_len;</span><br><span class="line"><span class="keyword">if</span> (bytes_transferred &lt; remain_msg) &#123;</span><br><span class="line"><span class="built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, bytes_transferred);</span><br><span class="line">_recv_msg_node-&gt;_cur_len += bytes_transferred;</span><br><span class="line">::<span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);</span><br><span class="line">_socket.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, MAX_LENGTH),</span><br><span class="line">std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, remain_msg);</span><br><span class="line">_recv_msg_node-&gt;_cur_len += remain_msg;</span><br><span class="line">bytes_transferred -= remain_msg;</span><br><span class="line">copy_len += remain_msg;</span><br><span class="line">_recv_msg_node-&gt;_data[_recv_msg_node-&gt;_total_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;receive data is &quot; &lt;&lt; _recv_msg_node-&gt;_data &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//此处可以调用Send发送测试</span></span><br><span class="line">Json::Reader reader;</span><br><span class="line">Json::Value root;</span><br><span class="line">reader.<span class="built_in">parse</span>(std::<span class="built_in">string</span>(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len), root);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;recevie msg id  is &quot;</span> &lt;&lt; root[<span class="string">&quot;id&quot;</span>].<span class="built_in">asInt</span>() &lt;&lt; <span class="string">&quot; msg data is &quot;</span></span><br><span class="line">&lt;&lt; root[<span class="string">&quot;data&quot;</span>].<span class="built_in">asString</span>() &lt;&lt; std::endl;</span><br><span class="line">root[<span class="string">&quot;data&quot;</span>] = <span class="string">&quot;server has received msg, msg data is &quot;</span> + root[<span class="string">&quot;data&quot;</span>].<span class="built_in">asString</span>();</span><br><span class="line">std::string return_str = root.<span class="built_in">toStyledString</span>();</span><br><span class="line"><span class="built_in">Send</span>(return_str, root[<span class="string">&quot;id&quot;</span>].<span class="built_in">asInt</span>());</span><br><span class="line"><span class="comment">//继续轮询剩余未处理数据</span></span><br><span class="line">_b_head_parse = <span class="literal">false</span>;</span><br><span class="line">_recv_head_node-&gt;<span class="built_in">Clear</span>();</span><br><span class="line"><span class="keyword">if</span> (bytes_transferred &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">::<span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);</span><br><span class="line">_socket.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, MAX_LENGTH),</span><br><span class="line">std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;handle read failed, error is &quot;</span> &lt;&lt; error.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">Close</span>();</span><br><span class="line">_server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Exception code is &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单例模式实现逻辑层设计"><a href="#单例模式实现逻辑层设计" class="headerlink" title="单例模式实现逻辑层设计"></a>单例模式实现逻辑层设计</h2><h3 id="单例模板类"><a href="#单例模板类" class="headerlink" title="单例模板类"></a>单例模板类</h3><ul><li>接下来我们实现一个单例模板类，因为服务器的逻辑处理需要单例模式，后期可能还会有一些模块的设计也需要单例模式，所以先实现一个单例模板类，然后其他想实现单例类只需要继承这个模板类即可。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> std::shared_ptr&lt;T&gt; <span class="title">GetInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//只有第一次调用的时候会初始化，再次调用就不会初始化</span></span><br><span class="line"><span class="comment">//其声明周期与进程生命周期相同</span></span><br><span class="line"><span class="type">static</span> std::once_flag s_flag;</span><br><span class="line">std::<span class="built_in">call_once</span>(s_flag, [&amp;]() &#123;</span><br><span class="line">_instance = <span class="built_in">shared_ptr</span>&lt;T&gt;(<span class="keyword">new</span> T);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">return</span> _instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::cout &lt;&lt; _instance-&gt;<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line"><span class="built_in">Singleton</span>(Singleton&lt;T&gt;&amp; st) = <span class="keyword">delete</span>;</span><br><span class="line">Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&lt;T&gt;&amp; st) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> std::shared_ptr&lt;T&gt; _instance;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">~<span class="built_in">Singleton</span>() &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;this is singleton destruct &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为是模板类，所以初始化的时候不能放在.cpp里，得放在.h里</span></span><br><span class="line"><span class="comment">// 并且又由于是模板类的静态成员，所以如果省略了 std::shared_ptr&lt;T&gt;，编译器将无法识别 _instance 的类型，并且无法进行类型推断。因此，在定义静态成员变量时，必须明确指明其类型。</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">std::shared_ptr&lt;T&gt; Singleton&lt;T&gt;::_instance = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><ul><li><p>其中的细节</p><ol><li>因为是模板类，所以初始化的时候不能放在.cpp里，得放在.h里，并且又由于是模板类的静态成员，所以如果省略了 std::shared_ptr<T>，编译器将无法识别 _instance 的类型，并且无法进行类型推断。因此，在定义静态成员变量时，必须明确指明其类型。</li><li><p>得保证线程安全，可以使用C++11的once_flag 与 call_once，std::call_once 函数接受一个 std::once_flag 对象和一个函数作为参数，它会确保这个函数只被调用一次，实现原理是用加锁和一个标志位来实现,其逻辑与下属类似：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span>* instance</span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(flag) <span class="keyword">return</span> instance;</span><br><span class="line">std::mutex mtx;</span><br><span class="line"><span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line"><span class="keyword">if</span>(flag) <span class="keyword">return</span> instance;</span><br><span class="line">instance = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">2</span>);</span><br><span class="line">flag = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>单例模式模板类将无参构造，拷贝构造，拷贝赋值都设定为protected属性，其他的类无法访问，其实也可以设置为私有属性。析构函数设置为公有的，其实设置为私有的更合理一点。<br>Singleton有一个static类型的属性_instance, 它是我们实际要开辟类型的智能指针类型。<br>s_flag是函数GetInstance内的局部静态变量，该变量在函数GetInstance第一次调用时被初始化。以后无论调用多少次GetInstance s_flag都不会被重复初始化，而且s_flag存在静态区，会随着进程结束而自动释放。<br>call_once只会调用一次，而且是线程安全的， 其内部的原理就是调用该函数时加锁，然后设置s_flag内部的标记，设置为已经初始化，执行lambda表达式逻辑初始化智能指针，然后解锁。第二次调用GetInstance 内部还会调用call_once, 只是call_once判断s_flag已经被初始化了就不执行初始化智能指针的操作了。</p></li></ul><h3 id="LogicSystem单例类"><a href="#LogicSystem单例类" class="headerlink" title="LogicSystem单例类"></a>LogicSystem单例类</h3><ul><li>我们实现逻辑系统的单例类，继承自Singleton<LogicSystem>，这样LogicSystem的构造函数和拷贝构造函数就都变为私有的了，因为基类的构造函数和拷贝构造函数都是私有的。另外LogicSystem也用了基类的成员_instance和GetInstance函数。从而达到单例效果。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;json/json.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;json/value.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;json/reader.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Singleton.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;const.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CSession.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">void</span>(std::shared_ptr&lt;CSession&gt; session, <span class="type">const</span> <span class="type">short</span>&amp; msg_id, <span class="type">const</span> std::string&amp; msg_data)&gt; FunCallBack;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LogicSystem</span> :<span class="keyword">public</span> Singleton&lt;LogicSystem&gt; &#123;</span><br><span class="line"><span class="comment">//由于在Singleton的GetInstacne中调用了LogicSystem的私有构造函数</span></span><br><span class="line"><span class="comment">//所以得声明友元，让对方能够调用</span></span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&lt;LogicSystem&gt;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//设置为公有是为了让单例类能够正常析构</span></span><br><span class="line">~<span class="built_in">LogicSystem</span>();</span><br><span class="line"><span class="comment">//将逻辑节点投递到消息队列里</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostMsgToQue</span><span class="params">(std::shared_ptr&lt;LogicNode&gt; msg)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">LogicSystem</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册功能</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RegisterCallBacks</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HelloWordCallBacks</span><span class="params">(std::shared_ptr&lt;CSession&gt; new_session, <span class="type">const</span> <span class="type">short</span>&amp; msg_id, <span class="type">const</span> std::string&amp; msg_data)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DealMsg</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用来存储逻辑节点</span></span><br><span class="line">std::queue&lt;std::shared_ptr&lt;LogicNode&gt;&gt; _msg_que;</span><br><span class="line"></span><br><span class="line"><span class="comment">//需要加锁</span></span><br><span class="line">std::mutex mtx;</span><br><span class="line"><span class="comment">//由于有消息队列，所以需要阻塞线程，所以需要</span></span><br><span class="line"><span class="comment">//条件变量来通知被阻塞的线程</span></span><br><span class="line">std::condition_variable _consume;</span><br><span class="line"></span><br><span class="line"><span class="comment">//还需要工作线程来消费逻辑消息</span></span><br><span class="line">std::thread _worker_thread;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用这个来标记逻辑停止</span></span><br><span class="line"><span class="type">bool</span> _b_stop;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用来存储回调函数，也就是注册进来</span></span><br><span class="line">std::map&lt;<span class="type">short</span>, FunCallBack&gt; _fun_callbacks;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>FunCallBack为要注册的回调函数类型，其参数为绘画类智能指针，消息id，以及消息内容</li><li>_msg_que为逻辑队列</li><li>_mutex 为保证逻辑队列安全的互斥量</li><li>_consume表示消费者条件变量，用来控制当逻辑队列为空时保证线程暂时挂起等待，不要干扰其他线程。</li><li>_fun_callbacks表示回调函数的map，根据id查找对应的逻辑处理函数。</li><li>_worker_thread表示工作线程，用来从逻辑队列中取数据并执行回调函数。</li><li>_b_stop表示收到外部的停止信号，逻辑类要中止工作线程并优雅退出。</li></ol><ul><li>LogicNode定义在CSession.h中</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LogicNode</span> &#123;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">LogicSystem</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">LogicNode</span>(std::shared_ptr&lt;CSession&gt; session, std::shared_ptr&lt;RecvNode&gt; recvnode);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::shared_ptr&lt;CSession&gt; _session;</span><br><span class="line">std::shared_ptr&lt;RecvNode&gt; _recvnode;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>其包含了会话类的智能指针，主要是为了实现伪闭包，防止session被释放。<br>其次包含了接收消息的节点类的智能指针。</li><li>实现如下:</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LogicNode::<span class="built_in">LogicNode</span>(std::shared_ptr&lt;CSession&gt; session, std::shared_ptr&lt;RecvNode&gt; recvnode): _session(session), _recvnode(recvnode)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>LogicSystem的构造函数如下</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LogicSystem::<span class="built_in">LogicSystem</span>(): _b_stop(<span class="literal">false</span>) &#123;</span><br><span class="line"><span class="comment">//用于绑定回调函数</span></span><br><span class="line"><span class="built_in">RegisterCallBacks</span>();</span><br><span class="line"><span class="comment">//启动工作线程</span></span><br><span class="line">_worker_thread = std::<span class="built_in">thread</span>(&amp;LogicSystem::DealMsg, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>构造函数中将停止信息初始化为false，注册消息处理函数并且启动了一个工作线程，工作线程执行DealMsg逻辑。<br>注册消息处理函数的逻辑如下:</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LogicSystem::RegisterCallBacks</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_fun_callbacks[MSG_HELLO_WORD] = std::<span class="built_in">bind</span>(&amp;LogicSystem::HelloWordCallBacks, <span class="keyword">this</span>,</span><br><span class="line">std::placeholders::_1, std::placeholders::_2, std::placeholders::_3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>MSG_HELLO_WORD定义在const.h中</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">MSG_IDS</span> &#123;</span><br><span class="line">    MSG_HELLO_WORD = <span class="number">1001</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>MSG_HELLO_WORD表示消息id，HelloWordCallBack为对应的回调处理函数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LogicSystem::HelloWordCallBacks</span><span class="params">(std::shared_ptr&lt;CSession&gt; session, <span class="type">const</span> <span class="type">short</span>&amp; msg_id, <span class="type">const</span> std::string&amp; msg_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Json::Reader reader;</span><br><span class="line">Json::Value root;</span><br><span class="line"><span class="comment">//将msg_data 内容系列化到root里</span></span><br><span class="line">reader.<span class="built_in">parse</span>(msg_data, root);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;receive msg id is&quot;</span> &lt;&lt; root[<span class="string">&quot;id&quot;</span>].<span class="built_in">asInt</span>() &lt;&lt; <span class="string">&quot;msg data is &quot;</span></span><br><span class="line">&lt;&lt; root[<span class="string">&quot;data&quot;</span>].<span class="built_in">asString</span>() &lt;&lt; std::endl;</span><br><span class="line">root[<span class="string">&quot;data&quot;</span>] = <span class="string">&quot;server has receive msg, msg data is &quot;</span> + root[<span class="string">&quot;data&quot;</span>].<span class="built_in">asString</span>();</span><br><span class="line"></span><br><span class="line">std::string return_str = root.<span class="built_in">toStyledString</span>();</span><br><span class="line"><span class="comment">//发送信息</span></span><br><span class="line">session-&gt;<span class="built_in">Send</span>(return_str, root[<span class="string">&quot;id&quot;</span>].<span class="built_in">asInt</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>在HelloWordCallBack里我们根据消息id和收到的消息，做了相应的处理并且回应给客户端。</p></li><li><p>工作线程的处理函数DealMsg逻辑</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LogicSystem::DealMsg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="comment">//配合条件变量使用，以及加锁</span></span><br><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">unique_lk</span><span class="params">(mtx)</span></span>;</span><br><span class="line"><span class="comment">//判断队列为空则用条件变量阻塞等待，并释放锁</span></span><br><span class="line"><span class="keyword">while</span> (_msg_que.<span class="built_in">empty</span>() &amp;&amp; !_b_stop) &#123;</span><br><span class="line">_consume.<span class="built_in">wait</span>(unique_lk);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 也可以这么写</span></span><br><span class="line"><span class="comment">_consume.wait(unique_lk, [this]()&#123;</span></span><br><span class="line"><span class="comment">return !_msg_que.empty() &amp;&amp; _b_stop</span></span><br><span class="line"><span class="comment">&#125;)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否为关闭状态，把所有逻辑执行完后则退出循环</span></span><br><span class="line"><span class="keyword">if</span> (_b_stop) &#123;</span><br><span class="line"><span class="keyword">while</span> (!_msg_que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"><span class="keyword">auto</span> msg_node = _msg_que.<span class="built_in">front</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;recv_msg id  is &quot;</span> &lt;&lt; msg_node-&gt;_recvnode-&gt;_msg_id &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">auto</span> call_back_iter = _fun_callbacks.<span class="built_in">find</span>(msg_node-&gt;_recvnode-&gt;_msg_id);</span><br><span class="line"><span class="keyword">if</span> (call_back_iter == _fun_callbacks.<span class="built_in">end</span>()) &#123;</span><br><span class="line">_msg_que.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">call_back_iter-&gt;<span class="built_in">second</span>(msg_node-&gt;_session, msg_node-&gt;_recvnode-&gt;_msg_id,</span><br><span class="line">std::<span class="built_in">string</span>(msg_node-&gt;_recvnode-&gt;_data, msg_node-&gt;_recvnode-&gt;_cur_len));</span><br><span class="line">_msg_que.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果没有停服，且说明队列中有数据</span></span><br><span class="line"><span class="keyword">auto</span> msg_node = _msg_que.<span class="built_in">front</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;recv_msg id  is &quot;</span> &lt;&lt; msg_node-&gt;_recvnode-&gt;_msg_id &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">auto</span> call_back_iter = _fun_callbacks.<span class="built_in">find</span>(msg_node-&gt;_recvnode-&gt;_msg_id);</span><br><span class="line"><span class="keyword">if</span> (call_back_iter == _fun_callbacks.<span class="built_in">end</span>()) &#123;</span><br><span class="line">_msg_que.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//因为second为FunCallBack其参数为三个，所以需要三个函数</span></span><br><span class="line">call_back_iter-&gt;<span class="built_in">second</span>(msg_node-&gt;_session, msg_node-&gt;_recvnode-&gt;_msg_id,</span><br><span class="line">std::<span class="built_in">string</span>(msg_node-&gt;_recvnode-&gt;_data, msg_node-&gt;_recvnode-&gt;_cur_len));</span><br><span class="line">_msg_que.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>DealMsg逻辑中初始化了一个unique_lock，主要是用来控制队列安全，并且配合条件变量可以随时解锁。lock_guard不具备解锁功能，所以此处用unique_lock。</li><li>我们判断队列为空，并且不是停止状态，就挂起线程。否则继续执行之后的逻辑，如果_b_stop为true，说明处于停服状态，则将队列中未处理的消息全部处理完然后退出循环。如果_b_stop未false，则说明没有停服，是consumer发送的激活信号激活了线程，则继续取队列中的数据处理。</li></ol><ul><li>LogicSystem的析构函数需要等待工作线程处理完再退出，但是工作线程可能处于挂起状态，所以要发送一个激活信号唤醒工作线程。并且将_b_stop标记设置为true。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LogicSystem::~<span class="built_in">LogicSystem</span>()&#123;</span><br><span class="line">    _b_stop = <span class="literal">true</span>;</span><br><span class="line">    _consume.<span class="built_in">notify_one</span>();</span><br><span class="line">    _worker_thread.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>因为网络层收到消息后我们需要将消息投递给逻辑队列进行处理，那么LogicSystem就要封装一个投递函数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LogicSystem::PostMsgToQue</span><span class="params">(std::shared_ptr&lt;LogicNode&gt; msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">unique_lk</span><span class="params">(mtx)</span></span>;</span><br><span class="line">_msg_que.<span class="built_in">push</span>(msg);</span><br><span class="line"><span class="comment">//由0变为1则发送通知信号,通知被阻塞的线程</span></span><br><span class="line"><span class="keyword">if</span> (_msg_que.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">unique_lk.<span class="built_in">unlock</span>();</span><br><span class="line">_consume.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在Session收到数据时这样调用</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LogicSystem::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">PostMsgToQue</span>(<span class="built_in">make_shared</span>&lt;LogicNode&gt;(<span class="built_in">shared_from_this</span>(), _recv_msg_node));</span><br></pre></td></tr></table></figure><h4 id="LogicSystem-完整代码"><a href="#LogicSystem-完整代码" class="headerlink" title="LogicSystem 完整代码"></a>LogicSystem 完整代码</h4><h5 id="头文件-1"><a href="#头文件-1" class="headerlink" title="头文件"></a>头文件</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;json/json.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;json/value.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;json/reader.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Singleton.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;const.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CSession.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">void</span>(std::shared_ptr&lt;CSession&gt; session, <span class="type">const</span> <span class="type">short</span>&amp; msg_id, <span class="type">const</span> std::string&amp; msg_data)&gt; FunCallBack;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LogicSystem</span> :<span class="keyword">public</span> Singleton&lt;LogicSystem&gt; &#123;</span><br><span class="line"><span class="comment">//由于在Singleton的GetInstacne中调用了LogicSystem的私有构造函数</span></span><br><span class="line"><span class="comment">//所以得声明友元，让对方能够调用</span></span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&lt;LogicSystem&gt;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//设置为公有是为了让单例类能够正常析构</span></span><br><span class="line">~<span class="built_in">LogicSystem</span>();</span><br><span class="line"><span class="comment">//将逻辑节点投递到消息队列里</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostMsgToQue</span><span class="params">(std::shared_ptr&lt;LogicNode&gt; msg)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">LogicSystem</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册功能,是注册函数的统一接口</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RegisterCallBacks</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//具体的注册的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HelloWordCallBacks</span><span class="params">(std::shared_ptr&lt;CSession&gt; new_session, <span class="type">const</span> <span class="type">short</span>&amp; msg_id, <span class="type">const</span> std::string&amp; msg_data)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DealMsg</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用来存储逻辑节点</span></span><br><span class="line">std::queue&lt;std::shared_ptr&lt;LogicNode&gt;&gt; _msg_que;</span><br><span class="line"></span><br><span class="line"><span class="comment">//需要加锁</span></span><br><span class="line">std::mutex mtx;</span><br><span class="line"><span class="comment">//由于有消息队列，所以需要阻塞线程，所以需要</span></span><br><span class="line"><span class="comment">//条件变量来通知被阻塞的线程</span></span><br><span class="line">std::condition_variable _consume;</span><br><span class="line"></span><br><span class="line"><span class="comment">//还需要工作线程来消费逻辑消息</span></span><br><span class="line">std::thread _worker_thread;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用这个来标记逻辑停止</span></span><br><span class="line"><span class="type">bool</span> _b_stop;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用来存储回调函数，也就是注册进来</span></span><br><span class="line">std::map&lt;<span class="type">short</span>, FunCallBack&gt; _fun_callbacks;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LogicSystem.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">LogicSystem::~<span class="built_in">LogicSystem</span>()</span><br><span class="line">&#123;</span><br><span class="line">_b_stop = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 可能还有被挂起的线程</span></span><br><span class="line">_consume.<span class="built_in">notify_one</span>();</span><br><span class="line"></span><br><span class="line">_worker_thread.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LogicSystem::PostMsgToQue</span><span class="params">(std::shared_ptr&lt;LogicNode&gt; msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">unique_lk</span><span class="params">(mtx)</span></span>;</span><br><span class="line">_msg_que.<span class="built_in">push</span>(msg);</span><br><span class="line"><span class="comment">//由0变为1则发送通知信号,通知被阻塞的线程</span></span><br><span class="line"><span class="keyword">if</span> (_msg_que.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">unique_lk.<span class="built_in">unlock</span>();</span><br><span class="line">_consume.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LogicSystem::RegisterCallBacks</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_fun_callbacks[MSG_HELLO_WORD] = std::<span class="built_in">bind</span>(&amp;LogicSystem::HelloWordCallBacks, <span class="keyword">this</span>,</span><br><span class="line">std::placeholders::_1, std::placeholders::_2, std::placeholders::_3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LogicSystem::HelloWordCallBacks</span><span class="params">(std::shared_ptr&lt;CSession&gt; session, <span class="type">const</span> <span class="type">short</span>&amp; msg_id, <span class="type">const</span> std::string&amp; msg_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Json::Reader reader;</span><br><span class="line">Json::Value root;</span><br><span class="line"><span class="comment">//将msg_data 内容系列化到root里</span></span><br><span class="line">reader.<span class="built_in">parse</span>(msg_data, root);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;receive msg id is&quot;</span> &lt;&lt; root[<span class="string">&quot;id&quot;</span>].<span class="built_in">asInt</span>() &lt;&lt; <span class="string">&quot;msg data is &quot;</span></span><br><span class="line">&lt;&lt; root[<span class="string">&quot;data&quot;</span>].<span class="built_in">asString</span>() &lt;&lt; std::endl;</span><br><span class="line">root[<span class="string">&quot;data&quot;</span>] = <span class="string">&quot;server has receive msg, msg data is &quot;</span> + root[<span class="string">&quot;data&quot;</span>].<span class="built_in">asString</span>();</span><br><span class="line"></span><br><span class="line">std::string return_str = root.<span class="built_in">toStyledString</span>();</span><br><span class="line"><span class="comment">//发送信息</span></span><br><span class="line">session-&gt;<span class="built_in">Send</span>(return_str, root[<span class="string">&quot;id&quot;</span>].<span class="built_in">asInt</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LogicSystem::DealMsg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="comment">//配合条件变量使用，以及加锁</span></span><br><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">unique_lk</span><span class="params">(mtx)</span></span>;</span><br><span class="line"><span class="comment">//判断队列为空则用条件变量阻塞等待，并释放锁</span></span><br><span class="line"><span class="keyword">while</span> (_msg_que.<span class="built_in">empty</span>() &amp;&amp; !_b_stop) &#123;</span><br><span class="line">_consume.<span class="built_in">wait</span>(unique_lk);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 也可以这么写</span></span><br><span class="line"><span class="comment">_consume.wait(unique_lk, [this]()&#123;</span></span><br><span class="line"><span class="comment">return !_msg_que.empty() &amp;&amp; _b_stop</span></span><br><span class="line"><span class="comment">&#125;)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否为关闭状态，把所有逻辑执行完后则退出循环</span></span><br><span class="line"><span class="keyword">if</span> (_b_stop) &#123;</span><br><span class="line"><span class="keyword">while</span> (!_msg_que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"><span class="keyword">auto</span> msg_node = _msg_que.<span class="built_in">front</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;recv_msg id  is &quot;</span> &lt;&lt; msg_node-&gt;_recvnode-&gt;_msg_id &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">auto</span> call_back_iter = _fun_callbacks.<span class="built_in">find</span>(msg_node-&gt;_recvnode-&gt;_msg_id);</span><br><span class="line"><span class="keyword">if</span> (call_back_iter == _fun_callbacks.<span class="built_in">end</span>()) &#123;</span><br><span class="line">_msg_que.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">call_back_iter-&gt;<span class="built_in">second</span>(msg_node-&gt;_session, msg_node-&gt;_recvnode-&gt;_msg_id,</span><br><span class="line">std::<span class="built_in">string</span>(msg_node-&gt;_recvnode-&gt;_data, msg_node-&gt;_recvnode-&gt;_cur_len));</span><br><span class="line">_msg_que.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果没有停服，且说明队列中有数据</span></span><br><span class="line"><span class="keyword">auto</span> msg_node = _msg_que.<span class="built_in">front</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;recv_msg id  is &quot;</span> &lt;&lt; msg_node-&gt;_recvnode-&gt;_msg_id &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">auto</span> call_back_iter = _fun_callbacks.<span class="built_in">find</span>(msg_node-&gt;_recvnode-&gt;_msg_id);</span><br><span class="line"><span class="keyword">if</span> (call_back_iter == _fun_callbacks.<span class="built_in">end</span>()) &#123;</span><br><span class="line">_msg_que.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//因为second为FunCallBack其参数为三个，所以需要三个函数</span></span><br><span class="line">call_back_iter-&gt;<span class="built_in">second</span>(msg_node-&gt;_session, msg_node-&gt;_recvnode-&gt;_msg_id,</span><br><span class="line">std::<span class="built_in">string</span>(msg_node-&gt;_recvnode-&gt;_data, msg_node-&gt;_recvnode-&gt;_cur_len));</span><br><span class="line">_msg_que.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LogicSystem::<span class="built_in">LogicSystem</span>(): _b_stop(<span class="literal">false</span>) &#123;</span><br><span class="line"><span class="comment">//用于绑定回调函数</span></span><br><span class="line"><span class="built_in">RegisterCallBacks</span>();</span><br><span class="line"><span class="comment">//启动工作线程</span></span><br><span class="line">_worker_thread = std::<span class="built_in">thread</span>(&amp;LogicSystem::DealMsg, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="服务器优雅退出"><a href="#服务器优雅退出" class="headerlink" title="服务器优雅退出"></a>服务器优雅退出</h2><h3 id="退出方式1：开辟线程，让服务器运行在线程中并接受退出信号退出"><a href="#退出方式1：开辟线程，让服务器运行在线程中并接受退出信号退出" class="headerlink" title="退出方式1：开辟线程，让服务器运行在线程中并接受退出信号退出"></a>退出方式1：开辟线程，让服务器运行在线程中并接受退出信号退出</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CServer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;csignal&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">bool</span> bstop = <span class="literal">false</span>;</span><br><span class="line">std::condition_variable cond_quit;</span><br><span class="line">std::mutex mutex_quit;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">signal_handler</span><span class="params">(<span class="type">int</span> sig)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (sig == SIGINT || sig == SIGTERM) &#123;</span><br><span class="line"><span class="comment">//访问共享数据接得加锁</span></span><br><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_quit)</span></span>;</span><br><span class="line">bstop = <span class="literal">true</span>;</span><br><span class="line">cond_quit.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">boost::asio::io_context ioc;</span><br><span class="line"><span class="function">std::thread <span class="title">network_thread</span><span class="params">([&amp;ioc]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">CServer server(ioc, <span class="number">8888</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">ioc.run();</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">signal</span>(SIGINT, signal_handler);</span><br><span class="line"><span class="built_in">signal</span>(SIGTERM, signal_handler);</span><br><span class="line"></span><br><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_quit)</span></span>;</span><br><span class="line"><span class="comment">//阻塞的时候自动解锁</span></span><br><span class="line">cond_quit.<span class="built_in">wait</span>(lock, []() &#123; &#123;</span><br><span class="line"><span class="keyword">return</span> bstop;</span><br><span class="line">&#125;&#125;);</span><br><span class="line"></span><br><span class="line">ioc.<span class="built_in">stop</span>();</span><br><span class="line">network_thread.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">std::cerr &lt;&lt; <span class="string">&quot;Exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="退出方式2：使用asio底层异步等待函数"><a href="#退出方式2：使用asio底层异步等待函数" class="headerlink" title="退出方式2：使用asio底层异步等待函数"></a>退出方式2：使用asio底层异步等待函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CServer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;csignal&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">boost::asio::io_context ioc;</span><br><span class="line">boost::<span class="function">asio::signal_set <span class="title">signals</span><span class="params">(ioc, SIGINT, SIGTERM)</span></span>;</span><br><span class="line"><span class="comment">//参数列表有两个参数表示接收到的信号</span></span><br><span class="line">signals.<span class="built_in">async_wait</span>([&amp;ioc](<span class="keyword">auto</span>, <span class="keyword">auto</span>) &#123;</span><br><span class="line">ioc.<span class="built_in">stop</span>();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="function">CServer <span class="title">server</span><span class="params">(ioc, <span class="number">8888</span>)</span></span>;</span><br><span class="line">ioc.<span class="built_in">run</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">std::cerr &lt;&lt; <span class="string">&quot;Exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li>两种方式都对服务器进行了优雅的退出</li></ul><h2 id="asio多线程模型IOServicePool"><a href="#asio多线程模型IOServicePool" class="headerlink" title="asio多线程模型IOServicePool"></a>asio多线程模型IOServicePool</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><ul><li>前面的设计，我们对asio的使用都是单线程模式，为了提升网络io并发处理的效率，这一次我们设计多线程模式下asio的使用方式。总体来说asio有两个多线程模型，第一个是启动多个线程，每个线程管理一个iocontext。第二种是只启动一个iocontext，被多个线程共享，后面的文章会对比两个模式的区别，<strong>这里先介绍第一种模式，多个线程，每个线程管理独立的iocontext服务</strong>。</li></ul><h3 id="单线程和多线程对比"><a href="#单线程和多线程对比" class="headerlink" title="单线程和多线程对比"></a>单线程和多线程对比</h3><ul><li>之前的单线程模式图如下</li></ul><p><img src="../assets/C++asio网络编程/image-20.png" alt="示例图片" style="zoom:100%;" /></p><ul><li>我们设计的IOServicePool类型的多线程模型如下：</li></ul><p><img src="../assets/C++asio网络编程/image-21.png" alt="示例图片" style="zoom:100%;" /></p><ul><li>IOServicePool多线程模式特点<ol><li>每一个io_context跑在不同的线程里，所以同一个socket会被注册在同一个io_context里，它的回调函数也会被单独的一个线程回调，那么对于同一个socket，他的回调函数每次触发都是在同一个线程里，就不会有线程安全问题，网络io层面上的并发是线程安全的。</li><li>但是对于不同的socket，回调函数的触发可能是同一个线程(两个socket被分配到同一个io_context)，也可能不是同一个线程(两个socket被分配到不同的io_context里)。所以如果两个socket对应的上层逻辑处理，如果有交互或者访问共享区，会存在线程安全问题。比如socket1代表玩家1，socket2代表玩家2，玩家1和玩家2在逻辑层存在交互，比如两个玩家都在做工会任务，他们属于同一个工会，工会积分的增加就是共享区的数据，需要保证线程安全。可以通过加锁或者逻辑队列的方式解决安全问题，我们目前采取了后者。</li><li>多线程相比单线程，极大的提高了并发能力，因为单线程仅有一个io_context服务用来监听读写事件，就绪后回调函数在一个线程里串行调用, 如果一个回调函数的调用时间较长肯定会影响后续的函数调用，毕竟是穿行调用。而采用多线程方式，可以在一定程度上减少前一个逻辑调用影响下一个调用的情况，比如两个socket被部署到不同的iocontext上，但是当两个socket部署到同一个iocontext上时仍然存在调用时间影响的问题。不过我们已经通过逻辑队列的方式将网络线程和逻辑线程解耦合了，不会出现前一个调用时间影响下一个回调触发的问题。</li></ol></li></ul><h3 id="IOServicePool实现"><a href="#IOServicePool实现" class="headerlink" title="IOServicePool实现"></a>IOServicePool实现</h3><ul><li>在使用拷贝构造的时候参数列表的&amp;是必须的，原因：<strong>这不仅仅只是为了减少一次构造成本，更重要是为了避免递归构造</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Pool</span>(<span class="type">const</span> Pool x);</span><br><span class="line"></span><br><span class="line">Pool p1 = p2;</span><br></pre></td></tr></table></figure><ul><li>以上就会有循环构造的情况，p2传给参数列表的时候又要调用拷贝构造 Pool x = p2, 之后又要进行拷贝构造，如此循环</li><li><p>同时一定要判断拷贝的是不是自己这种情况</p></li><li><p>IOServicePool本质上是一个线程池，基本功能就是根据构造函数传入的数量创建n个线程和iocontext，然后每个线程跑一个iocontext，这样就可以并发处理不同iocontext读写事件了。</p></li></ul><h4 id="IOServicePool的声明"><a href="#IOServicePool的声明" class="headerlink" title="IOServicePool的声明:"></a>IOServicePool的声明:</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CSession.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CServer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">CServer</span>(boost::asio::io_context&amp; ioc, <span class="type">unsigned</span> <span class="type">short</span> port);</span><br><span class="line">~<span class="built_in">CServer</span>();</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ClearSession</span><span class="params">(std::string&amp; uuid)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">//处理连接的回调函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HandleAccept</span><span class="params">(std::shared_ptr&lt;CSession&gt; session, <span class="type">const</span> boost::system::error_code&amp; error)</span></span>;</span><br><span class="line"><span class="comment">//开始建立连接的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StartAccept</span><span class="params">()</span></span>;</span><br><span class="line">boost::asio::ip::tcp::acceptor _acceptor;</span><br><span class="line">boost::asio::io_context&amp; _ioc;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> _port;</span><br><span class="line"><span class="comment">//将连接加入map，增加引用计数，防止未执行完逻辑就被析构</span></span><br><span class="line">std::map&lt;std::string, std::shared_ptr&lt;CSession&gt;&gt; _sessions;</span><br><span class="line">std::mutex mtx;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>_ioServices是一个IOService的vector变量，用来存储初始化的多个IOService。</li><li>WorkPtr是boost::asio::io_context::work类型的unique指针。<br>在实际使用中，我们通常会将一些异步操作提交给io_context进行处理，然后该操作会被异步执行，而不会立即返回结果。如果没有其他任务需要执行，那么io_context就会停止工作，导致所有正在进行的异步操作都被取消。这时，我们需要使用boost::asio::io_context::work对象来防止io_context停止工作。</li></ol><ul><li>boost::asio::io_context::work的作用是持有一个指向io_context的引用，并通过创建一个“工作”项来保证io_context不会停止工作，直到work对象被销毁或者调用reset()方法为止。当所有异步操作完成后，程序可以使用work.reset()方法来释放io_context，从而让其正常退出。</li></ul><ol><li>_threads是一个线程vector,管理我们开辟的所有线程。</li><li>_nextIOService是一个轮询索引，我们用最简单的轮询算法为每个新创建的连接分配io_context.</li><li>因为IOServicePool不允许被copy构造，所以我们将其拷贝构造和拷贝复制函数置为delete</li></ol><h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;IOServicePool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">IOServicePool::~<span class="built_in">IOServicePool</span>()</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;destruct IOServicePool&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IOServicePool::Stop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; work : _works) &#123;</span><br><span class="line"><span class="comment">//因为仅仅执行work.reset并不能让iocontext从run的状态中退出</span></span><br><span class="line"><span class="comment">//当iocontext已经绑定了读或写的监听事件后，还需要手动stop该服务。</span></span><br><span class="line"><span class="comment">//停止与work相关的上下文</span></span><br><span class="line">work-&gt;<span class="built_in">get_io_context</span>().<span class="built_in">stop</span>();</span><br><span class="line"><span class="comment">//重新设成空</span></span><br><span class="line">work.<span class="built_in">reset</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; td : _threads) &#123;</span><br><span class="line"><span class="keyword">if</span> (td.<span class="built_in">joinable</span>()) &#123;</span><br><span class="line">td.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">boost::<span class="function">asio::io_context&amp; <span class="title">IOServicePool::GetIOService</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span>&amp; service =  _ioService[_nextIOService++];</span><br><span class="line"><span class="keyword">if</span> (_nextIOService == _ioService.<span class="built_in">size</span>()) &#123;</span><br><span class="line">_nextIOService = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> service;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IOServicePool::<span class="built_in">IOServicePool</span>(std::<span class="type">size_t</span> size) : _works(size), _ioService(size),_nextIOService(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//初始化works</span></span><br><span class="line"><span class="keyword">for</span> (std::<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">_works[i] = std::<span class="built_in">unique_ptr</span>&lt;Work&gt;(<span class="keyword">new</span> <span class="built_in">Work</span>(_ioService[i]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历多个ioservice，创建多个线程，每个线程内部启动ioservice</span></span><br><span class="line"><span class="keyword">for</span> (std::<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; _ioService.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">_threads.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>, i]() &#123;</span><br><span class="line">_ioService[i].<span class="built_in">run</span>();</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="优雅退出"><a href="#优雅退出" class="headerlink" title="优雅退出"></a>优雅退出</h3><ul><li>IOServicePool多线程服务器退出时，需要捕获退出信号如SIGINT,SIGTERM等，将退出信号和一个iocontext绑定，当收到退出信号时，我们将IOServicePool停止，并且停止iocontext即可。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">auto</span> pool = AsioIOServicePool::<span class="built_in">GetInstance</span>();</span><br><span class="line">        boost::asio::io_context  io_context;</span><br><span class="line">        boost::<span class="function">asio::signal_set <span class="title">signals</span><span class="params">(io_context, SIGINT, SIGTERM)</span></span>;</span><br><span class="line">        signals.<span class="built_in">async_wait</span>([&amp;io_context,pool](<span class="keyword">auto</span>, <span class="keyword">auto</span>) &#123;</span><br><span class="line">            io_context.<span class="built_in">stop</span>();</span><br><span class="line">            pool-&gt;<span class="built_in">Stop</span>();</span><br><span class="line">            &#125;);</span><br><span class="line">        <span class="function">CServer <span class="title">s</span><span class="params">(io_context, <span class="number">10086</span>)</span></span>;</span><br><span class="line">        io_context.<span class="built_in">run</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="asio多线程模式IOThreadPool"><a href="#asio多线程模式IOThreadPool" class="headerlink" title="asio多线程模式IOThreadPool"></a>asio多线程模式IOThreadPool</h2><ul><li>今天给大家介绍asio多线程模式的第二种，之前我们介绍了IOServicePool的方式，一个IOServicePool开启n个线程和n个iocontext，每个线程内独立运行iocontext, 各个iocontext监听各自绑定的socket是否就绪，如果就绪就在各自线程里触发回调函数。为避免线程安全问题，我们将网络数据封装为逻辑包投递给逻辑系统，逻辑系统有一个单独线程处理，这样将网络IO和逻辑处理解耦合，极大的提高了服务器IO层面的吞吐率。<strong>这一次介绍的另一种多线程模式IOThreadPool，我们只初始化一个iocontext用来监听服务器的读写事件，包括新连接到来的监听也用这个iocontext。只是我们让iocontext.run在多个线程中调用，这样回调函数就会被不同的线程触发，从这个角度看回调函数被并发调用了。</strong></li></ul><h3 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h3><ul><li>线程池模式的多线程模型调度结构图,如下</li></ul><p><img src="../assets/C++asio网络编程/image-22.png" alt="示例图片" style="zoom:100%;" /></p><h3 id="先实现IOThreadPool"><a href="#先实现IOThreadPool" class="headerlink" title="先实现IOThreadPool"></a>先实现IOThreadPool</h3><h4 id="IOThreadPool-头文件"><a href="#IOThreadPool-头文件" class="headerlink" title="IOThreadPool 头文件"></a>IOThreadPool 头文件</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Singleton.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IOThreadPool</span> :<span class="keyword">public</span> Singleton&lt;IOThreadPool&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">using</span> Work = boost::asio::io_context::work;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&lt;IOThreadPool&gt;;</span><br><span class="line">~<span class="built_in">IOThreadPool</span>();</span><br><span class="line">boost::<span class="function">asio::io_context&amp; <span class="title">GetIOService</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Stop</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">IOThreadPool</span>(<span class="type">int</span> threadNum = std::thread::<span class="built_in">hardware_concurrency</span>());</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span>;</span><br><span class="line"><span class="built_in">IOThreadPool</span>(<span class="type">const</span> IOThreadPool&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">IOThreadPool&amp; <span class="keyword">operator</span> = (<span class="type">const</span> IOThreadPool&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">std::atomic_int thread_nums;</span><br><span class="line"></span><br><span class="line">boost::asio::io_context _service;</span><br><span class="line"></span><br><span class="line"><span class="comment">//防止io_context.run的时候退出</span></span><br><span class="line">std::unique_ptr&lt;Work&gt; _work;</span><br><span class="line"></span><br><span class="line">std::vector&lt;std::thread&gt; pools;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>IOThreadPool继承了Singleton<IOThreadPool>，实现了一个函数GetIOService获取iocontext</li></ul><h4 id="IOThreadPool-实现"><a href="#IOThreadPool-实现" class="headerlink" title="IOThreadPool 实现"></a>IOThreadPool 实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;IOThreadPool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">IOThreadPool::~<span class="built_in">IOThreadPool</span>()</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;destruct IOThreadPool &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">boost::<span class="function">asio::io_context&amp; <span class="title">IOThreadPool::GetIOService</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此处插入 return 语句</span></span><br><span class="line"><span class="keyword">return</span> _service;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IOThreadPool::Stop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_work.<span class="built_in">reset</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; td : pools) &#123;</span><br><span class="line">td.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IOThreadPool::Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; thread_nums; i++) &#123;</span><br><span class="line">pools.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>]() &#123;</span><br><span class="line">_service.<span class="built_in">run</span>();</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IOThreadPool::<span class="built_in">IOThreadPool</span>(<span class="type">int</span> threadNum):</span><br><span class="line">_work(<span class="keyword">new</span> <span class="built_in">Work</span>(_service))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (threadNum &lt; <span class="number">1</span>) thread_nums = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> thread_nums = threadNum;</span><br><span class="line"><span class="built_in">Start</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>构造函数中实现了一个线程池，线程池里每个线程都会运行_service.run函数，_service.run函数内部就是从iocp或者epoll获取就绪描述符和绑定的回调函数，进而调用回调函数，因为回调函数是在不同的线程里调用的，所以会存在不同的线程调用同一个socket的回调函数的情况。</p></li><li><p>_service.run 内部在Linux环境下调用的是epoll_wait返回所有就绪的描述符列表，在windows上会循环调用GetQueuedCompletionStatus函数返回就绪的描述符，二者原理类似，进而通过描述符找到对应的注册的回调函数，然后调用回调函数。</p></li></ul><h5 id="iocp的流程是这样的"><a href="#iocp的流程是这样的" class="headerlink" title="iocp的流程是这样的"></a>iocp的流程是这样的</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IOCP的使用主要分为以下几步：</span><br><span class="line"><span class="number">1</span> 创建完成端口(iocp)对象</span><br><span class="line"><span class="number">2</span> 创建一个或多个工作线程，在完成端口上执行并处理投递到完成端口上的I/O请求</span><br><span class="line"><span class="number">3</span> Socket关联iocp对象，在Socket上投递网络事件</span><br><span class="line"><span class="number">4</span> 工作线程调用GetQueuedCompletionStatus函数获取完成通知封包，取得事件信息并进行处理</span><br></pre></td></tr></table></figure><h5 id="epoll流程是这样的"><a href="#epoll流程是这样的" class="headerlink" title="epoll流程是这样的"></a>epoll流程是这样的</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> 调用epoll_creat在内核中创建一张epoll表</span><br><span class="line"><span class="number">2</span> 开辟一片包含n个epoll_event大小的连续空间</span><br><span class="line"><span class="number">3</span> 将要监听的socket注册到epoll表里</span><br><span class="line"><span class="number">4</span> 调用epoll_wait，传入之前我们开辟的连续空间，epoll_wait返回就绪的epoll_event列表，epoll会将就绪的socket信息写入我们之前开辟的连续空间</span><br></pre></td></tr></table></figure><h3 id="隐患-1"><a href="#隐患-1" class="headerlink" title="隐患"></a>隐患</h3><ul><li>IOThreadPool模式有一个隐患，同一个socket的就绪后，触发的回调函数可能在不同的线程里，比如第一次是在线程1，第二次是在线程3，如果这两次触发间隔时间不大，那么很可能出现不同线程并发访问数据的情况，比如在处理读事件时，第一次回调触发后我们从socket的接收缓冲区读数据出来，第二次回调触发,还是从socket的接收缓冲区读数据，就会造成两个线程同时从socket中读数据的情况，会造成数据混乱。</li></ul><h3 id="利用strand改进"><a href="#利用strand改进" class="headerlink" title="利用strand改进"></a>利用strand改进</h3><ul><li>对于多线程触发回调函数的情况，我们可以利用asio提供的串行类strand封装一下，这样就可以被串行调用了，其基本原理就是在线程各自调用函数时取消了直接调用的方式，而是利用一个strand类型的对象将要调用的函数投递到strand管理的队列中，再由一个统一的线程调用回调函数，调用是串行的，解决了线程并发带来的安全问题。</li></ul><p><img src="image-23.png" alt="alt text"></p><ul><li><p>图中当socket就绪后并不是由多个线程调用每个socket注册的回调函数，而是将回调函数投递给strand管理的队列，再由strand统一调度派发。</p></li><li><p>为了让回调函数被派发到strand的队列，我们只需要在注册回调函数时加一层strand的包装即可。</p></li><li><p>在CSession类中添加一个成员变量</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strand&lt;io_context::executor_type&gt; _strand;</span><br></pre></td></tr></table></figure><ul><li>CSession构造函数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CSession::<span class="built_in">CSession</span>(boost::asio::io_context&amp; io_context, CServer* server):</span><br><span class="line">    _socket(io_context), _server(server), _b_close(<span class="literal">false</span>),</span><br><span class="line">    _b_head_parse(<span class="literal">false</span>), _strand(io_context.<span class="built_in">get_executor</span>())&#123;</span><br><span class="line">    boost::uuids::uuid  a_uuid = boost::uuids::<span class="built_in">random_generator</span>()();</span><br><span class="line">    _uuid = boost::uuids::<span class="built_in">to_string</span>(a_uuid);</span><br><span class="line">    _recv_head_node = <span class="built_in">make_shared</span>&lt;MsgNode&gt;(HEAD_TOTAL_LEN);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>可以看到_strand的初始化是放在初始化列表里，利用io_context.get_executor()返回的执行器构造strand。</p></li><li><p>因为在asio中无论iocontext还是strand，底层都是通过executor调度的，我们将他理解为调度器就可以了，如果多个iocontext和strand的调度器是一个，那他们的消息派发统一由这个调度器执行。</p></li><li><p>我们利用iocontext的调度器构造strand，这样他们统一由一个调度器管理。在绑定回调函数的调度器时，我们选择strand绑定即可。</p></li><li><p>比如我们在Start函数里添加绑定 ，将回调函数的调用者绑定为_strand</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::Start</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ::<span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);</span><br><span class="line">    _socket.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, MAX_LENGTH),</span><br><span class="line">        boost::asio::<span class="built_in">bind_executor</span>(_strand, std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>,</span><br><span class="line">            std::placeholders::_1, std::placeholders::_2, <span class="built_in">SharedSelf</span>())));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>同样的道理，在所有收发的地方，都将调度器绑定为_strand， 比如发送部分我们需要修改为如下</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>&amp; msgnode = _send_que.<span class="built_in">front</span>();</span><br><span class="line">    boost::asio::<span class="built_in">async_write</span>(_socket, boost::asio::<span class="built_in">buffer</span>(msgnode-&gt;_data, msgnode-&gt;_total_len), </span><br><span class="line">    boost::asio::<span class="built_in">bind_executor</span>(_strand, std::<span class="built_in">bind</span>(&amp;CSession::HandleWrite, <span class="keyword">this</span>, std::placeholders::_1, <span class="built_in">SharedSelf</span>()))</span><br><span class="line">        );</span><br></pre></td></tr></table></figure><ul><li>修改main函数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CServer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;csignal&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;IOThreadPool.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">bool</span> bstop = <span class="literal">false</span>;</span><br><span class="line">std::condition_variable cond_quit;</span><br><span class="line">std::mutex mtx;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">auto</span> pool = IOThreadPool::<span class="built_in">GetInstance</span>();</span><br><span class="line">boost::asio::io_context ioc;</span><br><span class="line">boost::<span class="function">asio::signal_set <span class="title">signals</span><span class="params">(ioc, SIGINT, SIGTERM)</span></span>;</span><br><span class="line"><span class="comment">//参数列表有两个参数表示接收到的信号,他的注册函数会在asio的独立线程里</span></span><br><span class="line">        <span class="comment">//所以共享变量需要加锁</span></span><br><span class="line">signals.<span class="built_in">async_wait</span>([&amp;ioc](<span class="keyword">auto</span>, <span class="keyword">auto</span>) &#123;</span><br><span class="line">ioc.<span class="built_in">stop</span>();</span><br><span class="line">pool-&gt;<span class="built_in">stop</span>();</span><br><span class="line"><span class="comment">//加锁与条件变量是因为在主线程里并没有调用</span></span><br><span class="line"><span class="comment">//io_context.run()函数，而是在线程池里调用</span></span><br><span class="line"><span class="comment">//线程池相当于主线程的子线程</span></span><br><span class="line">std::unique_lock&lt;std::mutex&gt; <span class="built_in">lock</span>(mtx);</span><br><span class="line">bstop = <span class="literal">true</span>;</span><br><span class="line">cond_quit.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//修改这里</span></span><br><span class="line"><span class="function">CServer <span class="title">server</span><span class="params">(pool-&gt;GetIOService(), <span class="number">8888</span>)</span></span>;</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line"><span class="keyword">while</span> (!bstop) &#123;</span><br><span class="line">                <span class="comment">//线程挂起，锁释放</span></span><br><span class="line">cond_quit.<span class="built_in">wait</span>(lock);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">std::cerr &lt;&lt; <span class="string">&quot;Exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CSession代码"><a href="#CSession代码" class="headerlink" title="CSession代码"></a>CSession代码</h3><ul><li>改动了将回调函数绑定到_strand的处理器里上</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/uuid/uuid_io.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/uuid/uuid_generators.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MsgNode.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;const.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//避免循环依赖问题使用前置声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CServer</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LogicSystem</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CSession</span>: <span class="keyword">public</span> std::enable_shared_from_this&lt;CSession&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">CSession</span>(boost::asio::io_context&amp; ioc, CServer* server);</span><br><span class="line">~<span class="built_in">CSession</span>();</span><br><span class="line">boost::asio::ip::<span class="function">tcp::socket&amp; <span class="title">GetSocket</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">std::string&amp; <span class="title">GetUuid</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Send</span><span class="params">(<span class="type">char</span>* msg, <span class="type">short</span> max_len, <span class="type">short</span> msgid)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Send</span><span class="params">(std::string msg, <span class="type">short</span> msgid)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Close</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;CSession&gt; <span class="title">SharedSelf</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HandleRead</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, <span class="type">size_t</span> bytes_transferred, std::shared_ptr&lt;CSession&gt; shared_self)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HandleWrite</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, std::shared_ptr&lt;CSession&gt; shared_self)</span></span>;</span><br><span class="line">boost::asio::ip::tcp::socket _socket;</span><br><span class="line">std::string _uuid;</span><br><span class="line"><span class="type">char</span> _data[MAX_LENGTH];</span><br><span class="line">CServer* _server;</span><br><span class="line"><span class="comment">//标志是否关闭</span></span><br><span class="line"><span class="type">bool</span> _b_close;</span><br><span class="line"><span class="comment">//用于保证发送信息的时序性</span></span><br><span class="line">std::queue&lt;std::shared_ptr&lt;SendNode&gt;&gt; _send_que;</span><br><span class="line"><span class="comment">//对队列加锁</span></span><br><span class="line">std::mutex _send_lock;</span><br><span class="line"><span class="comment">// 收到的消息结构</span></span><br><span class="line">std::shared_ptr&lt;RecvNode&gt; _recv_msg_node;</span><br><span class="line"><span class="comment">//判断头部节点是否构造完成</span></span><br><span class="line"><span class="type">bool</span> _b_head_parse;</span><br><span class="line"><span class="comment">//收到的头部结构,包括消息id与消息体长度</span></span><br><span class="line">std::shared_ptr&lt;MsgNode&gt; _recv_head_node;</span><br><span class="line"></span><br><span class="line"><span class="comment">//并行执行事件改为串行执行，使用strand</span></span><br><span class="line"><span class="comment">//每个srand有个执行类型，让他为上下文的执行类型</span></span><br><span class="line"><span class="comment">//类似我们封装的logic system</span></span><br><span class="line">boost::asio::strand&lt;boost::asio::io_context::executor_type&gt; _strand;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LogicNode</span> &#123;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">LogicSystem</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">LogicNode</span>(std::shared_ptr&lt;CSession&gt; session, std::shared_ptr&lt;RecvNode&gt; recvnode);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::shared_ptr&lt;CSession&gt; _session;</span><br><span class="line">std::shared_ptr&lt;RecvNode&gt; _recvnode;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h3><ul><li><p>为了比较两种服务器多线程模式的性能，我们还是利用之前测试的客户端，客户端每隔10ms建立一个连接，总共建立100个连接，每个连接收发500次，总计10万个数据包，测试一下性能。</p></li><li><p>客户端测试代码如下</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;json/json.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;json/value.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;json/reader.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::asio::ip;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_LENGTH = <span class="number">1024</span> * <span class="number">2</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> HEAD_LENGTH = <span class="number">2</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> HEAD_TOTAL = <span class="number">4</span>;</span><br><span class="line">std::vector&lt;thread&gt; vec_threads;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> start = std::chrono::high_resolution_clock::<span class="built_in">now</span>(); <span class="comment">// 获取开始时间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        vec_threads.<span class="built_in">emplace_back</span>([]() &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//创建上下文服务</span></span><br><span class="line">                boost::asio::io_context   ioc;</span><br><span class="line">                <span class="comment">//构造endpoint</span></span><br><span class="line">                tcp::endpoint  <span class="built_in">remote_ep</span>(address::<span class="built_in">from_string</span>(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="number">10086</span>);</span><br><span class="line">                tcp::socket  <span class="built_in">sock</span>(ioc);</span><br><span class="line">                boost::system::error_code   error = boost::asio::error::host_not_found; ;</span><br><span class="line">                sock.<span class="built_in">connect</span>(remote_ep, error);</span><br><span class="line">                <span class="keyword">if</span> (error) &#123;</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;connect failed, code is &quot;</span> &lt;&lt; error.<span class="built_in">value</span>() &lt;&lt; <span class="string">&quot; error msg is &quot;</span> &lt;&lt; error.<span class="built_in">message</span>();</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (i &lt; <span class="number">500</span>) &#123;</span><br><span class="line">                    Json::Value root;</span><br><span class="line">                    root[<span class="string">&quot;id&quot;</span>] = <span class="number">1001</span>;</span><br><span class="line">                    root[<span class="string">&quot;data&quot;</span>] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">                    std::string request = root.<span class="built_in">toStyledString</span>();</span><br><span class="line">                    <span class="type">size_t</span> request_length = request.<span class="built_in">length</span>();</span><br><span class="line">                    <span class="type">char</span> send_data[MAX_LENGTH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">                    <span class="type">int</span> msgid = <span class="number">1001</span>;</span><br><span class="line">                    <span class="type">int</span> msgid_host = boost::asio::detail::socket_ops::<span class="built_in">host_to_network_short</span>(msgid);</span><br><span class="line">                    <span class="built_in">memcpy</span>(send_data, &amp;msgid_host, <span class="number">2</span>);</span><br><span class="line">                    <span class="comment">//转为网络字节序</span></span><br><span class="line">                    <span class="type">int</span> request_host_length = boost::asio::detail::socket_ops::<span class="built_in">host_to_network_short</span>(request_length);</span><br><span class="line">                    <span class="built_in">memcpy</span>(send_data + <span class="number">2</span>, &amp;request_host_length, <span class="number">2</span>);</span><br><span class="line">                    <span class="built_in">memcpy</span>(send_data + <span class="number">4</span>, request.<span class="built_in">c_str</span>(), request_length);</span><br><span class="line">                    boost::asio::<span class="built_in">write</span>(sock, boost::asio::<span class="built_in">buffer</span>(send_data, request_length + <span class="number">4</span>));</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;begin to receive...&quot;</span> &lt;&lt; endl;</span><br><span class="line">                    <span class="type">char</span> reply_head[HEAD_TOTAL];</span><br><span class="line">                    <span class="type">size_t</span> reply_length = boost::asio::<span class="built_in">read</span>(sock, boost::asio::<span class="built_in">buffer</span>(reply_head, HEAD_TOTAL));</span><br><span class="line">                    msgid = <span class="number">0</span>;</span><br><span class="line">                    <span class="built_in">memcpy</span>(&amp;msgid, reply_head, HEAD_LENGTH);</span><br><span class="line">                    <span class="type">short</span> msglen = <span class="number">0</span>;</span><br><span class="line">                    <span class="built_in">memcpy</span>(&amp;msglen, reply_head + <span class="number">2</span>, HEAD_LENGTH);</span><br><span class="line">                    <span class="comment">//转为本地字节序</span></span><br><span class="line">                    msglen = boost::asio::detail::socket_ops::<span class="built_in">network_to_host_short</span>(msglen);</span><br><span class="line">                    msgid = boost::asio::detail::socket_ops::<span class="built_in">network_to_host_short</span>(msgid);</span><br><span class="line">                    <span class="type">char</span> msg[MAX_LENGTH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">                    <span class="type">size_t</span>  msg_length = boost::asio::<span class="built_in">read</span>(sock, boost::asio::<span class="built_in">buffer</span>(msg, msglen));</span><br><span class="line">                    Json::Reader reader;</span><br><span class="line">                    reader.<span class="built_in">parse</span>(std::<span class="built_in">string</span>(msg, msg_length), root);</span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot;msg id is &quot;</span> &lt;&lt; root[<span class="string">&quot;id&quot;</span>] &lt;&lt; <span class="string">&quot; msg is &quot;</span> &lt;&lt; root[<span class="string">&quot;data&quot;</span>] &lt;&lt; endl;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">                std::cerr &lt;&lt; <span class="string">&quot;Exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : vec_threads) &#123;</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行一些需要计时的操作</span></span><br><span class="line">    <span class="keyword">auto</span> end = std::chrono::high_resolution_clock::<span class="built_in">now</span>(); <span class="comment">// 获取结束时间</span></span><br><span class="line">    <span class="keyword">auto</span> duration = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::seconds&gt;(end - start); <span class="comment">// 计算时间差，单位为微秒</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Time spent: &quot;</span> &lt;&lt; duration.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; seconds.&quot;</span> &lt;&lt; std::endl; <span class="comment">// 输</span></span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试得出今天实现的多线程模式较之前的IOServicePool版本慢了7秒</li></ul><h3 id="取舍"><a href="#取舍" class="headerlink" title="取舍"></a>取舍</h3><ul><li>实际的生产和开发中，我们尽可能利用C++特性，使用多核的优势，将iocontext分布在不同的线程中效率更可取一点（也就是第一种），但也要防止线程过多导致cpu切换带来的时间片开销，所以尽量让开辟的线程数小于或等于cpu的核数，从而利用多核优势。</li></ul><h2 id="boost-asio协程实现并发服务器"><a href="#boost-asio协程实现并发服务器" class="headerlink" title="boost::asio协程实现并发服务器"></a>boost::asio协程实现并发服务器</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><ul><li>之前介绍了asio服务器并发编程的几种模型，包括单线程，多线程IOServicePool，多线程IOThreadPool等，今天带着大家利用asio协程实现并发服务器。利用协程实现并发程序有两个好处<ol><li>将回调函数改写为顺序调用，提高开发效率。</li><li>协程调度比线程调度更轻量化，因为协程是运行在用户空间的，线程切换需要在用户空间和内核空间切换。</li></ol></li></ul><h3 id="协程案例"><a href="#协程案例" class="headerlink" title="协程案例"></a>协程案例</h3><ul><li>asio官网提供了一个协程并发编程的案例，我们列举一下</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio/co_spawn.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio/detached.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio/io_context.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio/ip/tcp.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio/signal_set.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio/write.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//允许异步等待</span></span><br><span class="line"><span class="keyword">using</span> boost::asio::awaitable;</span><br><span class="line"><span class="comment">//启动协程需要</span></span><br><span class="line"><span class="keyword">using</span> boost::asio::co_spawn;</span><br><span class="line"><span class="comment">//启动协程的方式，让协程独立启动</span></span><br><span class="line"><span class="keyword">using</span> boost::asio::detached;</span><br><span class="line"><span class="comment">//让协程可以等待</span></span><br><span class="line"><span class="keyword">using</span> boost::asio::use_awaitable;</span><br><span class="line"><span class="comment">//返回协程当前执行的环境，将此可以作为调度器</span></span><br><span class="line"><span class="keyword">namespace</span> this_coro = boost::asio::this_coro;</span><br><span class="line"></span><br><span class="line"><span class="function">awaitable&lt;<span class="type">void</span>&gt; <span class="title">echo</span><span class="params">(boost::asio::ip::tcp::socket sock)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">char</span> data[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="type">size_t</span> n = <span class="keyword">co_await</span> sock.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(data), use_awaitable);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;receive message is &quot;</span> &lt;&lt; std::<span class="built_in">string</span>(data, n) &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">co_await</span> boost::asio::<span class="built_in">async_write</span>(sock, boost::asio::<span class="built_in">buffer</span>(data, n), use_awaitable);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;send message: &quot;</span> &lt;&lt; std::<span class="built_in">string</span>(data, n) &lt;&lt; <span class="string">&quot;successed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;echo Exception is &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为了让协程能够使用，得需要加入关键字awaitable</span></span><br><span class="line"><span class="function">awaitable&lt;<span class="type">void</span>&gt; <span class="title">listener</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//co_await 是异步查询来获得调度器，如果没查到就挂起</span></span><br><span class="line"><span class="comment">//执行主线程中的别的协程，知道能捕获到执行器再切回来</span></span><br><span class="line"><span class="keyword">auto</span> executor = <span class="keyword">co_await</span> this_coro::executor;</span><br><span class="line">boost::asio::ip::<span class="function">tcp::endpoint <span class="title">ep</span><span class="params">(boost::asio::ip::tcp::v4(), <span class="number">8888</span>)</span></span>;</span><br><span class="line">boost::asio::ip::<span class="function">tcp::acceptor <span class="title">acceptor</span><span class="params">(executor, ep)</span></span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;等待客户端的连接&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">//加入co_await关键字就不需要传递回调函数了，挂起回释放协程使用权</span></span><br><span class="line"><span class="comment">//use_awaitable让这个函数能够阻塞等待</span></span><br><span class="line">boost::asio::ip::tcp::socket sock = <span class="keyword">co_await</span> acceptor.<span class="built_in">async_accept</span>(use_awaitable);</span><br><span class="line"><span class="built_in">co_spawn</span>(executor, <span class="built_in">echo</span>(std::<span class="built_in">move</span>(sock)), detached);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//参数是用来指定并发的级别，如果是1就表示只开一个工作线程</span></span><br><span class="line"><span class="comment">//如果是0就是默认，如果大于os的实际，则根据os的实际来运行</span></span><br><span class="line">boost::<span class="function">asio::io_context <span class="title">ioc</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">boost::<span class="function">asio::signal_set <span class="title">signals</span><span class="params">(ioc, SIGINT, SIGTERM)</span></span>;</span><br><span class="line">signals.<span class="built_in">async_wait</span>([&amp;](<span class="keyword">auto</span>, <span class="keyword">auto</span>) &#123;</span><br><span class="line">ioc.<span class="built_in">stop</span>();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//协程创建函数，第一个参数为上下文，第二个参数为一个协程函数</span></span><br><span class="line"><span class="comment">//第三个参数为执行策略，策略表示协程将在执行完成后自动销毁，而不会等待其父协程的完成</span></span><br><span class="line"><span class="built_in">co_spawn</span>(ioc, <span class="built_in">listener</span>(), detached);</span><br><span class="line">ioc.<span class="built_in">run</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Exception is&quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>我们用awaitable<void>声明了一个函数，那么这个函数就变为可等待的函数了，比如listener被添加awaitable<void>之后，就可以被协程调用和等待了。</li><li>co_spawn表示启动一个协程，参数分别为调度器，执行的函数，以及启动方式, 比如我们启动了一个协程，deatched表示将协程对象分离出来，这种启动方式可以启动多个协程，他们都是独立的，如何调度取决于调度器，在用户的感知上更像是线程调度的模式，类似于并发运行，其实底层都是串行的。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">co_spawn</span>(io_context, <span class="built_in">listener</span>(), detached);</span><br></pre></td></tr></table></figure><p>我们启动了一个协程，执行listener中的逻辑，listener内部co_await 等待 acceptor接收连接，如果没有连接到来则挂起协程。执行之后的io_context.run()逻辑。所以协程实际上是在一个线程中串行调度的，只是感知上像是并发而已。</p><ol><li>当acceptor接收到连接后，继续调用co_spawn启动一个协程，用来执行echo逻辑。echo逻辑里也是通过co_wait的方式接收和发送数据的，如果对端不发数据，执行echo的协程就会挂起，另一个协程启动，继续接收新的连接。当没有连接到来，接收新连接的协程挂起，如果所有协程都挂起，则等待新的就绪事件(对端发数据，或者新连接)到来唤醒。</li></ol><ul><li><strong>使用协程的时候有没有 co_await的区别</strong><ol><li>不使用 co_await：<br>如果不使用 co_await，acceptor.async_accept 将会返回一个可等待对象，但不会在此处等待该对象的完成。相反，它将立即返回，继续执行后续的代码，而不管是否有连接请求到来。这可能导致后续的代码在没有获得有效的 tcp::socket 对象的情况下进行执行，从而产生错误或未定义的行为。<ol><li>使用 co_await：<br>当使用 co_await 时，协程会在 acceptor.async_accept 返回的可等待对象完成之前挂起，并暂停当前协程的执行。这意味着协程会等待连接请求到来，并在收到请求后继续执行。在这种情况下，async_accept 返回的 tcp::socket 对象将被分配给变量 sock，以便后续与客户端进行通信。</li></ol></li></ol></li></ul><h3 id="完整并发服务器"><a href="#完整并发服务器" class="headerlink" title="完整并发服务器"></a>完整并发服务器</h3><ul><li>由于服务器发送数据或者请求比较频繁，所以考虑设计为不用协程而用线程的方式，这样相比协程可以增加效率，而且发送可能会在其他线程</li><li>我们可以利用协程改进服务器编码流程，用一个iocontext管理绑定acceptor用来接收新的连接，再用一个iocontext或以IOServicePool的方式管理连接的收发操作，在每个连接的接收数据时改为启动一个协程，通过顺序的方式读取收到的数据</li></ul><h4 id="AsiIOServicePool"><a href="#AsiIOServicePool" class="headerlink" title="AsiIOServicePool"></a>AsiIOServicePool</h4><h5 id="AsioIOServicePool头文件"><a href="#AsioIOServicePool头文件" class="headerlink" title="AsioIOServicePool头文件"></a>AsioIOServicePool头文件</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AsioIOServicePool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">using</span> IOService = boost::asio::io_context;</span><br><span class="line"><span class="keyword">using</span> Work = boost::asio::io_context::work;</span><br><span class="line"><span class="keyword">using</span> WorkPtr = std::unique_ptr&lt;Work&gt;;</span><br><span class="line">~<span class="built_in">AsioIOServicePool</span>();</span><br><span class="line"><span class="built_in">AsioIOServicePool</span>(<span class="type">const</span> AsioIOServicePool&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">AsioIOServicePool&amp; <span class="keyword">operator</span>=(<span class="type">const</span> AsioIOServicePool&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="function"><span class="type">static</span> AsioIOServicePool&amp; <span class="title">GetInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">static</span> AsioIOServicePool ins;</span><br><span class="line"><span class="keyword">return</span> ins;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Stop</span><span class="params">()</span></span>;</span><br><span class="line">boost::<span class="function">asio::io_context&amp; <span class="title">GetIOService</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">AsioIOServicePool</span>(<span class="type">const</span> <span class="type">int</span> nums = std::thread::<span class="built_in">hardware_concurrency</span>());</span><br><span class="line">std::vector&lt;IOService&gt; _ioService;</span><br><span class="line">std::vector&lt;WorkPtr&gt; _works;</span><br><span class="line">std::vector&lt;std::thread&gt; _threads;</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为轮询，所以要记录下一个io_context的下标是多少</span></span><br><span class="line">std::<span class="type">size_t</span> _nextIOService;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="AsioIOServicePool实现"><a href="#AsioIOServicePool实现" class="headerlink" title="AsioIOServicePool实现"></a>AsioIOServicePool实现</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AsioIOServicePool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">AsioIOServicePool::~<span class="built_in">AsioIOServicePool</span>()</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;AsioIOService Pool destruct &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AsioIOServicePool::Stop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//将work置空，会让ioService自动析构</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; work:_works) &#123;</span><br><span class="line">work.<span class="built_in">reset</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等待线程完成任务</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; td : _threads) &#123;</span><br><span class="line"><span class="keyword">if</span> (td.<span class="built_in">joinable</span>()) &#123;</span><br><span class="line">td.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">boost::<span class="function">asio::io_context&amp; <span class="title">AsioIOServicePool::GetIOService</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span>&amp; service = _ioService[_nextIOService++];</span><br><span class="line"><span class="keyword">if</span> (_nextIOService == _ioService.<span class="built_in">size</span>()) &#123;</span><br><span class="line">_nextIOService = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> service;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AsioIOServicePool::<span class="built_in">AsioIOServicePool</span>(<span class="type">const</span> <span class="type">int</span> nums):_ioService(nums),</span><br><span class="line">_works(nums),_nextIOService(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//初始化works指针</span></span><br><span class="line"><span class="keyword">for</span> (std::<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; nums; i++) &#123;</span><br><span class="line"><span class="comment">//右边为右值</span></span><br><span class="line">_works[i] = std::<span class="built_in">unique_ptr</span>&lt;Work&gt;(<span class="keyword">new</span> <span class="built_in">Work</span>(_ioService[i]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遍历多个ioService 创建多个线程，每个线程内部启动一个ioService</span></span><br><span class="line"><span class="keyword">for</span> (std::<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; nums; i++) &#123;</span><br><span class="line">_threads.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>, i]() &#123;</span><br><span class="line">_ioService[i].<span class="built_in">run</span>();</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="cosnt-h"><a href="#cosnt-h" class="headerlink" title="cosnt.h"></a>cosnt.h</h4><ul><li>专门用来存放常量</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MAX_LENGTH = <span class="number">1024</span> * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> HEAD_TOTAL_LEN = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> HEAD_ID_LEN = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> HEAD_DATA_LEN = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MAX_RECVQUE = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MAX_SENDQUE = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">MSG_IDS</span> &#123;</span><br><span class="line">MSG_HELLO_WORLD = <span class="number">1001</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="CServer-1"><a href="#CServer-1" class="headerlink" title="CServer"></a>CServer</h4><h5 id="CServer头文件-1"><a href="#CServer头文件-1" class="headerlink" title="CServer头文件"></a>CServer头文件</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CSession.h&quot;</span></span></span><br><span class="line"><span class="comment">//负责监听客户端的链接，处理链接</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CServer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">CServer</span>(boost::asio::io_context&amp; io_context, <span class="type">short</span> port);</span><br><span class="line">~<span class="built_in">CServer</span>();</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ClearSession</span><span class="params">(std::string&amp; uuid)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HandleAccpet</span><span class="params">(std::shared_ptr&lt;CSession&gt; session, <span class="type">const</span> boost::system::error_code&amp; error)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StartAccept</span><span class="params">()</span></span>;</span><br><span class="line">boost::asio::io_context&amp; _io_context;</span><br><span class="line">std::mutex mtx;</span><br><span class="line"><span class="type">short</span> _port;</span><br><span class="line">boost::asio::ip::tcp::acceptor _acceptor;</span><br><span class="line">std::map&lt;std::string, std::shared_ptr&lt;CSession&gt;&gt; _sessions;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="CServer实现-1"><a href="#CServer实现-1" class="headerlink" title="CServer实现"></a>CServer实现</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CServer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AsioIOServicePool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">CServer::<span class="built_in">CServer</span>(boost::asio::io_context&amp; io_context, <span class="type">short</span> port)</span><br><span class="line">:_io_context(io_context),_port(port),_acceptor(io_context, boost::asio::ip::tcp::<span class="built_in">endpoint</span>(boost::asio::ip::tcp::<span class="built_in">v4</span>(), port))</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Server start success, on port: &quot;</span> &lt;&lt; _port &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">StartAccept</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CServer::~<span class="built_in">CServer</span>()</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Server destruct listen on port : &quot;</span> &lt;&lt; _port &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CServer::ClearSession</span><span class="params">(std::string&amp; uuid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//加锁</span></span><br><span class="line"><span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (_sessions.<span class="built_in">find</span>(uuid) != _sessions.<span class="built_in">end</span>()) _sessions.<span class="built_in">erase</span>(uuid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CServer::HandleAccpet</span><span class="params">(std::shared_ptr&lt;CSession&gt; session, <span class="type">const</span> boost::system::error_code&amp; error)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!error) &#123;</span><br><span class="line"><span class="comment">//启动服务</span></span><br><span class="line">session-&gt;<span class="built_in">Start</span>();</span><br><span class="line"><span class="comment">//加锁</span></span><br><span class="line"><span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">_sessions.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(session-&gt;<span class="built_in">GetUuid</span>(), session));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;session accept failed, error is &quot;</span> &lt;&lt; error.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">StartAccept</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CServer::StartAccept</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//取得上下文</span></span><br><span class="line"><span class="keyword">auto</span>&amp; io_context = AsioIOServicePool::<span class="built_in">GetInstance</span>().<span class="built_in">GetIOService</span>();</span><br><span class="line"><span class="comment">//构造一个CSession的智能指针,也就是创建连接</span></span><br><span class="line">std::shared_ptr&lt;CSession&gt; new_session = std::<span class="built_in">make_shared</span>&lt;CSession&gt;(_io_context, <span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//进行异步连接</span></span><br><span class="line">_acceptor.<span class="built_in">async_accept</span>(new_session-&gt;<span class="built_in">GetSocket</span>(),</span><br><span class="line">std::<span class="built_in">bind</span>(&amp;CServer::HandleAccpet, <span class="keyword">this</span>, new_session, std::placeholders::_1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="CSession-1"><a href="#CSession-1" class="headerlink" title="CSession"></a>CSession</h4><h5 id="CSession-h"><a href="#CSession-h" class="headerlink" title="CSession.h"></a>CSession.h</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio/co_spawn.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio/detached.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;const.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MsgNode.h&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CServer</span>;</span><br><span class="line"><span class="comment">//用来处理客户端与服务器之间通s信的作用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CSession</span>:<span class="keyword">public</span> std::enable_shared_from_this&lt;CSession&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">CSession</span>(boost::asio::io_context&amp; io_context, CServer* server);</span><br><span class="line">~<span class="built_in">CSession</span>();</span><br><span class="line">boost::asio::ip::<span class="function">tcp::socket&amp; <span class="title">GetSocket</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> _socket;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Close</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">std::string&amp; <span class="title">GetUuid</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Send</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg, <span class="type">short</span> max_length, <span class="type">short</span> msg_id)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Send</span><span class="params">(std::string msg, <span class="type">short</span> msg_id)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HandleWrite</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, std::shared_ptr&lt;CSession&gt; shared_self)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">boost::asio::io_context&amp; _io_context;</span><br><span class="line">CServer* _server;</span><br><span class="line">boost::asio::ip::tcp::socket _socket;</span><br><span class="line">std::string _uuid;</span><br><span class="line"><span class="type">bool</span> _b_close;</span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::queue&lt;std::shared_ptr&lt;SendNode&gt;&gt; _send_que;</span><br><span class="line">std::shared_ptr&lt;RecvNode&gt; _recv_msg_node;</span><br><span class="line">std::shared_ptr&lt;MsgNode&gt; _recv_head_node;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LogicNode</span> &#123;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">LogicSystem</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">LogicNode</span>(std::shared_ptr&lt;CSession&gt; session, std::shared_ptr&lt;RecvNode&gt; recvnode) :</span><br><span class="line">_session(session), _recvnode(recvnode)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::shared_ptr&lt;CSession&gt; _session;</span><br><span class="line">std::shared_ptr&lt;RecvNode&gt; _recvnode;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="CSession实现"><a href="#CSession实现" class="headerlink" title="CSession实现"></a>CSession实现</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CSession.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CServer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/uuid/uuid_io.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/uuid/uuid_generators.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LogicSystem.h&quot;</span></span></span><br><span class="line">CSession::<span class="built_in">CSession</span>(boost::asio::io_context&amp; io_context, CServer* server):</span><br><span class="line">_io_context(io_context), _server(server),_socket(io_context),_b_close(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">boost::uuids::uuid a_uuid = boost::uuids::<span class="built_in">random_generator</span>()();</span><br><span class="line">_uuid = boost::uuids::<span class="built_in">to_string</span>(a_uuid);</span><br><span class="line"><span class="comment">//初始化头部节点</span></span><br><span class="line">_recv_head_node = std::<span class="built_in">make_shared</span>&lt;MsgNode&gt;(HEAD_TOTAL_LEN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CSession::~<span class="built_in">CSession</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;~CSession destruct&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">Close</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;exception is &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//为了防止智能指针被意外的释放</span></span><br><span class="line"><span class="keyword">auto</span> shared_this = <span class="built_in">shared_from_this</span>();</span><br><span class="line"><span class="comment">//开启协程</span></span><br><span class="line">boost::asio::<span class="built_in">co_spawn</span>(_io_context, [=, <span class="keyword">this</span>]()-&gt;boost::asio::awaitable&lt;<span class="type">void</span>&gt; &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (!_b_close)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//接收数据前先清空数组</span></span><br><span class="line">_recv_head_node-&gt;<span class="built_in">Clear</span>();</span><br><span class="line"><span class="comment">//开始接收数据</span></span><br><span class="line"><span class="type">size_t</span> n = <span class="keyword">co_await</span> boost::asio::<span class="built_in">async_read</span>(_socket, boost::asio::<span class="built_in">buffer</span>(_recv_head_node-&gt;_data,</span><br><span class="line">HEAD_TOTAL_LEN), boost::asio::use_awaitable);</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;receive peer closed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">Close</span>();</span><br><span class="line">_server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line"><span class="comment">//协程的返回</span></span><br><span class="line"><span class="keyword">co_return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取头部MSGID数据</span></span><br><span class="line"><span class="type">short</span> msg_id = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memcpy</span>(&amp;msg_id, _recv_head_node-&gt;_data, HEAD_ID_LEN);</span><br><span class="line"><span class="comment">//将网络字节序转成本地字节序</span></span><br><span class="line"><span class="type">short</span> msg_id_host = boost::asio::detail::socket_ops::<span class="built_in">network_to_host_short</span>(msg_id);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;msg_id is&quot;</span> &lt;&lt; msg_id_host &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">if</span> (msg_id_host &gt; MAX_LENGTH) &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;invaild msg id is &quot;</span> &lt;&lt; msg_id_host &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">//std::cout &lt;&lt; &quot;hello&quot; &lt;&lt; std::endl;</span></span><br><span class="line"><span class="built_in">Close</span>();</span><br><span class="line">_server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line"><span class="keyword">co_return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取数据长度</span></span><br><span class="line"><span class="type">short</span> msg_len = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memcpy</span>(&amp;msg_len, _recv_head_node-&gt;_data + HEAD_ID_LEN, HEAD_DATA_LEN);</span><br><span class="line"><span class="type">short</span> msg_len_host = boost::asio::detail::socket_ops::<span class="built_in">network_to_host_short</span>(msg_len);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;msg len is&quot;</span> &lt;&lt; msg_len_host &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">if</span> (msg_len_host &gt; MAX_LENGTH) &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;invaild msg len is &quot;</span> &lt;&lt; msg_len_host &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">Close</span>();</span><br><span class="line">_server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line"><span class="keyword">co_return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实际数据</span></span><br><span class="line">_recv_msg_node = std::<span class="built_in">make_shared</span>&lt;RecvNode&gt;(msg_len_host, msg_id_host);</span><br><span class="line"></span><br><span class="line"><span class="comment">//读出包体</span></span><br><span class="line">n = <span class="keyword">co_await</span> boost::asio::<span class="built_in">async_read</span>(_socket, boost::asio::<span class="built_in">buffer</span>(_recv_msg_node-&gt;_data,</span><br><span class="line">_recv_msg_node-&gt;_total_len), boost::asio::use_awaitable);</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;receive peer closed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">Close</span>();</span><br><span class="line">_server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line"><span class="comment">//协程的返回</span></span><br><span class="line"><span class="keyword">co_return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_recv_msg_node-&gt;_data[_recv_msg_node-&gt;_total_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;recv data is&quot;</span> &lt;&lt; _recv_msg_node-&gt;_data &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//投递到逻辑系统的逻辑队列里，交给队列处理</span></span><br><span class="line">LogicSystem::<span class="built_in">GetInstance</span>().<span class="built_in">PostMsgToQue</span>(std::<span class="built_in">make_shared</span>&lt;LogicNode&gt;(<span class="built_in">shared_from_this</span>(), _recv_msg_node));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (std::exception e) &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Exception is &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">Close</span>();</span><br><span class="line"><span class="comment">//关闭后从map中移除session</span></span><br><span class="line">_server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">&#125;</span><br><span class="line">&#125;, boost::asio::detached);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::Close</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_b_close = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//关闭socket</span></span><br><span class="line">_socket.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string&amp; <span class="title">CSession::GetUuid</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _uuid;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此处插入 return 语句</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::Send</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg, <span class="type">short</span> max_length, <span class="type">short</span> msg_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line"><span class="type">int</span> send_que_size = _send_que.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">if</span> (send_que_size &gt; MAX_SENDQUE) &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;session: &quot;</span> &lt;&lt; _uuid &lt;&lt; <span class="string">&quot;send que fulled, size is &quot;</span></span><br><span class="line">&lt;&lt; MAX_SENDQUE &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//往消息队列里插入数据</span></span><br><span class="line">_send_que.<span class="built_in">push</span>(std::<span class="built_in">make_shared</span>&lt;SendNode&gt;(msg, max_length, msg_id));</span><br><span class="line"><span class="comment">//判断数据量是否大于0，大于0就不发送数据，只有当发送队列里长度为1的时候才发送数据</span></span><br><span class="line"><span class="comment">//那么为什么他判断大于0呢，因为我们是先统计的数据量，再插入队列</span></span><br><span class="line"><span class="keyword">if</span> (send_que_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::shared_ptr&lt;SendNode&gt; msgnode = _send_que.<span class="built_in">front</span>();</span><br><span class="line">lock.<span class="built_in">unlock</span>();</span><br><span class="line"><span class="comment">//传递shread_from_this可以增加引用，防止session意外的释放</span></span><br><span class="line">boost::asio::<span class="built_in">async_write</span>(_socket, boost::asio::<span class="built_in">buffer</span>(msgnode-&gt;_data, msgnode-&gt;_total_len),</span><br><span class="line">std::<span class="built_in">bind</span>(&amp;CSession::HandleWrite, <span class="keyword">this</span>, std::placeholders::_1, <span class="built_in">shared_from_this</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::Send</span><span class="params">(std::string msg, <span class="type">short</span> msg_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">Send</span>(msg.<span class="built_in">c_str</span>(), msg.<span class="built_in">length</span>(), msg_id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意对于error_code 必须加入const，否则会在async_write处会报错</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::HandleWrite</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, std::shared_ptr&lt;CSession&gt; shared_self)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (!error) &#123;</span><br><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line"><span class="comment">//调用这个回调函数的时候说明数据已经处理完了</span></span><br><span class="line">_send_que.<span class="built_in">pop</span>();</span><br><span class="line"><span class="comment">//如果队列不为空就要继续发送数据</span></span><br><span class="line"><span class="keyword">if</span> (!_send_que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"><span class="keyword">auto</span>&amp; msgnode = _send_que.<span class="built_in">front</span>();</span><br><span class="line">boost::asio::<span class="built_in">async_write</span>(_socket, boost::asio::<span class="built_in">buffer</span>(msgnode-&gt;_data, msgnode-&gt;_total_len),</span><br><span class="line">std::<span class="built_in">bind</span>(&amp;CSession::HandleWrite, <span class="keyword">this</span>, std::placeholders::_1, <span class="built_in">shared_from_this</span>()));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;handle write failed, error is&quot;</span> &lt;&lt; error.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">Close</span>();</span><br><span class="line">_server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;exception is &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">Close</span>();</span><br><span class="line">_server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="LogicSystem"><a href="#LogicSystem" class="headerlink" title="LogicSystem"></a>LogicSystem</h4><h5 id="LogicSystem头文件"><a href="#LogicSystem头文件" class="headerlink" title="LogicSystem头文件"></a>LogicSystem头文件</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;json/json.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;json/reader.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;json/value.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;const.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CSession.h&quot;</span></span></span><br><span class="line"><span class="comment">//因为是string 可以调用函数获取长度，所以不需要传长度</span></span><br><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">void</span>(std::shared_ptr&lt;CSession&gt; session, <span class="type">const</span> <span class="type">short</span>&amp; msg_id, <span class="type">const</span> std::string&amp; msg_data)&gt; FunCallBack;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LogicSystem</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">LogicSystem</span>(<span class="type">const</span> LogicSystem&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">LogicSystem&amp; <span class="keyword">operator</span>=(<span class="type">const</span> LogicSystem&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">~<span class="built_in">LogicSystem</span>();</span><br><span class="line"><span class="function"><span class="type">static</span> LogicSystem&amp; <span class="title">GetInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">static</span> LogicSystem ins;</span><br><span class="line"><span class="keyword">return</span> ins;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostMsgToQue</span><span class="params">(std::shared_ptr&lt;LogicNode&gt; msg)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">LogicSystem</span>();</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RegisterCallBacks</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HelloWorldCallBack</span><span class="params">(std::shared_ptr&lt;CSession&gt; session, <span class="type">const</span> <span class="type">short</span>&amp; msg_id, <span class="type">const</span> std::string&amp; msg_data)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DealMsg</span><span class="params">()</span></span>;</span><br><span class="line">std::thread _worker;</span><br><span class="line">std::mutex mtx;</span><br><span class="line"><span class="comment">//与直接使用LogicNode的区别</span></span><br><span class="line">std::queue&lt;std::shared_ptr&lt;LogicNode&gt;&gt; _msg_que;</span><br><span class="line">std::condition_variable _consume;</span><br><span class="line"><span class="type">bool</span> _b_stop;</span><br><span class="line">std::map&lt;<span class="type">short</span>, FunCallBack&gt; _fun_callbacks;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="LogicSystem实现"><a href="#LogicSystem实现" class="headerlink" title="LogicSystem实现"></a>LogicSystem实现</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LogicSystem.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">LogicSystem::~<span class="built_in">LogicSystem</span>()</span><br><span class="line">&#123;</span><br><span class="line">_b_stop = <span class="literal">true</span>;</span><br><span class="line">_consume.<span class="built_in">notify_one</span>();</span><br><span class="line">_worker.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LogicSystem::PostMsgToQue</span><span class="params">(std::shared_ptr&lt;LogicNode&gt; msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">unique_lk</span><span class="params">(mtx)</span></span>;</span><br><span class="line">_msg_que.<span class="built_in">push</span>(msg);</span><br><span class="line"></span><br><span class="line"><span class="comment">//由0变为1则发送通知信号</span></span><br><span class="line"><span class="keyword">if</span> (_msg_que.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">unique_lk.<span class="built_in">unlock</span>();</span><br><span class="line">_consume.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LogicSystem::<span class="built_in">LogicSystem</span>():_b_stop(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">RegisterCallBacks</span>();</span><br><span class="line">_worker = std::<span class="built_in">thread</span>(&amp;LogicSystem::DealMsg, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LogicSystem::RegisterCallBacks</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//任务编号,将他存储起来</span></span><br><span class="line">_fun_callbacks[MSG_HELLO_WORLD] = std::<span class="built_in">bind</span>(&amp;LogicSystem::HelloWorldCallBack, <span class="keyword">this</span>, </span><br><span class="line">std::placeholders::_1, std::placeholders::_2, std::placeholders::_3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LogicSystem::HelloWorldCallBack</span><span class="params">(std::shared_ptr&lt;CSession&gt; session, <span class="type">const</span> <span class="type">short</span>&amp; msg_id, <span class="type">const</span> std::string&amp; msg_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Json::Reader reader;</span><br><span class="line">Json::Value root;</span><br><span class="line">reader.<span class="built_in">parse</span>(msg_data, root);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;recevie msg id is &quot;</span> &lt;&lt; root[<span class="string">&quot;id&quot;</span>].<span class="built_in">asInt</span>() &lt;&lt; <span class="string">&quot;receive msg data is &quot;</span></span><br><span class="line">&lt;&lt; root[<span class="string">&quot;data&quot;</span>].<span class="built_in">asString</span>() &lt;&lt; std::endl;</span><br><span class="line">root[<span class="string">&quot;data&quot;</span>] = <span class="string">&quot;server has received msg, msg data is &quot;</span> + root[<span class="string">&quot;data&quot;</span>].<span class="built_in">asString</span>();</span><br><span class="line">std::string return_str = root.<span class="built_in">toStyledString</span>();</span><br><span class="line">session-&gt;<span class="built_in">Send</span>(return_str, root[<span class="string">&quot;id&quot;</span>].<span class="built_in">asInt</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LogicSystem::DealMsg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">_consume.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]() &#123;</span><br><span class="line"><span class="keyword">return</span> _b_stop || !_msg_que.<span class="built_in">empty</span>();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">if</span> (_b_stop) &#123;</span><br><span class="line"><span class="keyword">while</span> (!_msg_que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">std::shared_ptr&lt;LogicNode&gt; msg_node = _msg_que.<span class="built_in">front</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;recv_msg id  is &quot;</span> &lt;&lt; msg_node-&gt;_recvnode-&gt;_msg_id &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">auto</span> call_back_iter = _fun_callbacks.<span class="built_in">find</span>(msg_node-&gt;_recvnode-&gt;_msg_id);</span><br><span class="line"><span class="comment">//如果没有注册回调函数就直接出队</span></span><br><span class="line"><span class="keyword">if</span> (call_back_iter == _fun_callbacks.<span class="built_in">end</span>()) &#123;</span><br><span class="line">_msg_que.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//否则调用回调函数</span></span><br><span class="line">call_back_iter-&gt;<span class="built_in">second</span>(msg_node-&gt;_session, msg_node-&gt;_recvnode-&gt;_msg_id,</span><br><span class="line">std::<span class="built_in">string</span>(msg_node-&gt;_recvnode-&gt;_data, msg_node-&gt;_recvnode-&gt;_total_len));</span><br><span class="line">_msg_que.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果没有停服，且说明队列中有数据</span></span><br><span class="line"><span class="keyword">auto</span> msg_node = _msg_que.<span class="built_in">front</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;recv_msg id  is &quot;</span> &lt;&lt; msg_node-&gt;_recvnode-&gt;_msg_id &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">auto</span> call_back_iter = _fun_callbacks.<span class="built_in">find</span>(msg_node-&gt;_recvnode-&gt;_msg_id);</span><br><span class="line"><span class="keyword">if</span> (call_back_iter == _fun_callbacks.<span class="built_in">end</span>()) &#123;</span><br><span class="line">_msg_que.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">call_back_iter-&gt;<span class="built_in">second</span>(msg_node-&gt;_session, msg_node-&gt;_recvnode-&gt;_msg_id,</span><br><span class="line">std::<span class="built_in">string</span>(msg_node-&gt;_recvnode-&gt;_data, msg_node-&gt;_recvnode-&gt;_total_len));</span><br><span class="line">_msg_que.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="MsgNode-1"><a href="#MsgNode-1" class="headerlink" title="MsgNode"></a>MsgNode</h4><h5 id="MsgNode头文件"><a href="#MsgNode头文件" class="headerlink" title="MsgNode头文件"></a>MsgNode头文件</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;const.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MsgNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MsgNode</span>(<span class="type">short</span> max_len) :_total_len(max_len), _cur_len(<span class="number">0</span>) &#123;</span><br><span class="line">_data = <span class="keyword">new</span> <span class="type">char</span>[_total_len + <span class="number">1</span>];</span><br><span class="line">_data[_total_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">MsgNode</span>() &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;destruct MsgNode&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">delete</span>[] _data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(_data, <span class="number">0</span>, _total_len);</span><br><span class="line">_cur_len = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> _cur_len;</span><br><span class="line"><span class="type">int</span> _total_len;</span><br><span class="line"><span class="type">char</span>* _data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RecvNode</span> :<span class="keyword">public</span> MsgNode &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">RecvNode</span>(<span class="type">short</span> max_len, <span class="type">short</span> msg_id);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">short</span> _msg_id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SendNode</span> :<span class="keyword">public</span> MsgNode &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">SendNode</span>(<span class="type">const</span> <span class="type">char</span>* msg, <span class="type">short</span> max_len, <span class="type">short</span> msg_id);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">short</span> _msg_id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="MsgNode-实现"><a href="#MsgNode-实现" class="headerlink" title="MsgNode 实现"></a>MsgNode 实现</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MsgNode.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">RecvNode::<span class="built_in">RecvNode</span>(<span class="type">short</span> max_len, <span class="type">short</span> msg_id):<span class="built_in">MsgNode</span>(max_len), _msg_id(msg_id)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SendNode::<span class="built_in">SendNode</span>(<span class="type">const</span> <span class="type">char</span>* msg, <span class="type">short</span> max_len, <span class="type">short</span> msg_id):<span class="built_in">MsgNode</span>(max_len + HEAD_TOTAL_LEN), _msg_id(msg_id)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//先发送id,转为网络字节序</span></span><br><span class="line"><span class="type">short</span> msg_id_net = boost::asio::detail::socket_ops::<span class="built_in">host_to_network_short</span>(msg_id);</span><br><span class="line"><span class="built_in">memcpy</span>(_data, &amp;msg_id_net, HEAD_ID_LEN);</span><br><span class="line"><span class="comment">//再发送长度，转为网络字节序</span></span><br><span class="line"><span class="type">short</span> msg_len_net = boost::asio::detail::socket_ops::<span class="built_in">host_to_network_short</span>(max_len);</span><br><span class="line"><span class="built_in">memcpy</span>(_data + HEAD_ID_LEN, &amp;msg_len_net, HEAD_DATA_LEN);</span><br><span class="line"><span class="comment">//最后在发送数据</span></span><br><span class="line"><span class="built_in">memcpy</span>(_data + HEAD_TOTAL_LEN, msg, max_len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="使用asio实现http服务器"><a href="#使用asio实现http服务器" class="headerlink" title="使用asio实现http服务器"></a>使用asio实现http服务器</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><ul><li>前文介绍了asio如何实现并发的长连接tcp服务器，今天介绍如何实现http服务器，在介绍实现http服务器之前，需要讲述下http报文头的格式，其实http报文头的格式就是为了避免我们之前提到的粘包现象，告诉服务器一个数据包的开始和结尾，并在包头里标识请求的类型如get或post等信息。</li></ul><h3 id="Http包头信息"><a href="#Http包头信息" class="headerlink" title="Http包头信息"></a>Http包头信息</h3><ul><li>一个标准的HTTP报文头通常由请求头和响应头两部分组成。</li></ul><h4 id="HTTP请求头"><a href="#HTTP请求头" class="headerlink" title="HTTP请求头"></a>HTTP请求头</h4><ul><li><p>HTTP请求头包括以下字段：</p><ol><li>Request-line：包含用于描述请求类型、要访问的资源以及所使用的HTTP版本的信息。</li><li>Host：指定被请求资源的主机名或IP地址和端口号。</li><li>Accept：指定客户端能够接收的媒体类型列表，用逗号分隔，例如 text/plain, text/html。</li><li>User-Agent：客户端使用的浏览器类型和版本号，供服务器统计用户代理信息。</li><li>Cookie：如果请求中包含cookie信息，则通过这个字段将cookie信息发送给Web服务器。</li><li>Connection：表示是否需要持久连接（keep-alive）</li></ol></li><li><p>比如下面就是一个实际应用</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET /index.html HTTP/<span class="number">1.1</span></span><br><span class="line">Host: www.example.com</span><br><span class="line">Accept: text/html, application/xhtml+xml, *<span class="comment">/*</span></span><br><span class="line"><span class="comment">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:123.0) Gecko/20100101 Firefox/123.0</span></span><br><span class="line"><span class="comment">Cookie: sessionid=abcdefg1234567</span></span><br><span class="line"><span class="comment">Connection: keep-alive</span></span><br></pre></td></tr></table></figure><ul><li>Request-line：指定使用GET方法请求/index.html资源，并使用HTTP/1.1协议版本。</li><li>Host：指定被请求资源所在主机名或IP地址和端口号。</li><li>Accept：客户端期望接收的媒体类型列表，本例中指定了text/html、application/xhtml+xml和任意类型的文件（/）。</li><li>User-Agent：客户端浏览器类型和版本号。</li><li>Cookie：客户端发送给服务器的cookie信息。</li><li>Connection：客户端请求后是否需要保持长连接。</li></ul><h4 id="HTTP响应头"><a href="#HTTP响应头" class="headerlink" title="HTTP响应头"></a>HTTP响应头</h4><ul><li><p>HTTP响应头包括以下字段：</p><ol><li>Status-line：包含协议版本、状态码和状态消息。</li><li>Content-Type：响应体的MIME类型。</li><li>Content-Length：响应体的字节数。</li><li>Set-Cookie：服务器向客户端发送cookie信息时使用该字段。</li><li>Server：服务器类型和版本号。</li><li>Connection：表示是否需要保持长连接（keep-alive）。</li></ol></li><li><p>在实际的HTTP报文头中，还可以包含其他可选字段。</p></li><li>如下就是一个例子</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">Content-Type: text/html; charset=UTF<span class="number">-8</span></span><br><span class="line">Content-Length: <span class="number">1024</span></span><br><span class="line">Set-Cookie: sessionid=abcdefg1234567; HttpOnly; Path=/</span><br><span class="line">Server: Apache/<span class="number">2.2</span><span class="number">.32</span> (Unix) mod_ssl/<span class="number">2.2</span><span class="number">.32</span> OpenSSL/<span class="number">1.0</span><span class="number">.1</span>e-fips mod_bwlimited/<span class="number">1.4</span></span><br><span class="line">Connection: keep-alive</span><br><span class="line">上述响应头包括了以下字段：</span><br></pre></td></tr></table></figure><ul><li>Status-line：指定HTTP协议版本、状态码和状态消息。</li><li>Content-Type：指定响应体的MIME类型及字符编码格式。</li><li>Content-Length：指定响应体的字节数。</li><li>Set-Cookie：服务器向客户端发送cookie信息时使用该字段。</li><li>Server：服务器类型和版本号。</li><li><p>Connection：服务器是否需要保持长连接。</p></li><li><p>源码请看<a href="https://gitee.com/secondtonone1/boostasio-learn">https://gitee.com/secondtonone1/boostasio-learn</a></p></li></ul><h2 id="使用beast网络库实现http服务器"><a href="#使用beast网络库实现http服务器" class="headerlink" title="使用beast网络库实现http服务器"></a>使用beast网络库实现http服务器</h2><h3 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h3><ul><li>前面的几篇文章已经介绍了如何使用asio搭建高并发的tcp服务器，以及http服务器。但是纯手写http服务器太麻烦了，有网络库beast已经帮我们实现了。这一期讲讲如何使用beast实现一个http服务器。</li></ul><h3 id="连接类"><a href="#连接类" class="headerlink" title="连接类"></a>连接类</h3><ul><li>我们先实现http_server函数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">http_server</span><span class="params">(boost::asio::ip::tcp::acceptor&amp; acceptor, boost::asio::ip::tcp::socket&amp; socket)</span> </span>&#123;</span><br><span class="line">acceptor.<span class="built_in">async_accept</span>(socket, [&amp;](boost::system::error_code ec) &#123;</span><br><span class="line"><span class="keyword">if</span> (!ec) &#123;</span><br><span class="line"><span class="comment">//启动http的connection</span></span><br><span class="line">std::<span class="built_in">make_shared</span>&lt;http_connection&gt;(std::<span class="built_in">move</span>(socket))-&gt;<span class="built_in">Start</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不管成功与失败都要继续监听请求</span></span><br><span class="line"><span class="built_in">http_server</span>(acceptor, socket);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>http_server中添加了异步接收连接的逻辑，当有新的连接到来时创建http_connection,然后启动服务，新连接监听对端数据。接下来http_server继续监听对端的新连接。</p></li><li><p>连接类http_connection里实现了start函数监听对端数据</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//读取请求</span></span><br><span class="line"><span class="built_in">read_request</span>();</span><br><span class="line"><span class="comment">//开始超时返回机制,对于短连接</span></span><br><span class="line"><span class="built_in">check_deadline</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>处理读请求,将读到的数据存储再成员变量request_中，然后调用process_request处理请求</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现读请求</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_request</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//千万不要用make_shared</span></span><br><span class="line"><span class="keyword">auto</span> self = <span class="built_in">shared_from_this</span>();</span><br><span class="line">boost::beast::http::<span class="built_in">async_read</span>(socket_, buffer_, request_,</span><br><span class="line">[self](boost::system::error_code ec, std::<span class="type">size_t</span> bytes_transferred) &#123;</span><br><span class="line"><span class="comment">//因为用不到后面那个参数，所以忽略他</span></span><br><span class="line"><span class="comment">//由于底层必须接收它，所以即使不用也要声明</span></span><br><span class="line">boost::<span class="built_in">ignore_unused</span>(bytes_transferred);</span><br><span class="line"><span class="keyword">if</span> (!ec) &#123;</span><br><span class="line">self-&gt;<span class="built_in">process_request</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>check_deadline主要时用来检测超时，当超过一定时间后自动关闭连接，因为http请求时短链接</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检测定时器</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">check_deadline</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//构造伪闭包，防止被析构的时候，意外地被释放</span></span><br><span class="line"><span class="keyword">auto</span> self = <span class="built_in">shared_from_this</span>();</span><br><span class="line"><span class="comment">//开始异步等待60s,传递的时候多传递一个self，这样做是为了</span></span><br><span class="line"><span class="comment">//防止在60之内的等待中，http_connection先被释放掉</span></span><br><span class="line"><span class="comment">//而导致this为空的崩溃</span></span><br><span class="line">deadline_.<span class="built_in">async_wait</span>([self](boost::system::error_code ec) &#123;</span><br><span class="line"><span class="keyword">if</span> (!ec) &#123;</span><br><span class="line">self-&gt;socket_.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>process_request函数中区分请求的类型，进行不同类型的处理如post还是get请求</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">process_request</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//设置回应版本,设置为请求回来的</span></span><br><span class="line">response_.<span class="built_in">version</span>(request_.<span class="built_in">version</span>());</span><br><span class="line"><span class="comment">//设置为短连接</span></span><br><span class="line">response_.<span class="built_in">keep_alive</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">switch</span> (request_.<span class="built_in">method</span>()) &#123;</span><br><span class="line"><span class="keyword">case</span> boost::beast::http::verb::get:</span><br><span class="line"><span class="comment">//设置为错误请求的状态码</span></span><br><span class="line">response_.<span class="built_in">result</span>(boost::beast::http::status::ok);</span><br><span class="line"><span class="comment">//设置响应头的MIME类型，也就是回应的数据类型</span></span><br><span class="line">response_.<span class="built_in">set</span>(boost::beast::http::field::server, <span class="string">&quot;Beast&quot;</span>);</span><br><span class="line"><span class="comment">//创建回应</span></span><br><span class="line"><span class="built_in">create_get_response</span>();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> boost::beast::http::verb::post:</span><br><span class="line"><span class="comment">//设置为错误请求的状态码</span></span><br><span class="line">response_.<span class="built_in">result</span>(boost::beast::http::status::ok);</span><br><span class="line"><span class="comment">//设置响应头的MIME类型，也就是回应的数据类型</span></span><br><span class="line">response_.<span class="built_in">set</span>(boost::beast::http::field::server, <span class="string">&quot;Beast&quot;</span>);</span><br><span class="line"><span class="comment">//创建回应</span></span><br><span class="line"><span class="built_in">create_post_response</span>();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">//设置为错误请求的状态码</span></span><br><span class="line">response_.<span class="built_in">result</span>(boost::beast::http::status::bad_request);</span><br><span class="line"><span class="comment">//设置响应头的MIME类型，也就是回应的数据类型</span></span><br><span class="line">response_.<span class="built_in">set</span>(boost::beast::http::field::content_type, <span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line"><span class="comment">//在响应头的body写数据</span></span><br><span class="line">boost::beast::<span class="built_in">ostream</span>(response_.<span class="built_in">body</span>()) &lt;&lt; <span class="string">&quot;invaild request-method&quot;</span></span><br><span class="line">&lt;&lt; std::<span class="built_in">string</span>(request_.<span class="built_in">method_string</span>()) &lt;&lt; <span class="string">&quot;`&quot;</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>create_response函数中解析了不同的路由处理get请求</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">create_get_response</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//判断请求的路由,假设他要问请求了多少次</span></span><br><span class="line"><span class="keyword">if</span> (request_.<span class="built_in">target</span>() == <span class="string">&quot;/count&quot;</span>) &#123;</span><br><span class="line"><span class="comment">//设置返回的MIME类型为HTML</span></span><br><span class="line">response_.<span class="built_in">set</span>(boost::beast::http::field::content_type, <span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">boost::beast::<span class="built_in">ostream</span>(response_.<span class="built_in">body</span>())</span><br><span class="line">&lt;&lt; <span class="string">&quot;&lt;html&gt;\n&quot;</span></span><br><span class="line">&lt;&lt; <span class="string">&quot;&lt;head&gt;&lt;title&gt;Current time&lt;/title&gt;&lt;/head&gt;\n&quot;</span></span><br><span class="line">&lt;&lt; <span class="string">&quot;&lt;body&gt;\n&quot;</span></span><br><span class="line">&lt;&lt; <span class="string">&quot;&lt;h1&gt;Current time&lt;/h1&gt;\n&quot;</span></span><br><span class="line">&lt;&lt; <span class="string">&quot;&lt;p&gt;The current time is &quot;</span></span><br><span class="line">&lt;&lt; my_program_state::<span class="built_in">request_count</span>()</span><br><span class="line">&lt;&lt; <span class="string">&quot; seconds since the epoch.&lt;/p&gt;\n&quot;</span></span><br><span class="line">&lt;&lt; <span class="string">&quot;&lt;/body&gt;\n&quot;</span></span><br><span class="line">&lt;&lt; <span class="string">&quot;&lt;/html&gt;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//假设问的是时间</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (request_.<span class="built_in">target</span>() == <span class="string">&quot;/time&quot;</span>) &#123;</span><br><span class="line"><span class="comment">//设置返回的MIME类型为HTML</span></span><br><span class="line">response_.<span class="built_in">set</span>(boost::beast::http::field::content_type, <span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">boost::beast::<span class="built_in">ostream</span>(response_.<span class="built_in">body</span>())</span><br><span class="line">&lt;&lt; <span class="string">&quot;&lt;html&gt;\n&quot;</span></span><br><span class="line">&lt;&lt; <span class="string">&quot;&lt;head&gt;&lt;title&gt;Current time&lt;/title&gt;&lt;/head&gt;\n&quot;</span></span><br><span class="line">&lt;&lt; <span class="string">&quot;&lt;body&gt;\n&quot;</span></span><br><span class="line">&lt;&lt; <span class="string">&quot;&lt;h1&gt;Current time&lt;/h1&gt;\n&quot;</span></span><br><span class="line">&lt;&lt; <span class="string">&quot;&lt;p&gt;The current time is &quot;</span></span><br><span class="line">&lt;&lt; my_program_state::<span class="built_in">now</span>()</span><br><span class="line">&lt;&lt; <span class="string">&quot; seconds since the epoch.&lt;/p&gt;\n&quot;</span></span><br><span class="line">&lt;&lt; <span class="string">&quot;&lt;/body&gt;\n&quot;</span></span><br><span class="line">&lt;&lt; <span class="string">&quot;&lt;/html&gt;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//设置状态为404，未找到页面</span></span><br><span class="line">response_.<span class="built_in">result</span>(boost::beast::http::status::not_found);</span><br><span class="line">boost::beast::<span class="built_in">ostream</span>(response_.<span class="built_in">body</span>())</span><br><span class="line">&lt;&lt; <span class="string">&quot;File not found\r\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>create_post_response处理了post请求中的一部分路由</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">create_post_response</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//判断路由是不是email</span></span><br><span class="line"><span class="keyword">if</span> (request_.<span class="built_in">target</span>() == <span class="string">&quot;/email&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//取出body</span></span><br><span class="line"><span class="keyword">auto</span>&amp; body = <span class="keyword">this</span>-&gt;request_.<span class="built_in">body</span>();</span><br><span class="line"><span class="comment">//得到body里的内容。将buffer转换为string</span></span><br><span class="line"><span class="keyword">auto</span> body_str = boost::beast::<span class="built_in">buffers_to_string</span>(body.<span class="built_in">data</span>());</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;receive body is &quot;</span> &lt;&lt; body_str &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">//设置为json</span></span><br><span class="line"><span class="keyword">this</span>-&gt;response_.<span class="built_in">set</span>(boost::beast::http::field::content_type, <span class="string">&quot;text/json&quot;</span>);</span><br><span class="line"><span class="comment">//这是回应给对方用的json</span></span><br><span class="line">Json::Value root;</span><br><span class="line"><span class="comment">//用于解析请求</span></span><br><span class="line">Json::Reader reader;</span><br><span class="line"><span class="comment">//表示原始的根</span></span><br><span class="line">Json::Value src_root;</span><br><span class="line"><span class="comment">//解析到原始的根里</span></span><br><span class="line"><span class="type">bool</span> parse_success = reader.<span class="built_in">parse</span>(body_str, src_root);</span><br><span class="line"><span class="comment">//如果解析错误</span></span><br><span class="line"><span class="keyword">if</span> (!parse_success) &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Failed to parse JSON data!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">root[<span class="string">&quot;error&quot;</span>] = <span class="number">1001</span>;</span><br><span class="line"><span class="comment">//将json序列化为字符串</span></span><br><span class="line">std::string jsonstr = root.<span class="built_in">toStyledString</span>();</span><br><span class="line"><span class="comment">//写道回应里的body里</span></span><br><span class="line">boost::beast::<span class="built_in">ostream</span>(<span class="keyword">this</span>-&gt;response_.<span class="built_in">body</span>()) &lt;&lt; jsonstr;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果解析正确</span></span><br><span class="line"><span class="keyword">auto</span> email = src_root[<span class="string">&quot;email&quot;</span>].<span class="built_in">asString</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;email is &quot;</span> &lt;&lt; email &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">root[<span class="string">&quot;error&quot;</span>] = <span class="number">0</span>;</span><br><span class="line">root[<span class="string">&quot;email&quot;</span>] = src_root[<span class="string">&quot;email&quot;</span>];</span><br><span class="line">root[<span class="string">&quot;msg&quot;</span>] = <span class="string">&quot;recevie email post success&quot;</span>;</span><br><span class="line"><span class="comment">//也就是以字符串的形式显示，其内部还是json格式</span></span><br><span class="line">std::string jsonstr = root.<span class="built_in">toStyledString</span>();</span><br><span class="line">boost::beast::<span class="built_in">ostream</span>(<span class="keyword">this</span>-&gt;response_.<span class="built_in">body</span>()) &lt;&lt; jsonstr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">response_.<span class="built_in">result</span>(boost::beast::http::status::not_found);</span><br><span class="line">response_.<span class="built_in">set</span>(boost::beast::http::field::content_type, <span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line">boost::beast::<span class="built_in">ostream</span>(response_.<span class="built_in">body</span>()) &lt;&lt; <span class="string">&quot;File not found\r\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>write_response发送请求</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_response</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> self = <span class="built_in">shared_from_this</span>();</span><br><span class="line"><span class="comment">//设置数据的长度类似tlv的长度</span></span><br><span class="line">response_.<span class="built_in">content_length</span>(response_.<span class="built_in">body</span>().<span class="built_in">size</span>());</span><br><span class="line"><span class="comment">//调用写函数</span></span><br><span class="line">boost::beast::http::<span class="built_in">async_write</span>(socket_, response_,</span><br><span class="line">[self](boost::system::error_code ec, std::<span class="type">size_t</span> bytes_transgerred) &#123;</span><br><span class="line"><span class="comment">//由于服务器是全双工的，我们关闭服务器的时候不能直接调用close</span></span><br><span class="line"><span class="comment">//因为一个服务器会调用很多很多连接，如果服务器主动断开连接</span></span><br><span class="line"><span class="comment">//会有很多客户端都需要等待四次挥手，所以我们为了避免这种情况</span></span><br><span class="line"><span class="comment">//可以只关闭服务器的发送端</span></span><br><span class="line">self-&gt;socket_.<span class="built_in">shutdown</span>(boost::asio::ip::tcp::socket::shutdown_send,ec);</span><br><span class="line"><span class="comment">//将定时器取消掉</span></span><br><span class="line">self-&gt;deadline_.<span class="built_in">cancel</span>();</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/beast/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/beast/http.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/beast/version.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;json/json.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;json/value.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;json/reader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> my_program_state &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//统计别人请求的个数</span></span><br><span class="line"><span class="function">std::<span class="type">size_t</span> <span class="title">request_count</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">static</span> std::<span class="type">size_t</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> ++count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到当前时间</span></span><br><span class="line"><span class="function">std::<span class="type">time_t</span> <span class="title">now</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">time</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建立连接，实际上建立过程和tcp服务器类似</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">http_connection</span> :<span class="keyword">public</span> std::enable_shared_from_this&lt;http_connection&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//不用引用是为了让每一个connection都独立管理自己的socket</span></span><br><span class="line"><span class="comment">//所以为了避免构造 得使用移动构造函数</span></span><br><span class="line"><span class="built_in">http_connection</span>(boost::asio::ip::tcp::socket socket) :</span><br><span class="line"><span class="built_in">socket_</span>(std::<span class="built_in">move</span>(socket)) </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//读取请求</span></span><br><span class="line"><span class="built_in">read_request</span>();</span><br><span class="line"><span class="comment">//开始超时返回机制,对于短连接</span></span><br><span class="line"><span class="built_in">check_deadline</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">//用于读取与发送的套接字</span></span><br><span class="line">boost::asio::ip::tcp::socket socket_;</span><br><span class="line"><span class="comment">//接收缓冲区,指定最大为8K</span></span><br><span class="line">boost::beast::flat_buffer buffer_&#123; <span class="number">8192</span> &#125;;</span><br><span class="line"><span class="comment">//请求头,其中dynamic_body 表示接收任意类型请求可以是html可以是javaScript</span></span><br><span class="line">boost::beast::http::request&lt; boost::beast::http::dynamic_body&gt; request_;</span><br><span class="line"><span class="comment">//响应头</span></span><br><span class="line">boost::beast::http::response&lt;boost::beast::http::dynamic_body&gt; response_;</span><br><span class="line"><span class="comment">//构造一个计时器</span></span><br><span class="line">boost::asio::steady_timer deadline_&#123;</span><br><span class="line">socket_.<span class="built_in">get_executor</span>(),std::chrono::<span class="built_in">seconds</span>(<span class="number">60</span>) &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现读请求</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_request</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//千万不要用make_shared</span></span><br><span class="line"><span class="keyword">auto</span> self = <span class="built_in">shared_from_this</span>();</span><br><span class="line">boost::beast::http::<span class="built_in">async_read</span>(socket_, buffer_, request_,</span><br><span class="line">[self](boost::system::error_code ec, std::<span class="type">size_t</span> bytes_transferred) &#123;</span><br><span class="line"><span class="comment">//因为用不到后面那个参数，所以忽略他</span></span><br><span class="line"><span class="comment">//由于底层必须接收它，所以即使不用也要声明</span></span><br><span class="line">boost::<span class="built_in">ignore_unused</span>(bytes_transferred);</span><br><span class="line"><span class="keyword">if</span> (!ec) &#123;</span><br><span class="line">self-&gt;<span class="built_in">process_request</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检测定时器</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">check_deadline</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//构造伪闭包，防止被析构的时候，意外地被释放</span></span><br><span class="line"><span class="keyword">auto</span> self = <span class="built_in">shared_from_this</span>();</span><br><span class="line"><span class="comment">//开始异步等待60s,传递的时候多传递一个self，这样做是为了</span></span><br><span class="line"><span class="comment">//防止在60之内的等待中，http_connection先被释放掉</span></span><br><span class="line"><span class="comment">//而导致this为空的崩溃</span></span><br><span class="line">deadline_.<span class="built_in">async_wait</span>([self](boost::system::error_code ec) &#123;</span><br><span class="line"><span class="keyword">if</span> (!ec) &#123;</span><br><span class="line">self-&gt;socket_.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process_request</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//设置回应版本,设置为请求回来的</span></span><br><span class="line">response_.<span class="built_in">version</span>(request_.<span class="built_in">version</span>());</span><br><span class="line"><span class="comment">//设置为短连接</span></span><br><span class="line">response_.<span class="built_in">keep_alive</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">switch</span> (request_.<span class="built_in">method</span>()) &#123;</span><br><span class="line"><span class="keyword">case</span> boost::beast::http::verb::get:</span><br><span class="line"><span class="comment">//设置为错误请求的状态码</span></span><br><span class="line">response_.<span class="built_in">result</span>(boost::beast::http::status::ok);</span><br><span class="line"><span class="comment">//设置响应头的MIME类型，也就是回应的数据类型</span></span><br><span class="line">response_.<span class="built_in">set</span>(boost::beast::http::field::server, <span class="string">&quot;Beast&quot;</span>);</span><br><span class="line"><span class="comment">//创建回应</span></span><br><span class="line"><span class="built_in">create_get_response</span>();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> boost::beast::http::verb::post:</span><br><span class="line"><span class="comment">//设置为错误请求的状态码</span></span><br><span class="line">response_.<span class="built_in">result</span>(boost::beast::http::status::ok);</span><br><span class="line"><span class="comment">//设置响应头的MIME类型，也就是回应的数据类型</span></span><br><span class="line">response_.<span class="built_in">set</span>(boost::beast::http::field::server, <span class="string">&quot;Beast&quot;</span>);</span><br><span class="line"><span class="comment">//创建回应</span></span><br><span class="line"><span class="built_in">create_post_response</span>();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">//设置为错误请求的状态码</span></span><br><span class="line">response_.<span class="built_in">result</span>(boost::beast::http::status::bad_request);</span><br><span class="line"><span class="comment">//设置响应头的MIME类型，也就是回应的数据类型</span></span><br><span class="line">response_.<span class="built_in">set</span>(boost::beast::http::field::content_type, <span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line"><span class="comment">//在响应头的body写数据</span></span><br><span class="line">boost::beast::<span class="built_in">ostream</span>(response_.<span class="built_in">body</span>()) &lt;&lt; <span class="string">&quot;invaild request-method&quot;</span></span><br><span class="line">&lt;&lt; std::<span class="built_in">string</span>(request_.<span class="built_in">method_string</span>()) &lt;&lt; <span class="string">&quot;`&quot;</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">create_get_response</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//判断请求的路由,假设他要问请求了多少次</span></span><br><span class="line"><span class="keyword">if</span> (request_.<span class="built_in">target</span>() == <span class="string">&quot;/count&quot;</span>) &#123;</span><br><span class="line"><span class="comment">//设置返回的MIME类型为HTML</span></span><br><span class="line">response_.<span class="built_in">set</span>(boost::beast::http::field::content_type, <span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">boost::beast::<span class="built_in">ostream</span>(response_.<span class="built_in">body</span>())</span><br><span class="line">&lt;&lt; <span class="string">&quot;&lt;html&gt;\n&quot;</span></span><br><span class="line">&lt;&lt; <span class="string">&quot;&lt;head&gt;&lt;title&gt;Current time&lt;/title&gt;&lt;/head&gt;\n&quot;</span></span><br><span class="line">&lt;&lt; <span class="string">&quot;&lt;body&gt;\n&quot;</span></span><br><span class="line">&lt;&lt; <span class="string">&quot;&lt;h1&gt;Current time&lt;/h1&gt;\n&quot;</span></span><br><span class="line">&lt;&lt; <span class="string">&quot;&lt;p&gt;The current time is &quot;</span></span><br><span class="line">&lt;&lt; my_program_state::<span class="built_in">request_count</span>()</span><br><span class="line">&lt;&lt; <span class="string">&quot; seconds since the epoch.&lt;/p&gt;\n&quot;</span></span><br><span class="line">&lt;&lt; <span class="string">&quot;&lt;/body&gt;\n&quot;</span></span><br><span class="line">&lt;&lt; <span class="string">&quot;&lt;/html&gt;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//假设问的是时间</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (request_.<span class="built_in">target</span>() == <span class="string">&quot;/time&quot;</span>) &#123;</span><br><span class="line"><span class="comment">//设置返回的MIME类型为HTML</span></span><br><span class="line">response_.<span class="built_in">set</span>(boost::beast::http::field::content_type, <span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">boost::beast::<span class="built_in">ostream</span>(response_.<span class="built_in">body</span>())</span><br><span class="line">&lt;&lt; <span class="string">&quot;&lt;html&gt;\n&quot;</span></span><br><span class="line">&lt;&lt; <span class="string">&quot;&lt;head&gt;&lt;title&gt;Current time&lt;/title&gt;&lt;/head&gt;\n&quot;</span></span><br><span class="line">&lt;&lt; <span class="string">&quot;&lt;body&gt;\n&quot;</span></span><br><span class="line">&lt;&lt; <span class="string">&quot;&lt;h1&gt;Current time&lt;/h1&gt;\n&quot;</span></span><br><span class="line">&lt;&lt; <span class="string">&quot;&lt;p&gt;The current time is &quot;</span></span><br><span class="line">&lt;&lt; my_program_state::<span class="built_in">now</span>()</span><br><span class="line">&lt;&lt; <span class="string">&quot; seconds since the epoch.&lt;/p&gt;\n&quot;</span></span><br><span class="line">&lt;&lt; <span class="string">&quot;&lt;/body&gt;\n&quot;</span></span><br><span class="line">&lt;&lt; <span class="string">&quot;&lt;/html&gt;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//设置状态为404，未找到页面</span></span><br><span class="line">response_.<span class="built_in">result</span>(boost::beast::http::status::not_found);</span><br><span class="line">boost::beast::<span class="built_in">ostream</span>(response_.<span class="built_in">body</span>())</span><br><span class="line">&lt;&lt; <span class="string">&quot;File not found\r\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_response</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> self = <span class="built_in">shared_from_this</span>();</span><br><span class="line"><span class="comment">//设置数据的长度类似tlv的长度</span></span><br><span class="line">response_.<span class="built_in">content_length</span>(response_.<span class="built_in">body</span>().<span class="built_in">size</span>());</span><br><span class="line"><span class="comment">//调用写函数</span></span><br><span class="line">boost::beast::http::<span class="built_in">async_write</span>(socket_, response_,</span><br><span class="line">[self](boost::system::error_code ec, std::<span class="type">size_t</span> bytes_transgerred) &#123;</span><br><span class="line"><span class="comment">//由于服务器是全双工的，我们关闭服务器的时候不能直接调用close</span></span><br><span class="line"><span class="comment">//因为一个服务器会调用很多很多连接，如果服务器主动断开连接</span></span><br><span class="line"><span class="comment">//会有很多客户端都需要等待四次挥手，所以我们为了避免这种情况</span></span><br><span class="line"><span class="comment">//可以只关闭服务器的发送端</span></span><br><span class="line">self-&gt;socket_.<span class="built_in">shutdown</span>(boost::asio::ip::tcp::socket::shutdown_send,ec);</span><br><span class="line"><span class="comment">//将定时器取消掉</span></span><br><span class="line">self-&gt;deadline_.<span class="built_in">cancel</span>();</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">create_post_response</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//判断路由是不是email</span></span><br><span class="line"><span class="keyword">if</span> (request_.<span class="built_in">target</span>() == <span class="string">&quot;/email&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//取出body</span></span><br><span class="line"><span class="keyword">auto</span>&amp; body = <span class="keyword">this</span>-&gt;request_.<span class="built_in">body</span>();</span><br><span class="line"><span class="comment">//得到body里的内容。将buffer转换为string</span></span><br><span class="line"><span class="keyword">auto</span> body_str = boost::beast::<span class="built_in">buffers_to_string</span>(body.<span class="built_in">data</span>());</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;receive body is &quot;</span> &lt;&lt; body_str &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">//设置为json</span></span><br><span class="line"><span class="keyword">this</span>-&gt;response_.<span class="built_in">set</span>(boost::beast::http::field::content_type, <span class="string">&quot;text/json&quot;</span>);</span><br><span class="line"><span class="comment">//这是回应给对方用的json</span></span><br><span class="line">Json::Value root;</span><br><span class="line"><span class="comment">//用于解析请求</span></span><br><span class="line">Json::Reader reader;</span><br><span class="line"><span class="comment">//表示原始的根</span></span><br><span class="line">Json::Value src_root;</span><br><span class="line"><span class="comment">//解析到原始的根里</span></span><br><span class="line"><span class="type">bool</span> parse_success = reader.<span class="built_in">parse</span>(body_str, src_root);</span><br><span class="line"><span class="comment">//如果解析错误</span></span><br><span class="line"><span class="keyword">if</span> (!parse_success) &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Failed to parse JSON data!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">root[<span class="string">&quot;error&quot;</span>] = <span class="number">1001</span>;</span><br><span class="line"><span class="comment">//将json序列化为字符串</span></span><br><span class="line">std::string jsonstr = root.<span class="built_in">toStyledString</span>();</span><br><span class="line"><span class="comment">//写道回应里的body里</span></span><br><span class="line">boost::beast::<span class="built_in">ostream</span>(<span class="keyword">this</span>-&gt;response_.<span class="built_in">body</span>()) &lt;&lt; jsonstr;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果解析正确</span></span><br><span class="line"><span class="keyword">auto</span> email = src_root[<span class="string">&quot;email&quot;</span>].<span class="built_in">asString</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;email is &quot;</span> &lt;&lt; email &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">root[<span class="string">&quot;error&quot;</span>] = <span class="number">0</span>;</span><br><span class="line">root[<span class="string">&quot;email&quot;</span>] = src_root[<span class="string">&quot;email&quot;</span>];</span><br><span class="line">root[<span class="string">&quot;msg&quot;</span>] = <span class="string">&quot;recevie email post success&quot;</span>;</span><br><span class="line"><span class="comment">//也就是以字符串的形式显示，其内部还是json格式</span></span><br><span class="line">std::string jsonstr = root.<span class="built_in">toStyledString</span>();</span><br><span class="line">boost::beast::<span class="built_in">ostream</span>(<span class="keyword">this</span>-&gt;response_.<span class="built_in">body</span>()) &lt;&lt; jsonstr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">response_.<span class="built_in">result</span>(boost::beast::http::status::not_found);</span><br><span class="line">response_.<span class="built_in">set</span>(boost::beast::http::field::content_type, <span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line">boost::beast::<span class="built_in">ostream</span>(response_.<span class="built_in">body</span>()) &lt;&lt; <span class="string">&quot;File not found\r\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">http_server</span><span class="params">(boost::asio::ip::tcp::acceptor&amp; acceptor, boost::asio::ip::tcp::socket&amp; socket)</span> </span>&#123;</span><br><span class="line">acceptor.<span class="built_in">async_accept</span>(socket, [&amp;](boost::system::error_code ec) &#123;</span><br><span class="line"><span class="keyword">if</span> (!ec) &#123;</span><br><span class="line"><span class="comment">//启动http的connection</span></span><br><span class="line">std::<span class="built_in">make_shared</span>&lt;http_connection&gt;(std::<span class="built_in">move</span>(socket))-&gt;<span class="built_in">Start</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不管成功与失败都要继续监听请求</span></span><br><span class="line"><span class="built_in">http_server</span>(acceptor, socket);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//服务器的地址，最后不要写内网，现在为了测试写内网</span></span><br><span class="line"><span class="keyword">auto</span> <span class="type">const</span> address = boost::asio::ip::<span class="built_in">make_address</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> port = <span class="built_in">static_cast</span>&lt;<span class="type">unsigned</span> <span class="type">short</span>&gt;(<span class="number">8080</span>);</span><br><span class="line">boost::<span class="function">asio::io_context <span class="title">io_context</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">boost::asio::ip::tcp::acceptor acceptor&#123; io_context, &#123;address, port&#125; &#125;;</span><br><span class="line">boost::asio::ip::<span class="function">tcp::socket <span class="title">socket</span><span class="params">(io_context)</span></span>;</span><br><span class="line"><span class="built_in">http_server</span>(acceptor, socket);</span><br><span class="line">io_context.<span class="built_in">run</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (std::exception e) &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="beast网络库实现websocket服务器"><a href="#beast网络库实现websocket服务器" class="headerlink" title="beast网络库实现websocket服务器"></a>beast网络库实现websocket服务器</h2><h3 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h3><ul><li>使用beast网络库实现websocket服务器，一般来说websocket是一个长连接的协议，但是自动包含了解包处理，当我们在浏览器输入一个http请求时如果是以ws开头的如ws://127.0.0.1:9501就是请求本地9501端口的websocket服务器处理。而beast为我们提供了websocket的处理方案，我们可以在http服务器的基础上升级协议为websocket，处理部分websocket请求。如果服务器收到的是普通的http请求则按照http请求处理。我们可以从官方文档中按照示例逐步搭建websocket服务器。</li></ul><h3 id="构造websocket"><a href="#构造websocket" class="headerlink" title="构造websocket"></a>构造websocket</h3><ul><li>原文档连接：<a href="https://llfc.club/category?catid=225RaiVNI8pFDD5L4m807g7ZwmF#!aid/2Rlhdbut49eOVgjIVq9aj6nF7Rg">https://llfc.club/category?catid=225RaiVNI8pFDD5L4m807g7ZwmF#!aid/2Rlhdbut49eOVgjIVq9aj6nF7Rg</a></li></ul><h3 id="开发的websocket代码"><a href="#开发的websocket代码" class="headerlink" title="开发的websocket代码"></a>开发的websocket代码</h3><h4 id="Connection-h"><a href="#Connection-h" class="headerlink" title="Connection.h"></a>Connection.h</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/beast.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/uuid/uuid.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/uuid/uuid_generators.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/uuid/uuid_io.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> net = boost::asio;</span><br><span class="line"><span class="keyword">namespace</span> beast = boost::beast;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Connection</span>:<span class="keyword">public</span> std::enable_shared_from_this&lt;Connection&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Connection</span>(net::io_context&amp; ioc);</span><br><span class="line"><span class="comment">//启动连接</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//发送数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Async_Send</span><span class="params">(std::string data)</span></span>;</span><br><span class="line"><span class="comment">//用于升级为websocket</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Async_Accept</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//发送回调函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SendCallBack</span><span class="params">(std::string msg)</span></span>;</span><br><span class="line"><span class="comment">//得到底层socket</span></span><br><span class="line">net::ip::<span class="function">tcp::socket&amp; <span class="title">GetSocket</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//得到id</span></span><br><span class="line"><span class="function">std::string <span class="title">GetUuid</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">//指向websocket的智能指针</span></span><br><span class="line">std::unique_ptr&lt;beast::websocket::stream&lt;beast::tcp_stream&gt;&gt; _ws_ptr;</span><br><span class="line"><span class="comment">//保证时序性的队列</span></span><br><span class="line">std::queue&lt;std::string&gt; _send_que;</span><br><span class="line">net::io_context&amp; _ioc;</span><br><span class="line"><span class="comment">//websocket的缓冲区数据</span></span><br><span class="line">beast::flat_buffer _recv_buffer;</span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line">std::string _uuid;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Connection-cpp"><a href="#Connection-cpp" class="headerlink" title="Connection.cpp"></a>Connection.cpp</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Connection.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ConnectionMgr.h&quot;</span></span></span><br><span class="line"><span class="comment">//使用strand来让处理变成串行</span></span><br><span class="line">Connection::<span class="built_in">Connection</span>(net::io_context&amp; ioc):_ioc(ioc),</span><br><span class="line">_ws_ptr(std::make_unique&lt;beast::websocket::stream&lt;beast::tcp_stream&gt;&gt;(net::<span class="built_in">make_strand</span>(ioc)))</span><br><span class="line">&#123;</span><br><span class="line">boost::uuids::random_generator grenerator;</span><br><span class="line">boost::uuids::uuid uuid = <span class="built_in">grenerator</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//转换为string</span></span><br><span class="line">_uuid = boost::uuids::<span class="built_in">to_string</span>(uuid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Connection::Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//增加有引用计数</span></span><br><span class="line"><span class="keyword">auto</span> self = <span class="built_in">shared_from_this</span>();</span><br><span class="line"><span class="comment">//先接受数据</span></span><br><span class="line">_ws_ptr-&gt;<span class="built_in">async_read</span>(_recv_buffer, [self](boost::system::error_code ec, std::<span class="type">size_t</span> t) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;fer.<span class="built_in">size</span>());</span><br><span class="line"><span class="keyword">if</span> (ec) &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;websocket async read error is &quot;</span> &lt;&lt; ec.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">ConnectionMgr::<span class="built_in">GetInstance</span>().<span class="built_in">Remove_Connection</span>(self-&gt;<span class="built_in">GetUuid</span>());</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用于创建文本消息数据帧，是用来发送的</span></span><br><span class="line">self-&gt;_ws_ptr-&gt;<span class="built_in">text</span>(self-&gt;_ws_ptr-&gt;<span class="built_in">got_text</span>());</span><br><span class="line"><span class="comment">//将缓冲区数据转为string格式</span></span><br><span class="line"><span class="comment">//.data是为了得到起始位置的指针</span></span><br><span class="line">std::string recv_data = boost::beast::<span class="built_in">buffers_to_string</span>(self-&gt;_recv_buffer.<span class="built_in">data</span>());</span><br><span class="line"><span class="comment">//清空缓冲区，方便下次接收</span></span><br><span class="line">self-&gt;_recv_buffer.<span class="built_in">consume</span>(self-&gt;_recv_buffer.<span class="built_in">size</span>());</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Recevie data is &quot;</span> &lt;&lt; recv_data &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">//发送回去</span></span><br><span class="line">self-&gt;<span class="built_in">Async_Send</span>(std::<span class="built_in">move</span>(recv_data));</span><br><span class="line"><span class="comment">//继续接收数据</span></span><br><span class="line">self-&gt;<span class="built_in">Start</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">std::cerr &lt;&lt; <span class="string">&quot;Exception is &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Connection::Async_Send</span><span class="params">(std::string data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line"><span class="type">int</span> que_len = _send_que.<span class="built_in">size</span>();</span><br><span class="line">_send_que.<span class="built_in">push</span>(data);</span><br><span class="line"><span class="keyword">if</span> (que_len &gt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">SendCallBack</span>(std::<span class="built_in">move</span>(data));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">std::cerr &lt;&lt; <span class="string">&quot;Async Send failed, Exception is &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Connection::Async_Accept</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> self = <span class="built_in">shared_from_this</span>();</span><br><span class="line">_ws_ptr-&gt;<span class="built_in">async_accept</span>([self](boost::system::error_code err) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (!err) &#123;</span><br><span class="line">ConnectionMgr::<span class="built_in">GetInstance</span>().<span class="built_in">Add_Connection</span>(self);</span><br><span class="line">self-&gt;<span class="built_in">Start</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;websocket accept failed, err is &quot;</span> &lt;&lt; err.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (std::exception&amp; exp) &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;websocket async accept exception is &quot;</span> &lt;&lt; exp.<span class="built_in">what</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Connection::SendCallBack</span><span class="params">(std::string msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> self = <span class="built_in">shared_from_this</span>();</span><br><span class="line"><span class="comment">//发送数据给客户端</span></span><br><span class="line">_ws_ptr-&gt;<span class="built_in">async_write</span>(boost::asio::<span class="built_in">buffer</span>(msg.<span class="built_in">c_str</span>(), msg.<span class="built_in">length</span>()),</span><br><span class="line">[self](boost::system::error_code err, std::<span class="type">size_t</span>  nsize) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;async send err is &quot;</span> &lt;&lt; err.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">ConnectionMgr::<span class="built_in">GetInstance</span>().<span class="built_in">Remove_Connection</span>(self-&gt;_uuid);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::string send_msg;</span><br><span class="line">&#123;</span><br><span class="line">std::lock_guard&lt;std::mutex&gt; <span class="built_in">lck_gurad</span>(self-&gt;mtx);</span><br><span class="line">self-&gt;_send_que.<span class="built_in">pop</span>();</span><br><span class="line"><span class="comment">//如果数据空了就返回</span></span><br><span class="line"><span class="keyword">if</span> (self-&gt;_send_que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">send_msg = self-&gt;_send_que.<span class="built_in">front</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self-&gt;<span class="built_in">SendCallBack</span>(std::<span class="built_in">move</span>(send_msg));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (std::exception&amp; exp) &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;async send exception is &quot;</span> &lt;&lt; exp.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">ConnectionMgr::<span class="built_in">GetInstance</span>().<span class="built_in">Remove_Connection</span>(self-&gt;_uuid);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">net::ip::<span class="function">tcp::socket&amp; <span class="title">Connection::GetSocket</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span>&amp; con_ptr = beast::<span class="built_in">get_lowest_layer</span>(*_ws_ptr).<span class="built_in">socket</span>();</span><br><span class="line"><span class="keyword">return</span> con_ptr;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此处插入 return 语句</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">Connection::GetUuid</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _uuid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="ConnectionMgr-h"><a href="#ConnectionMgr-h" class="headerlink" title="ConnectionMgr.h"></a>ConnectionMgr.h</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Connection.h&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConnectionMgr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> ConnectionMgr&amp; <span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Remove_Connection</span><span class="params">(std::string uuid)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add_Connection</span><span class="params">(std::shared_ptr&lt;Connection&gt; con)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">ConnectionMgr</span>();</span><br><span class="line"><span class="built_in">ConnectionMgr</span>(<span class="type">const</span> ConnectionMgr&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">ConnectionMgr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> ConnectionMgr&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="comment">//存储连接</span></span><br><span class="line">std::unordered_map&lt;std::string, std::shared_ptr&lt;Connection&gt;&gt; _cons;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="ConnectionMgr-cpp"><a href="#ConnectionMgr-cpp" class="headerlink" title="ConnectionMgr.cpp"></a>ConnectionMgr.cpp</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ConnectionMgr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">ConnectionMgr&amp; <span class="title">ConnectionMgr::GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">static</span> ConnectionMgr ins;</span><br><span class="line"><span class="keyword">return</span> ins;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConnectionMgr::Remove_Connection</span><span class="params">(std::string uuid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_cons.<span class="built_in">erase</span>(uuid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConnectionMgr::Add_Connection</span><span class="params">(std::shared_ptr&lt;Connection&gt; con)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (_cons.<span class="built_in">count</span>(con-&gt;<span class="built_in">GetUuid</span>()) == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">_cons[con-&gt;<span class="built_in">GetUuid</span>()] = con;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个必须写</span></span><br><span class="line">ConnectionMgr::<span class="built_in">ConnectionMgr</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="WebSocketServer-h"><a href="#WebSocketServer-h" class="headerlink" title="WebSocketServer.h"></a>WebSocketServer.h</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ConnectionMgr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> net = boost::asio;</span><br><span class="line"><span class="keyword">namespace</span> beast = boost::beast;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WebSocketServer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">WebSocketServer</span>(net::io_context&amp; ioc, <span class="type">unsigned</span> <span class="type">short</span> port);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StartAccept</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">WebSocketServer</span>(<span class="type">const</span> WebSocketServer&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">WebSocketServer&amp; <span class="keyword">operator</span>=(<span class="type">const</span> WebSocketServer&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">net::ip::tcp::acceptor _acceptor;</span><br><span class="line">net::io_context&amp; _io_context;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="WebSocketServer-cpp"><a href="#WebSocketServer-cpp" class="headerlink" title="WebSocketServer.cpp"></a>WebSocketServer.cpp</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;WebSocketServer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Connection.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebSocketServer::StartAccept</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">auto</span> con_ptr = std::<span class="built_in">make_shared</span>&lt;Connection&gt;(_io_context);</span><br><span class="line"><span class="comment">//监听连接</span></span><br><span class="line">_acceptor.<span class="built_in">async_accept</span>(con_ptr-&gt;<span class="built_in">GetSocket</span>(), [<span class="keyword">this</span>, con_ptr](boost::system::error_code ec) &#123;</span><br><span class="line"><span class="keyword">if</span> (ec) &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;accept failed, error is &quot;</span> &lt;&lt; ec.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//升级http为websocket</span></span><br><span class="line">con_ptr-&gt;<span class="built_in">Async_Accept</span>();</span><br><span class="line"><span class="comment">//继续监听连接</span></span><br><span class="line"><span class="built_in">StartAccept</span>();</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">std::cerr &lt;&lt; <span class="string">&quot;Exception is &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">WebSocketServer::<span class="built_in">WebSocketServer</span>(net::io_context&amp; ioc, <span class="type">unsigned</span> <span class="type">short</span> port):_io_context(ioc),</span><br><span class="line">_acceptor(ioc, net::ip::tcp::<span class="built_in">endpoint</span>(net::ip::tcp::<span class="built_in">v4</span>(), port))</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Server start on port : &quot;</span> &lt;&lt; port &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="main-cpp"><a href="#main-cpp" class="headerlink" title="main.cpp"></a>main.cpp</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;WebSocketServer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">net::io_context ioc;</span><br><span class="line"><span class="function">WebSocketServer <span class="title">server</span><span class="params">(ioc, <span class="number">8888</span>)</span></span>;</span><br><span class="line">server.<span class="built_in">StartAccept</span>();</span><br><span class="line">ioc.<span class="built_in">run</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><ul><li><p>头文件预编译的时候不要出现父子的情况，也就是说beast.hpp 包含了 beast/core，两个一起被编译就会出现问题</p></li><li><p>一旦声明构造函数，就要显示写出构造函数，因为他不会提供默认构造函数</p></li></ul><h2 id="gRPC的使用"><a href="#gRPC的使用" class="headerlink" title="gRPC的使用"></a>gRPC的使用</h2><ul><li>有关gRPC的配置及下载等请查阅<a href="https://llfc.club/articlepage?id=2QYdExDcUDazjD6ZKNjs8KLcyAp">https://llfc.club/articlepage?id=2QYdExDcUDazjD6ZKNjs8KLcyAp</a></li></ul><h3 id="gRPC客户端"><a href="#gRPC客户端" class="headerlink" title="gRPC客户端"></a>gRPC客户端</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;grpcpp/grpcpp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;demo.grpc.pb.h&quot;</span> <span class="comment">// 导入生成的 gRPC 协议文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> grpc::ClientContext;</span><br><span class="line"><span class="keyword">using</span> grpc::Channel;</span><br><span class="line"><span class="keyword">using</span> grpc::Status;</span><br><span class="line"><span class="keyword">using</span> hello::HelloReply; <span class="comment">// 导入生成的 HelloReply 类</span></span><br><span class="line"><span class="keyword">using</span> hello::HelloRequest; <span class="comment">// 导入生成的 HelloRequest 类</span></span><br><span class="line"><span class="keyword">using</span> hello::Greeter; <span class="comment">// 导入生成的 Greeter 服务</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 gRPC 客户端类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FCClient</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，传入 gRPC 通道，初始化 stub_</span></span><br><span class="line">    <span class="built_in">FCClient</span>(std::shared_ptr&lt;Channel&gt; channel) : <span class="built_in">stub_</span>(Greeter::<span class="built_in">NewStub</span>(channel)) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 客户端调用远程服务的方法</span></span><br><span class="line">    <span class="function">std::string <span class="title">SayHello</span><span class="params">(std::string name)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建客户端上下文</span></span><br><span class="line">        ClientContext context;</span><br><span class="line">        <span class="comment">// 创建请求和响应对象</span></span><br><span class="line">        HelloReply reply;</span><br><span class="line">        HelloRequest request;</span><br><span class="line">        <span class="comment">// 设置请求消息内容</span></span><br><span class="line">        request.<span class="built_in">set_message</span>(name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用远程服务的 SayHello 方法，并传入请求和响应对象</span></span><br><span class="line">        <span class="comment">// 注意：此处是同步调用，会阻塞当前线程直到得到响应或者发生错误</span></span><br><span class="line">        Status status = stub_-&gt;<span class="built_in">SayHello</span>(&amp;context, request, &amp;reply);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查调用是否成功</span></span><br><span class="line">        <span class="keyword">if</span> (status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">            <span class="comment">// 返回服务端返回的消息内容</span></span><br><span class="line">            <span class="keyword">return</span> reply.<span class="built_in">message</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 返回失败信息，包含错误信息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;failure &quot;</span> + status.<span class="built_in">error_message</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 定义 gRPC 客户端 stub</span></span><br><span class="line">    std::unique_ptr&lt;Greeter::Stub&gt; stub_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建 gRPC 通道，连接 gRPC 服务器</span></span><br><span class="line">    <span class="keyword">auto</span> channel = grpc::<span class="built_in">CreateChannel</span>(<span class="string">&quot;127.0.0.1:8888&quot;</span>, grpc::<span class="built_in">InsecureChannelCredentials</span>());</span><br><span class="line">    <span class="comment">// 创建 gRPC 客户端对象</span></span><br><span class="line">    <span class="function">FCClient <span class="title">client</span><span class="params">(channel)</span></span>;</span><br><span class="line">    <span class="comment">// 调用客户端方法，向服务器发送消息，并接收服务器返回的结果</span></span><br><span class="line">    std::string result = client.<span class="built_in">SayHello</span>(<span class="string">&quot;hello, zxn!&quot;</span>);</span><br><span class="line">    <span class="comment">// 打印客户端收到的结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;get result is &quot;</span> &lt;&lt; result.<span class="built_in">c_str</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>客户端创建了一个channel，然后调用NewStub生成stub，接下来就可以发送数据了，下面是运行的效果</li><li>其中stub是用来远程调用服务端的必要东西</li></ul><h3 id="gRPC服务端"><a href="#gRPC服务端" class="headerlink" title="gRPC服务端"></a>gRPC服务端</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;grpcpp/grpcpp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;demo.grpc.pb.h&quot;</span> <span class="comment">// 导入生成的 gRPC 协议文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> grpc::Server; <span class="comment">// gRPC 服务器</span></span><br><span class="line"><span class="keyword">using</span> grpc::ServerBuilder; <span class="comment">// 服务器构建器</span></span><br><span class="line"><span class="keyword">using</span> grpc::ServerContext; <span class="comment">// 服务器上下文</span></span><br><span class="line"><span class="keyword">using</span> grpc::Status; <span class="comment">// 状态</span></span><br><span class="line"><span class="keyword">using</span> hello::HelloRequest; <span class="comment">// 请求消息类型</span></span><br><span class="line"><span class="keyword">using</span> hello::HelloReply; <span class="comment">// 响应消息类型</span></span><br><span class="line"><span class="keyword">using</span> hello::Greeter; <span class="comment">// 服务接口类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 Greeter 服务的具体类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GreeterServiceImpl</span> <span class="keyword">final</span> : <span class="keyword">public</span> Greeter::Service &#123;</span><br><span class="line">    <span class="comment">// 实现服务定义的方法</span></span><br><span class="line">    <span class="function">Status <span class="title">SayHello</span><span class="params">(::grpc::ServerContext* context,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> ::hello::HelloRequest* request, ::hello::HelloReply* response)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 构造响应消息，包含客户端发来的消息内容</span></span><br><span class="line">        <span class="function">std::string <span class="title">prefix</span><span class="params">(<span class="string">&quot;zxn grpc server has received: &quot;</span>)</span></span>;</span><br><span class="line">        response-&gt;<span class="built_in">set_message</span>(prefix + request-&gt;<span class="built_in">message</span>());</span><br><span class="line">        <span class="comment">// 返回状态为 OK，表示处理成功</span></span><br><span class="line">        <span class="keyword">return</span> Status::OK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动 gRPC 服务器的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RunServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::string <span class="title">server_address</span><span class="params">(<span class="string">&quot;0.0.0.0:8888&quot;</span>)</span></span>; <span class="comment">// 服务器地址</span></span><br><span class="line">    GreeterServiceImpl service; <span class="comment">// 创建 Greeter 服务实现对象</span></span><br><span class="line">    ServerBuilder builder; <span class="comment">// 创建服务器构建器</span></span><br><span class="line">    builder.<span class="built_in">AddListeningPort</span>(server_address, grpc::<span class="built_in">InsecureServerCredentials</span>()); <span class="comment">// 添加监听端口和凭证</span></span><br><span class="line">    builder.<span class="built_in">RegisterService</span>(&amp;service); <span class="comment">// 注册服务</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建并启动服务器</span></span><br><span class="line">    <span class="function">std::unique_ptr&lt;Server&gt; <span class="title">server</span><span class="params">(builder.BuildAndStart())</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Server listening on &quot;</span> &lt;&lt; server_address &lt;&lt; std::endl; <span class="comment">// 输出服务器启动信息</span></span><br><span class="line">    server-&gt;<span class="built_in">Wait</span>(); <span class="comment">// 等待服务器关闭</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">RunServer</span>(); <span class="comment">// 运行 gRPC 服务器</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello World!\n&quot;</span>; <span class="comment">// 打印消息，表示服务器运行结束</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>GreeterServiceImpl 继承自 Greeter::Service，重写了SayHello函数，当收到客户端发送的SayHello请求后执行重写函数功能的逻辑。</li></ul>]]></content>
    
    
    <summary type="html">本文介绍了C++运用asio进行网络编程的相关知识</summary>
    
    
    
    <category term="C++" scheme="https://pigcanstudy.github.io/categories/C/"/>
    
    
    <category term="asio网络编程" scheme="https://pigcanstudy.github.io/tags/asio%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    <category term="C++" scheme="https://pigcanstudy.github.io/tags/C/"/>
    
    <category term="boost" scheme="https://pigcanstudy.github.io/tags/boost/"/>
    
  </entry>
  
  <entry>
    <title>C++Qt</title>
    <link href="https://pigcanstudy.github.io/posts/6e928d8a.html"/>
    <id>https://pigcanstudy.github.io/posts/6e928d8a.html</id>
    <published>2024-07-18T02:49:00.000Z</published>
    <updated>2024-07-18T02:50:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li><a href="#目录">目录</a><ul><li><a href="#模态对话框与非模块对话框">模态对话框与非模块对话框</a><ul><li><a href="#非模块对话框">非模块对话框</a></li><li><a href="#模块对话框">模块对话框</a><ul><li><a href="#创建方法一">创建方法一</a></li><li><a href="#创建方法二">创建方法二</a></li></ul></li><li><a href="#窗口置顶">窗口置顶</a></li><li><a href="#open方法和exec方法的区别">open方法和exec方法的区别</a><ul><li><a href="#exec方法">exec()方法</a></li><li><a href="#open方法">open()方法</a></li><li><a href="#总结">总结</a></li></ul></li></ul></li><li><a href="#信号和槽">信号和槽</a><ul><li><a href="#不同的连接方式">不同的连接方式</a></li><li><a href="#实现界面的切换">实现界面的切换</a><ul><li><a href="#实现父窗口切换子窗口再切换回去">实现父窗口切换子窗口，再切换回去</a></li></ul></li><li><a href="#连接信号">连接信号</a><ul><li><a href="#子界面代码">子界面代码：</a></li><li><a href="#父界面代码">父界面代码</a></li></ul></li></ul></li><li><a href="#模态对话框消息传递">模态对话框消息传递</a><ul><li><a href="#模态对话框接收和拒绝消息">模态对话框接收和拒绝消息</a><ul><li><a href="#主界面和登陆界面切换">主界面和登陆界面切换</a></li></ul></li></ul></li><li><a href="#qt几种标准对话框">QT几种标准对话框</a><ul><li><a href="#颜色对话框">颜色对话框</a></li><li><a href="#文件对话框">文件对话框</a></li><li><a href="#输入对话框">输入对话框</a><ul><li><a href="#条目输入对话框">条目输入对话框</a></li><li><a href="#整形输入对话框">整形输入对话框</a></li><li><a href="#浮点数输入对话框">浮点数输入对话框</a></li><li><a href="#文本输入对话框">文本输入对话框</a></li></ul></li><li><a href="#消息对话框">消息对话框</a></li><li><a href="#qt进度对话框">QT进度对话框</a></li><li><a href="#qt向导对话框">QT向导对话框</a><ul><li><a href="#qvboxlayout">QVBoxLayout</a></li><li><a href="#qbuttongroup">QButtonGroup</a></li><li><a href="#qradiobutton-与-qcheckbutton">QRadioButton 与 QCheckButton</a><ul><li><a href="#qradiobutton单选框">QRadioButton单选框</a></li><li><a href="#qcheckbutton复选框">QCheckButton复选框</a></li></ul></li><li><a href="#总结1">总结1</a></li></ul></li></ul></li><li><a href="#qt-qlineedit介绍">QT QLineEdit介绍</a><ul><li><a href="#实战">实战</a></li></ul></li><li><a href="#qt布局与页面切换">Qt布局与页面切换</a></li><li><a href="#qt主窗口">QT主窗口</a><ul><li><a href="#菜单栏">菜单栏</a><ul><li><a href="#通过ui来实现">通过Ui来实现</a></li><li><a href="#通过代码实现">通过代码实现</a></li></ul></li><li><a href="#工具栏">工具栏</a></li><li><a href="#状态栏">状态栏</a></li></ul></li><li><a href="#qtextedit-文本编辑器">QTextEdit 文本编辑器</a><ul><li><a href="#文本块">文本块</a></li><li><a href="#遍历文本块">遍历文本块</a><ul><li><a href="#只遍历根框架">只遍历根框架</a></li><li><a href="#直接遍历文本块">直接遍历文本块</a></li></ul></li><li><a href="#设置文本块样式">设置文本块样式</a></li><li><a href="#插入表格列表图片">插入表格列表图片</a></li><li><a href="#实现查找功能">实现查找功能</a></li></ul></li></ul></li></ul><h2 id="模态对话框与非模块对话框"><a href="#模态对话框与非模块对话框" class="headerlink" title="模态对话框与非模块对话框"></a>模态对话框与非模块对话框</h2><h3 id="非模块对话框"><a href="#非模块对话框" class="headerlink" title="非模块对话框"></a>非模块对话框</h3><ul><li>它是一种不会阻止用户与程序中其他部分进行交互的对话框，它们不会阻止用户与程序的其他部分进行交互。用户可以同时打开多个非模态对话框，而不必等待一个对话框关闭才能操作其他部分</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent) :</span><br><span class="line">    <span class="built_in">QMainWindow</span>(parent),</span><br><span class="line">    <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">QDialog <span class="title">w</span><span class="params">()</span></span>;</span><br><span class="line">    w.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>我们在MainWindow的构造函数里创建了QDialog类型的变量w。 然后调用w的show函数展示该对话框。 运行程序后会看到对话框w一闪而逝，然后创建了主窗口。 一闪而逝的而原因是w在MainWindow的构造函数里，构造函数结束w就被释放了。所以窗口就会一闪而逝。 即便是如下设置w的父窗口为mainwindow也无济于事</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent) :</span><br><span class="line">    <span class="built_in">QMainWindow</span>(parent),</span><br><span class="line">    <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">QDialog <span class="title">w</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    w.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>因为无论w的父窗口是谁，都会随着MainWindow构造函数的结束而释放。那么好用的办法就是通过new创建对话框，这样对话框的空间在堆上，就不会随着构造函数结束而被释放了。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent) :</span><br><span class="line">    <span class="built_in">QMainWindow</span>(parent),</span><br><span class="line">    <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    QDialog w = <span class="keyword">new</span> <span class="built_in">QDialog</span>(<span class="keyword">this</span>);</span><br><span class="line">    w.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>用new创建QDialog 对象w，并且指明了this(MainWindow)为其父窗口，这样在父窗口关闭或者释放后，其子窗口也会释放。这个原理在之后会讲给大家，QT提供了<strong>对象树的机制</strong>，<strong><em>保证了父类被释放后子类都会被回收</em></strong>。所以这也是我们指明w的父窗口为MainWindow的意思，如果不指明就需要手动回收w。不回收就会造成内存泄漏。</li></ul><h3 id="模块对话框"><a href="#模块对话框" class="headerlink" title="模块对话框"></a>模块对话框</h3><ul><li><strong>模态对话框</strong>是一种<strong>会阻止用户与程序中其他部分进行交互的对话框</strong>。也就是说，当模态对话框显示时，用户必须在对话框关闭之前处理该对话框，无法转到程序的其他部分进行操作，可以像如下设置模块</li></ul><h4 id="创建方法一"><a href="#创建方法一" class="headerlink" title="创建方法一"></a>创建方法一</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent) :</span><br><span class="line">    <span class="built_in">QMainWindow</span>(parent),</span><br><span class="line">    <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">   <span class="keyword">auto</span> w = <span class="keyword">new</span> <span class="built_in">QDialog</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 为true就说明是模块对话框</span></span><br><span class="line">   w-&gt;<span class="built_in">setModal</span>(<span class="literal">true</span>);</span><br><span class="line">   w-&gt;<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>点击运行，弹出一个对话框和主窗口，点击主窗口没有任何反应，点击对话框关闭后才能点击主窗口，所以w就是一个模态对话框</li></ul><h4 id="创建方法二"><a href="#创建方法二" class="headerlink" title="创建方法二"></a>创建方法二</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent) :</span><br><span class="line">    <span class="built_in">QMainWindow</span>(parent),</span><br><span class="line">    <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="function">QDialog <span class="title">w</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    w.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要原因是exec这个函数会阻塞其他界面响应事件。所以直到我们关闭这个对话框后，exec才返回，这样MainWindow的构造函数才继续往下执行。也就是说只有关闭这个对话框才能执行后续内容</li></ul><h3 id="窗口置顶"><a href="#窗口置顶" class="headerlink" title="窗口置顶"></a>窗口置顶</h3><ul><li>有时我们需要将对话框置顶，不论其是不是模态对话框我们都可以这么做</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent) :</span><br><span class="line">    <span class="built_in">QMainWindow</span>(parent),</span><br><span class="line">    <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">auto</span> s = <span class="keyword">new</span> <span class="built_in">QDialog</span>(<span class="keyword">this</span>);</span><br><span class="line">    s-&gt;<span class="built_in">setWindowFlag</span>(Qt::WindowStaysOnTopHint);</span><br><span class="line">    s-&gt;<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="open方法和exec方法的区别"><a href="#open方法和exec方法的区别" class="headerlink" title="open方法和exec方法的区别"></a>open方法和exec方法的区别</h3><h4 id="exec-方法"><a href="#exec-方法" class="headerlink" title="exec()方法"></a>exec()方法</h4><ul><li>exec()方法是一个阻塞调用，它会阻塞当前线程，直到用户关闭对话框。<br>当对话框关闭时，exec()方法会返回用户的操作结果（例如QDialog::Accepted或QDialog::Rejected）。<br>通常情况下，你会将exec()方法用于模态对话框，因为它会阻塞用户与应用程序的交互，直到用户完成对话框的操作。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Copy code</span><br><span class="line"><span class="type">int</span> result = dialog.<span class="built_in">exec</span>();</span><br><span class="line"><span class="keyword">if</span> (result == QDialog::Accepted) &#123;</span><br><span class="line">    <span class="comment">// 用户点击了确定按钮</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 用户点击了取消按钮或者关闭按钮</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="open-方法"><a href="#open-方法" class="headerlink" title="open()方法"></a>open()方法</h4><ul><li>open()方法是一个非阻塞调用，它会将对话框显示在界面上，但不会阻塞当前线程。<br>当使用open()方法时，你通常需要手动检查对话框的结果或者在对话框的槽函数中处理用户的操作。<br>你可以将open()方法用于非模态对话框，因为它不会阻塞用户与应用程序的交互。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Copy code</span><br><span class="line">dialog.<span class="built_in">open</span>();</span><br><span class="line"><span class="comment">// 继续执行其他代码</span></span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>总的来说，exec()方法适用于模态对话框，它会阻塞当前线程直到用户关闭对话框，而open()方法适用于非模态对话框，它会将对话框显示在界面上但不会阻塞当前线程。选择使用哪种方法取决于你的应用程序逻辑和用户体验的需求。</li></ul><h2 id="信号和槽"><a href="#信号和槽" class="headerlink" title="信号和槽"></a>信号和槽</h2><ul><li>当我们需要一个界面通知另一个界面时，可以采用信号和槽机制。通过链接信号和槽，当一个界面发送信号时，链接该信号的槽会被响应，从而达到消息传递的目的。</li><li>所以我们先创建一个Qapplication Widgets 应用。Creator会为我们生成mainwindow类和其界面。我们在界面添加一个按钮，按钮的名字叫showChildButton, 按钮显示的文字改为“显示子界面”。<br>同时为该界面添加一个label，显示的文字修改为“这是主界面”</li></ul><p><img src="../assets/Qt/image.png" alt="示例图片" style="zoom:100%;" /></p><ul><li>现在实现点击按钮，在控制台打印一条日志 “show child dialog “</li><li>我们先在MainWindow的构造函数中添加信号和槽的链接逻辑</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//信号的发送者，信号的事件，信号的接收者，执行的函数</span></span><br><span class="line"><span class="built_in">connect</span>(ui-&gt;showChildButton, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>(<span class="type">bool</span>)), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">showChildDialog</span>()));</span><br></pre></td></tr></table></figure><ul><li><p><strong>connect函数的参数</strong> ：<strong><em>信号的发送者，信号的事件，信号的接收者，执行的槽函数</em></strong></p></li><li><p>然后我们为MainWindow添加showChildDialog槽函数，槽函数需要<strong>用slots声明</strong>，我们这里在mainwindow.h里用<strong>public slots</strong>的方式声明槽函数。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showChildDialog</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li><strong>public slots</strong> 声明一个为信号槽，用来接收信号并作出对应响应，也就是说connect的最后一个参数必须为槽函数</li><li>接下来去mainwindow.cpp中完成该函数的实现，可以在头文件中右键该函数，在弹出菜单里选择Refactor(重构), 再选择在mainwindow.cpp中添加实现。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;childdialog.h&quot;</span></span></span><br><span class="line">QT_BEGIN_NAMESPACE</span><br><span class="line"><span class="keyword">namespace</span> Ui &#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span>;</span><br><span class="line">&#125;</span><br><span class="line">QT_END_NAMESPACE</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">MainWindow</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showChildWindow</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showMain</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::MainWindow *ui;</span><br><span class="line">    ChildDialog * child_dialog;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MAINWINDOW_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;childdialog.h&quot;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow),<span class="built_in">child_dialog</span>(<span class="keyword">new</span> <span class="built_in">ChildDialog</span>(<span class="keyword">this</span>))</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    child_dialog = <span class="keyword">new</span> <span class="built_in">ChildDialog</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;showChildButton, &amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;MainWindow::showChildWindow);</span><br><span class="line">    <span class="built_in">connect</span>(child_dialog, &amp;ChildDialog::showMainsig, <span class="keyword">this</span>, &amp;MainWindow::showMain);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::showChildWindow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">hide</span>();</span><br><span class="line">    child_dialog-&gt;<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::showMain</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="不同的连接方式"><a href="#不同的连接方式" class="headerlink" title="不同的连接方式"></a>不同的连接方式</h3><ul><li>我们上边用来连接信号和槽的方式是qt4提供的方式，用SIGNAL和SLOT将信号和槽转化为字符串。<br>但是这种方式会存在一定问题，Qt要求槽函数的参数不能超过信号定义的参数，比如我们用到的信号clicked(bool)参数就是bool，我们定义的槽函数showChildDialog()是不带参数的，可以连接成功，如果我们在连接的时候将showChildDialog的参数写为3个，也可以连接成功</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//qt4 风格的Slot和Signal 只是宏转换，字符串定义不能检测编译错误</span></span><br><span class="line"><span class="built_in">connect</span>(ui-&gt;showChildButton, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>(<span class="type">bool</span>)), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">showChildDialog</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)));</span><br></pre></td></tr></table></figure><ul><li>但是点击会没有反应，说明qt4 这种连接信号和槽的方式不做编译检查，只是将信号和槽函数转译成字符串。</li></ul><p>所以我推荐使用qt5以上版本的连接方式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//推荐qt5 风格</span></span><br><span class="line"><span class="built_in">connect</span>(ui-&gt;showChildButton, &amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;MainWindow::showChildDialog);</span><br></pre></td></tr></table></figure><ul><li>如果 showChildDialog 是 MainWindow 类的成员函数，那么使用 &amp;MainWindow::showChildDialog 来表示该成员函数的指针。如果直接写 &amp;showChildDialog，那么编译器会认为你要连接的是一个全局函数，而不是 MainWindow 类的成员函数，因此会导致编译错误。</li></ul><h3 id="实现界面的切换"><a href="#实现界面的切换" class="headerlink" title="实现界面的切换"></a>实现界面的切换</h3><ul><li>主窗口转向子窗口<ol><li>方法一：直接new出一个子窗口对象</li></ol></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::showChildDialog</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;show child dialog &quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">auto</span> _child_dialog = <span class="keyword">new</span> <span class="built_in">ChildDialog</span>(<span class="keyword">this</span>);</span><br><span class="line">    _child_dialog-&gt;<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>再次运行程序点击显示子界面的按钮，就会弹出子界面了。关闭子界面，再次点击主窗口的显示子窗口按钮，子窗口又显示出来。<br>这么做有一个问题就是可能会重复创建子窗口，但是Qt的对象树机制会保证父窗口回收时才回收子窗口，所以关闭子窗口只是隐藏了。<br>那么随着点击，久而久之窗口会越来越多。</li></ul><ol><li>方法二：我们想到的一个避免重复创建的办法就是在MainWindow的构造函数里创建好子界面，在槽函数中只控制子界面的显示即可。<br>但同时要注意在MainWindow的析构函数里回收子界面类对象。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;childdialog.h&quot;</span></span></span><br><span class="line">QT_BEGIN_NAMESPACE</span><br><span class="line"><span class="keyword">namespace</span> Ui &#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span>;</span><br><span class="line">&#125;</span><br><span class="line">QT_END_NAMESPACE</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">MainWindow</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="comment">//接收信号并实现显示子窗口逻辑</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showChildWindow</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//接收信号并实现显示自己</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showMain</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::MainWindow *ui;</span><br><span class="line">    <span class="comment">//指向子窗口</span></span><br><span class="line">    ChildDialog * child_dialog;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MAINWINDOW_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;childdialog.h&quot;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow),<span class="built_in">child_dialog</span>(<span class="keyword">new</span> <span class="built_in">ChildDialog</span>(<span class="keyword">this</span>))</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    child_dialog = <span class="keyword">new</span> <span class="built_in">ChildDialog</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// UI界面的按钮为发送者，信号函数为点击事件，作用自己，信号槽函数</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;showChildButton, &amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;MainWindow::showChildWindow);</span><br><span class="line">    <span class="comment">// 发送者为子窗口，发送的信号函数是showMainsig，作用于自己，信号槽响应函数</span></span><br><span class="line">    <span class="built_in">connect</span>(child_dialog, &amp;ChildDialog::showMainsig, <span class="keyword">this</span>, &amp;MainWindow::showMain);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">    <span class="keyword">if</span>(_child_dialog)&#123;</span><br><span class="line">        <span class="keyword">delete</span>  _child_dialog;</span><br><span class="line">        _child_dialog = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::showChildWindow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//实现隐藏</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">hide</span>();</span><br><span class="line">    child_dialog-&gt;<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::showMain</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="实现父窗口切换子窗口，再切换回去"><a href="#实现父窗口切换子窗口，再切换回去" class="headerlink" title="实现父窗口切换子窗口，再切换回去"></a>实现父窗口切换子窗口，再切换回去</h4><ul><li>父窗口切换子窗口 可以用槽函数 加connect连接来实现 代码如上</li><li>子窗口切换父窗口 可以声明一个信号，用来通知主界面显示</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ChildDialog</span> : <span class="keyword">public</span> QDialog</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">signals:</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">showMainSig</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">ChildDialog</span><span class="params">(QWidget *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    ~<span class="built_in">ChildDialog</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::ChildDialog *ui;</span><br><span class="line">    QWidget *_parent;</span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showMainWindow</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>showMainSig是一个信号，用来通知主界面，所以主界面MainWindow类要连接这个信号，我们先在主界面类中声明这个函数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MainWindow</span><span class="params">(QWidget *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    ~<span class="built_in">MainWindow</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::MainWindow *ui;</span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showChildDialog</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showMainDialog</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ChildDialog *_child_dialog;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>showMainDialog 是新增的槽函数，用来连接ChildDialog的showMainSig信号。</li><li>我们修改ChildDialog的showMainWindow函数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChildDialog::showMainWindow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;show main window&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">hide</span>();</span><br><span class="line">    <span class="comment">//可以再次发送信号通知主窗口显示</span></span><br><span class="line">    <span class="function">emit <span class="title">showMainSig</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>然后再mainwindow里实现逻辑</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent) :</span><br><span class="line">    <span class="built_in">QMainWindow</span>(parent),</span><br><span class="line">    <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    _child_dialog = <span class="keyword">new</span> <span class="built_in">ChildDialog</span>(<span class="keyword">this</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//推荐qt5 风格</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;showChildButton, &amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;MainWindow::showChildDialog);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>(_child_dialog, &amp;ChildDialog::showMainSig, <span class="keyword">this</span>, &amp;MainWindow::showMainDialog);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::showChildDialog</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;show child dialog &quot;</span> &lt;&lt; endl;</span><br><span class="line">    _child_dialog-&gt;<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">hide</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="连接信号"><a href="#连接信号" class="headerlink" title="连接信号"></a>连接信号</h3><ul><li>上面的程序还可以进一步优化，因为Qt提供了信号连接信号的方式，也就是说我们可以把子界面的按钮点击信号和showMainSig信号连接起来。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ChildDialog::<span class="built_in">ChildDialog</span>(QWidget *parent) :</span><br><span class="line">    <span class="built_in">QDialog</span>(parent),</span><br><span class="line">    <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::ChildDialog),_parent(parent)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;showMainWindow, &amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;ChildDialog::showMainSig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>将clicked和showMainSig两个信号连接起来，也可以实现消息的传递，让代码更简洁了。</li></ul><h4 id="子界面代码："><a href="#子界面代码：" class="headerlink" title="子界面代码："></a>子界面代码：</h4><ol><li>头文件</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CHILDDIALOG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHILDDIALOG_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDialog&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Ui &#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChildDialog</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChildDialog</span> : <span class="keyword">public</span> QDialog</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showMainsig</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">ChildDialog</span><span class="params">(QWidget *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    ~<span class="built_in">ChildDialog</span>();</span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showMainWindow</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::ChildDialog *ui;</span><br><span class="line">    QWidget *_parent;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// CHILDDIALOG_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>cpp</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;childdialog.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_childdialog.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">ChildDialog::<span class="built_in">ChildDialog</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QDialog</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::ChildDialog),_parent(parent)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//信号的发送者，信号的事件，信号的接收者，执行的函数</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;pushButton, &amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;ChildDialog::showMainWindow);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ChildDialog::~<span class="built_in">ChildDialog</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChildDialog::showMainWindow</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">hide</span>();</span><br><span class="line">    <span class="function">emit <span class="title">showMainsig</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="父界面代码"><a href="#父界面代码" class="headerlink" title="父界面代码"></a>父界面代码</h4><ul><li>头文件</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;childdialog.h&quot;</span></span></span><br><span class="line">QT_BEGIN_NAMESPACE</span><br><span class="line"><span class="keyword">namespace</span> Ui &#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span>;</span><br><span class="line">&#125;</span><br><span class="line">QT_END_NAMESPACE</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">MainWindow</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showChildWindow</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showMain</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::MainWindow *ui;</span><br><span class="line">    ChildDialog * child_dialog;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MAINWINDOW_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>资源文件</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;childdialog.h&quot;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow),<span class="built_in">child_dialog</span>(<span class="keyword">new</span> <span class="built_in">ChildDialog</span>(<span class="keyword">this</span>))</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;showChildButton, &amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;MainWindow::showChildWindow);</span><br><span class="line">    <span class="built_in">connect</span>(child_dialog, &amp;ChildDialog::showMainsig, <span class="keyword">this</span>, &amp;MainWindow::show);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::showChildWindow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">hide</span>();</span><br><span class="line">    child_dialog-&gt;<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::showMain</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="模态对话框消息传递"><a href="#模态对话框消息传递" class="headerlink" title="模态对话框消息传递"></a>模态对话框消息传递</h2><h3 id="模态对话框接收和拒绝消息"><a href="#模态对话框接收和拒绝消息" class="headerlink" title="模态对话框接收和拒绝消息"></a>模态对话框接收和拒绝消息</h3><ul><li>我们创建一个模态对话框，调用exec函数后可以根据其返回值进行不同的处理，exec的返回值有两种，Qt的官方文档记录的为</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QDialog::Accepted</span><br><span class="line">QDialog::Rejected</span><br></pre></td></tr></table></figure><ul><li>Accepted 表示接受消息， Rejected表示拒绝消息。</li><li>还是按照之前的操作，选择新建QT Application项目，然后创建类名为MainWindow, 基类选择QDialog, 点击创建生成Qt项目。然后我们添加设计师界面类，类名MyDialog, 基类选择QDialog。然后在这个mydialog.ui中添加两个按钮，一个是进入主界面，一个是退出程序。</li></ul><p><img src="../assets/Qt/image-1.png" alt="示例图片" style="zoom:100%;" /></p><ul><li>在设计师界面点击Edit Signal/Slots 信号槽的按钮，进入信号槽编辑界面, 鼠标按住退出程序按钮不松开拖动，将另一端连接到MyDialog对话框，QPushbutton这边信号选择clicked()， MyDialog信号选择reject，这样就将两个信号连接起来了，我们点击退出程序按钮，会触发MyDialog发送reject信号，因为MyDialog调用exec后等待信号返回，此时收到reject信号，exec就会返回Rjected值。<br>同样道理，MyDialog发送accetp()信号后, exec返回值为Accepted。</li></ul><p><img src="../assets/Qt/image-2.png" alt="示例图片" style="zoom:100%;" /></p><ul><li><p>我们点击Edit Widget 按钮， 然后右键点击键入主界面按钮，点击进入槽，在Qt 为我们生成的槽函数里添加accetp()信号发送逻辑</p></li><li><p>他会生成一个槽函数，并且在内部实现了点击响应执行这个槽函数的代码</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDialog::on_pushButton_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">accept</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    MainWindow w;</span><br><span class="line">    MyDialog dialog;</span><br><span class="line">    <span class="keyword">if</span>(dialog.<span class="built_in">exec</span>() == QDialog::Accepted)&#123;</span><br><span class="line">        w.<span class="built_in">show</span>();</span><br><span class="line">         <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="主界面和登陆界面切换"><a href="#主界面和登陆界面切换" class="headerlink" title="主界面和登陆界面切换"></a>主界面和登陆界面切换</h4><ul><li>现在我们要实现主界面和登录界面的互相切换，我们刚才创建的对话框界面MyDialog界面是登录界面，主界面是MainWindow类。<br>我们在mainwindow.ui添加两个按钮，返回登录按钮和退出程序按钮, 再添加一个label表示这是主界面.<br>然后点击Edit Signal/Slot 进入信号编辑界面，点击退出程序按钮不松开拖动到尾部连接MainWindow的主界面上，选择退出程序的clicked()信号，MainWindow选择reject信号,将两个信号连接起来。</li></ul><p><img src="../assets/Qt/image-3.png" alt="示例图片" style="zoom:100%;" /></p><ul><li>然后右击登录按钮转到槽，在槽函数里添加这个逻辑</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_pushButton_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">close</span>();</span><br><span class="line">    MyDialog mydialog;</span><br><span class="line">    <span class="keyword">if</span>(mydialog.<span class="built_in">exec</span>() == QDialog::Accepted )&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">show</span>();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>点击返回登陆按钮就会close主窗口，但是并不是真的关闭，只是将主窗口隐藏，Qt回收机制是所有窗口都关闭后才回收。</li><li>再次运行程序，点击进入主界面按钮就可以进入主界面，点击返回登录按钮就可以返回登录界面，可以实现两个界面的切换了。</li></ul><h2 id="QT几种标准对话框"><a href="#QT几种标准对话框" class="headerlink" title="QT几种标准对话框"></a>QT几种标准对话框</h2><h3 id="颜色对话框"><a href="#颜色对话框" class="headerlink" title="颜色对话框"></a>颜色对话框</h3><ul><li>颜色对话框用来选择颜色，创建后会显示各种颜色和透明度信息</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_pushButton_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    QColorDialog colorDlg(Qt::blue, this);</span></span><br><span class="line"><span class="comment">//    colorDlg.setOption(QColorDialog::ShowAlphaChannel);</span></span><br><span class="line"><span class="comment">//    colorDlg.exec();</span></span><br><span class="line"><span class="comment">//    QColor color = colorDlg.currentColor();</span></span><br><span class="line"><span class="comment">//    qDebug() &lt;&lt; &quot;color is &quot; &lt;&lt; color;</span></span><br><span class="line"></span><br><span class="line">   QColor color = QColorDialog::<span class="built_in">getColor</span>(Qt::blue, <span class="keyword">this</span>,<span class="built_in">tr</span>(<span class="string">&quot;选择颜色&quot;</span>), QColorDialog::ShowAlphaChannel );</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;color is &quot;</span> &lt;&lt; color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>setOption()方法用于设置颜色对话框的选项，以控制对话框的行为和外观。通过这个方法，你可以根据自己的需求对对话框进行定制，例如设置初始颜色、显示模式、自定义按钮等。</li><li><p>QColorDialog::ColorDialogOption：</p></li><li><p>QColorDialog::ShowAlphaChannel：设置是否显示颜色对话框中的Alpha通道（透明度），默认是不显示。</p></li><li>QColorDialog::NoButtons：设置是否隐藏颜色对话框中的按钮（确定和取消按钮），默认是显示。</li><li>QColorDialog::DontUseNativeDialog：设置是否使用平台本地的颜色对话框，而不是Qt内置的对话框。</li></ul><h3 id="文件对话框"><a href="#文件对话框" class="headerlink" title="文件对话框"></a>文件对话框</h3><ul><li><p>它允许用户浏览文件系统并选择文件或目录，以便在应用程序中进行处理。文件对话框提供了多种选项和模式，包括：</p><ol><li>打开文件对话框：允许用户选择一个或多个文件以供读取或处理。也就是<strong>getOpenFileName()</strong>：打开一个打开文件对话框，允许用户选择一个或多个文件以供读取或处理。</li><li>保存文件对话框：允许用户指定文件名和位置，以便保存文件。<strong>getSaveFileName()</strong>：打开一个保存文件对话框，允许用户指定文件名和位置以供保存文件。</li><li>选择文件夹对话框：允许用户选择一个文件夹或目录。<strong>getExistingDirectory()</strong>：打开一个选择文件夹对话框，允许用户选择一个文件夹或目录。</li></ol></li><li><p>这些函数通常需要指定一些参数，包括父窗口、对话框的标题、初始路径、过滤器等，以及返回选择的文件路径或目录路径。</p></li><li>以下是简单示例</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QFileDialog&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QFile&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTextStream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开文件对话框，选择要打开的文件</span></span><br><span class="line">    QString filePath = QFileDialog::<span class="built_in">getOpenFileName</span>(<span class="literal">nullptr</span>, <span class="string">&quot;选择文件&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;文本文件 (*.txt)&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!filePath.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        <span class="comment">// 如果用户选择了文件，则打开文件并读取内容</span></span><br><span class="line">        <span class="function">QFile <span class="title">file</span><span class="params">(filePath)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (file.<span class="built_in">open</span>(QIODevice::ReadOnly | QIODevice::Text)) &#123;</span><br><span class="line">            <span class="function">QTextStream <span class="title">in</span><span class="params">(&amp;file)</span></span>;</span><br><span class="line">            QString content = in.<span class="built_in">readAll</span>();</span><br><span class="line">            <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;文件内容：&quot;</span> &lt;&lt; content;</span><br><span class="line">            file.<span class="built_in">close</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;无法打开文件：&quot;</span> &lt;&lt; file.<span class="built_in">errorString</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;用户取消了选择文件&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>常常配合QFile 来对文件进行一系列操作</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_pushButton_2_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QString path = QDir::<span class="built_in">currentPath</span>();</span><br><span class="line">    QString title = <span class="built_in">tr</span>(<span class="string">&quot;文件对话框&quot;</span>);</span><br><span class="line">    QString filter = <span class="built_in">tr</span>(<span class="string">&quot;文本文件(*.txt);;图片文件(*.jpg *.gif *.png);;所有文件(*.*)&quot;</span>);</span><br><span class="line">    QString aFileName=QFileDialog::<span class="built_in">getOpenFileName</span>(<span class="keyword">this</span>,title,path,filter);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; aFileName &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输入对话框"><a href="#输入对话框" class="headerlink" title="输入对话框"></a>输入对话框</h3><ul><li>输入对话框分几种，包括文本(字符串)输入对话框，整数输入对话框，浮点数输入对话框，条目输入对话框。</li></ul><h4 id="条目输入对话框"><a href="#条目输入对话框" class="headerlink" title="条目输入对话框"></a>条目输入对话框</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QString <span class="title">QInputDialog::getItem</span><span class="params">(QWidget *parent, <span class="type">const</span> QString &amp;title, <span class="type">const</span> QString &amp;label, <span class="type">const</span> QStringList &amp;items, <span class="type">int</span> current = <span class="number">0</span>, <span class="type">bool</span> editable = <span class="literal">false</span>, <span class="type">bool</span> *ok = <span class="literal">nullptr</span>, Qt::WindowFlags flags = Qt::WindowFlags())</span></span>;</span><br></pre></td></tr></table></figure><ul><li>参数说明：<ol><li>parent：指定对话框的父窗口，即在哪个窗口中显示对话框。</li><li>title：指定对话框的标题。</li><li>label：指定对话框中显示的文本标签，用于提示用户输入或选择条目。</li><li>items：一个字符串列表，包含了用户可以选择的条目。</li><li>current：指定默认选中的条目的索引。默认为0，即默认选中列表中的第一个条目。</li><li>editable：一个布尔值，指示是否允许用户输入自定义的条目。如果设置为 true，则在对话框中显示一个可编辑的文本框，用户可以输入自己的条目；如果设置为 false，则只允许用户选择预定义的条目，不允许输入自定义的条目。</li><li>ok：一个指向布尔变量的指针，用于接收用户是否点击了对话框的确认按钮。如果用户点击了确认按钮，则 ok 为 true；如果用户点击了取消按钮，则 ok 为 false。这个参数是可选的。</li><li>flags：指定对话框的标志，例如 Qt::WindowStaysOnTopHint 表示对话框始终位于最顶层，Qt::WindowCloseButtonHint 表示显示关闭按钮等。这个参数也是可选的</li></ol></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QStringList items;</span><br><span class="line">items &lt;&lt; <span class="built_in">tr</span>(<span class="string">&quot;条目一&quot;</span>) &lt;&lt; <span class="built_in">tr</span>(<span class="string">&quot;条目二&quot;</span>);</span><br><span class="line"><span class="type">bool</span> ok = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">auto</span> itemData = QInputDialog::<span class="built_in">getItem</span>(<span class="keyword">this</span>, <span class="built_in">tr</span>(<span class="string">&quot;条目对话框&quot;</span>), <span class="built_in">tr</span>(<span class="string">&quot;输入或选择条目&quot;</span>), items, <span class="number">0</span>, <span class="literal">false</span>, &amp;ok);</span><br><span class="line"><span class="keyword">if</span>(ok)&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;item is &quot;</span> &lt;&lt; itemData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="../assets/Qt/image-4.png" alt="示例图片" style="zoom:100%;" /></p><h4 id="整形输入对话框"><a href="#整形输入对话框" class="headerlink" title="整形输入对话框"></a>整形输入对话框</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">QInputDialog::getInt</span><span class="params">(QWidget *parent, <span class="type">const</span> QString &amp;title, <span class="type">const</span> QString &amp;label, <span class="type">int</span> value = <span class="number">0</span>, <span class="type">int</span> minValue = <span class="number">-2147483647</span>, <span class="type">int</span> maxValue = <span class="number">2147483647</span>, <span class="type">int</span> step = <span class="number">1</span>, <span class="type">bool</span> *ok = <span class="literal">nullptr</span>, Qt::WindowFlags flags = Qt::WindowFlags())</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>参数说明：<ol><li>parent：指定整型输入对话框的父窗口，即在哪个窗口中显示对话框。</li><li>title：指定对话框的标题。</li><li>label：指定对话框中显示的文本标签，用于提示用户输入。</li><li>value：指定整型输入框的初始值，默认为0。</li><li>minValue：指定可输入的最小值，默认为-2147483647。</li><li>maxValue：指定可输入的最大值，默认为2147483647。</li><li>step：指定增加或减少的步长，默认为1。</li><li>ok：一个bool类型的指针，用于指示用户是否点击了对话框中的确认按钮。如果用户点击了确认按钮，则ok为true；如果用户点击了取消按钮，则ok为false。这个参数是可选的。</li><li>flags：指定对话框的标志，例如Qt::WindowStaysOnTopHint表示对话框始终位于最顶层，Qt::WindowCloseButtonHint表示显示关闭按钮等。</li></ol></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_pushButton_4_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="type">bool</span> ok = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">auto</span> intdata = QInputDialog::<span class="built_in">getInt</span>(<span class="keyword">this</span>,<span class="built_in">tr</span>(<span class="string">&quot;数字输入对话框&quot;</span>),<span class="built_in">tr</span>(<span class="string">&quot;请输入数字&quot;</span>),<span class="number">200</span>,<span class="number">-200</span>,<span class="number">400</span>,<span class="number">10</span>,&amp;ok);</span><br><span class="line">    <span class="keyword">if</span>(ok)&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; intdata &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="浮点数输入对话框"><a href="#浮点数输入对话框" class="headerlink" title="浮点数输入对话框"></a>浮点数输入对话框</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QInputDialog::getDouble</span><span class="params">(QWidget *parent, <span class="type">const</span> QString &amp;title, <span class="type">const</span> QString &amp;label, <span class="type">double</span> value = <span class="number">0</span>, <span class="type">double</span> minValue = <span class="number">-2147483647</span>, <span class="type">double</span> maxValue = <span class="number">2147483647</span>, <span class="type">int</span> decimals = <span class="number">1</span>, <span class="type">bool</span> *ok = <span class="literal">nullptr</span>, Qt::WindowFlags flags = Qt::WindowFlags())</span></span>;</span><br></pre></td></tr></table></figure><ul><li>与其他输入对话框不同的是 他的decimals 那位并不是表示步长，而是表示浮点数的小数位数</li></ul><h4 id="文本输入对话框"><a href="#文本输入对话框" class="headerlink" title="文本输入对话框"></a>文本输入对话框</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QString <span class="title">QInputDialog::getText</span><span class="params">(QWidget *parent, <span class="type">const</span> QString &amp;title, <span class="type">const</span> QString &amp;label, QLineEdit::EchoMode echo = QLineEdit::Normal, <span class="type">const</span> QString &amp;text = QString(), <span class="type">bool</span> *ok = <span class="literal">nullptr</span>, Qt::WindowFlags flags = Qt::WindowFlags())</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>参数说明：</p><ol><li>parent：指定对话框的父窗口，即在哪个窗口中显示对话框。</li><li>title：指定对话框的标题。</li><li>label：指定对话框中显示的文本标签，用于提示用户输入。</li><li>echo：指定输入框的回显模式，默认为 QLineEdit::Normal，即显示输入的文本。</li><li>text：指定输入框的初始文本，默认为空字符串。</li><li>ok：一个 bool 类型的指针，用于指示用户是否点击了对话框中的确认按钮。如果用户点击了确认按钮，则 ok 为 true；如果用户点击了取消按钮，则 ok 为 false。这个参数是可选的。</li><li>flags：指定对话框的标志，例如 Qt::WindowStaysOnTopHint 表示对话框始终位于最顶层，Qt::WindowCloseButtonHint 表示显示关闭按钮等。</li></ol></li><li><p>echo的多种常见模式：</p><ol><li>QLineEdit::Normal：默认模式，显示用户输入的文本。这是最常用的回显模式</li><li>QLineEdit::NoEcho：不显示任何输入，通常用于隐藏输入内容，例如用于密码输入框。</li><li>QLineEdit::Password：显示密码字符（通常是圆点或星号）来隐藏用户输入的文本。这个模式常用于密码输入框，以保护用户的隐私安全。</li><li>QLineEdit::PasswordEchoOnEdit：当编辑文本时显示密码字符，否则显示原始文本。这种模式在用户输入密码时会显示圆点或星号，但在编辑密码时会显示实际的文本。</li></ol></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_pushButton_3_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> ok = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">auto</span> text = QInputDialog::<span class="built_in">getText</span>(<span class="keyword">this</span>, <span class="built_in">tr</span>(<span class="string">&quot;文字输入对话框&quot;</span>), <span class="built_in">tr</span>(<span class="string">&quot;请输入用户的姓名&quot;</span>), QLineEdit::Normal, <span class="built_in">tr</span>(<span class="string">&quot;admin&quot;</span>), &amp;ok);</span><br><span class="line">    <span class="keyword">if</span>(ok)&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; text &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息对话框"><a href="#消息对话框" class="headerlink" title="消息对话框"></a>消息对话框</h3><ul><li><p>消息提示对话框用于向用户显示简单的信息、警告或错误消息，通常是以模态（阻塞）的方式显示。Qt 提供了 QMessageBox 类来创建消息提示对话框，并支持不同的消息类型，包括信息、警告、错误、询问等</p></li><li><p>这里的 parent 参数指定了消息提示框的父窗口，即在哪个窗口中显示对话框。title 参数指定了对话框的标题，text 参数指定了对话框中显示的文本内容。</p></li><li><p>QMessageBox 还提供了更多的参数，以支持更丰富的功能。例如，你可以使用 </p></li><li>QMessageBox::Yes 和 QMessageBox::No 指定对话框中的按钮</li><li>或者使用 QMessageBox::Ok 指定只显示一个确定按钮。</li><li>你也可以使用 QMessageBox::setDetailedText() 方法设置更详细的文本信息。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_pushButton_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> ret = QMessageBox::<span class="built_in">question</span>(<span class="keyword">this</span>,<span class="built_in">tr</span>(<span class="string">&quot;提问对话框&quot;</span>),<span class="built_in">tr</span>(<span class="string">&quot;你是单身吗&quot;</span>),QMessageBox::Yes, QMessageBox::No);</span><br><span class="line">    <span class="keyword">if</span>(ret == QMessageBox::Yes || ret == QMessageBox::No)&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;ret is &quot;</span> &lt;&lt; ret &lt;&lt; Qt::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> ret2 = QMessageBox::<span class="built_in">information</span>(<span class="keyword">this</span>,<span class="built_in">tr</span>(<span class="string">&quot;通知对话框&quot;</span>),<span class="built_in">tr</span>(<span class="string">&quot;你好单身狗&quot;</span>),QMessageBox::Ok);</span><br><span class="line">    <span class="keyword">if</span>(ret2 == QMessageBox::Ok)&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;ret2 is &quot;</span> &lt;&lt; ret2 &lt;&lt; Qt::endl;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">auto</span> ret3 = QMessageBox::<span class="built_in">warning</span>(<span class="keyword">this</span>,<span class="built_in">tr</span>(<span class="string">&quot;警告对话框&quot;</span>),<span class="built_in">tr</span>(<span class="string">&quot;你最好找个地方发泄一下&quot;</span>),QMessageBox::Ok);</span><br><span class="line">    <span class="keyword">if</span>(ret3 == QMessageBox::Ok)&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;ret3 is &quot;</span> &lt;&lt; ret3 &lt;&lt; Qt::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> ret4 = QMessageBox::<span class="built_in">critical</span>(<span class="keyword">this</span>,<span class="built_in">tr</span>(<span class="string">&quot;关键提示对话框&quot;</span>), <span class="built_in">tr</span>(<span class="string">&quot;我梦寐以求是真爱和自由&quot;</span>),QMessageBox::Ok);</span><br><span class="line">    <span class="keyword">if</span>(ret4 == QMessageBox::Ok)&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;ret4 is &quot;</span> &lt;&lt; ret4 &lt;&lt; Qt::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="QT进度对话框"><a href="#QT进度对话框" class="headerlink" title="QT进度对话框"></a>QT进度对话框</h3><ul><li>用于显示任务的进度情况。进度对话框通常用于长时间运行的任务，以便向用户显示任务的完成进度，并让用户了解任务是否正在进行中。</li><li>你可以设置进度对话框的标题、文本、进度条的范围和当前值等属性，以及显示取消按钮以允许用户取消任务。</li><li>最基本的用法</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QProgressDialog&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">QProgressDialog <span class="title">progressDialog</span><span class="params">(<span class="string">&quot;任务进行中...&quot;</span>, <span class="string">&quot;取消&quot;</span>, <span class="number">0</span>, <span class="number">100</span>, parent)</span></span>;</span><br><span class="line">progressDialog.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;进度对话框&quot;</span>);</span><br><span class="line">progressDialog.<span class="built_in">setWindowModality</span>(Qt::WindowModal);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">    <span class="comment">// 执行任务的代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新进度对话框的进度值</span></span><br><span class="line">    progressDialog.<span class="built_in">setValue</span>(i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查用户是否点击了取消按钮</span></span><br><span class="line">    <span class="keyword">if</span> (progressDialog.<span class="built_in">wasCanceled</span>()) &#123;</span><br><span class="line">        <span class="comment">// 用户点击了取消按钮，执行相应的操作</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>我们可以通过定时器的方式定时更新进度，这样就可以更清楚的看到进度条对话框更新情况了</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_pushButton_2_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// QProgressDialog progressdialog(tr(&quot;正在复制&quot;), tr(&quot;取消复制&quot;), 0, 5000, this);</span></span><br><span class="line">    <span class="comment">// progressdialog.setWindowTitle(tr(&quot;文件复制进度对话框&quot;));</span></span><br><span class="line">    <span class="comment">// progressdialog.setWindowModality(Qt::ApplicationModal);</span></span><br><span class="line">    <span class="comment">// progressdialog.show();</span></span><br><span class="line">    <span class="comment">// for(int i = 0; i &lt; 5000; i ++)&#123;</span></span><br><span class="line">    <span class="comment">//     progressdialog.setValue(i);</span></span><br><span class="line">    <span class="comment">//     QApplication::processEvents();</span></span><br><span class="line">    <span class="comment">//     if(progressdialog.wasCanceled()) break;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// progressdialog.setValue(5000);</span></span><br><span class="line">    progressdialog = <span class="keyword">new</span> <span class="built_in">QProgressDialog</span>(<span class="built_in">tr</span>(<span class="string">&quot;正在复制&quot;</span>), <span class="built_in">tr</span>(<span class="string">&quot;取消复制&quot;</span>), <span class="number">0</span>, <span class="number">5000</span>, <span class="keyword">this</span>);</span><br><span class="line">    progressdialog-&gt;<span class="built_in">setWindowTitle</span>(<span class="built_in">tr</span>(<span class="string">&quot;文件复制进度对话框&quot;</span>));</span><br><span class="line">    progressdialog-&gt;<span class="built_in">setWindowModality</span>(Qt::ApplicationModal);</span><br><span class="line">    _timer = <span class="keyword">new</span> <span class="built_in">QTimer</span>(<span class="keyword">this</span>);</span><br><span class="line">    _count = <span class="number">0</span>; </span><br><span class="line">    <span class="built_in">connect</span>(_timer, &amp;QTimer::timeout, <span class="keyword">this</span>, &amp;MainWindow::on_updateProgressDialog);</span><br><span class="line">    <span class="built_in">connect</span>(progressdialog, &amp;QProgressDialog::canceled, <span class="keyword">this</span>, &amp;MainWindow::out_cancelProgressDialog);</span><br><span class="line">    _timer-&gt;<span class="built_in">start</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_updateProgressDialog</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _count ++;</span><br><span class="line">    <span class="keyword">if</span>(_count &gt; <span class="number">5000</span>)&#123;</span><br><span class="line">        <span class="keyword">delete</span> _timer;</span><br><span class="line">        _timer = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">delete</span> progressdialog;</span><br><span class="line">        progressdialog = <span class="literal">nullptr</span>;</span><br><span class="line">        _count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    progressdialog-&gt;<span class="built_in">setValue</span>(_count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::out_cancelProgressDialog</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> _timer;</span><br><span class="line">    _timer = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">delete</span> progressdialog;</span><br><span class="line">    progressdialog = <span class="literal">nullptr</span>;</span><br><span class="line">    _count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QProgressDialog&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTimer&gt;</span></span></span><br><span class="line">QT_BEGIN_NAMESPACE</span><br><span class="line"><span class="keyword">namespace</span> Ui &#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span>;</span><br><span class="line">&#125;</span><br><span class="line">QT_END_NAMESPACE</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">MainWindow</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">on_colorBtn_clicked</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">on_textBtn_clicked</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">on_intBtn_clicked</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">on_floatBtn_clicked</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">on_listBtn_clicked</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">on_pushButton_clicked</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">on_inputBtn_clicked</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">on_pushButton_2_clicked</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//以下才是进度对话框真正用到的</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">on_updateProgressDialog</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">out_cancelProgressDialog</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::MainWindow *ui;</span><br><span class="line">    QProgressDialog *progressdialog;</span><br><span class="line">    QTimer* _timer;</span><br><span class="line">    <span class="type">int</span> _count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="QT向导对话框"><a href="#QT向导对话框" class="headerlink" title="QT向导对话框"></a>QT向导对话框</h3><ul><li>所需头文件</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWizard&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QButtonGroup&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QRadioButton&gt;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_pushButton_10_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QWizard <span class="title">wizard</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    wizard.<span class="built_in">setWindowTitle</span>(<span class="built_in">tr</span>(<span class="string">&quot;全城热恋&quot;</span>));</span><br><span class="line">    QWizardPage* page1 = <span class="keyword">new</span> <span class="built_in">QWizardPage</span>();</span><br><span class="line">    page1-&gt;<span class="built_in">setTitle</span>(<span class="built_in">tr</span>(<span class="string">&quot;婚恋介绍引导程序&quot;</span>));</span><br><span class="line">    <span class="keyword">auto</span> label1 = <span class="keyword">new</span> <span class="built_in">QLabel</span>();</span><br><span class="line">    label1-&gt;<span class="built_in">setText</span>(<span class="built_in">tr</span>(<span class="string">&quot;该程序帮助您找到人生伴侣&quot;</span>));</span><br><span class="line">    QVBoxLayout *layout = <span class="keyword">new</span> <span class="built_in">QVBoxLayout</span>();</span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(label1);</span><br><span class="line">    page1-&gt;<span class="built_in">setLayout</span>(layout);</span><br><span class="line">    wizard.<span class="built_in">addPage</span>(page1);</span><br><span class="line">    QWizardPage* page2 = <span class="keyword">new</span> <span class="built_in">QWizardPage</span>();</span><br><span class="line">    page2-&gt;<span class="built_in">setTitle</span>(<span class="string">&quot;选择心动类型&quot;</span>);</span><br><span class="line"></span><br><span class="line">    QButtonGroup *group = <span class="keyword">new</span> <span class="built_in">QButtonGroup</span>(page2);</span><br><span class="line">    QRadioButton * btn1 = <span class="keyword">new</span> <span class="built_in">QRadioButton</span>();</span><br><span class="line">    btn1-&gt;<span class="built_in">setText</span>(<span class="string">&quot;白富美&quot;</span>);</span><br><span class="line">    group-&gt;<span class="built_in">addButton</span>(btn1);</span><br><span class="line">    QRadioButton * btn2 = <span class="keyword">new</span> <span class="built_in">QRadioButton</span>();</span><br><span class="line">    btn2-&gt;<span class="built_in">setText</span>(<span class="string">&quot;萝莉&quot;</span>);</span><br><span class="line">    group-&gt;<span class="built_in">addButton</span>(btn2);</span><br><span class="line">    QRadioButton * btn3 = <span class="keyword">new</span> <span class="built_in">QRadioButton</span>();</span><br><span class="line">    btn3-&gt;<span class="built_in">setText</span>(<span class="string">&quot;御姐&quot;</span>);</span><br><span class="line">    group-&gt;<span class="built_in">addButton</span>(btn3);</span><br><span class="line">    QRadioButton * btn4 = <span class="keyword">new</span> <span class="built_in">QRadioButton</span>();</span><br><span class="line">    btn4-&gt;<span class="built_in">setText</span>(<span class="string">&quot;小家碧玉&quot;</span>);</span><br><span class="line">    group-&gt;<span class="built_in">addButton</span>(btn4);</span><br><span class="line">    QRadioButton * btn5 = <span class="keyword">new</span> <span class="built_in">QRadioButton</span>();</span><br><span class="line">    btn5-&gt;<span class="built_in">setText</span>(<span class="string">&quot;女汉子&quot;</span>);</span><br><span class="line">    group-&gt;<span class="built_in">addButton</span>(btn5);</span><br><span class="line"></span><br><span class="line">    QRadioButton * btn6 = <span class="keyword">new</span> <span class="built_in">QRadioButton</span>();</span><br><span class="line">    btn6-&gt;<span class="built_in">setText</span>(<span class="string">&quot;成年人不做选择，全选!&quot;</span>);</span><br><span class="line">    group-&gt;<span class="built_in">addButton</span>(btn6);</span><br><span class="line">    QVBoxLayout *vboxLayout2 = <span class="keyword">new</span> <span class="built_in">QVBoxLayout</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; group-&gt;<span class="built_in">buttons</span>().<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        vboxLayout2-&gt;<span class="built_in">addWidget</span>(group-&gt;<span class="built_in">buttons</span>()[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    page2-&gt;<span class="built_in">setLayout</span>(vboxLayout2);</span><br><span class="line">    wizard.<span class="built_in">addPage</span>(page2);</span><br><span class="line"></span><br><span class="line">    QWizardPage* page3 = <span class="keyword">new</span> <span class="built_in">QWizardPage</span>();</span><br><span class="line">    page3-&gt;<span class="built_in">setTitle</span>(<span class="built_in">tr</span>(<span class="string">&quot;你的缘分即将到来&quot;</span>));</span><br><span class="line">    <span class="keyword">auto</span> label3 = <span class="keyword">new</span> <span class="built_in">QLabel</span>();</span><br><span class="line">    label3-&gt;<span class="built_in">setText</span>(<span class="built_in">tr</span>(<span class="string">&quot;感谢您的参与，接下来的一个月会遇到对的人&quot;</span>));</span><br><span class="line">    QVBoxLayout *layout3 = <span class="keyword">new</span> <span class="built_in">QVBoxLayout</span>();</span><br><span class="line">    layout3-&gt;<span class="built_in">addWidget</span>(label3);</span><br><span class="line">    page3-&gt;<span class="built_in">setLayout</span>(layout3);</span><br><span class="line">    wizard.<span class="built_in">addPage</span>(page3);</span><br><span class="line">    wizard.<span class="built_in">show</span>();</span><br><span class="line">    wizard.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>我们来讲讲以上代码中用到的类以及方法</li></ul><h4 id="QVBoxLayout"><a href="#QVBoxLayout" class="headerlink" title="QVBoxLayout"></a>QVBoxLayout</h4><ul><li><p>这是Qt 中的一个布局管理器，用于在垂直方向上排列子部件，它可以将子部件按照垂直方向依次排列，使它们在垂直方向上均匀分布。QVBoxLayout 通常与 QWidget 或其子类一起使用，用于管理窗口或部件中的子部件的布局。</p></li><li><p>使用时的基本案例</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建父部件</span></span><br><span class="line">QWidget *parentWidget = <span class="keyword">new</span> <span class="built_in">QWidget</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 QVBoxLayout 布局管理器</span></span><br><span class="line">QVBoxLayout *layout = <span class="keyword">new</span> <span class="built_in">QVBoxLayout</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建子部件</span></span><br><span class="line">QLabel *label1 = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;Label 1&quot;</span>);</span><br><span class="line">QPushButton *button1 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;Button 1&quot;</span>);</span><br><span class="line">QPushButton *button2 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;Button 2&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将子部件添加到 QVBoxLayout 中</span></span><br><span class="line">layout-&gt;<span class="built_in">addWidget</span>(label1);</span><br><span class="line">layout-&gt;<span class="built_in">addWidget</span>(button1);</span><br><span class="line">layout-&gt;<span class="built_in">addWidget</span>(button2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 QVBoxLayout 设置为父部件的布局管理器</span></span><br><span class="line">parentWidget-&gt;<span class="built_in">setLayout</span>(layout);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示父部件</span></span><br><span class="line">parentWidget-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="QButtonGroup"><a href="#QButtonGroup" class="headerlink" title="QButtonGroup"></a>QButtonGroup</h4><ul><li>这是 Qt 中的一个类，用于管理一组按钮。它可以将多个单选按钮或复选按钮组织在一起，形成一个逻辑上的单元，使它们能够相互排斥或者互斥。</li><li>使用 QButtonGroup 可以方便地管理一组按钮的状态和行为，特别是在需要对按钮进行组合选择或互斥选择时。例如，你可以将多个单选按钮添加到一个 QButtonGroup 中，使用户只能选择其中的一个按钮，而取消选择其他按钮；或者将多个复选按钮添加到一个 QButtonGroup 中，使它们在同一时间只能有一个或多个被选中。</li><li>以下未使用案例</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QButtonGroup&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QRadioButton&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 QButtonGroup 对象</span></span><br><span class="line">QButtonGroup *buttonGroup = <span class="keyword">new</span> <span class="built_in">QButtonGroup</span>(parent);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建单选按钮并添加到按钮组中</span></span><br><span class="line">QRadioButton *radioButton1 = <span class="keyword">new</span> <span class="built_in">QRadioButton</span>(<span class="string">&quot;Option 1&quot;</span>);</span><br><span class="line">QRadioButton *radioButton2 = <span class="keyword">new</span> <span class="built_in">QRadioButton</span>(<span class="string">&quot;Option 2&quot;</span>);</span><br><span class="line">QRadioButton *radioButton3 = <span class="keyword">new</span> <span class="built_in">QRadioButton</span>(<span class="string">&quot;Option 3&quot;</span>);</span><br><span class="line"></span><br><span class="line">buttonGroup-&gt;<span class="built_in">addButton</span>(radioButton1);</span><br><span class="line">buttonGroup-&gt;<span class="built_in">addButton</span>(radioButton2);</span><br><span class="line">buttonGroup-&gt;<span class="built_in">addButton</span>(radioButton3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置按钮组中的默认选中按钮</span></span><br><span class="line">radioButton1-&gt;<span class="built_in">setChecked</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听按钮组中按钮的选择状态变化</span></span><br><span class="line"><span class="built_in">connect</span>(buttonGroup, <span class="built_in">SIGNAL</span>(<span class="built_in">buttonClicked</span>(QAbstractButton*)), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">onButtonClicked</span>(QAbstractButton*)));</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="QRadioButton-与-QCheckButton"><a href="#QRadioButton-与-QCheckButton" class="headerlink" title="QRadioButton 与 QCheckButton"></a>QRadioButton 与 QCheckButton</h4><h5 id="QRadioButton单选框"><a href="#QRadioButton单选框" class="headerlink" title="QRadioButton单选框"></a>QRadioButton单选框</h5><ul><li>这是 Qt 中的一个类，用于创建单选按钮。单选按钮通常用于让用户在一组互斥的选项中选择一个选项。</li><li>与普通的按钮类似，QRadioButton 也是 QAbstractButton 的子类，因此它继承了按钮的所有功能和特性。单选按钮的特点是它们可以成组出现，并且在同一组中只能选择一个按钮，当选择一个按钮时，其他按钮会自动取消选择。</li></ul><h5 id="QCheckButton复选框"><a href="#QCheckButton复选框" class="headerlink" title="QCheckButton复选框"></a>QCheckButton复选框</h5><ul><li>是 Qt 中的一个类，用于创建复选框。与单选按钮类似，复选框也是一种用户界面控件，但是它允许用户同时选择多个选项。</li></ul><h4 id="总结1"><a href="#总结1" class="headerlink" title="总结1"></a>总结1</h4><ul><li>new出来的需要手动释放，除非他被加载到了父对象上，只要他被加载到了一个界面上，就不需要手动释放了，只需要手动释放那个界面就行</li></ul><h2 id="QT-QLineEdit介绍"><a href="#QT-QLineEdit介绍" class="headerlink" title="QT QLineEdit介绍"></a>QT QLineEdit介绍</h2><ul><li><p>QLineEdit属于输入插件，用来实现单行录入。支持几种录入模式。</p></li><li><p>Normal表示正常录入,录入的信息会显示在QLineEdit上。</p></li><li><p>Password表示密码录入的方式，录入的信息不显示QLineEdit，只是通过黑色圆点显示。</p></li><li><p>NoEcho 表示不显示录入信息，类似于Linux输入密码时，显示的是一片空白。</p></li><li><p>PasswordEchoOnEdit 表示在输入的一刹那可以看到字符，但是立刻变为不可见的黑色圆点显示。</p></li></ul><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><ul><li>做一个如下页面</li></ul><p><img src="../assets/Qt/image-5.png" alt="示例图片" style="zoom:100%;" /></p><ul><li>QLineEdit 支持正则表达式，支持mask（定义一种输入规则）</li></ul><p><img src="../assets/Qt/image-6.png" alt="示例图片" style="zoom:100%;" /></p><p><img src="../assets/Qt/image-7.png" alt="示例图片" style="zoom:100%;" /></p><ul><li>正则表达式</li></ul><p><img src="../assets/Qt/image-8.png" alt="示例图片" style="zoom:100%;" /></p><ul><li>源码</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QRegularExpressionValidator&gt;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    QString ip_mask = <span class="string">&quot;000.000.000.000;-&quot;</span>;</span><br><span class="line">    ui-&gt;IPlineEdit-&gt;<span class="built_in">setInputMask</span>(ip_mask);</span><br><span class="line">    QString mac_mask = <span class="string">&quot;HH:HH:HH:HH:HH:HH;-&quot;</span>;</span><br><span class="line">    ui-&gt;MAClineEdit-&gt;<span class="built_in">setInputMask</span>(mac_mask);</span><br><span class="line">    ui-&gt;pwdlineEdit-&gt;<span class="built_in">setEchoMode</span>(QLineEdit::Password);</span><br><span class="line">    <span class="function">QRegularExpression <span class="title">reg</span><span class="params">(<span class="string">&quot;[a-zA-Z0-9-_]+@[A-Za-z0-9]+\.[a-zA-Z0-9]+&quot;</span>)</span></span>;</span><br><span class="line">    QValidator * validator = <span class="keyword">new</span> <span class="built_in">QRegularExpressionValidator</span>(reg, ui-&gt;emaillineEdit);</span><br><span class="line">    ui-&gt;emaillineEdit-&gt;<span class="built_in">setValidator</span>(validator);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Qt布局与页面切换"><a href="#Qt布局与页面切换" class="headerlink" title="Qt布局与页面切换"></a>Qt布局与页面切换</h2><ul><li><p>Qt 中的布局有三种方式，水平布局，垂直布局，栅格布局。</p></li><li><p>具体见如下链接</p></li></ul><p><a href="https://llfc.club/category?catid=2DX72J8YkeAknl5uTeM7ysTkgHS#!aid/2FqCn3phpuy0qm5aHMHa3wBFGXY">https://llfc.club/category?catid=2DX72J8YkeAknl5uTeM7ysTkgHS#!aid/2FqCn3phpuy0qm5aHMHa3wBFGXY</a></p><h2 id="QT主窗口"><a href="#QT主窗口" class="headerlink" title="QT主窗口"></a>QT主窗口</h2><ul><li>任何界面应用都有一个主窗口，今天我们谈谈主窗口相关知识。一个主窗口包括菜单栏，工具栏，状态栏，以及中心区域等部分。我们先从菜单栏说起</li></ul><h3 id="菜单栏"><a href="#菜单栏" class="headerlink" title="菜单栏"></a>菜单栏</h3><ul><li><p>主菜单通常包括以下几个部分：</p><ol><li>菜单项（Menu）： 顶级菜单栏上的每个项目称为一个菜单项，点击菜单项会弹出子菜单或执行相应的操作。</li><li>子菜单（Submenu）： 菜单项可以包含子菜单，子菜单是下拉菜单，包含了一组相关的菜单命令或选项。</li><li>动作（Action）： 菜单项或子菜单中的每个命令或选项称为一个动作，通常与具体的操作或功能相关联。</li></ol></li><li>在Qt中，可以通过QMenu和QAction类来创建菜单和动作。主菜单通常是由多个QMenu对象组成的，而每个QMenu对象又包含多个QAction对象。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMenu&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMenuBar&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>)</span><br><span class="line">        : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建菜单</span></span><br><span class="line">        QMenu *fileMenu = <span class="built_in">menuBar</span>()-&gt;<span class="built_in">addMenu</span>(<span class="built_in">tr</span>(<span class="string">&quot;文件&quot;</span>));</span><br><span class="line">        QMenu *editMenu = <span class="built_in">menuBar</span>()-&gt;<span class="built_in">addMenu</span>(<span class="built_in">tr</span>(<span class="string">&quot;编辑&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建动作</span></span><br><span class="line">        QAction *newAction = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="built_in">tr</span>(<span class="string">&quot;新建&quot;</span>), <span class="keyword">this</span>);</span><br><span class="line">        QAction *openAction = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="built_in">tr</span>(<span class="string">&quot;打开&quot;</span>), <span class="keyword">this</span>);</span><br><span class="line">        QAction *saveAction = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="built_in">tr</span>(<span class="string">&quot;保存&quot;</span>), <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        QAction *cutAction = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="built_in">tr</span>(<span class="string">&quot;剪切&quot;</span>), <span class="keyword">this</span>);</span><br><span class="line">        QAction *copyAction = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="built_in">tr</span>(<span class="string">&quot;复制&quot;</span>), <span class="keyword">this</span>);</span><br><span class="line">        QAction *pasteAction = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="built_in">tr</span>(<span class="string">&quot;粘贴&quot;</span>), <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将动作添加到菜单中</span></span><br><span class="line">        fileMenu-&gt;<span class="built_in">addAction</span>(newAction);</span><br><span class="line">        fileMenu-&gt;<span class="built_in">addAction</span>(openAction);</span><br><span class="line">        fileMenu-&gt;<span class="built_in">addAction</span>(saveAction);</span><br><span class="line"></span><br><span class="line">        editMenu-&gt;<span class="built_in">addAction</span>(cutAction);</span><br><span class="line">        editMenu-&gt;<span class="built_in">addAction</span>(copyAction);</span><br><span class="line">        editMenu-&gt;<span class="built_in">addAction</span>(pasteAction);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="通过Ui来实现"><a href="#通过Ui来实现" class="headerlink" title="通过Ui来实现"></a>通过Ui来实现</h4><ul><li>我们创建一个主窗口应用程序, 在ui文件里的菜单栏里有“在这里输入”的一个菜单，我们双击它输入“文件(&amp;F)”, 这样通过点击alt + F 就可以弹出文件菜单。点击文件菜单，同样会弹出“在这里输入”，我们双击它编辑输入“新建文件(&amp;N)”，可以在右侧的属性栏里为其添加一个图标，同样，我们再添加一个“显示Dock(&amp;D)”的菜单。我们再从左侧的控件Containers里拖动Dock Widget到中心区域，在dock widget中添加一个按钮，一个fontComboBox，一个QTextEdit。DockWidget添加的控件并不会影响主窗口的centralwidget, 我们在centralwidget中添加一个QMdiArea控件。</li></ul><p><img src="../assets/Qt/image-10.png" alt="示例图片" style="zoom:100%;" /></p><p><img src="../assets/Qt/image-9.png" alt="示例图片" style="zoom:100%;" /></p><ul><li>我们可以选择Action Editor中的两个action，分别为其添加槽函数，右击actionnew_N选择转到槽，然后选择trigger信号，Qt会自动生成槽函数代码</li></ul><p><img src="../assets/Qt/image-11.png" alt="示例图片" style="zoom:100%;" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTextEdit&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMdiSubWindow&gt;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_actionNew_triggered</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;新建文件...&quot;</span>;</span><br><span class="line">    QTextEdit *textedit = <span class="keyword">new</span> <span class="built_in">QTextEdit</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">auto</span> childWindow = ui-&gt;mdiArea-&gt;<span class="built_in">addSubWindow</span>(textedit);</span><br><span class="line">    childWindow-&gt;<span class="built_in">setWindowTitle</span>(<span class="built_in">tr</span>(<span class="string">&quot;文本编剧框&quot;</span>));</span><br><span class="line">    childWindow-&gt;<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_actionshowduck_S_triggered</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;显示dock Widget&quot;</span>;</span><br><span class="line">    ui-&gt;dockWidget_2-&gt;<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>因为QMdiArea是一个多窗口控件，这样我们每次点击新建菜单就会在窗口的中心部件中创建一个子窗口，多次点击会生成多个子窗口。点击显示dock菜单就会显示dockwidget。</li></ul><h4 id="通过代码实现"><a href="#通过代码实现" class="headerlink" title="通过代码实现"></a>通过代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTextEdit&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMdiSubWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMenu&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QActionGroup&gt;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    QMenu * editMenu = ui-&gt;menubar-&gt;<span class="built_in">addMenu</span>(<span class="built_in">tr</span>(<span class="string">&quot;编辑(&amp;E)&quot;</span>));</span><br><span class="line">    editMenu-&gt;<span class="built_in">addSeparator</span>();</span><br><span class="line">    QAction * action_Open = editMenu-&gt;<span class="built_in">addAction</span>(<span class="built_in">QIcon</span>(<span class="string">&quot;:/img/head.jpg&quot;</span>), <span class="built_in">tr</span>(<span class="string">&quot;打开文件(&amp;O)&quot;</span>));</span><br><span class="line">    action_Open-&gt;<span class="built_in">setShortcut</span>(<span class="built_in">QKeySequence</span>(<span class="string">&quot;Ctrl+O&quot;</span>));</span><br><span class="line">    <span class="comment">//建立动作组</span></span><br><span class="line">    QActionGroup * group = <span class="keyword">new</span> <span class="built_in">QActionGroup</span>(<span class="keyword">this</span>);</span><br><span class="line">    QAction * action_L = group-&gt;<span class="built_in">addAction</span>(<span class="built_in">tr</span>(<span class="string">&quot;左对(&amp;L)&quot;</span>));</span><br><span class="line">    action_L-&gt;<span class="built_in">setCheckable</span>(<span class="literal">true</span>);</span><br><span class="line">    QAction * action_R = group-&gt;<span class="built_in">addAction</span>(<span class="built_in">tr</span>(<span class="string">&quot;右对(&amp;R)&quot;</span>));</span><br><span class="line">    action_R-&gt;<span class="built_in">setCheckable</span>(<span class="literal">true</span>);</span><br><span class="line">    QAction * action_C = group-&gt;<span class="built_in">addAction</span>(<span class="built_in">tr</span>(<span class="string">&quot;居中(&amp;C)&quot;</span>));</span><br><span class="line">    action_C-&gt;<span class="built_in">setCheckable</span>(<span class="literal">true</span>);</span><br><span class="line">    editMenu-&gt;<span class="built_in">addSeparator</span>();</span><br><span class="line">    editMenu-&gt;<span class="built_in">addAction</span>(action_L);</span><br><span class="line">    editMenu-&gt;<span class="built_in">addAction</span>(action_R);</span><br><span class="line">    editMenu-&gt;<span class="built_in">addAction</span>(action_C);</span><br><span class="line">    <span class="built_in">connect</span>(action_Open,&amp;QAction::triggered, <span class="keyword">this</span>, &amp;MainWindow::on_action_open_triggered);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_actionNew_triggered</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;新建文件...&quot;</span>;</span><br><span class="line">    QTextEdit *textedit = <span class="keyword">new</span> <span class="built_in">QTextEdit</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">auto</span> childWindow = ui-&gt;mdiArea-&gt;<span class="built_in">addSubWindow</span>(textedit);</span><br><span class="line">    childWindow-&gt;<span class="built_in">setWindowTitle</span>(<span class="built_in">tr</span>(<span class="string">&quot;文本编剧框&quot;</span>));</span><br><span class="line">    childWindow-&gt;<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_action_open_triggered</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;打开文件...&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_actionshowduck_S_triggered</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;显示dock Widget&quot;</span>;</span><br><span class="line">    ui-&gt;dockWidget_2-&gt;<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>除了可以为菜单栏添加动作外，还可以添加动作组</p></li><li><p>我们也可以自定义动作类，我们接下来自定义一个动作类，动作类包含一个label和lineEdit。自定义的动作类叫MyAction，声明如下</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MYACTION_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYACTION_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidgetAction&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLineEdit&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyAction</span> : <span class="keyword">public</span> QWidgetAction</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getText</span><span class="params">(<span class="type">const</span> QString&amp; string)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">explicit</span> <span class="title">MyAction</span><span class="params">(QObject * parent = <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">MyAction</span>();</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> QWidget *<span class="title">createWidget</span><span class="params">(QWidget *parent)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sentText</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//声明行编辑器对象</span></span><br><span class="line">    QLineEdit* lineEdit;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MYACTION_H</span></span></span><br></pre></td></tr></table></figure><ul><li>createWidget 为一个虚函数，继承自QWidgetAction， 将Action加入菜单或者工具栏就会调用createWidget函数。接下来我们实现这个类</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myaction.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSplitter&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MyAction::<span class="built_in">MyAction</span>(QObject * parent):<span class="built_in">QWidgetAction</span>(parent)&#123;</span><br><span class="line">    <span class="comment">// 创建行编辑器</span></span><br><span class="line">    lineEdit = <span class="keyword">new</span> QLineEdit;</span><br><span class="line">    <span class="comment">// 将行编辑器的按下回车键信号和发送文本槽关联</span></span><br><span class="line">    <span class="built_in">connect</span>(lineEdit, &amp;QLineEdit::returnPressed, <span class="keyword">this</span>, &amp;MyAction::sentText);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">QWidget* <span class="title">MyAction::createWidget</span><span class="params">(QWidget * parent)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(parent-&gt;<span class="built_in">inherits</span>(<span class="string">&quot;QMenu&quot;</span>)|| parent-&gt;<span class="built_in">inherits</span>(<span class="string">&quot;QToolBar&quot;</span>))&#123;</span><br><span class="line">        QSplitter * spliter = <span class="keyword">new</span> <span class="built_in">QSplitter</span>(parent);</span><br><span class="line">        QLabel * label = <span class="keyword">new</span> QLabel;</span><br><span class="line">        label-&gt;<span class="built_in">setText</span>(<span class="built_in">tr</span>(<span class="string">&quot;插入文本:&quot;</span>));</span><br><span class="line">        spliter-&gt;<span class="built_in">addWidget</span>(label);</span><br><span class="line">        spliter-&gt;<span class="built_in">addWidget</span>(lineEdit);</span><br><span class="line">        <span class="keyword">return</span> spliter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyAction::sentText</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">emit <span class="title">getText</span><span class="params">(lineEdit-&gt;text())</span></span>;</span><br><span class="line">    lineEdit-&gt;<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>构造函数里创建了一个LineEdit，然后绑定了LineEdit的返回信号，在sentText槽函数里发送了getText信号，然后清除了lineEdit里的内容。createWidget里判断了父节点如果是QMenu或者QToolBar，就创建一个spliter，然后将label和lineedit都加入spliter。在mainwindow的构造函数中创建MyAction，并且加入菜单里。然后将MyAction的getText的信号和MainWindow的setText函数绑定在一起。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MyAction * action = <span class="keyword">new</span> <span class="built_in">MyAction</span>(<span class="keyword">this</span>);</span><br><span class="line">editMenu-&gt;<span class="built_in">addAction</span>(action);</span><br><span class="line"><span class="built_in">connect</span>(action, &amp;MyAction::getText, <span class="keyword">this</span>, &amp;MainWindow::setText);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::setText</span><span class="params">(<span class="type">const</span> QString &amp;string)</span></span>&#123;</span><br><span class="line">    ui-&gt;textEdit-&gt;<span class="built_in">setText</span>(string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="工具栏"><a href="#工具栏" class="headerlink" title="工具栏"></a>工具栏</h3><ul><li>工具栏相比菜单栏更容易操作，更加直观，添加方式和菜单的方式类似，可以添加label，按钮，以及spinbox等。<br>可以通过ui添加，也可以通过代码添加，下面用代码添加工具栏菜单。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//工具栏添加元素</span></span><br><span class="line">QToolButton * toolBtn = <span class="keyword">new</span> <span class="built_in">QToolButton</span>(<span class="keyword">this</span>);</span><br><span class="line">toolBtn-&gt;<span class="built_in">setText</span>(<span class="built_in">tr</span>(<span class="string">&quot;颜色&quot;</span>));</span><br><span class="line">QMenu* colorMenu = <span class="keyword">new</span> <span class="built_in">QMenu</span>(<span class="keyword">this</span>);</span><br><span class="line">colorMenu-&gt;<span class="built_in">addAction</span>(<span class="built_in">tr</span>(<span class="string">&quot;红色&quot;</span>));</span><br><span class="line">colorMenu-&gt;<span class="built_in">addAction</span>(<span class="built_in">tr</span>(<span class="string">&quot;绿色&quot;</span>));</span><br><span class="line">toolBtn-&gt;<span class="built_in">setMenu</span>(colorMenu);</span><br><span class="line">toolBtn-&gt;<span class="built_in">setPopupMode</span>(QToolButton::MenuButtonPopup);</span><br><span class="line">ui-&gt;toolBar-&gt;<span class="built_in">addWidget</span>(toolBtn);</span><br><span class="line">QSpinBox* spinBox = <span class="keyword">new</span> <span class="built_in">QSpinBox</span>(<span class="keyword">this</span>);</span><br><span class="line">ui-&gt;toolBar-&gt;<span class="built_in">addSeparator</span>();</span><br><span class="line">ui-&gt;toolBar-&gt;<span class="built_in">addWidget</span>(spinBox);</span><br></pre></td></tr></table></figure><h3 id="状态栏"><a href="#状态栏" class="headerlink" title="状态栏"></a>状态栏</h3><ul><li>状态栏在窗口的下方，一般在右下方，左下方的为临时的，右下方的为永久的</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::init_status_bar</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//显示临时消息</span></span><br><span class="line">    ui-&gt;statusbar-&gt;<span class="built_in">showMessage</span>(<span class="built_in">tr</span>(<span class="string">&quot;欢迎使用多文档编辑器&quot;</span>),<span class="number">2000</span>);</span><br><span class="line">    <span class="comment">//创建标签</span></span><br><span class="line">    QLabel* permanent = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="keyword">this</span>);</span><br><span class="line">    permanent-&gt;<span class="built_in">setFrameStyle</span>(QFrame::Box | QFrame::Sunken);</span><br><span class="line">    permanent-&gt;<span class="built_in">setText</span>(<span class="string">&quot;llfc.club&quot;</span>);</span><br><span class="line">    ui-&gt;statusbar-&gt;<span class="built_in">addPermanentWidget</span>(permanent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="QTextEdit-文本编辑器"><a href="#QTextEdit-文本编辑器" class="headerlink" title="QTextEdit 文本编辑器"></a>QTextEdit 文本编辑器</h2><ul><li>它是一个富文本编辑器而QPlainTextEdit是纯文本编辑器</li></ul><h3 id="文本块"><a href="#文本块" class="headerlink" title="文本块"></a>文本块</h3><ul><li>我们在MainWindow的ui文件中添加了textedit插件，然后在MainWindow的构造函数中写代码，修改文本框样式</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTextDocument&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTextFrame&gt;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    QTextDocument *doc = ui-&gt;textEdit-&gt;<span class="built_in">document</span>();</span><br><span class="line">    <span class="comment">// 得到所有框架的根框架</span></span><br><span class="line">    QTextFrame *root_frame = doc-&gt;<span class="built_in">rootFrame</span>();</span><br><span class="line">    <span class="comment">// 文本框的格式</span></span><br><span class="line">    QTextFrameFormat format;</span><br><span class="line">    <span class="comment">//设置边框颜色</span></span><br><span class="line">    format.<span class="built_in">setBorderBrush</span>(Qt::blue);</span><br><span class="line">    <span class="comment">//设置边框宽度</span></span><br><span class="line">    format.<span class="built_in">setBorder</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">//将样式加入道根框架</span></span><br><span class="line">    root_frame-&gt;<span class="built_in">setFrameFormat</span>(format);</span><br><span class="line">    ui-&gt;textEdit-&gt;<span class="built_in">insertPlainText</span>(<span class="string">&quot;hello world!\n&quot;</span>);</span><br><span class="line">    ui-&gt;textEdit-&gt;<span class="built_in">insertPlainText</span>(<span class="string">&quot;Hello Qt\n&quot;</span>);</span><br><span class="line">    QTextFrameFormat frameFormat;</span><br><span class="line">    frameFormat.<span class="built_in">setBackground</span>(Qt::lightGray);</span><br><span class="line">    <span class="comment">//设置外边框</span></span><br><span class="line">    frameFormat.<span class="built_in">setMargin</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//设置内边框</span></span><br><span class="line">    frameFormat.<span class="built_in">setPadding</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">//设置边框宽度</span></span><br><span class="line">    frameFormat.<span class="built_in">setBorder</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//设置边框样式为虚线</span></span><br><span class="line">    frameFormat.<span class="built_in">setBorderStyle</span>(QTextFrameFormat::BorderStyle_Dashed);</span><br><span class="line">    <span class="comment">//获取textedit的光标</span></span><br><span class="line">    QTextCursor cursor = ui-&gt;textEdit-&gt;<span class="built_in">textCursor</span>();</span><br><span class="line">    <span class="comment">//将上述定义好的文本框架格式用到光标所在位置，光标位置就是输入位置</span></span><br><span class="line">    cursor.<span class="built_in">insertFrame</span>(frameFormat);</span><br><span class="line">    ui-&gt;textEdit-&gt;<span class="built_in">insertPlainText</span>(<span class="string">&quot;inner text!\n&quot;</span>);</span><br><span class="line">    ui-&gt;textEdit-&gt;<span class="built_in">insertPlainText</span>(<span class="string">&quot;Hello inner Text!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>运行效果</li></ul><p><img src="../assets/Qt/image-12.png" alt="示例图片" style="zoom:100%;" /></p><h3 id="遍历文本块"><a href="#遍历文本块" class="headerlink" title="遍历文本块"></a>遍历文本块</h3><ul><li>默认情况下，Qt 将文本按照换行符进行分割，每个文本块对应一行文字。但是，你也可以通过设置 QTextDocument 的文本格式来自定义文本块的边界，例如设置段落间距、文本对齐方式等，从而影响文本块的形成。</li><li>我们可以遍历文本块和框架节点。先在构造函数中添加一个菜单，用来打印Frame和TextBlock</li></ul><h4 id="只遍历根框架"><a href="#只遍历根框架" class="headerlink" title="只遍历根框架"></a>只遍历根框架</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历根框架</span></span><br><span class="line">    QAction* action_frame = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="string">&quot;Frame&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">connect</span>(action_frame, &amp;QAction::triggered, <span class="keyword">this</span>, &amp;MainWindow::showTextFrame);</span><br><span class="line">    ui-&gt;mainToolBar-&gt;<span class="built_in">addAction</span>(action_frame);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::showTextFrame</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//得到文本文档</span></span><br><span class="line">    <span class="keyword">auto</span> doc = ui-&gt;textEdit-&gt;<span class="built_in">document</span>();</span><br><span class="line">    <span class="comment">//从文档中得到根框架</span></span><br><span class="line">    <span class="keyword">auto</span> rootFrame = doc-&gt;<span class="built_in">rootFrame</span>();</span><br><span class="line">    <span class="comment">//遍历根框架，根框架里面可能还有其他子框架所以要考虑其实不是样式(frame)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> iter = rootFrame-&gt;<span class="built_in">begin</span>(); iter != rootFrame-&gt;<span class="built_in">end</span>(); iter++)&#123;</span><br><span class="line">        <span class="keyword">auto</span> cur_frame = iter.<span class="built_in">currentFrame</span>();</span><br><span class="line">        <span class="keyword">auto</span> cur_block = iter.<span class="built_in">currentBlock</span>();</span><br><span class="line">        <span class="comment">//是样式</span></span><br><span class="line">        <span class="keyword">if</span>(cur_frame)&#123;</span><br><span class="line">            <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;cur node is frame &quot;</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不是样式</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cur_block.<span class="built_in">isValid</span>())&#123;</span><br><span class="line">            <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;cur node is text block ,text is &quot;</span> &lt;&lt; cur_block.<span class="built_in">text</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="直接遍历文本块"><a href="#直接遍历文本块" class="headerlink" title="直接遍历文本块"></a>直接遍历文本块</h4><ul><li>遍历文本块不受子框架影响，即使文本块在子框架中也能遍历到</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历根框架及其子框架里的文本</span></span><br><span class="line">    QAction* action_textBlock = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="built_in">tr</span>(<span class="string">&quot;文本块&quot;</span>),<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">connect</span>(action_textBlock, &amp;QAction::triggered, <span class="keyword">this</span>, &amp;MainWindow::showTextBlock);</span><br><span class="line">    ui-&gt;mainToolBar-&gt;<span class="built_in">addAction</span>(action_textBlock);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::showTextBlock</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QTextDocument* document = ui-&gt;textEdit-&gt;<span class="built_in">document</span>();</span><br><span class="line">    <span class="comment">//得到第一个文本块</span></span><br><span class="line">    QTextBlock block = document-&gt;<span class="built_in">firstBlock</span>();</span><br><span class="line">    <span class="comment">//遍历所有文本块</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; document-&gt;<span class="built_in">blockCount</span>(); i++)&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="built_in">tr</span>(<span class="string">&quot;文本块%1, 文本块首行行号%2, 长度%3, 内容%4&quot;</span>).<span class="built_in">arg</span>(i).<span class="built_in">arg</span>(block.<span class="built_in">firstLineNumber</span>()).<span class="built_in">arg</span>(block.<span class="built_in">length</span>())</span><br><span class="line">                 &lt;&lt; block.<span class="built_in">text</span>();</span><br><span class="line">        block = block.<span class="built_in">next</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="设置文本块样式"><a href="#设置文本块样式" class="headerlink" title="设置文本块样式"></a>设置文本块样式</h3><ul><li>之前我们设置的都是文本框架的样式，这次我们设置文本块的样式.</li><li>在构造函数中添加字体菜单，用来设置文本块的字体样式</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置本文块样式</span></span><br><span class="line">    QAction* action_font = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="built_in">tr</span>(<span class="string">&quot;字体&quot;</span>), <span class="keyword">this</span>);</span><br><span class="line">    action_font-&gt;<span class="built_in">setCheckable</span>(<span class="literal">true</span>);</span><br><span class="line">    <span class="built_in">connect</span>(action_font, &amp;QAction::toggled, <span class="keyword">this</span>, &amp;MainWindow::setTextFont);</span><br><span class="line">    ui-&gt;mainToolBar-&gt;<span class="built_in">addAction</span>(action_font);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::setTextFont</span><span class="params">(<span class="type">bool</span> checked)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//选中状态</span></span><br><span class="line">    <span class="keyword">if</span>(checked)&#123;</span><br><span class="line">        <span class="comment">//得到光标</span></span><br><span class="line">        QTextCursor cursor = ui-&gt;textEdit-&gt;<span class="built_in">textCursor</span>();</span><br><span class="line">        <span class="comment">//文本格式样式</span></span><br><span class="line">        QTextBlockFormat blockFormat;</span><br><span class="line">        <span class="comment">//设置为居中对齐</span></span><br><span class="line">        blockFormat.<span class="built_in">setAlignment</span>(Qt::AlignCenter);</span><br><span class="line">        <span class="comment">//插入样式</span></span><br><span class="line">        cursor.<span class="built_in">insertBlock</span>(blockFormat);</span><br><span class="line">        <span class="comment">//字符样式</span></span><br><span class="line">        QTextCharFormat charFormat;</span><br><span class="line">        charFormat.<span class="built_in">setBackground</span>(Qt::lightGray);</span><br><span class="line">        charFormat.<span class="built_in">setForeground</span>(Qt::blue);</span><br><span class="line">        charFormat.<span class="built_in">setFont</span>(<span class="built_in">QFont</span>(<span class="built_in">tr</span>(<span class="string">&quot;宋体&quot;</span>),<span class="number">12</span>,QFont::Bold,<span class="literal">true</span>));</span><br><span class="line">        charFormat.<span class="built_in">setFontUnderline</span>(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//设置字符样式</span></span><br><span class="line">        cursor.<span class="built_in">setCharFormat</span>(charFormat);</span><br><span class="line">        <span class="comment">//插入字体</span></span><br><span class="line">        cursor.<span class="built_in">insertText</span>(<span class="built_in">tr</span>(<span class="string">&quot;插入字体&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//非选中状态</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        QTextCursor cursor = ui-&gt;textEdit-&gt;<span class="built_in">textCursor</span>();</span><br><span class="line">        QTextBlockFormat blockFormat;</span><br><span class="line">        <span class="comment">//左对齐</span></span><br><span class="line">        blockFormat.<span class="built_in">setAlignment</span>(Qt::AlignLeft);</span><br><span class="line">        cursor.<span class="built_in">insertBlock</span>(blockFormat);</span><br><span class="line">        QTextCharFormat charFormat;</span><br><span class="line">        <span class="comment">//        charFormat.setBackground(Qt::white);</span></span><br><span class="line">        <span class="comment">//        charFormat.setForeground(Qt::black);</span></span><br><span class="line">        <span class="comment">//        charFormat.setFont(QFont(tr(&quot;微软雅黑&quot;),12,QFont::Normal, false));</span></span><br><span class="line">        <span class="comment">//        charFormat.setFontUnderline(false);</span></span><br><span class="line">        cursor.<span class="built_in">setCharFormat</span>(charFormat);</span><br><span class="line">        cursor.<span class="built_in">insertText</span>(<span class="built_in">tr</span>(<span class="string">&quot;微软雅黑字体&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>其中QTextBlockFormat 是 Qt 中用于描述文本块格式的类。文本块是 QTextDocument 中的基本单元，它通常对应于文本中的一行或一段。QTextBlockFormat 可以用于控制文本块的各种属性，例如对齐方式、缩进、间距、行高等。</li><li>以下为常用的方法与属性<ol><li>setAlignment(Qt::Alignment align)：设置文本块的对齐方式。</li><li>setIndent(int indentation)：设置文本块的缩进。</li><li>setLeadingMargin(int margin)：设置文本块的行首缩进。</li><li>setTrailingMargin(int margin)：设置文本块的行尾缩进。</li><li>setTopMargin(int margin)：设置文本块的顶部间距。</li><li>setBottomMargin(int margin)：设置文本块的底部间距。</li><li>setLineHeight(int height, QTextBlockFormat::LineHeightTypes heightType)：设置文本块的行高，可以指定行高的类型，如固定高度、行间距的倍数等。</li></ol></li></ul><h3 id="插入表格列表图片"><a href="#插入表格列表图片" class="headerlink" title="插入表格列表图片"></a>插入表格列表图片</h3><ul><li>QTextEdit也支持插入表格，列表，图片等资源。在MainWindow的构造函数里增加列表，图片，表格的信号和槽函数连接逻辑</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">QAction* action_textTable = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="built_in">tr</span>(<span class="string">&quot;表格&quot;</span>), <span class="keyword">this</span>);</span><br><span class="line">    QAction* action_textList = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="built_in">tr</span>(<span class="string">&quot;列表&quot;</span>), <span class="keyword">this</span>);</span><br><span class="line">    QAction* action_textImage = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="built_in">tr</span>(<span class="string">&quot;图片&quot;</span>), <span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">connect</span>(action_textTable, &amp;QAction::triggered,<span class="keyword">this</span>, &amp;MainWindow::insertTable);</span><br><span class="line">    ui-&gt;mainToolBar-&gt;<span class="built_in">addAction</span>(action_textTable);</span><br><span class="line">    <span class="built_in">connect</span>(action_textList, &amp;QAction::triggered,<span class="keyword">this</span>, &amp;MainWindow::insertList);</span><br><span class="line">    ui-&gt;mainToolBar-&gt;<span class="built_in">addAction</span>(action_textList);</span><br><span class="line">    <span class="built_in">connect</span>(action_textImage, &amp;QAction::triggered,<span class="keyword">this</span>, &amp;MainWindow::insertImage);</span><br><span class="line">    ui-&gt;mainToolBar-&gt;<span class="built_in">addAction</span>(action_textImage);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::insertTable</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QTextCursor cursor = ui-&gt;textEdit-&gt;<span class="built_in">textCursor</span>();</span><br><span class="line">    QTextTableFormat format;</span><br><span class="line">    <span class="comment">//设置间距宽度</span></span><br><span class="line">    format.<span class="built_in">setCellSpacing</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//设置外边框宽度</span></span><br><span class="line">    format.<span class="built_in">setCellPadding</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//插入表格 宽度 高度 和样式</span></span><br><span class="line">    cursor.<span class="built_in">insertTable</span>(<span class="number">2</span>,<span class="number">2</span>,format);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::insertList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QTextListFormat format;</span><br><span class="line">    <span class="comment">//有序列表</span></span><br><span class="line">    format.<span class="built_in">setStyle</span>(QTextListFormat::ListDecimal);</span><br><span class="line">    ui-&gt;textEdit-&gt;<span class="built_in">textCursor</span>().<span class="built_in">insertList</span>(format);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::insertImage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QTextImageFormat format;</span><br><span class="line">    <span class="comment">//得将图片资源加入同级目录</span></span><br><span class="line">    format.<span class="built_in">setName</span>(<span class="string">&quot;:/img/head.jpg&quot;</span>);</span><br><span class="line">    ui-&gt;textEdit-&gt;<span class="built_in">textCursor</span>().<span class="built_in">insertImage</span>(format);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="实现查找功能"><a href="#实现查找功能" class="headerlink" title="实现查找功能"></a>实现查找功能</h3><ul><li>在构造函数里写</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">QAction* action_textFind = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="built_in">tr</span>(<span class="string">&quot;查找&quot;</span>), <span class="keyword">this</span>);</span><br><span class="line">        <span class="built_in">connect</span>(action_textFind, &amp;QAction::triggered, <span class="keyword">this</span>, &amp;MainWindow::textfind);</span><br><span class="line">        ui-&gt;mainToolBar-&gt;<span class="built_in">addAction</span>(action_textFind);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//类的一个成员</span></span><br><span class="line">        findDialog = <span class="keyword">new</span> <span class="built_in">QDialog</span>(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//类的另一个成员</span></span><br><span class="line">        lineEdit = <span class="keyword">new</span> <span class="built_in">QLineEdit</span>(findDialog);</span><br><span class="line">        <span class="comment">//加入一个按钮</span></span><br><span class="line">        QPushButton * btn = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(findDialog);</span><br><span class="line">        </span><br><span class="line">        btn-&gt;<span class="built_in">setText</span>(<span class="built_in">tr</span>(<span class="string">&quot;查找下一个&quot;</span>));</span><br><span class="line">        <span class="built_in">connect</span>(btn, &amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;MainWindow::findnext);</span><br><span class="line">        QVBoxLayout* layout = <span class="keyword">new</span> <span class="built_in">QVBoxLayout</span>();</span><br><span class="line">        layout-&gt;<span class="built_in">addWidget</span>(lineEdit);</span><br><span class="line">        layout-&gt;<span class="built_in">addWidget</span>(btn);</span><br><span class="line">        findDialog-&gt;<span class="built_in">setLayout</span>(layout);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::textfind</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    findDialog-&gt;<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::findnext</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QString string = lineEdit-&gt;<span class="built_in">text</span>();</span><br><span class="line">    <span class="type">bool</span> isFind = ui-&gt;textEdit-&gt;<span class="built_in">find</span>(string, QTextDocument::FindBackward);</span><br><span class="line">    <span class="keyword">if</span>(isFind)&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="built_in">tr</span>(<span class="string">&quot;行号%1, 列号%2,&quot;</span>).<span class="built_in">arg</span>(ui-&gt;textEdit-&gt;<span class="built_in">textCursor</span>().<span class="built_in">blockNumber</span>()).<span class="built_in">arg</span>(ui-&gt;textEdit-&gt;<span class="built_in">textCursor</span>().<span class="built_in">columnNumber</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">本文介绍了C++Qt的相关知识</summary>
    
    
    
    <category term="C++" scheme="https://pigcanstudy.github.io/categories/C/"/>
    
    
    <category term="C++" scheme="https://pigcanstudy.github.io/tags/C/"/>
    
    <category term="Qt" scheme="https://pigcanstudy.github.io/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>C++并发编程</title>
    <link href="https://pigcanstudy.github.io/posts/e8e79e61.html"/>
    <id>https://pigcanstudy.github.io/posts/e8e79e61.html</id>
    <published>2024-07-18T02:49:00.000Z</published>
    <updated>2024-07-18T02:50:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li><a href="#目录">目录</a><ul><li><a href="#线程基础知识">线程基础知识</a><ul><li><a href="#线程的发起">线程的发起</a></li><li><a href="#线程等待">线程等待</a></li><li><a href="#线程可以调用的参数">线程可以调用的参数</a><ul><li><a href="#调用函数对象">调用函数对象</a></li><li><a href="#使用lambda表达式当作其参数">使用lambda表达式当作其参数</a></li><li><a href="#使用成员函数指针来当作参数">使用成员函数指针来当作参数</a></li><li><a href="#注意当其调用函数有参数的时候需要在后面加入对应的参数">注意当其调用函数有参数的时候需要在后面加入对应的参数</a></li></ul></li><li><a href="#线程detach">线程detach</a><ul><li><a href="#解决办法">解决办法</a></li></ul></li><li><a href="#异常处理">异常处理</a></li><li><a href="#慎用隐式转换">慎用隐式转换</a></li><li><a href="#引用参数">引用参数</a><ul><li><a href="#什么是stdref">什么是std::ref？</a><ul><li><a href="#stdref-和不同引用的区别">std::ref 和不同引用的区别</a></li><li><a href="#总结">总结</a></li></ul></li></ul></li><li><a href="#使用move操作">使用move操作</a></li><li><a href="#线程底层做的处理">线程底层做的处理</a></li></ul></li><li><a href="#c线程管控">C++线程管控</a><ul><li><a href="#线程归属权">线程归属权</a></li><li><a href="#joining_thread">joining_thread</a></li><li><a href="#容器存储">容器存储</a></li><li><a href="#选择运行数量">选择运行数量</a></li><li><a href="#识别线程">识别线程</a></li></ul></li><li><a href="#互斥和死锁">互斥和死锁</a><ul><li><a href="#锁的使用">锁的使用</a></li><li><a href="#lock_guard的使用">lock_guard的使用</a></li><li><a href="#如何保证数据安全">如何保证数据安全</a><ul><li><a href="#解决的办法">解决的办法</a></li></ul></li><li><a href="#死锁是怎么造成的">死锁是怎么造成的</a><ul><li><a href="#死锁解决办法">死锁解决办法</a></li></ul></li><li><a href="#同时加锁">同时加锁</a></li><li><a href="#thread_local">thread_local</a></li><li><a href="#层级加锁">层级加锁</a></li></ul></li><li><a href="#cunique_lock共享锁和递归锁">C++unique_lock，共享锁和递归锁</a><ul><li><a href="#unique_lock">unique_lock</a><ul><li><a href="#unique_lock的owns_lock判断是否持有锁">unique_lock的owns_lock判断是否持有锁</a></li><li><a href="#unique_lock的延迟加锁defer_lock">unique_lock的延迟加锁defer_lock</a></li><li><a href="#unique_lock的领养加锁">unique_lock的领养加锁</a></li><li><a href="#锁的粒度">锁的粒度</a></li></ul></li><li><a href="#共享锁shared_lock以及shared_mutex">共享锁shared_lock以及shared_mutex</a></li><li><a href="#递归锁">递归锁</a></li></ul></li><li><a href="#c线程安全单例模式的演变">C++线程安全单例模式的演变</a><ul><li><a href="#局部静态变量">局部静态变量</a></li><li><a href="#饿汉与懒汉式详情看面试笔记">饿汉与懒汉式，详情看面试笔记</a></li><li><a href="#智能指针">智能指针</a><ul><li><a href="#改进方案">改进方案</a></li></ul></li><li><a href="#call_once">call_once</a></li><li><a href="#总结1">总结1</a></li></ul></li><li><a href="#c11多线程同步">C++11多线程同步</a><ul><li><a href="#使用future与promise">使用future与promise</a></li><li><a href="#使用条件变量来实现同步">使用条件变量来实现同步</a></li></ul></li><li><a href="#利用条件变量实现线程安全队列">利用条件变量实现线程安全队列</a><ul><li><a href="#不良实现">不良实现</a></li><li><a href="#条件变量">条件变量</a></li><li><a href="#实现安全队列">实现安全队列</a></li></ul></li><li><a href="#并发三剑客asyncpromisefuture">并发三剑客async,promise,future</a><ul><li><a href="#async用法">async用法</a><ul><li><a href="#async的启动策略">async的启动策略</a></li></ul></li><li><a href="#future的wait和get">future的wait和get</a></li><li><a href="#将任务和future关联paskaged_task">将任务和future关联（paskaged_task）</a></li><li><a href="#promise的用法">promise的用法</a></li><li><a href="#共享类型的future">共享类型的future</a></li><li><a href="#异常处理1">异常处理1</a></li><li><a href="#线程池">线程池</a></li></ul></li><li><a href="#两种并发设计模式">两种并发设计模式</a><ul><li><a href="#actor设计模式">Actor设计模式</a></li><li><a href="#csp模式">CSP模式</a></li></ul></li><li><a href="#thread-源码解读及一些常见问题">thread 源码解读及一些常见问题</a><ul><li><a href="#默认移动构造">默认移动构造</a></li><li><a href="#线程归属权问题">线程归属权问题</a></li><li><a href="#future-析构的细节">future 析构的细节</a></li></ul></li><li><a href="#原子操作和内存模型">原子操作和内存模型</a><ul><li><a href="#改动序列">改动序列</a></li><li><a href="#原子类型">原子类型</a></li><li><a href="#内存次序">内存次序</a></li><li><a href="#实现自旋锁">实现自旋锁</a></li><li><a href="#宽松内存序">宽松内存序</a></li><li><a href="#先行">先行</a><ul><li><a href="#顺序先行">顺序先行</a></li><li><a href="#线程间先行">线程间先行</a></li></ul></li><li><a href="#依赖关系">依赖关系</a></li><li><a href="#happens-before不代表指令执行顺序">Happens-before不代表指令执行顺序</a></li><li><a href="#脑图">脑图</a></li></ul></li><li><a href="#用内存顺序实现内存模型">用内存顺序实现内存模型</a><ul><li><a href="#memory_order_seq_cst">memory_order_seq_cst</a></li><li><a href="#memory_order_relaxed">memory_order_relaxed</a></li><li><a href="#acquire-release">Acquire-Release</a></li><li><a href="#release-sequences">Release sequences</a></li><li><a href="#memory_order_consume">memory_order_consume</a></li><li><a href="#单例模型改良">单例模型改良</a></li></ul></li><li><a href="#用内存顺序和原子变量实现无锁队列">用内存顺序和原子变量实现无锁队列</a><ul><li><a href="#环形队列">环形队列</a></li><li><a href="#用锁实现环形队列">用锁实现环形队列</a></li><li><a href="#无锁队列">无锁队列</a><ul><li><a href="#单一原子变量的弊端">单一原子变量的弊端</a></li><li><a href="#优化性能">优化性能</a></li></ul></li><li><a href="#思考">思考</a></li></ul></li><li><a href="#利用栅栏实现同步模型">利用栅栏实现同步模型</a><ul><li><a href="#线程可见顺序">线程可见顺序</a></li></ul></li><li><a href="#栅栏">栅栏</a></li><li><a href="#基于锁是新鲜线程安全队列与栈">基于锁是新鲜线程安全队列与栈</a><ul><li><a href="#线程安全的栈">线程安全的栈</a></li><li><a href="#线程安全队列">线程安全队列</a></li></ul></li><li><a href="#实现线程安全的查找表">实现线程安全的查找表</a><ul><li><a href="#散列表">散列表</a></li><li><a href="#设计思路">设计思路</a></li><li><a href="#代码实现">代码实现</a></li></ul></li><li><a href="#实现线程安全链表">实现线程安全链表</a></li><li><a href="#线程间切分任务的方法">线程间切分任务的方法</a><ul><li><a href="#按数量切分">按数量切分</a></li></ul></li><li><a href="#线程池原理和实现">线程池原理和实现</a></li></ul></li></ul><h2 id="线程基础知识"><a href="#线程基础知识" class="headerlink" title="线程基础知识"></a>线程基础知识</h2><h3 id="线程的发起"><a href="#线程的发起" class="headerlink" title="线程的发起"></a>线程的发起</h3><ul><li>线程发起顾名思义就是启动一个线程，C++11标准统一了线程操作，可以在定义一个线程变量后，该变量启动线程执行回调逻辑。如下即可发起一个线程</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thead_work1</span><span class="params">(std::string str)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str is &quot;</span> &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1 通过()初始化并启动一个线程</span></span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(thead_work1, hellostr)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="线程等待"><a href="#线程等待" class="headerlink" title="线程等待"></a>线程等待</h3><ul><li>当我们启动一个线程后，线程可能没有立即执行，如果在局部作用域启动了一个线程，或者main函数中，很可能子线程没运行就被回收了，回收时会调用线程的析构函数，执行terminate操作。所以为了防止主线程退出或者局部作用域结束导致子线程被析构的情况，我们可以通过join，其作用是让主线程等待子线程启动运行，子线程运行结束后主线程再运行。(也就是让当前进程等待调用join的线程运行结束后在运行)</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个简单的线程函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello from thread!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个新的线程</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(threadFunction)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在主线程中做一些其他的事情</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程结束</span></span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="线程可以调用的参数"><a href="#线程可以调用的参数" class="headerlink" title="线程可以调用的参数"></a>线程可以调用的参数</h3><h4 id="调用函数对象"><a href="#调用函数对象" class="headerlink" title="调用函数对象"></a>调用函数对象</h4><ul><li>调用函数对象的时候可能会遇到一种情况，如果按如下方式去调用就会报错</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">func</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;hello thread&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(func())</span></span>;</span><br><span class="line">t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>原因</strong>：因为std::thread t1(func());这句话会被翻译成函数声明，即编译器会将t2当成一个函数对象, 返回一个std::thread类型的值, 函数的参数为一个函数指针,该函数指针返回值为background_task, 参数为void。可以理解为如下</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;std::thread (*)(background_task (*)())&quot;</span></span><br></pre></td></tr></table></figure><ul><li><p><strong><em>解决办法</em></strong>:</p><ol><li><p>使用{}来替代()</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::thread t1&#123;<span class="built_in">func</span>()&#125;;</span><br><span class="line">t<span class="number">1.</span><span class="built_in">join</span>();</span><br></pre></td></tr></table></figure></li><li><p>多加一层()来</p></li></ol></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">((func()))</span></span>;</span><br><span class="line">t<span class="number">1.</span><span class="built_in">join</span>();</span><br></pre></td></tr></table></figure><h4 id="使用lambda表达式当作其参数"><a href="#使用lambda表达式当作其参数" class="headerlink" title="使用lambda表达式当作其参数"></a>使用lambda表达式当作其参数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">t3</span><span class="params">([]()&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">// lambda 表达式的函数体</span></span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="使用成员函数指针来当作参数"><a href="#使用成员函数指针来当作参数" class="headerlink" title="使用成员函数指针来当作参数"></a>使用成员函数指针来当作参数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">memberFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 成员函数体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyClass obj;</span><br><span class="line"><span class="function">std::thread <span class="title">t2</span><span class="params">(&amp;MyClass::memberFunction, &amp;obj)</span></span>; <span class="comment">// memberFunction 是一个成员函数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="注意当其调用函数有参数的时候需要在后面加入对应的参数"><a href="#注意当其调用函数有参数的时候需要在后面加入对应的参数" class="headerlink" title="注意当其调用函数有参数的时候需要在后面加入对应的参数"></a>注意当其调用函数有参数的时候需要在后面加入对应的参数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程函数，接受两个参数，并返回它们的和</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sum of &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; is: &quot;</span> &lt;&lt; (a + b) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>, y = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个新线程，并传递参数</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(sum, x, y)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程结束</span></span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="线程detach"><a href="#线程detach" class="headerlink" title="线程detach"></a>线程detach</h3><ul><li>detach() 函数的作用是将线程托管到后台来运行，实现主线程与线程分离，这被称为守护线程，分离线程后，父子线程就不会共享同一个内存，但是却可以通过指针和引用共同访问一个堆区资源，但是需要人为增加同步机制。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">func</span> &#123;</span><br><span class="line">    <span class="type">int</span>&amp; _i;</span><br><span class="line">    <span class="built_in">func</span>(<span class="type">int</span> &amp; i): _i(i)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            _i = i;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;_i is &quot;</span> &lt;&lt; _i &lt;&lt; std::endl;</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">oops</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> some_local_state = <span class="number">0</span>;</span><br><span class="line">        <span class="function">func <span class="title">myfunc</span><span class="params">(some_local_state)</span></span>;</span><br><span class="line">        <span class="function">std::thread <span class="title">functhread</span><span class="params">(myfunc)</span></span>;</span><br><span class="line">        <span class="comment">//隐患，访问局部变量，局部变量可能会随着&#125;结束而回收或随着主线程退出而回收</span></span><br><span class="line">        functhread.<span class="built_in">detach</span>();    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// detach 注意事项</span></span><br><span class="line"><span class="built_in">oops</span>();</span><br><span class="line"><span class="comment">//防止主线程退出过快，需要停顿一下，让子线程跑起来detach</span></span><br><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>上面的例子存在隐患，因为some_local_state是局部变量, 当oops调用结束后局部变量some_local_state就可能被释放了，而线程还在detach后台运行，容易出现崩溃。</li></ul><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><ul><li>使用智能指针shared_ptr,使用引用计数来保证局部变量不被释放，是伪闭包策略</li><li>可以将引用传递改为按值传递，这样会需要拷贝构造，增加空间消耗，减少效率</li><li>可以让主线程等待子线程完毕后再执行，但这样往往会影响程序的逻辑(因为这样就不是后台运行了)</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_join</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> some_local_state = <span class="number">0</span>;</span><br><span class="line">    <span class="function">func <span class="title">myfunc</span><span class="params">(some_local_state)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">functhread</span><span class="params">(myfunc)</span></span>;</span><br><span class="line">    functhread.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// join 用法</span></span><br><span class="line"><span class="built_in">use_join</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><ul><li>当我们启动一个线程后，如果主线程产生崩溃，会导致子线程也会异常退出，就是调用terminate，如果子线程在进行一些重要的操作比如将充值信息入库等，丢失这些信息是很危险的。所以常用的做法是捕获异常，并且在异常情况下保证子线程稳定运行结束后，主线程抛出异常结束运行。如下面的逻辑：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">catch_exception</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> some_local_state = <span class="number">0</span>;</span><br><span class="line">    <span class="function">func <span class="title">myfunc</span><span class="params">(some_local_state)</span></span>;</span><br><span class="line">    std::thread  functhread&#123; myfunc &#125;;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//本线程做一些事情,可能引发崩溃</span></span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;<span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">        functhread.<span class="built_in">join</span>();</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    functhread.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>但是这种写法不完美，你需要自行添加 还得自行判断哪个必须要执行完才行，所以有什么方法可以自动判定而不需要人为选择呢？ 那就是采用<strong>RAII</strong>思想</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">func</span> &#123;</span><br><span class="line">    <span class="type">int</span>&amp; _i;</span><br><span class="line">    <span class="built_in">func</span>(<span class="type">int</span> &amp; i): _i(i)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            _i = i;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;_i is &quot;</span> &lt;&lt; _i &lt;&lt; std::endl;</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">thread_guard</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::thread&amp; <span class="type">_t</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">thread_guard</span><span class="params">(std::thread&amp; t)</span>:_t(t)&#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">thread_guard</span>() &#123;</span><br><span class="line">        <span class="comment">//join只能调用一次</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="type">_t</span>.<span class="built_in">joinable</span>()) &#123;</span><br><span class="line">            <span class="type">_t</span>.<span class="built_in">join</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">thread_guard</span>(thread_guard <span class="type">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    thread_guard&amp; <span class="keyword">operator</span>=(thread_guard <span class="type">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">auto_guard</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> some_local_state = <span class="number">0</span>;</span><br><span class="line">    <span class="function">func <span class="title">my_func</span><span class="params">(some_local_state)</span></span>;</span><br><span class="line">    <span class="function">std::thread  <span class="title">t</span><span class="params">(my_func)</span></span>;</span><br><span class="line">    <span class="function">thread_guard <span class="title">g</span><span class="params">(t)</span></span>;</span><br><span class="line">    <span class="comment">//本线程做一些事情</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;auto guard finished &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">auto_guard</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="慎用隐式转换"><a href="#慎用隐式转换" class="headerlink" title="慎用隐式转换"></a>慎用隐式转换</h3><ul><li>C++中会有一些隐式转换，比如char* 转换为string等。这些隐式转换在线程的调用上可能会造成崩溃问题</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_str</span><span class="params">(<span class="type">int</span> &amp; i, <span class="type">const</span> std::string &amp; buf)</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;i is&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;buf is&quot;</span> &lt;&lt; buf &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">danger_oops</span><span class="params">(<span class="type">int</span> som_param)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(buffer, <span class="string">&quot;%i&quot;</span>, som_param);</span><br><span class="line">    <span class="comment">//在线程内部将char const* 转化为std::string</span></span><br><span class="line">    <span class="comment">//指针常量  char * const  指针本身不能变</span></span><br><span class="line">    <span class="comment">//常量指针  const char * 指向的内容不能变</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(print_str, <span class="number">3</span>, buffer)</span></span>;<span class="comment">// 这里buffer 类型为char * 被隐式转换为 string</span></span><br><span class="line">    t.<span class="built_in">detach</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;danger oops finished &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>当我们定义一个线程变量thread t时，传递给这个线程的参数buffer会被保存到thread的成员变量中。而在线程对象t内部启动并运行线程时，参数才会被传递给调用函数print_str。而此时buffer可能随着’}’运行结束而释放了。</li><li>改进的方式很简单，我们将参数传递给thread时显示转换为string就可以了，这样thread内部保存的是string类型。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">safe_oops</span><span class="params">(<span class="type">int</span> some_param)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(buffer, <span class="string">&quot;%i&quot;</span>, some_param);</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(print_str, <span class="number">3</span>, std::string(buffer))</span></span>;</span><br><span class="line">    t.<span class="built_in">detach</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引用参数"><a href="#引用参数" class="headerlink" title="引用参数"></a>引用参数</h3><ul><li>当线程要调用的回调函数参数为引用类型时，需要将参数显示转化为引用对象传递给线程的构造函数，如果采用如下调用会编译失败</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">change_param</span><span class="params">(<span class="type">int</span>&amp; param)</span> </span>&#123;</span><br><span class="line">    param++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ref_oops</span><span class="params">(<span class="type">int</span> some_param)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;before change , param is &quot;</span> &lt;&lt; some_param &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">//需使用引用显示转换</span></span><br><span class="line">    <span class="function">std::thread  <span class="title">t2</span><span class="params">(change_param, some_param)</span></span>;</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;after change , param is &quot;</span> &lt;&lt; some_param &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>即使函数change_param的参数为int&amp;类型，我们传递给t2的构造函数为some_param,也不会达到在change_param函数内部修改关联到外部some_param的效果。因为some_param在传递给thread的构造函数后（底层会转换为右值）会转变为右值保存，右值传递给一个左值引用会出问题，所以编译出了问题。</li><li>改为如下调用就可以了:</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ref_oops</span><span class="params">(<span class="type">int</span> some_param)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;before change , param is &quot;</span> &lt;&lt; some_param &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">//需使用引用显示转换</span></span><br><span class="line">    <span class="function">std::thread  <span class="title">t2</span><span class="params">(change_param, std::ref(some_param))</span></span>;</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;after change , param is &quot;</span> &lt;&lt; some_param &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="什么是std-ref？"><a href="#什么是std-ref？" class="headerlink" title="什么是std::ref？"></a>什么是std::ref？</h4><ul><li><p>std::ref的作用是将一个值包装为reference_Wrapper，这个对象在bind 和 thread时会被识别为引用，这样就解决了bind与thread 无法传递引用的问题（因为原本会被拷贝为右值）</p></li><li><p>大致可以这么理解：在底层 ref函数会把 一个值的地址和类型封装成reference_wrapper，当我们调用的时候触发了仿函数()，取得了该地址下的值，使其表现为左值引用</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> _CONSTEXPR20 <span class="keyword">operator</span> _Ty&amp;() <span class="type">const</span> <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> *_Ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">_NODISCARD _CONSTEXPR20 _Ty&amp; <span class="title">get</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *_Ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="std-ref-和不同引用的区别"><a href="#std-ref-和不同引用的区别" class="headerlink" title="std::ref 和不同引用的区别"></a>std::ref 和不同引用的区别</h5><ul><li>std::ref只是尝试模拟引用传递，并不能真正变成引用，在非模板情况下，std::ref根本没法实现引用传递，只有模板自动推导类型或类型隐式转换时，std::ref能用包装类型reference_wrapper来代替原本会被识别的值类型，而reference_wrapper能隐式转换为被引用的值的引用类型。</li></ul><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul><li>我来给总结下，首先我们讲解了std::ref的一些用法，然后我们讲解std::ref是通过std::reference_wrapper实现，然后我们借助了cppreference上的实现来给大家剖析了他本质就是存放了对象的地址(类似指针的用法😁)，还讲解了noexcept等语法，最后我们讲解了下std::bind为什么要使用到reference_wrapper。</li><li>std::bind使用的是参数的拷贝而不是引用，当可调用对象期待入参为引用时，必须显示利用std::ref来进行引用绑定。</li><li>多线程std::thread的可调用对象期望入参为引用时，也必须显式通过std::ref来绑定引用进行传参。</li></ul><h3 id="使用move操作"><a href="#使用move操作" class="headerlink" title="使用move操作"></a>使用move操作</h3><ul><li>有时候传递给线程的参数是独占的，所谓独占就是不支持拷贝赋值和构造，但是我们可以通过std::move的方式将参数的所有权转移给线程，如下</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">deal_unique</span><span class="params">(std::unique_ptr&lt;<span class="type">int</span>&gt; p)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;unique ptr data is &quot;</span> &lt;&lt; *p &lt;&lt; std::endl;</span><br><span class="line">    (*p)++;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;after unique ptr data is &quot;</span> &lt;&lt; *p &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">move_oops</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> p = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">100</span>);</span><br><span class="line">    <span class="function">std::thread  <span class="title">t</span><span class="params">(deal_unique, std::move(p))</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="comment">//不能再使用p了，p已经被move废弃</span></span><br><span class="line">   <span class="comment">// std::cout &lt;&lt; &quot;after unique ptr data is &quot; &lt;&lt; *p &lt;&lt; std::endl;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程底层做的处理"><a href="#线程底层做的处理" class="headerlink" title="线程底层做的处理"></a>线程底层做的处理</h3><ul><li>传递给线程的参数首先会去掉引用，并保存副本在tuple里，无论传递的是左值还是右值，最后都会被转换成右值引用给invoke调用你</li></ul><h2 id="C-线程管控"><a href="#C-线程管控" class="headerlink" title="C++线程管控"></a>C++线程管控</h2><h3 id="线程归属权"><a href="#线程归属权" class="headerlink" title="线程归属权"></a>线程归属权</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">some_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(some_function)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>t1是一个线程变量，管理一个线程，该线程执行<strong>some_function()</strong>,对于std::thread C++ 不允许其执行拷贝构造和拷贝赋值, 所以只能通过移动和局部变量返回的方式将线程变量管理的线程转移给其他变量管理。</li><li>C++ 中类似的类型还有<strong>std::mutex, std::ifstream, std::unique_ptr</strong>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">some_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">some_other_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//t1 绑定some_function</span></span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(some_function)</span></span>; </span><br><span class="line"><span class="comment">//2 转移t1管理的线程给t2，转移后t1无效,因为t1move后是右值，调用的是移动构造函数</span></span><br><span class="line">std::thread t2 =  std::<span class="built_in">move</span>(t1);</span><br><span class="line"><span class="comment">//3 t1 可继续绑定其他线程,执行some_other_function</span></span><br><span class="line">t1 = std::<span class="built_in">thread</span>(some_other_function);</span><br><span class="line"><span class="comment">//4  创建一个线程变量t3</span></span><br><span class="line">std::thread t3;</span><br><span class="line"><span class="comment">//5  转移t2管理的线程给t3</span></span><br><span class="line">t3 = std::<span class="built_in">move</span>(t2);</span><br><span class="line"><span class="comment">//6  转移t3管理的线程给t1</span></span><br><span class="line">t1 = std::<span class="built_in">move</span>(t3);</span><br><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2000</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>上面的代码会引发崩溃，是因为步骤6造成的崩溃。</li><li>让主函数睡眠2000秒，是为了告诉规避主函数退出引发崩溃的问题，因为我们在之前给大家演示过，如果线程不detach或者join，主线程退出时会引发崩溃，而我们这些线程没有join和detach，为了给大家演示是因为步骤6引发的崩溃，所以让主线程睡眠2000秒暂时不退出，但是程序仍然会崩溃，说明是步骤6导致的崩溃。</li><li>上面代码将t2管理的线程交给t3，之后将t3管理的线程交给t1，此时t1管理线程运行着 some_function，步骤6导致崩溃的原因就是将t3管理的线程交给t1，而此时t1正在管理线程运行some_other_function。</li><li><p>所以我们可以得出一个结论，就是<strong>不要将一个线程的管理权交给一个已经绑定线程的变量</strong>，否则会触发线程的terminate函数引发崩溃。</p></li><li><p>和std::unique_ptr一样，我们可以在函数内部返回一个局部的std::thread变量。如下:</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 采用了RVO机制，编译器优化了返回值，执行了移动构造函数</span></span><br><span class="line"><span class="function">std::thread  <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">thread</span>(some_function);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">param_function</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::thread <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这是NRVO机制，具名的返回值优化</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(param_function, <span class="number">43</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>因为C++ 在返回局部变量时，会优先寻找这个类的拷贝构造函数，如果没有就会使用这个类的移动构造函数。（RVO与NRVO机制）</li></ul><h3 id="joining-thread"><a href="#joining-thread" class="headerlink" title="joining_thread"></a>joining_thread</h3><ul><li>曾经有一份C++17标准的备选提案，主张引入新的类joining_thread，它与std::thread类似，但只要其执行析构函数，线程即能自动汇合，这点与scoped_thread非常像。可惜C++标准委员会未能达成共识，结果C++17标准没有引入这个类，后来它改名为<strong>std::jthread</strong>，依然进入了C++20标准的议程（现已被正式纳入C++20标准）。除去这些，实际上joining_thread类的代码相对容易编写</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">joining_thread</span> &#123;</span><br><span class="line">    std::thread  <span class="type">_t</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">joining_thread</span>() <span class="keyword">noexcept</span> = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Callable, <span class="keyword">typename</span> ...  Args&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">explicit</span>  <span class="title">joining_thread</span><span class="params">(Callable&amp;&amp; func, Args&amp;&amp; ...args)</span>:</span></span><br><span class="line"><span class="function">        _t(std::forward&lt;Callable&gt;(func),  std::forward&lt;Args&gt;(args)...)&#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">joining_thread</span><span class="params">(std::thread  t)</span> <span class="keyword">noexcept</span>: _t(std::move(t))&#123;</span>&#125;</span><br><span class="line">    <span class="built_in">joining_thread</span>(joining_thread&amp;&amp; other) <span class="keyword">noexcept</span>: <span class="type">_t</span>(std::<span class="built_in">move</span>(other.<span class="type">_t</span>))&#123;&#125;</span><br><span class="line">    joining_thread&amp; <span class="keyword">operator</span>=(joining_thread&amp;&amp; other) <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果当前线程可汇合，则汇合等待线程完成再赋值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">joinable</span>()) &#123;</span><br><span class="line">            <span class="built_in">join</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">_t</span> = std::<span class="built_in">move</span>(other.<span class="type">_t</span>);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    joining_thread&amp; <span class="keyword">operator</span>=(joining_thread other) <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果当前线程可汇合，则汇合等待线程完成再赋值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">joinable</span>()) &#123;</span><br><span class="line">            <span class="built_in">join</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">_t</span> = std::<span class="built_in">move</span>(other.<span class="type">_t</span>);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">joining_thread</span>() <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">joinable</span>()) &#123;</span><br><span class="line">            <span class="built_in">join</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(joining_thread&amp; other)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="type">_t</span>.<span class="built_in">swap</span>(other.<span class="type">_t</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="function">thread::id   <span class="title">get_id</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">_t</span>.<span class="built_in">get_id</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">joinable</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">_t</span>.<span class="built_in">joinable</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">_t</span>.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">detach</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">_t</span>.<span class="built_in">detach</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::thread&amp; <span class="title">as_thread</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">_t</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> std::thread&amp; <span class="title">as_thread</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">_t</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>用起来就比较简单了</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_jointhread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1 根据线程构造函数构造joiningthread</span></span><br><span class="line">    <span class="function">joining_thread <span class="title">j1</span><span class="params">([](<span class="type">int</span> maxindex) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxindex; i++) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::cout &lt;&lt; <span class="string">&quot;in thread id &quot;</span> &lt;&lt; std::this_thread::get_id()</span></span></span><br><span class="line"><span class="params"><span class="function">                &lt;&lt; <span class="string">&quot; cur index is &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::this_thread::sleep_for(std::chrono::seconds(<span class="number">1</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="comment">//2 根据thread构造joiningthread</span></span><br><span class="line">    <span class="function">joining_thread <span class="title">j2</span><span class="params">(std::thread([](<span class="type">int</span> maxindex) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxindex; i++) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::cout &lt;&lt; <span class="string">&quot;in thread id &quot;</span> &lt;&lt; std::this_thread::get_id()</span></span></span><br><span class="line"><span class="params"><span class="function">                &lt;&lt; <span class="string">&quot; cur index is &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::this_thread::sleep_for(std::chrono::seconds(<span class="number">1</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;, <span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="comment">//3 根据thread构造j3</span></span><br><span class="line">    <span class="function">joining_thread <span class="title">j3</span><span class="params">(std::thread([](<span class="type">int</span> maxindex) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxindex; i++) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::cout &lt;&lt; <span class="string">&quot;in thread id &quot;</span> &lt;&lt; std::this_thread::get_id()</span></span></span><br><span class="line"><span class="params"><span class="function">                &lt;&lt; <span class="string">&quot; cur index is &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::this_thread::sleep_for(std::chrono::seconds(<span class="number">1</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;, <span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="comment">//4 把j3赋值给j1，joining_thread内部会等待j1汇合结束后</span></span><br><span class="line">    <span class="comment">//再将j3赋值给j1</span></span><br><span class="line">    j1 = std::<span class="built_in">move</span>(j3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="容器存储"><a href="#容器存储" class="headerlink" title="容器存储"></a>容器存储</h3><ul><li>容器存储线程时，比使用<strong>emplace_back()</strong>,直接创造匿名对象可以节约一次构造函数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_vector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        threads.<span class="built_in">emplace_back</span>(param_function, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; entry : threads) &#123;</span><br><span class="line">        entry.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择运行数量"><a href="#选择运行数量" class="headerlink" title="选择运行数量"></a>选择运行数量</h3><ul><li>借用C++标准库的<strong>std::thread::hardware_concurrency()</strong>函数，它的返回值是一个指标，表示程序在各次运行中可真正并发的线程数量.<br>我们可以模拟实现一个并行计算的功能，计算容器内所有元素的和</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">parallel_accumulate</span><span class="params">(Iterator first, Iterator last, T init)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> length = std::<span class="built_in">distance</span>(first, last);</span><br><span class="line">    <span class="keyword">if</span> (!length)</span><br><span class="line">        <span class="keyword">return</span> init;    <span class="comment">//⇽-- - ①</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> min_per_thread = <span class="number">25</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> max_threads =</span><br><span class="line">        (length + min_per_thread - <span class="number">1</span>) / min_per_thread;    <span class="comment">//⇽-- - ②</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> hardware_threads =</span><br><span class="line">        std::thread::<span class="built_in">hardware_concurrency</span>();</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> num_threads =</span><br><span class="line">        std::<span class="built_in">min</span>(hardware_threads != <span class="number">0</span> ? hardware_threads : <span class="number">2</span>, max_threads);    <span class="comment">//⇽-- - ③</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> block_size = length / num_threads;    <span class="comment">//⇽-- - ④</span></span><br><span class="line">        <span class="function">std::vector&lt;T&gt; <span class="title">results</span><span class="params">(num_threads)</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;std::thread&gt;  <span class="title">threads</span><span class="params">(num_threads - <span class="number">1</span>)</span></span>;   <span class="comment">// ⇽-- - ⑤</span></span><br><span class="line">        Iterator block_start = first;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">long</span> i = <span class="number">0</span>; i &lt; (num_threads - <span class="number">1</span>); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        Iterator block_end = block_start;</span><br><span class="line">        std::<span class="built_in">advance</span>(block_end, block_size);    <span class="comment">//⇽-- - ⑥</span></span><br><span class="line">            threads[i] = std::<span class="built_in">thread</span>(<span class="comment">//⇽-- - ⑦</span></span><br><span class="line">                <span class="built_in">accumulate_block</span>&lt;Iterator, T&gt;(),</span><br><span class="line">                block_start, block_end, std::<span class="built_in">ref</span>(results[i]));</span><br><span class="line">        block_start = block_end;    <span class="comment">//⇽-- - ⑧</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">accumulate_block</span>&lt;Iterator, T&gt;()(</span><br><span class="line">        block_start, last, results[num_threads - <span class="number">1</span>]);    <span class="comment">//⇽-- - ⑨</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; entry : threads)</span><br><span class="line">            entry.<span class="built_in">join</span>();    <span class="comment">//⇽-- - ⑩</span></span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">accumulate</span>(results.<span class="built_in">begin</span>(), results.<span class="built_in">end</span>(), init);    <span class="comment">//⇽-- - ⑪</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_parallel_acc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector &lt;<span class="type">int</span>&gt; <span class="built_in">vec</span>(<span class="number">10000</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    sum = parallel_accumulate&lt;std::vector&lt;<span class="type">int</span>&gt;::iterator, <span class="type">int</span>&gt;(vec.<span class="built_in">begin</span>(), </span><br><span class="line">        vec.<span class="built_in">end</span>(), sum);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sum is &quot;</span> &lt;&lt; sum &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的代码1处判断要计算的容器内元素为0个则返回。</p><p>2处计算最大开辟的线程数，我们预估每个线程计算25个数据长度。</p><p>但是我们可以通过std::thread::hardware_concurrency返回cpu的核数，我们期待的是开辟的线</p><p>程数小于等于cpu核数，这样才不会造成线程过多时间片切换开销。</p><p>所以3处计算了适合开辟线程数的最小值。</p><p>4处计算了步长，根据步长移动迭代器然后开辟线程计算。</p><p>5处初始化了线程数-1个大小的vector，因为主线程也参与计算，所以这里-1.</p><p>6处移动步长，7处开辟线程，8处更新起始位置。</p><p>9处为主线程计算。</p><p>10 处让所有线程join</p><p>11 处最后将所有计算结果再次调用std的accumulate算出结果。</p><h3 id="识别线程"><a href="#识别线程" class="headerlink" title="识别线程"></a>识别线程</h3><ul><li>所谓识别线程就是获取线程id，可以根据线程id是否相同判断是否同一个线程。</li><li>比如我们启动了一个线程,我们可以通过线程变量的get_id()获取线程id</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">([]()&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    std::cout &lt;&lt; <span class="string">&quot;thread start&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line">t.<span class="built_in">get_id</span>();</span><br></pre></td></tr></table></figure><ul><li>但是如果我们想在线程的运行函数中区分线程，或者判断哪些是主线程或者子线程，可以通过这种方式</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">([]()&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    std::cout &lt;&lt; <span class="string">&quot;in thread id &quot;</span> &lt;&lt; </span></span></span><br><span class="line"><span class="params"><span class="function">    std::this_thread::get_id() &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">    std::cout &lt;&lt; <span class="string">&quot;thread start&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="互斥和死锁"><a href="#互斥和死锁" class="headerlink" title="互斥和死锁"></a>互斥和死锁</h2><h3 id="锁的使用"><a href="#锁的使用" class="headerlink" title="锁的使用"></a>锁的使用</h3><ul><li><p>我们可以通过mutex对共享数据进行加锁，防止多线程访问共享区造成数据不一致问题。如下，我们初始化一个共享变量shared_data，然后定义了一个互斥量std::mutex，接下来启动了两个线程，分别执行use_lock增加数据，和一个lambda表达式减少数据。<br>结果可以看到两个线程对于共享数据的访问是独占的，单位时间片只有一个线程访问并输出日志。</p></li><li><p><strong>一个线程不能再次加一个自己已经锁定的锁</strong>： 如果一个线程已经持有某个锁（比如 std::mutex），则再次尝试在同一个线程中对该锁进行加锁会导致死锁。因为锁是互斥的，同一线程不能重复持有同一个互斥量。</p></li><li><p><strong>其他线程尝试加已经锁定的锁会被阻塞</strong>： 如果一个线程已经持有某个锁，并且另一个线程尝试在此时对同一个锁进行加锁，则后者线程会被阻塞，直到锁被释放。这是互斥量的基本行为，它确保了在任意时刻只有一个线程可以访问被保护的临界区，从而避免了数据竞争和不确定的行为。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lock mutex.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line">std::mutex mtx1;</span><br><span class="line"><span class="type">int</span> share_data = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        mtx<span class="number">1.l</span>ock();</span><br><span class="line">        share_data++;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;current thread is&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;share_data is &quot;</span> &lt;&lt; share_data &lt;&lt; std::endl;</span><br><span class="line">        mtx<span class="number">1.</span><span class="built_in">unlock</span>();</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">microseconds</span>(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(use_lock)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            mtx<span class="number">1.l</span>ock();</span></span></span><br><span class="line"><span class="params"><span class="function">            share_data--;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::cout &lt;&lt; <span class="string">&quot;current thread is&quot;</span> &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::cout &lt;&lt; <span class="string">&quot;share_data is &quot;</span> &lt;&lt; share_data &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">            mtx<span class="number">1.</span>unlock();</span></span></span><br><span class="line"><span class="params"><span class="function">            std::this_thread::sleep_for(std::chrono::microseconds(<span class="number">10</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test_lock</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello World!\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="lock-guard的使用"><a href="#lock-guard的使用" class="headerlink" title="lock_guard的使用"></a>lock_guard的使用</h3><ul><li>当然我们可以用lock_guard自动加锁和解锁,比如上面的函数可以等价简化为</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(use_lock)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                std::lock_guard&lt;std::mutex&gt; lk_lock(mtx1);</span></span></span><br><span class="line"><span class="params"><span class="function">                share_data--;</span></span></span><br><span class="line"><span class="params"><span class="function">                std::cout &lt;&lt; <span class="string">&quot;current thread is&quot;</span> &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">                std::cout &lt;&lt; <span class="string">&quot;share_data is &quot;</span> &lt;&lt; share_data &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::this_thread::sleep_for(std::chrono::microseconds(<span class="number">10</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>注意：</strong>使用lock_guard的时候，它是在创造的时候加锁，在被析构的时候解锁，如果你不注意它的作用域，就会导致一些资源浪费问题，甚至其他线程无法工作的情况，所以加入 <strong>{ }</strong> 是必要的，没有加入的话t2线程将会一直占用共享数据，这么做的一个好处是简化了一些特殊情况从函数中返回的写法，比如异常或者条件不满足时，函数内部直接return，锁也会自动解开</li></ul><h3 id="如何保证数据安全"><a href="#如何保证数据安全" class="headerlink" title="如何保证数据安全"></a>如何保证数据安全</h3><ul><li><p>有时候我们可以将对共享数据的访问和修改聚合到一个函数，在函数内加锁保证数据的安全性。但是对于读取类型的操作，即使读取函数是线程安全的，但是返回值抛给外边使用，存在不安全性。比如一个栈对象，我们要保证其在多线程访问的时候是安全的，可以在判断栈是否为空，判断操作内部我们可以加锁，但是判断结束后返回值就不在加锁了，就会存在线程安全问题。</p></li><li><p>比如我定义了如下栈, 对于多线程访问时判断栈是否为空，此后两个线程同时出栈，可能会造成崩溃。如下所示</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lock mutex.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadsafe_stack1</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::stack&lt;T&gt; stk;</span><br><span class="line">    <span class="keyword">mutable</span> std::mutex m;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">threadsafe_stack1</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">threadsafe_stack1</span>(<span class="type">const</span> threadsafe_stack1&amp; other) &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(other.m)</span></span>;</span><br><span class="line">        stk = other.stk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    threadsafe_stack1&amp; <span class="keyword">operator</span> = (<span class="type">const</span> threadsafe_stack1&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T new_value)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        stk.<span class="built_in">push</span>(std::<span class="built_in">move</span>(new_value));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//问题代码</span></span><br><span class="line">    <span class="function">T <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">auto</span> element = stk.<span class="built_in">top</span>();</span><br><span class="line">        stk.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//危险</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> stk.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_threadsafe_stack1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    threadsafe_stack1&lt;<span class="type">int</span>&gt; safe_stack;</span><br><span class="line">    safe_stack.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;safe_stack]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">if</span> (!safe_stack.empty()) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::this_thread::sleep_for(std::chrono::seconds(<span class="number">1</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">            safe_stack.pop();</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([&amp;safe_stack]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">if</span> (!safe_stack.empty()) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::this_thread::sleep_for(std::chrono::seconds(<span class="number">1</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">            safe_stack.pop();</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//test_lock();</span></span><br><span class="line">    <span class="built_in">test_threadsafe_stack1</span>();</span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; &quot;Hello World!\n&quot;;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>在这段代码会在出栈的时候报错，因为可能栈里就一个元素但是我们却出栈了两次</li></ul><h4 id="解决的办法"><a href="#解决的办法" class="headerlink" title="解决的办法"></a>解决的办法</h4><ul><li>定义一个空栈异常，然后实现我们的出栈函数，如下所示</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">empty_stack</span> : std::exception</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">what</span><span class="params">()</span> <span class="type">const</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">T <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (data.<span class="built_in">empty</span>()) <span class="keyword">throw</span> <span class="built_in">empty_stack</span>();</span><br><span class="line">    <span class="keyword">auto</span> element = data.<span class="built_in">top</span>();</span><br><span class="line">    data.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>这么做就需要在外层使用的时候捕获异常。这是C++ 并发编程中提及的建议。但是我觉得可以在函数pop内部再次判断栈是否为空，若为空则返回一个非法数据，这样比抛出异常好一些</li><li>但是如果T是一个复杂类型，我们很难定义一个非法值给外界知晓，这一点可以通过智能指针进行优化。之后我们再介绍更优化的方案，因为现在这个pop函数仍存在问题，比如T是一个vector<int>类型，那么在pop函数内部element就是vector<int>类型，开始element存储了一些int值，程序没问题，函数执行pop操作， 假设此时程序内存暴增，导致当程序使用的内存足够大时，可用的有效空间不够， 函数返回element时，就会就会存在vector做拷贝赋值时造成失败。即使我们捕获异常，释放部分空间但也会导致栈元素已经出栈，数据丢失了。这其实是内存管理不当造成的，但是C++ 并发编程一书中给出了优化方案。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">empty_stack</span> : std::exception</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">what</span><span class="params">()</span> <span class="type">const</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadsafe_stack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::stack&lt;T&gt; data;</span><br><span class="line">    <span class="keyword">mutable</span> std::mutex m;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">threadsafe_stack</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">threadsafe_stack</span>(<span class="type">const</span> threadsafe_stack&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(other.m)</span></span>;</span><br><span class="line">        <span class="comment">//①在构造函数的函数体（constructor body）内进行复制操作</span></span><br><span class="line">        data = other.data;   </span><br><span class="line">    &#125;</span><br><span class="line">    threadsafe_stack&amp; <span class="keyword">operator</span>=(<span class="type">const</span> threadsafe_stack&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        data.<span class="built_in">push</span>(std::<span class="built_in">move</span>(new_value));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法二</span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="comment">//②试图弹出前检查是否为空栈</span></span><br><span class="line">        <span class="keyword">if</span> (data.<span class="built_in">empty</span>()) <span class="keyword">throw</span> <span class="built_in">empty_stack</span>();</span><br><span class="line">        <span class="comment">//③改动栈容器前设置返回值</span></span><br><span class="line">            <span class="function">std::shared_ptr&lt;T&gt; <span class="type">const</span> <span class="title">res</span><span class="params">(std::make_shared&lt;T&gt;(data.top()))</span></span>;    </span><br><span class="line">            data.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法一</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(T&amp; value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (data.<span class="built_in">empty</span>()) <span class="keyword">throw</span> <span class="built_in">empty_stack</span>();</span><br><span class="line">        value = data.<span class="built_in">top</span>();</span><br><span class="line">        data.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> data.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>我们提供了两个版本的pop操作，一个是带引用类型的参数的，一个是直接pop出智能指针类型，这样在pop函数内部减少了数据的拷贝，防止内存溢出，其实这两种做法确实是相比之前直接pop固定类型的值更节省内存，运行效率也好很多。我们也完全可以基于之前的思想，在pop时如果队列为空则返回空指针，这样比抛出异常更有好一些</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;T&gt; <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="comment">//②试图弹出前检查是否为空栈</span></span><br><span class="line">    <span class="keyword">if</span> (data.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">//③改动栈容器前设置返回值</span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="type">const</span> <span class="title">res</span><span class="params">(std::make_shared&lt;T&gt;(data.top()))</span></span>;    </span><br><span class="line">    data.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="死锁是怎么造成的"><a href="#死锁是怎么造成的" class="headerlink" title="死锁是怎么造成的"></a>死锁是怎么造成的</h3><ul><li>死锁一般是由于调运顺序不一致导致的，比如两个线程循环调用。当线程1先加锁A，再加锁B，而线程2先加锁B，再加锁A。那么在某一时刻就可能造成死锁。比如线程1对A已经加锁，线程2对B已经加锁，那么他们都希望彼此占有对方的锁，又不释放自己占有的锁导致了死锁。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">std::mutex t_lock1;</span><br><span class="line">std::mutex t_lock2;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m_1 = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> m_2 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dead_lock1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;dead_lock1 begin &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        t_lock<span class="number">1.l</span>ock();</span><br><span class="line">        m_1 = <span class="number">1024</span>;</span><br><span class="line">        t_lock<span class="number">2.l</span>ock();</span><br><span class="line">        m_2 = <span class="number">2048</span>;</span><br><span class="line">        t_lock<span class="number">2.</span><span class="built_in">unlock</span>();</span><br><span class="line">        t_lock<span class="number">1.</span><span class="built_in">unlock</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;dead_lock1 end &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dead_lock2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;dead_lock2 begin &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        t_lock<span class="number">2.l</span>ock();</span><br><span class="line">        m_2 = <span class="number">2048</span>;</span><br><span class="line">        t_lock<span class="number">1.l</span>ock();</span><br><span class="line">        m_1 = <span class="number">1024</span>;</span><br><span class="line">        t_lock<span class="number">1.</span><span class="built_in">unlock</span>();</span><br><span class="line">        t_lock<span class="number">2.</span><span class="built_in">unlock</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;dead_lock2 end &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_dead_lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(dead_lock1)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(dead_lock2)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//test_lock();</span></span><br><span class="line">    <span class="comment">//test_threadsafe_stack1();</span></span><br><span class="line">    <span class="built_in">test_dead_lock</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这样运行之后在某一个时刻一定会导致死锁</li></ul><h4 id="死锁解决办法"><a href="#死锁解决办法" class="headerlink" title="死锁解决办法"></a>死锁解决办法</h4><ul><li>实际工作中避免死锁的一个方式就是将加锁和解锁的功能封装为独立的函数，这样能保证在独立的函数里执行完操作后就解锁，不会导致一个函数里使用多个锁的情况,即加锁和解锁作为原子操作解耦合，各自只管理自己的功能</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加锁和解锁作为原子操作解耦合，各自只管理自己的功能</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">atomic_lock1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;lock1 begin lock&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    t_lock<span class="number">1.l</span>ock();</span><br><span class="line">    m_1 = <span class="number">1024</span>;</span><br><span class="line">    t_lock<span class="number">1.</span><span class="built_in">unlock</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;lock1 end lock&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">atomic_lock2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;lock2 begin lock&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    t_lock<span class="number">2.l</span>ock();</span><br><span class="line">    m_2 = <span class="number">2048</span>;</span><br><span class="line">    t_lock<span class="number">2.</span><span class="built_in">unlock</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;lock2 end lock&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">safe_lock1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">atomic_lock1</span>();</span><br><span class="line">        <span class="built_in">atomic_lock2</span>();</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">safe_lock2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">atomic_lock2</span>();</span><br><span class="line">        <span class="built_in">atomic_lock1</span>();</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_safe_lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(safe_lock1)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(safe_lock2)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="同时加锁"><a href="#同时加锁" class="headerlink" title="同时加锁"></a>同时加锁</h3><ul><li>当我们无法避免在一个函数内部使用两个互斥量，并且都要解锁的情况，那我们可以采取<strong>同时加锁</strong>的方式。我们先定义一个类,假设这个类不推荐拷贝构造，但我们也提供了这个类的拷贝构造和移动构造</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">som_big_object</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">som_big_object</span>(<span class="type">int</span> data) :_data(data) &#123;&#125;</span><br><span class="line">    <span class="comment">//拷贝构造</span></span><br><span class="line">    <span class="built_in">som_big_object</span>(<span class="type">const</span> som_big_object&amp; b2) :_data(b<span class="number">2.</span>_data) &#123;</span><br><span class="line">        _data = b<span class="number">2.</span>_data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//移动构造</span></span><br><span class="line">    <span class="built_in">som_big_object</span>(som_big_object&amp;&amp; b2) :_data(std::<span class="built_in">move</span>(b<span class="number">2.</span>_data)) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重载输出运算符</span></span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span> &lt;&lt; (std::ostream&amp; os, <span class="type">const</span> som_big_object&amp; big_obj) &#123;</span><br><span class="line">        os &lt;&lt; big_obj._data;</span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重载赋值运算符</span></span><br><span class="line">    som_big_object&amp; <span class="keyword">operator</span> = (<span class="type">const</span> som_big_object&amp; b2) &#123;</span><br><span class="line">        <span class="comment">// _data = std::move(b2._data);</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;b2) &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _data = b<span class="number">2.</span>_data;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交换数据</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">swap</span><span class="params">(som_big_object&amp; b1, som_big_object&amp; b2)</span> </span>&#123;</span><br><span class="line">        som_big_object temp = std::<span class="built_in">move</span>(b1);</span><br><span class="line">        b1 = std::<span class="built_in">move</span>(b2);</span><br><span class="line">        b2 = std::<span class="built_in">move</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>以上代码的一个<strong>小知识</strong>：当我们提供了一个 <strong><em>移动构造函数的时候，就不会提供默认的拷贝和移动赋值函数了</em></strong></p></li><li><p>接下来我们定义一个类对上面的类做管理，为防止多线程情况下数据混乱， 包含了一个互斥量。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">big_object_mgr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">big_object_mgr</span>(<span class="type">int</span> data = <span class="number">0</span>) :_obj(data) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printinfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;current obj data is &quot;</span> &lt;&lt; _obj &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">danger_swap</span><span class="params">(big_object_mgr&amp; objm1, big_object_mgr&amp; objm2)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">safe_swap</span><span class="params">(big_object_mgr&amp; objm1, big_object_mgr&amp; objm2)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">safe_swap_scope</span><span class="params">(big_object_mgr&amp; objm1, big_object_mgr&amp; objm2)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::mutex _mtx;</span><br><span class="line">    som_big_object _obj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>接下来定义了三个交换函数看看，三个函数哪些是危险的以及为什么</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">danger_swap</span><span class="params">(big_object_mgr&amp; objm1, big_object_mgr&amp; objm2)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;thread [ &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; ] begin&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">if</span> (&amp;objm1 == &amp;objm2) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::lock_guard &lt;std::mutex&gt; <span class="built_in">gurad1</span>(objm<span class="number">1.</span>_mtx);</span><br><span class="line">    <span class="comment">//此处为了故意制造死锁，我们让线程小睡一会</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard2</span><span class="params">(objm<span class="number">2.</span>_mtx)</span></span>;</span><br><span class="line">    <span class="built_in">swap</span>(objm<span class="number">1.</span>_obj, objm<span class="number">2.</span>_obj);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;thread [ &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; ] end&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">safe_swap</span><span class="params">(big_object_mgr&amp; objm1, big_object_mgr&amp; objm2)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;thread [ &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; ] begin&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">if</span> (&amp;objm1 == &amp;objm2) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同时加多个锁</span></span><br><span class="line">    std::<span class="built_in">lock</span>(objm<span class="number">1.</span>_mtx, objm<span class="number">2.</span>_mtx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//领养锁管理它自动释放，std::adopt_lock有了这个操作后gurad1就只会负责解锁而不负责加锁</span></span><br><span class="line">    std::lock_guard &lt;std::mutex&gt; <span class="built_in">gurad1</span>(objm<span class="number">1.</span>_mtx, std::adopt_lock);</span><br><span class="line">    <span class="comment">//此处为了故意制造死锁，我们让线程小睡一会</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    std::lock_guard &lt;std::mutex&gt; <span class="built_in">gurad2</span>(objm<span class="number">2.</span>_mtx, std::adopt_lock);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">swap</span>(objm<span class="number">1.</span>_obj, objm<span class="number">2.</span>_obj);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;thread [ &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; ] end&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当然上面加锁的方式可以简化，C++17 scope_lock可以对多个互斥量同时加锁，并且自动释放</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">safe_swap_scope</span><span class="params">(big_object_mgr&amp; objm1, big_object_mgr&amp; objm2)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;thread [ &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; ] begin&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">if</span> (&amp;objm1 == &amp;objm2) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::scoped_lock  <span class="title">guard</span><span class="params">(objm<span class="number">1.</span>_mtx, objm<span class="number">2.</span>_mtx)</span></span>;</span><br><span class="line">    <span class="comment">//等价于</span></span><br><span class="line">    <span class="comment">//std::scoped_lock&lt;std::mutex, std::mutex&gt; guard(objm1._mtx, objm2._mtx);</span></span><br><span class="line">    <span class="built_in">swap</span>(objm<span class="number">1.</span>_obj, objm<span class="number">2.</span>_obj);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;thread [ &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; ] end&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">test_danger_swap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">big_object_mgr <span class="title">objm1</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="function">big_object_mgr <span class="title">objm2</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(danger_swap, std::ref(objm1), std::ref(objm2))</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(danger_swap, std::ref(objm2), std::ref(objm1))</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    objm<span class="number">1.</span><span class="built_in">printinfo</span>();</span><br><span class="line">    objm<span class="number">2.</span><span class="built_in">printinfo</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_safe_swap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">big_object_mgr <span class="title">objm1</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="function">big_object_mgr <span class="title">objm2</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(safe_swap, std::ref(objm1), std::ref(objm2))</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(safe_swap, std::ref(objm2), std::ref(objm1))</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    objm<span class="number">1.</span><span class="built_in">printinfo</span>();</span><br><span class="line">    objm<span class="number">2.</span><span class="built_in">printinfo</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>C++17的<strong>scoped_lock</strong>，用于多个互斥锁的免死锁 RAII 封装器，是一种更加灵活和安全的互斥量管理方式。是一种独占互斥锁，它可以同时锁定多个互斥锁，并保证以原子方式获得所有互斥锁，从而有效避免死锁。</p></li><li><p>它可以接受多个互斥锁作为参数，并在构造函数中自动锁定这些互斥锁。</p></li><li>当std::scoped_lock对象出作用域时，它会析构并自动解锁所有已经锁定的互斥锁，确保互斥访问的安全性和正确性。</li></ul><h3 id="thread-local"><a href="#thread-local" class="headerlink" title="thread_local"></a>thread_local</h3><ul><li>这个修饰符的意思是创建一个线程变量，它只会在线程创建时初始化一次，在同一个线程内部的所有对象是共享的，但是不同线程的对象之间不是共享的，也就意味着这个是线程安全的</li></ul><h3 id="层级加锁"><a href="#层级加锁" class="headerlink" title="层级加锁"></a>层级加锁</h3><ul><li>现实开发中常常很难规避同一个函数内部加多个锁的情况，我们要尽可能避免循环加锁，所以可以自定义一个层级锁，保证实际项目中对多个互斥量加锁时是有序的，这可以用于检测你所加的锁是否会引起死锁</li><li>大概原理就是：首先每个线程默认都会有一个层级(优先级)（不同线程不共享），这个优先级是ulong的最大值，还有一个变量是用来计算当前允许加锁的层级（不同线程共享），还有一个变量是记录的上一次线程加锁的层值,当线程的层级大于锁的层级时才可以加锁，否则不能，析构的时候就把层级还原（赋给thread_local的层级变量）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//层级锁</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hierarchical_mutex</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">hierarchical_mutex</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> value)</span> :_hierarchy_value(value),</span></span><br><span class="line"><span class="function">        _previous_hierarchy_value(<span class="number">0</span>) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">hierarchical_mutex</span>(<span class="type">const</span> hierarchical_mutex&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    hierarchical_mutex&amp; <span class="keyword">operator</span>=(<span class="type">const</span> hierarchical_mutex&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">check_for_hierarchy_violation</span>();</span><br><span class="line">        _internal_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="built_in">update_hierarchy_value</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解锁</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_this_thread_hierarchy_value != _hierarchy_value) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;mutex hierarchy violated&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        _this_thread_hierarchy_value = _previous_hierarchy_value;</span><br><span class="line">        _internal_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//尝试加锁</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">try_lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">check_for_hierarchy_violation</span>();</span><br><span class="line">        <span class="keyword">if</span> (!_internal_mutex.<span class="built_in">try_lock</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">update_hierarchy_value</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">//内在的锁 </span></span><br><span class="line">    std::mutex  _internal_mutex;</span><br><span class="line">    <span class="comment">//当前层级值（优先级）,只有大于等于这个值的锁才可以加锁</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> _hierarchy_value;</span><br><span class="line">    <span class="comment">//上一次层级值</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> _previous_hierarchy_value;</span><br><span class="line">    <span class="comment">//本线程记录的层级值</span></span><br><span class="line">    <span class="type">static</span> <span class="keyword">thread_local</span>  <span class="type">unsigned</span> <span class="type">long</span>  _this_thread_hierarchy_value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否能加锁，当线程当前层级大于允许加锁层级是才可加锁，否则不行</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">check_for_hierarchy_violation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_this_thread_hierarchy_value &lt;= _hierarchy_value) &#123;</span><br><span class="line">            <span class="keyword">throw</span>  std::<span class="built_in">logic_error</span>(<span class="string">&quot;mutex  hierarchy violated&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新层级</span></span><br><span class="line">    <span class="function"><span class="type">void</span>  <span class="title">update_hierarchy_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        _previous_hierarchy_value = _this_thread_hierarchy_value;</span><br><span class="line">        _this_thread_hierarchy_value = _hierarchy_value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义静态成员，thread_local 表示线程本地，是属于一个线程作用域，不是共用的，也就是说t1与t2不共享这个</span></span><br><span class="line"><span class="keyword">thread_local</span> <span class="type">unsigned</span> <span class="type">long</span> hierarchical_mutex::_this_thread_hierarchy_value(ULONG_MAX);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_hierarchy_lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">hierarchical_mutex  <span class="title">hmtx1</span><span class="params">(<span class="number">1000</span>)</span></span>;</span><br><span class="line">    <span class="function">hierarchical_mutex  <span class="title">hmtx2</span><span class="params">(<span class="number">500</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;hmtx1, &amp;hmtx2]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        hmtx<span class="number">1.l</span>ock();</span></span></span><br><span class="line"><span class="params"><span class="function">        hmtx<span class="number">2.l</span>ock();</span></span></span><br><span class="line"><span class="params"><span class="function">        hmtx<span class="number">2.</span>unlock();</span></span></span><br><span class="line"><span class="params"><span class="function">        hmtx<span class="number">1.</span>unlock();</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([&amp;hmtx1, &amp;hmtx2]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        hmtx<span class="number">2.l</span>ock();</span></span></span><br><span class="line"><span class="params"><span class="function">        hmtx<span class="number">1.l</span>ock();</span></span></span><br><span class="line"><span class="params"><span class="function">        hmtx<span class="number">1.</span>unlock();</span></span></span><br><span class="line"><span class="params"><span class="function">        hmtx<span class="number">2.</span>unlock();</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>层级锁能保证我们每个线程加锁时，一定是先加权重高的锁。并且释放时也保证了顺序。主要原理就是将当前锁的权重保存在线程变量中，这样该线程再次加锁时判断线程变量的权重和锁的权重是否大于，如果满足条件则继续加锁。</li></ul><h2 id="C-unique-lock，共享锁和递归锁"><a href="#C-unique-lock，共享锁和递归锁" class="headerlink" title="C++unique_lock，共享锁和递归锁"></a>C++unique_lock，共享锁和递归锁</h2><h3 id="unique-lock"><a href="#unique-lock" class="headerlink" title="unique_lock"></a>unique_lock</h3><ul><li>unique_lock和lock_guard基本用法相同，构造时默认加锁，析构时默认解锁，但unique_lock有个好处就是可以<strong>手动解锁</strong>。这一点尤为重要，方便我们控制锁住区域的粒度(加锁的范围大小),也能支持和条件变量配套使用，至于条件变量我们之后再介绍，本文主要介绍锁的相关操作。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_unique</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx1)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;lock success&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    share_data++;</span><br><span class="line">    <span class="comment">//可以手动解锁</span></span><br><span class="line">    lock.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*som_big_object obj1(100);</span></span><br><span class="line"><span class="comment">    som_big_object obj2(100);</span></span><br><span class="line"><span class="comment">    obj2 = std::move(obj1);*/</span></span><br><span class="line">    <span class="comment">//test_lock();</span></span><br><span class="line">    <span class="comment">//test_threadsafe_stack1();</span></span><br><span class="line">    <span class="comment">//test_dead_lock();</span></span><br><span class="line">    <span class="comment">//test_hierarchy_lock();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="unique-lock的owns-lock判断是否持有锁"><a href="#unique-lock的owns-lock判断是否持有锁" class="headerlink" title="unique_lock的owns_lock判断是否持有锁"></a>unique_lock的owns_lock判断是否持有锁</h4><ul><li>我们可以通过unique_lock的owns_lock判断是否持有锁</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可判断是否占有锁</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">owns_lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//lock可自动解锁，也可手动解锁</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    shared_data++;</span><br><span class="line">    <span class="keyword">if</span> (lock.<span class="built_in">owns_lock</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;owns lock&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;doesn&#x27;t own lock&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    lock.<span class="built_in">unlock</span>();</span><br><span class="line">    <span class="keyword">if</span> (lock.<span class="built_in">owns_lock</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;owns lock&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;doesn&#x27;t own lock&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="unique-lock的延迟加锁defer-lock"><a href="#unique-lock的延迟加锁defer-lock" class="headerlink" title="unique_lock的延迟加锁defer_lock"></a>unique_lock的延迟加锁defer_lock</h4><ul><li>允许延迟加锁, <strong>std::defer_lock</strong> 表示延迟加锁的意思</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以延迟加锁</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">defer_lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//延迟加锁，锁正常初始化，但并没有自动加锁</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx, std::defer_lock)</span></span>;</span><br><span class="line">    <span class="comment">//可以加锁</span></span><br><span class="line">    lock.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="comment">//可以自动析构解锁，也可以手动解锁</span></span><br><span class="line">    lock.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="unique-lock的领养加锁"><a href="#unique-lock的领养加锁" class="headerlink" title="unique_lock的领养加锁"></a>unique_lock的领养加锁</h4><ul><li>和lock_guard一样，unique_lock也支持领养锁，尽管是领养的，但是打印还是会出现owns lock，因为不管如何锁被加上，就会输出owns lock。</li><li><strong>注意</strong>:领养一个锁前一定要加锁，否则就会报错，因为你领养前如果不加锁，后面他会自动解锁，而你本来没有加锁就会让一个没加锁的锁解锁就会报错</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_own_adopt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mtx<span class="number">1.l</span>ock();</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx1, std::adopt_lock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (lock.<span class="built_in">owns_lock</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;owns lock&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;dose not have the lock&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    lock.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>既然unique_lock支持领养操作也支持延迟加锁，那么可以用两种方式实现前文lock_guard实现的swap操作。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//之前的交换代码可以可以用如下方式等价实现</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">99</span>;</span><br><span class="line">std::mutex  mtx1;</span><br><span class="line">std::mutex  mtx2;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">safe_swap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">lock</span>(mtx1, mtx2);</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock1</span><span class="params">(mtx1, std::adopt_lock)</span></span>;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock2</span><span class="params">(mtx2, std::adopt_lock)</span></span>;</span><br><span class="line">    std::<span class="built_in">swap</span>(a, b);</span><br><span class="line">    <span class="comment">// 错误用法，因为此时mtx1已经没有所有权了</span></span><br><span class="line">    <span class="comment">//mtx1.unlock();</span></span><br><span class="line">    <span class="comment">//mtx2.unlock();</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">safe_swap2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock1</span><span class="params">(mtx1, std::defer_lock)</span></span>;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock2</span><span class="params">(mtx2, std::defer_lock)</span></span>;</span><br><span class="line">    <span class="comment">//需用lock1,lock2加锁</span></span><br><span class="line">    std::<span class="built_in">lock</span>(lock1, lock2);</span><br><span class="line">    <span class="comment">//错误用法</span></span><br><span class="line">    <span class="comment">//std::lock(mtx1, mtx2);</span></span><br><span class="line">    std::<span class="built_in">swap</span>(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>大家注意一旦mutex被unique_lock管理，加锁和释放的操作就交给unique_lock，不能调用mutex加锁和解锁，因为锁的使用权已经交给unique_lock了</li><li><p><strong>unique_lock</strong> 在底层实现了移动赋值函数以及移动构造函数，禁止了拷贝构造和拷贝复制函数</p></li><li><p>我们知道mutex是不支持移动和拷贝的，但是unique_lock支持移动，当一个mutex被转移给unique_lock后，可以通过unique_ptr转移其归属权.</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//转移互斥量所有权</span></span><br><span class="line"><span class="comment">//互斥量本身不支持move操作，但是unique_lock支持</span></span><br><span class="line">std::unique_lock &lt;std::mutex&gt;  <span class="built_in">get_lock</span>() &#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt;  <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    shared_data++;</span><br><span class="line">    <span class="keyword">return</span> lock;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_return</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(get_lock())</span></span>;</span><br><span class="line">    shared_data++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="锁的粒度"><a href="#锁的粒度" class="headerlink" title="锁的粒度"></a>锁的粒度</h4><ul><li>锁的粒度表示加锁（范围）的精细程度，一个锁的粒度足够大，保证可以锁住要访问的共享数据</li><li>同时一个锁的粒度足够小，保证非共享数据不被锁住影响效率而unique_lock则很好的支持手动解锁</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">precision_lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    shared_data++;</span><br><span class="line">    lock.<span class="built_in">unlock</span>();</span><br><span class="line">    <span class="comment">//不设计共享数据的耗时操作不要放在锁内执行</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    lock.<span class="built_in">lock</span>();</span><br><span class="line">    shared_data++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="共享锁shared-lock以及shared-mutex"><a href="#共享锁shared-lock以及shared-mutex" class="headerlink" title="共享锁shared_lock以及shared_mutex"></a>共享锁shared_lock以及shared_mutex</h3><ul><li>试想这样一个场景，对于一个DNS服务，我们可以根据域名查询服务对应的ip地址，它很久才更新一次，比如新增记录，删除记录或者更新记录等。平时大部分时间都是提供给外部查询，对于查询操作，即使多个线程并发查询不加锁也不会有问题，但是当有线程修改DNS服务的ip记录或者增减记录时，其他线程不能查询，需等待修改完再查询。或者等待查询完，线程才能修改。也就是说读操作并不是互斥的，同一时间可以有多个线程同时读，但是写和读是互斥的，写与写是互斥的，简而言之，写操作需要独占锁。而读操作需要共享锁。</li><li>要想使用共享锁，需使用<strong>共享互斥量std::shared_mutex</strong>,std::shared_mutex是<strong>C++17</strong>标准提出的。</li><li><strong>C++14标准</strong>可以使用<strong>std::shared_time_mutex</strong></li><li><strong>C++11</strong>的话可以使用boost</li><li>std::shared_mutex 和 std::shared_timed_mutex 都是用于实现多线程并发访问共享数据的互斥锁，但它们之间存在一些区别：<ol><li>std::shared_mutex：</li></ol></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 提供了 `lock()`, `try_lock()`, 和 `try_lock_for()` 以及 `try_lock_until()` 函数，这些函数都可以用于获取互斥锁。</span><br><span class="line">* 提供了 `try_lock_shared()` 和 `lock_shared()` 函数，这些函数可以用于获取共享锁。</span><br><span class="line">* 当 `<span class="built_in">std</span>::shared_mutex` 被锁定后，其他尝试获取该锁的线程将会被阻塞，直到该锁被解锁。</span><br></pre></td></tr></table></figure><ol><li>std::shared_timed_mutex：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 与 `<span class="built_in">std</span>::shared_mutex` 类似，也提供了 `lock()`, `try_lock()`, 和 `try_lock_for()` 以及  `try_lock_until()` 函数用于获取互斥锁。</span><br><span class="line">* 与 `<span class="built_in">std</span>::shared_mutex` 不同的是，它还提供了 `try_lock_shared()` 和 `lock_shared()` 函数用于获取共享锁，这些函数在尝试获取共享锁时具有超时机制。</span><br><span class="line">* 当 `<span class="built_in">std</span>::shared_timed_mutex` 被锁定后，其他尝试获取该锁的线程将会被阻塞，直到该锁被解锁，这与 `<span class="built_in">std</span>::shared_mutex` 相同。然而，当尝试获取共享锁时，如果不能立即获得锁，`<span class="built_in">std</span>::shared_timed_mutex` 会设置一个超时，超时过后如果仍然没有获取到锁，则操作将返回失败。</span><br></pre></td></tr></table></figure><ul><li><p>因此，std::shared_timed_mutex 提供了额外的超时机制，这使得它在某些情况下更适合于需要处理超时的并发控制。然而，如果不需要超时机制，可以使用更简单的 std::shared_mutex。</p></li><li><p>下面我们定义了一个DNS类，查询使用共享锁，写数据使用独占锁</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DNSserver</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DNSserver</span>()&#123;&#125;</span><br><span class="line">    <span class="function">std::string <span class="title">QueryDNS</span><span class="params">(<span class="type">const</span> std::string&amp; dnsname)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::shared_lock&lt;std::shared_mutex&gt; <span class="title">shared_locks</span><span class="params">(_shared_mtx)</span></span>;</span><br><span class="line">        <span class="keyword">auto</span> iter = _dns_info.<span class="built_in">find</span>(dnsname);</span><br><span class="line">        <span class="keyword">if</span> (iter != _dns_info.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> iter-&gt;second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span><span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddDNSInfo</span><span class="params">(<span class="type">const</span> std::string&amp; dnsname,<span class="type">const</span> std::string&amp; dnsentry)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::shared_mutex&gt; <span class="title">lock_guards</span><span class="params">(_shared_mtx)</span></span>;</span><br><span class="line">        <span class="keyword">auto</span> iter = _dns_info.<span class="built_in">find</span>(dnsname);</span><br><span class="line">        <span class="keyword">if</span> (iter != _dns_info.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            _dns_info[dnsname] = dnsentry;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> _dns_info.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(dnsname, dnsentry));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> std::shared_mutex _shared_mtx;</span><br><span class="line">    std::map&lt;std::string, std::string&gt; _dns_info;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="递归锁"><a href="#递归锁" class="headerlink" title="递归锁"></a>递归锁</h3><ul><li><p>有时候我们在实现接口的时候内部加锁，接口内部调用完结束自动解锁。会出现一个接口调用另一个接口的情况，如果用普通的std::mutex就会出现卡死，因为嵌套加锁导致卡死。但是我们可以使用递归锁。</p></li><li><p>但我个人并不推荐递归锁，可以从设计源头规避嵌套加锁的情况，我们可以将接口相同的功能抽象出来，统一加锁。下面的设计演示了如何使用递归锁</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RecursiveDemo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RecursiveDemo</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">QueryStudent</span><span class="params">(std::string name)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::recursive_mutex&gt;  <span class="title">recursive_lock</span><span class="params">(_recursive_mtx)</span></span>;</span><br><span class="line">        <span class="keyword">auto</span> iter_find = _students_info.<span class="built_in">find</span>(name);</span><br><span class="line">        <span class="keyword">if</span> (iter_find == _students_info.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddScore</span><span class="params">(std::string name, <span class="type">int</span> score)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::recursive_mutex&gt;  <span class="title">recursive_lock</span><span class="params">(_recursive_mtx)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">QueryStudent</span>(name)) &#123;</span><br><span class="line">            _students_info.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(name, score));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _students_info[name] = _students_info[name] + score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不推荐采用递归锁，使用递归锁说明设计思路并不理想，需优化设计</span></span><br><span class="line">    <span class="comment">//推荐拆分逻辑，将共有逻辑拆分为统一接口</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddScoreAtomic</span><span class="params">(std::string name, <span class="type">int</span> score)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::recursive_mutex&gt;  <span class="title">recursive_lock</span><span class="params">(_recursive_mtx)</span></span>;</span><br><span class="line">        <span class="keyword">auto</span> iter_find = _students_info.<span class="built_in">find</span>(name);</span><br><span class="line">        <span class="keyword">if</span> (iter_find == _students_info.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            _students_info.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(name, score));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _students_info[name] = _students_info[name] + score;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::map&lt;std::string, <span class="type">int</span>&gt; _students_info;</span><br><span class="line">    std::recursive_mutex   _recursive_mtx;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>我们可以看到AddScore函数内部调用了QueryStudent, 所以采用了递归锁。</li><li>但是我们同样可以改变设计，将两者公有的部分抽离出来生成一个新的接口AddScoreAtomic.</li><li>AddScoreAtomic可以不适用递归锁，照样能完成线程安全操作的目的。</li></ul><h2 id="C-线程安全单例模式的演变"><a href="#C-线程安全单例模式的演变" class="headerlink" title="C++线程安全单例模式的演变"></a>C++线程安全单例模式的演变</h2><h3 id="局部静态变量"><a href="#局部静态变量" class="headerlink" title="局部静态变量"></a>局部静态变量</h3><ul><li>C++11之后可以使用静态内部方法来实现，我们知道当一个函数中定义一个局部静态变量，那么这个局部静态变量只会初始化一次，就是在这个函数第一次调用的时候，以后无论调用几次这个函数，函数内的局部静态变量都不再初始化。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Single2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Single2&amp; <span class="title">GetInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> Single2 single;</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Single2</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Single2</span>(<span class="type">const</span> Single2&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Single2&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Single2&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="饿汉与懒汉式，详情看面试笔记"><a href="#饿汉与懒汉式，详情看面试笔记" class="headerlink" title="饿汉与懒汉式，详情看面试笔记"></a>饿汉与懒汉式，详情看面试笔记</h3><h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><ul><li>懒汉与饿汉式存在一个缺陷，存在多重释放或者不知道哪个指针释放的问题。</li><li>所以我们想到可以用智能指针来自动释放</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以利用智能指针完成自动回收</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleAuto</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">SingleAuto</span>()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">SingleAuto</span>(<span class="type">const</span> SingleAuto&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    SingleAuto&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SingleAuto&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">SingleAuto</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;single auto delete success &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> std::shared_ptr&lt;SingleAuto&gt; <span class="title">GetInst</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (single != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> single;</span><br><span class="line">        &#125;</span><br><span class="line">        s_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span> (single != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">return</span> single;</span><br><span class="line">        &#125;</span><br><span class="line">        single = std::<span class="built_in">shared_ptr</span>&lt;SingleAuto&gt;(<span class="keyword">new</span> SingleAuto);</span><br><span class="line">        s_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> std::shared_ptr&lt;SingleAuto&gt; single;</span><br><span class="line">    <span class="type">static</span> std::mutex s_mutex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::shared_ptr&lt;SingleAuto&gt; SingleAuto::single = <span class="literal">nullptr</span>;</span><br><span class="line">std::mutex SingleAuto::s_mutex;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_singleauto</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> sp1 = SingleAuto::<span class="built_in">GetInst</span>();</span><br><span class="line">    <span class="keyword">auto</span> sp2 = SingleAuto::<span class="built_in">GetInst</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sp1  is  &quot;</span> &lt;&lt; sp1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sp2  is  &quot;</span> &lt;&lt; sp2 &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">//此时存在隐患，可以手动删除裸指针，造成崩溃</span></span><br><span class="line">    <span class="comment">// delete sp1.get();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这样开辟的资源交给智能指针管理免去了回收资源的麻烦。但是有些人觉得虽然智能指针能自动回收内存，如果有开发人员手动delete指针怎么办？</li><li>可以直接把<strong>析构函数设为私有</strong>吗？ 不行，因为析构的时候会调用智能指针的析构函数，在智能指针的析构函数里会调用单例模式的析构，而单例模式的析构是私有无法析构</li><li>所以有人提出了利用<strong>辅助类帮助智能指针释放资源，将智能指针的析构设置为私有</strong>。</li></ul><h4 id="改进方案"><a href="#改进方案" class="headerlink" title="改进方案"></a>改进方案</h4><ul><li><strong>辅助类帮助智能指针释放资源，将智能指针的析构设置为私有</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为了规避用户手动释放内存，可以提供一个辅助类帮忙回收内存</span></span><br><span class="line"><span class="comment">//并将单例类的析构函数写为私有</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleAutoSafe</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SafeDeletor</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(SingleAutoSafe* sf)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;this is safe deleter operator()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">delete</span> sf;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleAutoSafe</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">SingleAutoSafe</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">SingleAutoSafe</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;this is single auto safe deletor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">SingleAutoSafe</span>(<span class="type">const</span> SingleAutoSafe&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    SingleAutoSafe&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SingleAutoSafe&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="comment">//定义友元类，通过友元类调用该类析构函数</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">SafeDeletor</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> std::shared_ptr&lt;SingleAutoSafe&gt; <span class="title">GetInst</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//1处</span></span><br><span class="line">        <span class="keyword">if</span> (single != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> single;</span><br><span class="line">        &#125;</span><br><span class="line">        s_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="comment">//2处</span></span><br><span class="line">        <span class="keyword">if</span> (single != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">return</span> single;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//额外指定删除器  </span></span><br><span class="line">        <span class="comment">//3 处</span></span><br><span class="line">        single = std::<span class="built_in">shared_ptr</span>&lt;SingleAutoSafe&gt;(<span class="keyword">new</span> SingleAutoSafe, <span class="built_in">SafeDeletor</span>());</span><br><span class="line">        <span class="comment">//也可以指定删除函数</span></span><br><span class="line">        <span class="comment">// single = std::shared_ptr&lt;SingleAutoSafe&gt;(new SingleAutoSafe, SafeDelFunc);</span></span><br><span class="line">        s_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> std::shared_ptr&lt;SingleAutoSafe&gt; single;</span><br><span class="line">    <span class="type">static</span> std::mutex s_mutex;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>SafeDeletor就是删除的辅助类，实现了仿函数。构造智能指针时指定了SafeDeletor对象，这样就能帮助智能指针释放了。</p></li><li><p>但是上面的代码存在危险，比如懒汉式的使用方式，当多个线程调用单例时，有一个线程加锁进入3处的逻辑。</p></li><li><p>其他的线程有的在1处，判断指针非空则跳过初始化直接使用单例的内存会存在问题。<br>主要原因在于SingleAutoSafe * temp = new SingleAutoSafe() 这个操作是由三部分组成的</p><ol><li>调用allocate开辟内存</li><li>调用construct执行SingleAutoSafe的构造函数</li><li>调用赋值操作将地址赋值给temp</li></ol></li><li><p>而现实中2和3的步骤可能颠倒，所以有可能在一些编译器中通过优化是1，3，2的调用顺序，<br>其他线程取到的指针就是非空，还没来的及调用构造函数就交给外部使用造成不可预知错误。<br>为解决这个问题，<strong>C++11 推出了std::call_once函数保证多个线程只执行一次</strong></p></li></ul><h3 id="call-once"><a href="#call-once" class="headerlink" title="call_once"></a>call_once</h3><ul><li>C++11 提出了call_once函数，我们可以配合一个局部的静态变量once_flag实现线程安全的初始化。</li><li>多线程调用call_once函数时，会判断once_flag是否被初始化，如没被初始化则进入初始化流程，调用我们提供的初始化函数。但是同一时刻只有一个线程能进入这个初始化函数。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingletonOnce</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">SingletonOnce</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">SingletonOnce</span>(<span class="type">const</span> SingletonOnce&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    SingletonOnce&amp; <span class="keyword">operator</span> = (<span class="type">const</span> SingletonOnce&amp; st) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="type">static</span> std::shared_ptr&lt;SingletonOnce&gt; _instance;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="function"><span class="type">static</span> std::shared_ptr&lt;SingletonOnce&gt; <span class="title">GetInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> std::once_flag s_flag;</span><br><span class="line">        std::<span class="built_in">call_once</span>(s_flag, [&amp;]() &#123;</span><br><span class="line">            _instance = std::<span class="built_in">shared_ptr</span>&lt;SingletonOnce&gt;(<span class="keyword">new</span> SingletonOnce);</span><br><span class="line">            &#125;);</span><br><span class="line">        <span class="keyword">return</span> _instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PrintAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; _instance.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">SingletonOnce</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;this is singleton destruct&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">std::shared_ptr&lt;SingletonOnce&gt; SingletonOnce::_instance = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestSingle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::this_thread::sleep_for(std::chrono::seconds(<span class="number">1</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">            SingletonOnce::GetInstance()-&gt;PrintAddress();    </span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::this_thread::sleep_for(std::chrono::seconds(<span class="number">1</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">            SingletonOnce::GetInstance()-&gt;PrintAddress();</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>为了使用单例类更通用，比如项目中使用多个单例类，可以通过继承实现多个单例类</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为了让单例更加通用，可以做成模板类</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&lt;T&gt;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&lt;T&gt;&amp; st) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="type">static</span> std::shared_ptr&lt;T&gt; _instance;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> std::shared_ptr&lt;T&gt; <span class="title">GetInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> std::once_flag s_flag;</span><br><span class="line">        std::<span class="built_in">call_once</span>(s_flag, [&amp;]() &#123;</span><br><span class="line">            _instance = std::<span class="built_in">shared_ptr</span>&lt;T&gt;(<span class="keyword">new</span> T);</span><br><span class="line">            &#125;);</span><br><span class="line">        <span class="keyword">return</span> _instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PrintAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; _instance.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Singleton</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;this is singleton destruct&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::shared_ptr&lt;T&gt; Singleton&lt;T&gt;::_instance = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//想使用单例类，可以继承上面的模板，我们在网络编程中逻辑单例类用的就是这种方式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LogicSystem</span> :<span class="keyword">public</span> Singleton&lt;LogicSystem&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&lt;LogicSystem&gt;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">LogicSystem</span>()&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">LogicSystem</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="总结1"><a href="#总结1" class="headerlink" title="总结1"></a>总结1</h3><ul><li>如果你只是实现一个简单的单例类推荐使用返回局部静态变量的方式</li><li>如果想大规模实现多个单例类可以用call_once实现的模板类。</li></ul><h2 id="C-11多线程同步"><a href="#C-11多线程同步" class="headerlink" title="C++11多线程同步"></a>C++11多线程同步</h2><ul><li>在多线程编程中，有许多情况需要线程之间的同步，比如你得先登录才能执行其他操作等情况，这可以通过<strong>std::future</strong>和<strong>std::promise</strong>来实现</li></ul><h3 id="使用future与promise"><a href="#使用future与promise" class="headerlink" title="使用future与promise"></a>使用future与promise</h3><ul><li><strong>std::future</strong>是一个对象，可以从某个对象或函数获取值，并在不同线程之间提供恰当的同步访问。</li><li><p><strong>std::promise</strong>是可以存储类型T的值的对象，该值可以被另一线程的std::future对象获取，并提供了同步机制。</p></li><li><p>简单来说就是，promise存储了一个在未来会改变其值（类型为T）的对象，并且在未来会改变该值，而future则存储一个已知其值在将来会改变的值，并且在该值改变后可以线程安全地读取。</p></li><li>这两一般配合使用,以下为<strong>线程间共享一个需要另一个线程设置变量时的代码</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(std::promise&lt;<span class="type">int</span>&gt; * pro)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread B&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">3</span>));</span><br><span class="line">    pro-&gt;<span class="built_in">set_value</span>(<span class="number">23</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_future</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::promise&lt;<span class="type">int</span>&gt; promObj;</span><br><span class="line">    <span class="comment">// 将promise&lt;T&gt;转成future&lt;T&gt;</span></span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; futObj = promObj.<span class="built_in">get_future</span>();</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(init, &amp;promObj)</span></span>;</span><br><span class="line">    <span class="comment">// 只有在promise被设置值的时候这个才不会被阻塞，否则就会一直阻塞直到设置值为止</span></span><br><span class="line">    std::cout &lt;&lt; futObj.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>future与promise的关系</strong>：promise就相当于生产者生成的一个东西，消费者通过把它转换为future来读取这个东西，也就是说生产者线程可以使用 std::promise 设置异步任务的结果，而消费者线程可以通过 std::future 等待异步任务的完成并获取结果</p></li><li><p>实现线程间的同步操作</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">loginSrv</span><span class="params">(std::promise&lt;<span class="type">bool</span>&gt; * promObj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread B&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 模拟登录操作，假设登录成功</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">3</span>));</span><br><span class="line">    promObj-&gt;<span class="built_in">set_value</span>(<span class="literal">true</span>); <span class="comment">// 设置登录结果为 true</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::promise&lt;<span class="type">bool</span>&gt; promiseObj;</span><br><span class="line">    std::future&lt;<span class="type">bool</span>&gt; futureObj = promiseObj.<span class="built_in">get_future</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::thread <span class="title">th</span><span class="params">(loginSrv, &amp;promiseObj)</span></span>; <span class="comment">// 启动线程B</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 等待登录结果，最多等待10秒</span></span><br><span class="line">    <span class="keyword">auto</span> status = futureObj.<span class="built_in">wait_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">10</span>));</span><br><span class="line">    <span class="keyword">if</span> (status == std::future_status::ready) &#123;</span><br><span class="line">        <span class="comment">// 异步操作已完成</span></span><br><span class="line">        <span class="keyword">if</span> (futureObj.<span class="built_in">get</span>()) &#123;</span><br><span class="line">            <span class="comment">// 登录成功</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Login succeeded!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="comment">// 进行登录成功后的操作</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 登录失败</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Login failed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="comment">// 进行登录失败后的操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == std::future_status::timeout) &#123;</span><br><span class="line">        <span class="comment">// 超时未登录成功</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Timeout! Login failed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 进行超时后的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    th.<span class="built_in">join</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>future对象的<strong>wait_for函数</strong>会<strong>阻塞</strong>等待结果变得可用，可用的标志为以下两种情况之一：</p></li><li><p>设置的时间超时</p></li><li><p>共享对象的状态变为ready</p></li><li><p>原型如下:</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Rep, <span class="keyword">class</span> Period &gt;</span></span><br><span class="line"><span class="function">std::future_status <span class="title">wait_for</span><span class="params">( <span class="type">const</span> std::chrono::duration&lt;Rep,Period&gt;&amp; timeout_duration )</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>返回值标识了结果的状态，为：</p><ol><li>future_status::deferred ：计算结果的函数未启动</li><li>future_status::ready：结果ready</li><li>future_status::timeout：超时</li></ol></li></ul><h3 id="使用条件变量来实现同步"><a href="#使用条件变量来实现同步" class="headerlink" title="使用条件变量来实现同步"></a>使用条件变量来实现同步</h3><ul><li>当某个线程的执行需要另一个线程完成后才能进行，可以使用条件变量(condition_variable)。</li><li><p>也可以把它理解为信号通知机制，一个线程负责发送信号，其他线程等待该信号的触发,condition_variable 存在一些问题，如虚假唤醒</p></li><li><p><strong>通知方</strong></p></li><li><p>获取 std::mutex, 通常是 std::lock_guard</p></li><li>修改共享变量（即使共享变量是原子变量，也需要在互斥对象内进行修改，以保证正确地将修改发布到等待线程）</li><li><p>在 condition_variable 上执行 notify_one/notify_all 通知条件变量（该操作不需要锁）</p></li><li><p><strong>等待方</strong></p></li><li><p>获取相同的std::mutex，使用std::unique_lock</p></li><li>执行wait，wait_for或wait_until(该操作会自动释放锁并阻塞)</li><li><p>接收到条件变量通知、超时或者发生虚假唤醒时，线程被唤醒，并自动获取锁。唤醒的线程负责检查共享变量，如果是虚假唤醒，则应继续等待</p></li><li><p><strong>注意：</strong> </p><ol><li>std :: condition_variable仅适用于 std::unique_lock, 此限制允许在某些平台上获得最大效率。 </li><li>std :: condition_variable_any提供可与任何BasicLockable对象一起使用的条件变量，例如std :: shared_lock。</li></ol></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">std::mutex mtx_num;</span><br><span class="line">std::condition_variable cvA;</span><br><span class="line">std::condition_variable cvB;</span><br><span class="line"><span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ResonableImplemention</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span> (; ;) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::unique_lock&lt;std::mutex&gt; lock(mtx_num);</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="comment">//方法一</span></span></span></span><br><span class="line"><span class="params"><span class="function">            cvA.wait(lock, []() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">return</span> num == <span class="number">1</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">                &#125;);</span></span></span><br><span class="line"><span class="params"><span class="function">            num++;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::cout &lt;&lt; <span class="string">&quot;thread A point 1......&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">            cvB.notify_one();</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">     &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span> (;;) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::unique_lock&lt;std::mutex&gt; lock(mtx_num);</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="comment">//方法二</span></span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">while</span> (num != <span class="number">2</span>) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                cvB.wait(lock);</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">            num--;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::cout &lt;&lt; <span class="string">&quot;thread B point 2.......&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">            cvA.notify_one();</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="利用条件变量实现线程安全队列"><a href="#利用条件变量实现线程安全队列" class="headerlink" title="利用条件变量实现线程安全队列"></a>利用条件变量实现线程安全队列</h2><ul><li>如何让线程按一定顺序执行，也就是说如何控制并发的同步操作？可以用一个变量num 当num为1，执行线程A，当num为2执行线程B, 如果当num为1时碰到了线程B 就直接让线程b睡一会，实现大概如下：</li></ul><h3 id="不良实现"><a href="#不良实现" class="headerlink" title="不良实现"></a>不良实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PoorImpleman</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span> (;;) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                std::lock_guard&lt;std::mutex&gt; lock(mtx_num);</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">if</span> (num == <span class="number">1</span>) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                    std::cout &lt;&lt; <span class="string">&quot;thread A print 1.....&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">                    num++;</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">continue</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">                &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::this_thread::sleep_for(std::chrono::milliseconds(<span class="number">500</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">     &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span> (;;) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                std::lock_guard&lt;std::mutex&gt; lock(mtx_num);</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">if</span> (num == <span class="number">2</span>) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                    std::cout &lt;&lt; <span class="string">&quot;thread B print 2.....&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">                    num--;</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">continue</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">                &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::this_thread::sleep_for(std::chrono::milliseconds(<span class="number">500</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>PoorImpleman虽然能实现我们交替打印的功能，会造成消息处理的不及时，因为线程A要循环检测num值，如果num不为1，则线程A就睡眠了，在线程A睡眠这段时间很可能B已经处理完打印了，此时A还在睡眠，是对资源的浪费，也错过了最佳的处理时机。</li></ul><h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">std::mutex mtx_num;</span><br><span class="line">std::condition_variable cvA;</span><br><span class="line">std::condition_variable cvB;</span><br><span class="line"><span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ResonableImplemention</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span> (; ;) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::unique_lock&lt;std::mutex&gt; lock(mtx_num);</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="comment">//方法一</span></span></span></span><br><span class="line"><span class="params"><span class="function">            cvA.wait(lock, []() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">return</span> num == <span class="number">1</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">                &#125;);</span></span></span><br><span class="line"><span class="params"><span class="function">            num++;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::cout &lt;&lt; <span class="string">&quot;thread A point 1......&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">            cvB.notify_one();</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">     &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span> (;;) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::unique_lock&lt;std::mutex&gt; lock(mtx_num);</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="comment">//方法二</span></span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">while</span> (num != <span class="number">2</span>) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                cvB.wait(lock);</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">            num--;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::cout &lt;&lt; <span class="string">&quot;thread B point 2.......&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">            cvA.notify_one();</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当条件不满足时(num 不等于1 时)cvA.wait就会挂起，等待线程B通知通知线程A唤醒，线程B采用的是cvA.notifyone。</li><li>这么做的好处就是线程交替处理非常及时。比起sleep的方式，我们可以从控制台上看出差异效果，sleep的方式看出日志基本是每隔1秒才打印一次，效率不高。</li></ul><h3 id="实现安全队列"><a href="#实现安全队列" class="headerlink" title="实现安全队列"></a>实现安全队列</h3><ul><li>之前我们实现过线程安全的栈，对于pop操作，我们如果在线程中调用empty判断是否为空，如果不为空，则pop，因为empty和pop内部分别加锁，是两个原子操作，导致pop时可能会因为其他线程提前pop导致队列为空，从而引发崩溃。我们当时的处理方式是实现了两个版本的pop，一种是返回智能指针类型，一种通过参数为引用的方式返回。对于智能指针版本我们发现队列为空则返回空指针，对于引用版本，发现队列为空则抛出异常，这么做并不是很友好，所以我们可以通过条件变量完善之前的程序，不过这次我们重新实现一个线程安全队列。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadsafe_queue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">threadsafe_queue</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">threadsafe_queue</span>(<span class="type">const</span> threadsafe_queue&amp; q) &#123;</span><br><span class="line">        <span class="comment">//防止拷贝构造的时候被拷贝对象执行了其他操作</span></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(q.mtx)</span></span>;</span><br><span class="line">        tq = q.tq;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">threadsafe_queue</span>(<span class="type">const</span> threadsafe_queue&amp;&amp; q) &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(q.mtx)</span></span>;</span><br><span class="line">        tq = std::<span class="built_in">move</span>(q.tq);</span><br><span class="line">    &#125;</span><br><span class="line">    threadsafe_queue&lt;T&gt;&amp; <span class="keyword">operator</span> = (<span class="type">const</span> threadsafe_queue &amp; q)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;q) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(q.mtx)</span></span>;</span><br><span class="line">        tq = q.tq;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    threadsafe_queue&lt;T&gt;&amp; <span class="keyword">operator</span> = (<span class="type">const</span> threadsafe_queue&amp;&amp; q) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;q) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(q.mtx)</span></span>;</span><br><span class="line">        tq = std::<span class="built_in">move</span>(q.tq);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T value)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        tq.<span class="built_in">push</span>(value);</span><br><span class="line">        <span class="comment">//加入这条语句是为了让其他因为队列为空而挂起的线程继续执行</span></span><br><span class="line">        cvA.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wait_and_pop</span><span class="params">(T&amp; value)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        <span class="comment">//[this] 就是捕获这个类 使得lambda表达式可以使用该类的所有函数</span></span><br><span class="line">        cvA.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]() &#123;<span class="keyword">return</span> !tq.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line">        <span class="comment">// 只有一次拷贝</span></span><br><span class="line">        value = tq.<span class="built_in">front</span>();</span><br><span class="line">        tq.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">wait_and_pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        cvA.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]() &#123;<span class="keyword">return</span> !tq.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line">        std::shared_ptr&lt;T&gt; res = std::<span class="built_in">make_shared</span>&lt;T&gt;(tq.<span class="built_in">front</span>());</span><br><span class="line">        tq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">try_pop</span><span class="params">(T&amp; value)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (tq.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        value = tq.<span class="built_in">front</span>();</span><br><span class="line">        tq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">try_pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (tq.<span class="built_in">empty</span>()) <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;T&gt;();</span><br><span class="line">        std::shared_ptr&lt;T&gt; res = std::<span class="built_in">make_shared</span>&lt;T&gt;(tq.<span class="built_in">front</span>());</span><br><span class="line">        tq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span><span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> tq.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> std::mutex mtx;</span><br><span class="line">    std::condition_variable cvA;</span><br><span class="line">    std::queue&lt;T&gt; tq;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_safe_que</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    threadsafe_queue&lt;<span class="type">int</span>&gt;  safe_que;</span><br><span class="line">    std::mutex  mtx_print;</span><br><span class="line">    <span class="function">std::thread <span class="title">producer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        [&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; ; i++) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                safe_que.push(i);</span></span></span><br><span class="line"><span class="params"><span class="function">                &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="comment">// 为了打印完整一行</span></span></span></span><br><span class="line"><span class="params"><span class="function">                    std::lock_guard&lt;std::mutex&gt; printlk(mtx_print);</span></span></span><br><span class="line"><span class="params"><span class="function">                    std::cout &lt;&lt; <span class="string">&quot;producer push data is &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">                &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">                std::this_thread::sleep_for(std::chrono::milliseconds(<span class="number">200</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">consumer1</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        [&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">for</span> (;;) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">auto</span> data = safe_que.wait_and_pop();</span></span></span><br><span class="line"><span class="params"><span class="function">                &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                    std::lock_guard&lt;std::mutex&gt; printlk(mtx_print);</span></span></span><br><span class="line"><span class="params"><span class="function">                    std::cout &lt;&lt; <span class="string">&quot;consumer1 wait and pop data is &quot;</span> &lt;&lt; *data &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">                &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">                std::this_thread::sleep_for(std::chrono::milliseconds(<span class="number">500</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">consumer2</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        [&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">for</span> (;;) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">auto</span> data = safe_que.try_pop();</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">if</span> (data != <span class="literal">nullptr</span>) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                    &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                        std::lock_guard&lt;std::mutex&gt; printlk(mtx_print);</span></span></span><br><span class="line"><span class="params"><span class="function">                        std::cout &lt;&lt; <span class="string">&quot;consumer2 try_pop data is &quot;</span> &lt;&lt; *data &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">                    &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">                &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">                std::this_thread::sleep_for(std::chrono::milliseconds(<span class="number">500</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line">    producer.<span class="built_in">join</span>();</span><br><span class="line">    consumer<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    consumer<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>我们可以启动三个线程，一个producer线程用来向队列中放入数据。一个consumer1线程用来阻塞等待pop队列中的元素。</p></li><li><p>另一个consumer2尝试从队列中pop元素，如果队列为空则直接返回，如果非空则pop元素。</p></li><li><p>打印时为了保证线程输出在屏幕上不会乱掉，所以加了锁保证互斥输出</p></li></ul><h2 id="并发三剑客async-promise-future"><a href="#并发三剑客async-promise-future" class="headerlink" title="并发三剑客async,promise,future"></a>并发三剑客async,promise,future</h2><h3 id="async用法"><a href="#async用法" class="headerlink" title="async用法"></a>async用法</h3><ul><li>std::async 是一个用于异步执行函数的模板函数，它返回一个 std::future 对象，该对象用于获取函数的返回值。</li><li>以下是一个使用 std::async 的示例：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="comment">// 定义一个异步任务</span></span><br><span class="line"><span class="function">std::string <span class="title">fetchDataFromDB</span><span class="params">(std::string query)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 模拟一个异步任务，比如从数据库中获取数据</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Data: &quot;</span> + query;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 std::async 异步调用 fetchDataFromDB</span></span><br><span class="line">    std::future&lt;std::string&gt; resultFromDB = std::<span class="built_in">async</span>(std::launch::async, fetchDataFromDB, <span class="string">&quot;Data&quot;</span>);</span><br><span class="line">    <span class="comment">// 在主线程中做其他事情</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Doing something else...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 从 future 对象中获取数据</span></span><br><span class="line">    std::string dbData = resultFromDB.<span class="built_in">get</span>();</span><br><span class="line">    std::cout &lt;&lt; dbData &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在这个示例中，<strong>std::async</strong> 创建了一个新的线程（或从内部线程池中挑选一个线程）并自动与一个 <strong>std::promise</strong>对象相关联。<strong>std::promise</strong> 对象被传递给 <strong>fetchDataFromDB</strong> 函数，函数的返回值被存储在 <strong>std::future</strong> 对象中。在主线程中，我们可以使用 <strong>std::future::get</strong> 方法从 <strong>std::future</strong> 对象中获取数据。<strong><em>注意</em></strong>，在使用 <strong>std::async</strong> 的情况下，我们必须使用 <strong>std::launch::async</strong> 标志来明确表明我们希望函数异步执行</li></ul><h4 id="async的启动策略"><a href="#async的启动策略" class="headerlink" title="async的启动策略"></a>async的启动策略</h4><ul><li><p>std::async函数可以接受几个不同的启动策略，这些策略在std::launch枚举中定义。除了std::launch::async之外，还有以下启动策略：</p><ol><li>std::launch::deferred：这种策略意味着任务将在调用std::future::get()或std::future::wait()函数时延迟执行。换句话说，任务将在需要结果时同步执行。</li><li>std::launch::async | std::launch::deferred：这种策略是上面两个策略的组合。任务可以在一个单独的线程上异步执行，也可以延迟执行，具体取决于实现。</li></ol></li><li>默认情况下，std::async使用std::launch::async | std::launch::deferred策略。这意味着任务可能异步执行，也可能延迟执行，具体取决于实现。需要注意的是，不同的编译器和操作系统可能会有不同的默认行为。</li></ul><h3 id="future的wait和get"><a href="#future的wait和get" class="headerlink" title="future的wait和get"></a>future的wait和get</h3><ul><li>std::future::get() 和 std::future::wait() 是 C++ 中用于处理异步任务的两个方法，它们的功能和用法有一些重要的区别。</li></ul><ol><li>std::future::get():<ul><li>std::future::get() 是一个阻塞调用，用于获取 std::future 对象表示的值或异常。如果异步任务还没有完成，get() 会阻塞当前线程，直到任务完成。如果任务已经完成，get() 会立即返回任务的结果。重要的是，get() 只能调用一次，因为它会移动或消耗掉 std::future 对象的状态。一旦 get() 被调用，std::future 对象就不能再被用来获取结果。</li></ul></li><li>std::future::wait():<ul><li>std::future::wait() 也是一个阻塞调用，但它与 get() 的主要区别在于 wait() 不会返回任务的结果。它只是等待异步任务完成。如果任务已经完成，wait() 会立即返回。如果任务还没有完成，wait() 会阻塞当前线程，直到任务完成。与 get() 不同，wait() 可以被多次调用，它不会消耗掉 std::future 对象的状态。</li></ul></li></ol><ul><li>总结下这两个方法的主要区别：<ol><li>std::future::get() 用于获取并返回任务的结果，而 std::future::wait() 只是等待任务完成</li><li>get() 只能调用一次，而 wait() 可以被多次调用。</li><li>如果任务还没有完成，get() 和 wait() 都会阻塞当前线程，但 get() 会一直阻塞直到任务完成并返回结果，而 wait() 只是在等待任务完成。</li></ol></li><li>可以使用std::future的wait_for()或wait_until()方法来检查异步操作是否已完成。这些方法返回一个表示操作状态的std::future_status值。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(fut.<span class="built_in">wait_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>)) == std::future_status::ready)&#123;</span><br><span class="line">    <span class="comment">//操作已完成</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//操作失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="将任务和future关联（paskaged-task）"><a href="#将任务和future关联（paskaged-task）" class="headerlink" title="将任务和future关联（paskaged_task）"></a>将任务和future关联（paskaged_task）</h3><ul><li>std::packaged_task和std::future是C++11中引入的两个类，它们用于处理异步任务的结果。</li><li>std::packaged_task是一个可调用目标，它包装了一个任务，该任务可以在另一个线程上运行。它可以捕获任务的返回值或异常，并将其存储在std::future对象中，以便以后使用。</li><li>std::future代表一个异步操作的结果。它可以用于从异步任务中获取返回值或异常。</li><li>以下是使用std::packaged_task和std::future的基本步骤：<ol><li>创建一个std::packaged_task对象，该对象包装了要执行的任务。</li><li>调用std::packaged_task对象的get_future()方法，该方法返回一个与任务关联的std::future对象。</li><li>在另一个线程上调用std::packaged_task对象的operator()，以执行任务。</li><li>在需要任务结果的地方，调用与任务关联的std::future对象的get()方法，以获取任务的返回值或异常</li></ol></li><li>以下是一个简单的示例代码</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">my_task</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;my task run 5 s&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_package</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个包装了任务的 std::packaged_task 对象  </span></span><br><span class="line">    <span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">()</span>&gt; <span class="title">task</span><span class="params">(my_task)</span></span>;</span><br><span class="line">    <span class="comment">// 获取与任务关联的 std::future 对象  </span></span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; result = task.<span class="built_in">get_future</span>();</span><br><span class="line">    <span class="comment">// 在另一个线程上执行任务  </span></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(std::move(task))</span></span>;</span><br><span class="line">    t.<span class="built_in">detach</span>(); <span class="comment">// 将线程与主线程分离，以便主线程可以等待任务完成  </span></span><br><span class="line">    <span class="comment">// 等待任务完成并获取结果  </span></span><br><span class="line">    <span class="type">int</span> value = result.<span class="built_in">get</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The result is: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>在上面的示例中，我们创建了一个包装了任务的std::packaged_task对象，并获取了与任务关联的std::future对象。然后，我们在另一个线程上执行任务，并等待任务完成并获取结果。最后，我们输出结果。</p></li><li><p>我们可以使用 std::function 和 std::package_task 来包装带参数的函数。std::package_task 是一个模板类，它包装了一个可调用对象，并允许我们将其作为异步任务传递。</p></li><li><p><strong>注意</strong>在传入package_task对象给线程的时候，一定要使用<strong>std::move</strong>函数</p></li></ul><h3 id="promise的用法"><a href="#promise的用法" class="headerlink" title="promise的用法"></a>promise的用法</h3><ul><li>C++11引入了std::promise和std::future两个类，用于实现异步编程。std::promise用于在某一线程中设置某个值或异常，而std::future则用于在另一线程中获取这个值或异常。</li><li>下面是std::promise的基本用法：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_value</span><span class="params">(std::promise&lt;<span class="type">int</span>&gt; prom)</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">3</span>));</span><br><span class="line">    <span class="comment">// 设置 promise 的值</span></span><br><span class="line">    prom.<span class="built_in">set_value</span>(<span class="number">10</span>);</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;value set success&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;子线程执行完毕&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_promise</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 promise 对象</span></span><br><span class="line">    std::promise&lt;<span class="type">int</span>&gt; prom;</span><br><span class="line">    <span class="comment">// 获取与 promise 相关联的 future 对象</span></span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; fut = prom.<span class="built_in">get_future</span>();</span><br><span class="line">    <span class="comment">// 在新线程中设置 promise 的值,传入参数的时候一定要使用move</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(set_value, std::move(prom))</span></span>;</span><br><span class="line">    <span class="comment">//在主线程中获取future的值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Waiting for the thread to set the value...\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value set by the thread: &quot;</span> &lt;&lt; fut.<span class="built_in">get</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>程序输出</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Waiting <span class="keyword">for</span> the thread to set the value...</span><br><span class="line">Value set by the thread: <span class="number">10</span></span><br><span class="line">value set success</span><br><span class="line">子线程执行完毕</span><br></pre></td></tr></table></figure><ul><li>在上面的代码中，我们首先创建了一个std::promise<int>对象，然后通过调用get_future()方法获取与之相关联的std::future<int>对象。然后，我们在新线程中通过调用set_value()方法设置promise的值，并在主线程中通过调用fut.get()方法获取这个值。注意，在调用fut.get()方法时，如果promise的值还没有被设置，则该方法会阻塞当前线程，直到值被设置为止。</li><li><p><strong>注意</strong>promise的值被设置后就可以被get，而不需要等待子线程执行完成才能get，这个就是和前面package_task的区别之一</p></li><li><p>除了set_value()方法外，std::promise还有一个set_exception()方法，用于设置异常。该方法接受一个std::exception_ptr参数，该参数可以通过调用std::current_exception()方法获取。</p></li><li>下面是一个例子：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_exception</span><span class="params">(std::promise&lt;<span class="type">void</span>&gt; prom)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//抛出一个异常</span></span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;An error occurred!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">        <span class="comment">//设置 promise的异常</span></span><br><span class="line">        prom.<span class="built_in">set_exception</span>(std::<span class="built_in">current_exception</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_promise_exception</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::promise&lt;<span class="type">void</span>&gt; prom;</span><br><span class="line">    std::future&lt;<span class="type">void</span>&gt; fut = prom.<span class="built_in">get_future</span>();</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(set_exception, std::move(prom))</span></span>;</span><br><span class="line">    <span class="comment">// 在主线程中获取 future 的异常</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Waiting for the thread to set the exception...\n&quot;</span>;</span><br><span class="line">        fut.<span class="built_in">get</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Exception set by the thread: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;hello world!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>子线程抛出了异常一定要在主线程里也捕获异常</p></li><li><p>当然我们使用promise时要注意一点，如果promise被释放了，而其他的线程还未使用与promise关联的future，当其使用这个future时会报错。</p></li></ul><h3 id="共享类型的future"><a href="#共享类型的future" class="headerlink" title="共享类型的future"></a>共享类型的future</h3><ul><li>当我们需要多个线程等待同一个执行结果时，需要使用std::shared_future</li><li>以下是一个适合使用std::shared_future的场景，多个线程等待同一个异步操作的结果：</li><li>假设你有一个异步任务，需要多个线程等待其完成，然后这些线程需要访问任务的结果。在这种情况下，你可以使用std::shared_future来共享异步任务的结果。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">(std::promise&lt;<span class="type">int</span>&gt;&amp;&amp; promise)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 模拟一些工作</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    promise.<span class="built_in">set_value</span>(<span class="number">42</span>); <span class="comment">// 设置 promise 的值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">(std::shared_future&lt;<span class="type">int</span>&gt; future)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> result = future.<span class="built_in">get</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> std::future_error&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Future error: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_shared_future</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::promise&lt;<span class="type">int</span>&gt; promise;</span><br><span class="line">    std::shared_future&lt;<span class="type">int</span>&gt; future = promise.<span class="built_in">get_future</span>();</span><br><span class="line">    <span class="function">std::thread <span class="title">myThread1</span><span class="params">(myFunction, std::move(promise))</span></span>; <span class="comment">// 将 promise 移动到线程中</span></span><br><span class="line">    <span class="comment">// 使用 share() 方法获取新的 shared_future 对象  </span></span><br><span class="line">    <span class="function">std::thread <span class="title">myThread2</span><span class="params">(threadFunction, future)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">myThread3</span><span class="params">(threadFunction, future)</span></span>;</span><br><span class="line">    myThread<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    myThread<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    myThread<span class="number">3.</span><span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在这个示例中，我们创建了一个std::promise<int>对象promise和一个与之关联的std::shared_future<int>对象future。然后，我们将promise对象移动到另一个线程myThread1中，该线程将执行myFunction函数，并在完成后设置promise的值。我们还创建了两个线程myThread2和myThread3，它们将等待future对象的结果。如果myThread1成功地设置了promise的值，那么future.get()将返回该值。这些线程可以同时访问和等待future对象的结果，而不会相互干扰。</li><li>但是大家要注意，如果一个future被移动给两个shared_future是错误的。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_shared_future_error</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::promise&lt;<span class="type">int</span>&gt; promise;</span><br><span class="line">    std::shared_future&lt;<span class="type">int</span>&gt; future = promise.<span class="built_in">get_future</span>();</span><br><span class="line">    <span class="function">std::thread <span class="title">myThread1</span><span class="params">(myFunction, std::move(promise))</span></span>; <span class="comment">// 将 promise 移动到线程中</span></span><br><span class="line">    <span class="function">std::thread <span class="title">myThread2</span><span class="params">(threadFunction, std::move(future))</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">myThread3</span><span class="params">(threadFunction, std::move(future))</span></span>;</span><br><span class="line">    myThread<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    myThread<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    myThread<span class="number">3.</span><span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这种用法是错误的，一个future通过隐式构造传递给shared_future之后，这个shared_future被移动传递给两个线程是不合理的，因为第一次移动后shared_future的生命周期被转移了，接下来myThread3构造时用的std::move(future)future已经失效了，会报错，一般都是no state 之类的错误。</li></ul><h3 id="异常处理1"><a href="#异常处理1" class="headerlink" title="异常处理1"></a>异常处理1</h3><ul><li>std::future 是C++的一个模板类，它用于表示一个可能还没有准备好的异步操作的结果。你可以通过调用 std::future::get 方法来获取这个结果。如果在获取结果时发生了异常，那么 std::future::get 会重新抛出这个异常。</li></ul><p>以下是一个例子，演示了如何在 std::future 中获取异常：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">may_throw</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这里我们抛出一个异常。在实际的程序中，这可能在任何地方发生。</span></span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Oops, something went wrong!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个异步任务</span></span><br><span class="line">    <span class="function">std::future&lt;<span class="type">void</span>&gt; <span class="title">result</span><span class="params">(std::async(std::launch::async, may_throw))</span></span>;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取结果（如果在获取结果时发生了异常，那么会重新抛出这个异常）</span></span><br><span class="line">        result.<span class="built_in">get</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> std::exception &amp;e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 捕获并打印异常</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Caught exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在这个例子中，我们创建了一个异步任务 may_throw，这个任务会抛出一个异常。然后，我们创建一个 std::future 对象 result 来表示这个任务的结果。在 main 函数中，我们调用 result.get() 来获取任务的结果。如果在获取结果时发生了异常，那么 result.get() 会重新抛出这个异常，然后我们在 catch 块中捕获并打印这个异常。</li></ul><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><ul><li><p>我们可以利用上面提到的std::packaged_task和std::promise构建线程池，提高程序的并发能力。<br>先了解什么是线程池：</p></li><li><p><strong>线程池</strong>是一种多线程处理形式，它处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。线程池线程都是后台线程。每个线程都使用默认的堆栈大小，以默认的优先级运行，并处于多线程单元中。如果某个线程在托管代码中空闲（如正在等待某个事件）,则线程池将插入另一个辅助线程来使所有处理器保持繁忙。如果所有线程池线程都始终保持繁忙，但队列中包含挂起的工作，则线程池将在一段时间后创建另一个辅助线程但线程的数目永远不会超过最大值。超过最大值的线程可以排队，但他们要等到其他线程完成后才启动。</p></li></ul><p>-<strong>线程池</strong>可以避免在处理短时间任务时创建与销毁线程的代价，它维护着多个线程，等待着监督管理者分配可并发执行的任务，从而提高了整体性能。</p><ul><li><strong>线程池注意事项</strong></li><li>保证并发，且执行时无序的（可以用线程池）</li><li>互斥性很大，强关联（不能用线程池）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Task = std::packaged_task&lt;<span class="built_in">void</span>()&gt;;</span><br><span class="line">    ~<span class="built_in">ThreadPool</span>() &#123;</span><br><span class="line">        <span class="built_in">stop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> ThreadPool&amp; <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> ThreadPool ins;</span><br><span class="line">        <span class="keyword">return</span> ins;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回一个future，将一个可调用函数封装成无参数无返回值类型</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">F</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">commit</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span> -&gt; std::future&lt;<span class="title">decltype</span><span class="params">(f(args...))</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> RetType = <span class="keyword">decltype</span>(<span class="built_in">f</span>(args...));</span><br><span class="line">        <span class="keyword">if</span> (stop_.<span class="built_in">load</span>()) <span class="keyword">return</span> std::future&lt;RetType&gt;&#123;&#125;;</span><br><span class="line">        <span class="comment">// 打包一个无参数的可调用函数</span></span><br><span class="line">        <span class="keyword">auto</span> task = std::make_shared&lt;std::packaged_task&lt;<span class="built_in">RetType</span>()&gt;&gt;(</span><br><span class="line">            <span class="comment">//重新绑定可调用函数，让有参形式变得无参</span></span><br><span class="line">            std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...));</span><br><span class="line">        <span class="comment">/*auto task = std::make_shared&lt;std::packaged_task&lt;RetType()&gt;&gt;(</span></span><br><span class="line"><span class="comment">            std::bind(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...));*/</span></span><br><span class="line">        std::future&lt;RetType&gt; ret = task-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//由于队列被多线程共享所以需要互斥添加</span></span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">cv_mt</span><span class="params">(cv_mt_)</span></span>;</span><br><span class="line">            <span class="comment">//调用packaged_task的operator()让有返回值函数变为无返回值</span></span><br><span class="line">            tasks_.<span class="built_in">emplace</span>([task] &#123;(*task)(); &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//通知被阻塞的线程</span></span><br><span class="line">        cv_lock_.<span class="built_in">notify_one</span>();</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">idleThreadCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> thread_nums_;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="type">const</span> ThreadPool&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    ThreadPool&amp; <span class="keyword">operator</span>=(<span class="type">const</span> ThreadPool&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="type">unsigned</span> <span class="type">int</span> num = <span class="number">5</span>): <span class="built_in">stop_</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">1</span>) thread_nums_ = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> thread_nums_ = num;</span><br><span class="line">        <span class="built_in">start</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建num个线程</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; thread_nums_; i++) &#123;</span><br><span class="line">            pool_.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>]() &#123;</span><br><span class="line">                <span class="keyword">while</span> (!stop_.<span class="built_in">load</span>()) &#123;</span><br><span class="line">                    Task task;</span><br><span class="line">                    &#123;</span><br><span class="line">                        std::unique_lock&lt;std::mutex&gt; <span class="built_in">cv_mt</span>(cv_mt_);</span><br><span class="line">                        <span class="keyword">this</span>-&gt;cv_lock_.<span class="built_in">wait</span>(cv_mt, [<span class="keyword">this</span>] &#123;<span class="keyword">return</span> <span class="keyword">this</span>-&gt;stop_.<span class="built_in">load</span>() || !<span class="keyword">this</span>-&gt;tasks_.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line">                        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;tasks_.<span class="built_in">empty</span>()) <span class="keyword">return</span>;</span><br><span class="line">                        <span class="comment">//因为package_task里需要右值</span></span><br><span class="line">                        task = std::<span class="built_in">move</span>(<span class="keyword">this</span>-&gt;tasks_.<span class="built_in">front</span>());</span><br><span class="line">                        <span class="comment">//首先++,--操作是原子操作其次它是在构造函数里进行的，不存在创建线程的时候thread_nums_变化</span></span><br><span class="line">                        <span class="keyword">this</span>-&gt;tasks_.<span class="built_in">pop</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">this</span>-&gt;thread_nums_--;</span><br><span class="line">                    <span class="built_in">task</span>();</span><br><span class="line">                    <span class="keyword">this</span>-&gt;thread_nums_++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stop_.<span class="built_in">store</span>(<span class="literal">true</span>);</span><br><span class="line">        cv_lock_.<span class="built_in">notify_all</span>();</span><br><span class="line">        <span class="comment">// 当线程还没执行完任务时让他先执行完</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; td : pool_) &#123;</span><br><span class="line">            <span class="keyword">if</span> (td.<span class="built_in">joinable</span>()) &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;join thread &quot;</span> &lt;&lt; td.<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">                td.<span class="built_in">join</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::mutex cv_mt_;</span><br><span class="line">    std::condition_variable cv_lock_;</span><br><span class="line">    <span class="comment">//表示线程池的启动状态,false表示启动</span></span><br><span class="line">    std::atomic_bool stop_;</span><br><span class="line">    <span class="comment">//表示线程池的线程数量</span></span><br><span class="line">    std::atomic_int thread_nums_;</span><br><span class="line">    <span class="comment">//任务队列</span></span><br><span class="line">    std::queue&lt;Task&gt; tasks_;</span><br><span class="line">    <span class="comment">//存放预先创建好的线程</span></span><br><span class="line">    std::vector&lt;std::thread&gt; pool_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; tp = ThreadPool::<span class="built_in">getInstance</span>();</span><br><span class="line">    <span class="type">int</span> m = <span class="number">0</span>;</span><br><span class="line">    tp.<span class="built_in">commit</span>([](<span class="type">int</span>&amp; m) &#123;</span><br><span class="line">        m = <span class="number">1024</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;inner set m is &quot;</span> &lt;&lt; m &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;m address is &quot;</span> &lt;&lt; &amp;m &lt;&lt; std::endl;</span><br><span class="line">     &#125;, m);</span><br><span class="line">    tp.<span class="built_in">commit</span>([](<span class="type">int</span>&amp; m) &#123;</span><br><span class="line">        m = <span class="number">1024</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;inner set m is &quot;</span> &lt;&lt; m &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;m address is &quot;</span> &lt;&lt; &amp;m &lt;&lt; std::endl;</span><br><span class="line">    &#125;, std::<span class="built_in">ref</span>(m));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="两种并发设计模式"><a href="#两种并发设计模式" class="headerlink" title="两种并发设计模式"></a>两种并发设计模式</h2><h3 id="Actor设计模式"><a href="#Actor设计模式" class="headerlink" title="Actor设计模式"></a>Actor设计模式</h3><ul><li>简单点说，actor通过消息传递的方式与外界通信。消息传递是异步的。每个actor都有一个邮箱，该邮箱接收并缓存其他actor发过来的消息，actor一次只能同步处理一个消息，处理消息过程中，除了可以接收消息，不能做任何其他操作。<br>每一个类独立在一个线程里称作Actor，Actor之间通过队列通信，比如Actor1 发消息给Actor2， Actor2 发消息给Actor1都是投递到对方的队列中。好像给对方发邮件，对方从邮箱中取出一样。如下图：</li></ul><p><img src="../assets/并发编程/image.png" alt="示例图片" style="zoom:100%;" /></p><ul><li>Actor模型的另一个好处就是可以消除共享状态，因为它每次只能处理一条消息，所以actor内部可以安全的处理状态，而不用考虑锁机制。</li></ul><p><img src="../assets/并发编程/image-1.png" alt="示例图片" style="zoom:100%;" /></p><ul><li><p>我们在网络编程中对于逻辑层的处理就采用了将要处理的逻辑消息封装成包投递给逻辑队列，逻辑类从队列中消费的思想，其实就是一种Actor设计模式。Erlang是天然支持Actor的语言。</p></li><li><p><strong>应用场景</strong>：<br>一个游戏有很多地图，每个地图都由一个独立的线程管理，在每个地图上都能购物，如果只有一个购物类给其他线程提供购物接口，其他线程调用找个接口，为了考虑线程安全性就得考虑频繁加锁，并且如果购物类崩了，就会导致用到这个接口的所有线程都会崩，所以可以采用Actor设计模式，将一个购物类安排在一个线程里，并且它有一个线程安全队列来接受购物请求，其他线程需要购物的时往这个队列加入请求，购物类消费请求，这样就可以做到解耦，并且如果购物类崩了很容易排查</p></li></ul><h3 id="CSP模式"><a href="#CSP模式" class="headerlink" title="CSP模式"></a>CSP模式</h3><ul><li><p>SP 是 Communicating Sequential Process 的简称，中文可以叫做通信顺序进程，是一种并发编程模型，是一个很强大的并发数据模型，是上个世纪七十年代提出的，用于描述两个独立的并发实体通过共享的通讯 channel(管道)进行通信的并发模型。相对于Actor模型，CSP中channel是第一类对象，它不关注发送消息的实体，而关注与发送消息时使用的channel。go是天然支持csp模式的语言。</p></li><li><p>CSP和Actor类似，只不过CSP将消息投递给channel，至于谁从channel中取数据，发送的一方是不关注的。简单的说Actor在发送消息前是直到接收方是谁，而接受方收到消息后也知道发送方是谁，更像是邮件的通信模式。而csp是完全解耦合的。</p></li></ul><p><img src="../assets/并发编程/image-2.png" alt="示例图片" style="zoom:100%;" /></p><ul><li>C++ 风格CSP</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">channel</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">channel</span>(<span class="type">size_t</span> capacity = <span class="number">0</span>):<span class="built_in">close_</span>(<span class="literal">false</span>), <span class="built_in">capacity_</span>(capacity)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">send</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">        cv_producer_.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]() &#123;</span><br><span class="line">            <span class="built_in">return</span> (capacity_ == <span class="number">0</span> &amp;&amp; queue_.<span class="built_in">empty</span>()) || close_ || queue_.<span class="built_in">size</span>() &lt; capacity_;</span><br><span class="line">            &#125;);</span><br><span class="line">        <span class="keyword">if</span> (close_) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        queue_.<span class="built_in">push</span>(value);</span><br><span class="line">        cv_consumer_.<span class="built_in">notify_one</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">receive</span><span class="params">(T&amp; value)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">        cv_consumer_.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]() &#123;</span><br><span class="line">            <span class="keyword">return</span> !queue_.<span class="built_in">empty</span>() || close_;</span><br><span class="line">            &#125;);</span><br><span class="line">        <span class="keyword">if</span> (close_ &amp;&amp; queue_.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        value = queue_.<span class="built_in">front</span>();</span><br><span class="line">        queue_.<span class="built_in">pop</span>();</span><br><span class="line">        cv_producer_.<span class="built_in">notify_one</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">        close_ = <span class="literal">true</span>;</span><br><span class="line">        cv_consumer_.<span class="built_in">notify_all</span>();</span><br><span class="line">        cv_producer_.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::queue&lt;<span class="type">int</span>&gt; queue_;</span><br><span class="line">    std::mutex mtx_;</span><br><span class="line">    std::condition_variable cv_producer_;</span><br><span class="line">    std::condition_variable cv_consumer_;</span><br><span class="line">    <span class="type">size_t</span> capacity_;</span><br><span class="line">    <span class="type">bool</span> close_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_channel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">channel&lt;<span class="type">int</span>&gt; <span class="title">ch</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">producer</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            ch.send(i);</span></span></span><br><span class="line"><span class="params"><span class="function">            std::cout &lt;&lt; <span class="string">&quot;Sent: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        ch.close();</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">consumer</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::this_thread::sleep_for(std::chrono::milliseconds(<span class="number">500</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int</span> val;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span> (ch.receive(val)) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::cout &lt;&lt; <span class="string">&quot;Received: &quot;</span> &lt;&lt; val &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    producer.<span class="built_in">join</span>();</span><br><span class="line">    consumer.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>消息队列：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">﻿<span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> messaging</span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">//①消息基类。队列中存储的项目</span></span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">message_base</span>   </span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">message_base</span>()</span><br><span class="line">  &#123;&#125;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//②每种消息都具有特化类型</span></span><br><span class="line"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Msg&gt;</span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">wrapped_message</span> : </span><br><span class="line">  message_base</span><br><span class="line"> &#123;</span><br><span class="line">  Msg contents;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">wrapped_message</span><span class="params">(Msg <span class="type">const</span>&amp; contents_)</span> :</span></span><br><span class="line"><span class="function">   contents(contents_)</span></span><br><span class="line"><span class="function">  &#123;</span>&#125;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//③消息队列</span></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">queue</span>   </span><br><span class="line"> &#123;</span><br><span class="line">  std::mutex m;</span><br><span class="line">  std::condition_variable c;</span><br><span class="line">  <span class="comment">//④以内部队列存储message_base型共享指针</span></span><br><span class="line">  std::queue&lt;std::shared_ptr&lt;message_base&gt; &gt; q;    </span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">  <span class="type">void</span> <span class="title">push</span><span class="params">(T <span class="type">const</span>&amp; msg)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">   <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;</span><br><span class="line">   <span class="comment">//⑤包装发布的消息，并存储相关的指针</span></span><br><span class="line">   q.<span class="built_in">push</span>(std::make_shared&lt;wrapped_message&lt;T&gt; &gt;(msg));     </span><br><span class="line">   c.<span class="built_in">notify_all</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">std::shared_ptr&lt;message_base&gt; <span class="title">wait_and_pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">   <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;</span><br><span class="line">   <span class="comment">//⑥如果队列为空，就发生阻塞</span></span><br><span class="line">   c.<span class="built_in">wait</span>(lk,[&amp;] &#123;<span class="keyword">return</span> !q.<span class="built_in">empty</span>(); &#125;);   </span><br><span class="line">   <span class="keyword">auto</span> res = q.<span class="built_in">front</span>();</span><br><span class="line">   q.<span class="built_in">pop</span>();</span><br><span class="line">   <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="thread-源码解读及一些常见问题"><a href="#thread-源码解读及一些常见问题" class="headerlink" title="thread 源码解读及一些常见问题"></a>thread 源码解读及一些常见问题</h2><h3 id="默认移动构造"><a href="#默认移动构造" class="headerlink" title="默认移动构造"></a>默认移动构造</h3><ul><li>关于局部变量返回值的问题我曾在视频中说会通过构造函数返回一个局部变量给调用者，编译器会先执行拷贝构造，如果没有拷贝构造再寻找移动构造。这么说是有问题的。<br>有热心的粉丝查询了chatgpt，当函数返回一个类类型的局部变量时会先调用移动构造，如果没有移动构造再调用拷贝构造。</li><li>所以对于一些没有拷贝构造但是实现了移动构造的类类型也支持通过函数返回局部变量。</li><li>在 C++11 之后，编译器会默认使用移动语义（move semantics）来提高性能</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestCopy</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TestCopy</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">TestCopy</span>(<span class="type">const</span> TestCopy&amp; tp) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Test Copy Copy &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">TestCopy</span>(TestCopy&amp;&amp; cp) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Test Copy Move &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">TestCopy <span class="title">TestCp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TestCopy tp;</span><br><span class="line">    <span class="keyword">return</span> tp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">TestCp</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>发现打印的是”Test Copy Move” .这说明优先调用的是移动构造，这也提醒我们，如果我们自定义的类实现了拷贝构造和移动构造，而这个类的移动给构造和拷贝构造实现方式不同时，要注意通过函数内部局部变量返回该类时调用移动构造是否会存在一些逻辑或安全的问题。</p></li><li><p>优先按照移动构造的方式返回局部的类对象，有一个好处就是可以返回一些只支持移动构造的类型</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ReturnUniquePtr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt;  uq_ptr = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">return</span>  uq_ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::thread <span class="title">ReturnThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">([]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int</span> i = <span class="number">0</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::cout &lt;&lt; <span class="string">&quot;i is &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">            i++;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">break</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::this_thread::sleep_for(std::chrono::seconds(<span class="number">1</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> rt_ptr = <span class="built_in">ReturnUniquePtr</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;rt_ptr value is &quot;</span> &lt;&lt; *rt_ptr &lt;&lt; std::endl;</span><br><span class="line">    std::thread rt_thread = <span class="built_in">ReturnThread</span>();</span><br><span class="line">    rt_thread.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程归属权问题"><a href="#线程归属权问题" class="headerlink" title="线程归属权问题"></a>线程归属权问题</h3><ul><li><strong>我们不能将一个线程的归属权转移给一个已经绑定线程的变量。</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadOp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int</span> i = <span class="number">0</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span> (i &lt; <span class="number">5</span>) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::this_thread::sleep_for(std::chrono::seconds(<span class="number">1</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">            i++;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int</span> i = <span class="number">0</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::this_thread::sleep_for(std::chrono::seconds(<span class="number">1</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">            i++;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    <span class="comment">//不能将一个线程归属权绑定给一个已经绑定线程的变量，否则会触发terminate导致崩溃</span></span><br><span class="line">    t1 = std::<span class="built_in">move</span>(t2);</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这样就会发生崩溃</li></ul><p><img src="../assets/并发编程/image-3.png" alt="示例图片" style="zoom:100%;" /></p><ul><li><p>t1已经绑定了一个线程执行循环操作直到i&lt;5。如果在t1没运行完的情况下将t2的归属权给t1，则会引发terminate崩溃错误。</p></li><li><p>所以综上所述，std::thread向回调函数传递值是以副本的方式,回调函数参数是引用类型，可以将传递的实参用std::ref包装达到修改的效果。<br>因为std::ref其实是构造了reference_wrapper类对象，这个类实现了仿函数</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">_CONSTEXPR20 <span class="keyword">operator</span> _Ty&amp;() <span class="type">const</span> <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> *_Ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>所以当线程接收std::ref包裹的参数时会调用仿函数通过指针解引用的方式获取外部实参，以_Ty&amp;返回，从而达到修改的效果。</li></ul><h3 id="future-析构的细节"><a href="#future-析构的细节" class="headerlink" title="future 析构的细节"></a>future 析构的细节</h3><ul><li>future在析构之前会等待任务结束才会正确析构，否则会阻塞，它内部会有一个引用计数，只有当引用计数为0的时候future才会析构</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BlockAsync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;begin block async&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#123;</span><br><span class="line">        std::<span class="built_in">async</span>(std::launch::async, []() &#123;</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">3</span>));</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;std::async called &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;end block async&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>输出如下：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">begin block async</span><br><span class="line">std::async called</span><br><span class="line">end block async</span><br></pre></td></tr></table></figure><ul><li><p>我们发现并没有并行运行，因为会在async局部作用域的时候阻塞，等待任务执行完主线程才会继续执行</p></li><li><p><strong>需求</strong></p></li><li>你的需求是func1 中要异步执行asyncFunc函数。</li><li>func2中先收集asyncFunc函数运行的结果，只有结果正确才执行</li><li>func1启动异步任务后继续执行，执行完直接退出不用等到asyncFunc运行完</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">asyncFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">3</span>));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;this is asyncFunc&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(std::future&lt;<span class="type">int</span>&gt;&amp; future_ref)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;this is func1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    future_ref = std::<span class="built_in">async</span>(std::launch::async, asyncFunc);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(std::future&lt;<span class="type">int</span>&gt;&amp; future_ref)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;this is func2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">auto</span> future_res = future_ref.<span class="built_in">get</span>();</span><br><span class="line">    <span class="keyword">if</span> (future_res == <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;get asyncFunc result success !&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;get asyncFunc result failed !&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//提供多种思路，这是第一种</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">first_method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; future_tmp;</span><br><span class="line">    <span class="built_in">func1</span>(future_tmp);</span><br><span class="line">    <span class="built_in">func2</span>(future_tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>上面的例子我们保证在func1和func2使用的是future的引用即可。这样func1内不会因为启动async而阻塞，因为future_ref不是shared state最后持有者。</p></li><li><p>纯异步代码</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Func, <span class="keyword">typename</span>... Args  &gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span>  <span class="title">ParallenExe</span><span class="params">(Func&amp;&amp; func, Args &amp;&amp; ... args)</span> -&gt; std::future&lt;<span class="title">decltype</span><span class="params">(func(args...))</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span>    <span class="title">decltype</span><span class="params">(func(args...))</span>  RetType</span>;</span><br><span class="line">    std::function&lt;RetType()&gt;  bind_func = std::<span class="built_in">bind</span>(std::forward&lt;Func&gt;(func), std::forward&lt;Args&gt;(args)...);</span><br><span class="line">    <span class="function">std::packaged_task&lt;<span class="title">RetType</span><span class="params">()</span>&gt; <span class="title">task</span><span class="params">(bind_func)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> rt_future = task.<span class="built_in">get_future</span>();</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(std::move(task))</span></span>;</span><br><span class="line">    t.<span class="built_in">detach</span>();</span><br><span class="line">    <span class="keyword">return</span> rt_future;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="原子操作和内存模型"><a href="#原子操作和内存模型" class="headerlink" title="原子操作和内存模型"></a>原子操作和内存模型</h2><h3 id="改动序列"><a href="#改动序列" class="headerlink" title="改动序列"></a>改动序列</h3><ul><li>在一个C++程序中，每个对象都具有一个改动序列，它由所有线程在对象上的全部写操作构成，其中第一个写操作即为对象的初始化。</li><li>大部分情况下，这个序列会随程序的多次运行而发生变化，但是在程序的任意一次运行过程中，所含的全部线程都必须形成相同的改动序列。</li></ul><p>改动序列基本要求如下：</p><ol><li>只要某线程看到过某个对象，则该线程的后续读操作必须获得相对新近的值，并且，该线程就同一对象的后续写操作，必然出现在改动序列后方。（也就是说只有在修改后才能继续修改或读取）</li><li>如果某线程先向一个对象写数据，过后再读取它，那么必须读取前面写的值。</li><li>若在改动序列中，上述读写操作之间还有别的写操作，则必须读取最后写的值。</li><li>在程序内部，对于同一个对象，全部线程都必须就其形成相同的改动序列，并且在所有对象上都要求如此.（多个线程作用在一个对象上需要井然有序）</li><li>多个对象上的改动序列只是相对关系，线程之间不必达成一致</li></ol><h3 id="原子类型"><a href="#原子类型" class="headerlink" title="原子类型"></a>原子类型</h3><ul><li><p>标准原子类型的定义位于头文件<atomic>内。我们可以通过atomic&lt;&gt;定义一些原子类型的变量，如atomic<bool>,atomic<int> 这些类型的操作全是原子化的。</p></li><li><p>从C++17开始，所有的原子类型都包含一个静态常量表达式成员变量，<strong>std::atomic::is_always_lock_free（判断是否天生原子性）</strong>。这个成员变量的值表示在任意给定的目标硬件上，原子类型X是否始终以无锁结构形式实现。如果在所有支持该程序运行的硬件上，原子类型X都以无锁结构形式实现，那么这个成员变量的值就为true；否则为false。</p></li><li><p>只有一个原子类型不提供is_lock_free()成员函数：std::atomic_flag 。类型<strong>std::atomic_flag的对象在初始化时清零</strong>，随后即可通过成员函数<strong>test_and_set()</strong>查值并设置成立，或者由<strong>clear()清零</strong>。整个过程只有这两个操作。其他的atomic&lt;&gt;的原子类型都可以基于其实现。</p></li><li><p><strong>std::atomic_flag的test_and_set成员函数是一个原子操作</strong>，他会先检查std::atomic_flag当前的状态是否被设置过，</p></li></ul><p>test_ans_set的作用:</p><ol><li><p>如果没被设置过(比如初始状态或者清除后)，将<strong>std::atomic_flag</strong>当前的状态设置为true，并返回false。</p></li><li><p>如果被设置过则直接返回ture。</p></li></ol><p>对于std::atomic<T>类型的原子变量，还支持load()（读操作）和store()（写操作）、exchange()、compare_exchange_weak()（比较期望值，不相等交换）和compare_exchange_strong()等操作。</p><h3 id="内存次序"><a href="#内存次序" class="headerlink" title="内存次序"></a>内存次序</h3><ul><li>对于原子类型上的每一种操作，我们都可以提供额外的参数，从枚举类std::memory_order取值，用于设定所需的内存次序语义（memory-ordering semantics）。</li><li>枚举类std::memory_order具有6个可能的值，分别是：std::memory_order_relaxed、std::memory_order_consume、std::memory_order_acquire、std::memory_order_release、std::memory_order_acq_rel或std::memory_order_seq_cst。</li></ul><ol><li>包括std::memory_order_relaxed、std:: memory_order_acquire、std::memory_order_consume、</li></ol><p>std::memory_order_acq_rel、std::memory_order_release和 std::memory_order_seq_cst。</p><ol><li><p>存储（store）操作，可选用的内存次序有std::memory_order_relaxed、std::memory_order_release或std::memory_order_seq_cst（全局一致性）。</p></li><li><p>载入（load）操作，可选用的内存次序有std::memory_order_relaxed、std::memory_order_consume、std::memory_order_acquire或std::memory_order_seq_cst。</p></li><li><p>“读-改-写”（read-modify-write）操作，可选用的内存次序有std::memory_order_relaxed、std::memory_order_consume、std::memory_order_acquire、std::memory_order_release、std::memory_order_acq_rel或std::memory_order_seq_cst。</p></li><li><p>原子操作默认使用的是std::memory_order_seq_cst次序。</p></li></ol><p>这六种内存顺序相互组合可以实现三种顺序模型 (ordering model)</p><ol><li>Sequencial consistent ordering. 实现同步, 且保证全局顺序一致 (single total order) 的模型. 是一致性最强的模型, 也是默认的顺序模型.</li><li>Acquire-release ordering. 实现同步, 但不保证保证全局顺序一致的模型.</li><li>Relaxed ordering. 不能实现同步, 只保证原子性的模型.</li></ol><h3 id="实现自旋锁"><a href="#实现自旋锁" class="headerlink" title="实现自旋锁"></a>实现自旋锁</h3><ul><li>自旋锁是一种在多线程环境下保护共享资源的同步机制。它的基本思想是，当一个线程尝试获取锁时，如果锁已经被其他线程持有，那么该线程就会不断地循环检查锁的状态，直到成功获取到锁为止。</li><li>我们可以用std::atomic_flag来实现自旋锁</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SpinLock</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//自旋等待直到可获取锁</span></span><br><span class="line">        <span class="keyword">while</span> (flag.<span class="built_in">test_and_set</span>(std::memory_order_acquire));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//释放锁</span></span><br><span class="line">        flag.<span class="built_in">clear</span>(std::memory_order_release);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//初始化为0</span></span><br><span class="line">    std::atomic_flag flag = ATOMIC_FLAG_INIT;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestSpinLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SpinLock spinlock;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;spinlock]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        spinlock.lock();</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::cout &lt;&lt; <span class="string">&quot;*&quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::cout &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">        spinlock.unlock();</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([&amp;spinlock]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        spinlock.lock();</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::cout &lt;&lt; <span class="string">&quot;?&quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::cout &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">        spinlock.unlock();</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>在多线程调用时，仅有一个线程在同一时刻进入test_and_set，因为atomic_flag初始状态为false,所以test_and_set将atomic_flag设置为true，并且返回false。</p></li><li><p>比如线程A调用了test_and_set返回false，这样lock函数返回，线程A继续执行加锁区域的逻辑。此时线程B调用test_and_set，test_and_set会返回true,导致线程B在while循环中循环等待，达到自旋检测标记的效果。当线程A直行至2处调用clear操作后，atomic_flag被设置为清空状态，线程B调用test_and_set会将状态设为成立并返回false，B线程执行加锁区域的逻辑。</p></li></ul><h3 id="宽松内存序"><a href="#宽松内存序" class="headerlink" title="宽松内存序"></a>宽松内存序</h3><ul><li>为了给大家介绍不同的字节序，我们先从最简单的字节序std::memory_order_relaxed(宽松字节序)介绍。</li><li>因为字节序是为了实现改动序列的，所以为了理解字节序还要结合改动序列讲起。</li><li>我们先看一个CPU和内存结构图：</li></ul><p><img src="../assets/并发编程/image-4.png" alt="示例图片" style="zoom:100%;" /></p><ul><li><p>其中StoreBuffer就是一级Cache， Catche是二级Cache，Memory是三级Cache。</p></li><li><p>每个标识CPU的块就是core，上图画的就是4核结构。每两个core构成一个bank，共享一个cache。四个core共享memory。</p></li><li><p>每个CPU所作的store均会写到store buffer中，每个CPU会在任何时刻将store buffer中结果写入到cache或者memory中。</p></li><li><p>那该如何保证数据一致性？这就要提及<strong>MESI一致性协议</strong>。</p></li><li><strong>MESI 协议</strong>，是一种叫作<strong>写失效（Write Invalidate）的协议</strong>。在写失效协议里，<strong>只有一个 CPU 核心负责写入数据，其他的核心，只是同步读取到这个写入</strong>。在这个 CPU 核心写入 cache 之后，它会去<strong>广播一个“失效”请求告诉所有其他的 CPU 核心</strong>。</li><li>MESI 协议对应的四个不同的标记，分别是：</li></ul><ol><li><p><strong>M：代表已修改（Modified）</strong>：“已修改”用来告诉其他cpu已经修改完成，其他cpu可以向cache中写入数据</p></li><li><p><strong>I：代表已失效（Invalidated）</strong></p></li><li><p><strong>E：代表独占（Exclusive）</strong>：“独占”表示数据只是加载到当前 CPU核 的store buffer中，其他的 CPU 核，并没有加载对应的数据到自己的 store buffer 里。，这个时候，如果要向独占的 store buffer 写入数据，我们可以自由地写入数据，而不需要告知其他 CPU 核。</p></li><li><p><strong>S：代表共享（Shared）</strong>：共享状态就是在多核中<strong>同时加载了同一份数据</strong>。所以在共享状态下想要修改数据要<strong>先向所有的其他 CPU 核心广播一个请求</strong>，要求先把其他 CPU 核心里面的 cache ，都变成无效的状态，然后再更新当前 cache 里面的数据，我们可以这么理解，如果变量a此刻在各个cpu的StoreBuffer中，那么CPU1核修改这个a的值，放入cache时通知其他CPU核写失效，因为同一时刻仅有一个CPU核可以写数据，但是其他CPU核是可以读数据的，那么其他核读到的数据可能是CPU1核修改之前的。这就涉及我们提到的改动序列了。</p></li></ol><p>这里给大家简单介绍两个改动序列的术语</p><ol><li><p><strong><em>“synchronizes-with“ : 同步, “A synchronizes-with B” 的意思就是 A和B同步，简单来说如果多线程环境下，有一个线程先修改了变量m，我们将这个操作叫做A，之后有另一个线程读取变量m，我们将这个操作叫做B，如果A先修改了，那么B一定读取A修改m之后的最新值。也可以称作 A “happens-before“ B，即A操作的结果对B操作可见。</em></strong></p></li><li><p>“happens-before“ : 先行，”A happens-before B” 的意思是如果A操作先于B操作，那么A操作的结果对B操作可见。”happens-before“包含很多种境况，不仅仅是我们上面提到的”synchronizes-with“,之后给大家一个脑图详细说明”happens-before“的几种情况。</p></li></ol><ul><li><p>我的理解是先行关系多数情况下描述对同一变量的先后操作，只有变量之间存在依赖关系才会有对不同变量的先后操作存在先行关系</p></li><li><p>我们接下来谈谈<strong>std::memory_order_relaxed</strong>。</p></li><li><p>关于std::memory_order_relaxed具备如下几个功能：</p><ol><li>作用于原子变量(写的时候是完整的，不会发生写一半而被终止)</li><li>不具有synchronizes-with关系(同步)（<strong>也就是说在多线程里不能保证读操作能读到写操作后的值</strong>）</li><li>对于同一个原子变量，在同一个线程中具有happens-before关系, <strong>在同一线程中不同的原子变量不具有happens-before关系，可以乱序执行。</strong></li><li>多线程情况下不具有happens-before关系。</li></ol></li><li><p>由上述可知，如果采用最松散的内存顺序模型，在一个线程中，如果某个表达式已经看到原子变量的某个值a，则该表达式的后续表达式只能看到a或者比a更新的值。</p></li><li>我们看下面的代码：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; x, y;</span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; z;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_x_then_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    x.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_relaxed);  <span class="comment">// 1</span></span><br><span class="line">    y.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_relaxed);  <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_y_then_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!y.<span class="built_in">load</span>(std::memory_order_relaxed)) &#123; <span class="comment">// 3</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;y load false&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x.<span class="built_in">load</span>(std::memory_order_relaxed)) &#123; <span class="comment">//4</span></span><br><span class="line">        ++z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestOrderRelaxed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(write_x_then_y)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(read_y_then_x)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    <span class="built_in">assert</span>(z.<span class="built_in">load</span>() != <span class="number">0</span>); <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>我们从两个角度分析</li></ul><ol><li>从cpu架构分析</li></ol><p>假设线程t1运行在CPU1上，t2运行在CPU3上，那么t1对x和y的操作，t2是看不到的。</p><p>比如当线程t1运行至1处将x设置为true，t1运行至2处将y设置为true。这些操作仅在CPU1的store buffer中，还未放入cache和memory中，CPU2自然不知道。</p><p>如果CPU1先将y放入memory，那么CPU2就会读取y的值为true。那么t2就会运行至3处从while循环退出，进而运行至4处，此时CPU1还未将x的值写入memory，</p><p>t2读取的x值为false，进而线程t2运行结束，然后CPU1将x写入true, t1结束运行，最后主线程运行至5处，因为z为0,所以触发断言。</p><ol><li>从宽松内存序分析</li></ol><p>因为memory_order_relaxed是宽松的内存序列，它只保证操作的原子性，并不能保证多个变量之间的顺序性，也不能保证同一个变量在不同线程之间的可见顺序。</p><p>比如t1可能先运行2处代码再运行1处代码，因为我们的代码会被编排成指令执行，编译器在不破坏语义的情况下(2处和1处代码无耦合，可调整顺序)，2可能先于1执行。如果这样，t2运行至3处退出while循环，继续运行4处，此时t1还未执行1初代码，则t2运行4处条件不成立不会对z做增加，t2结束。这样也会导致z为0引发断言。</p><p>如图：<br><img src="../assets/并发编程/image-5.png" alt="示例图片" style="zoom:100%;" /></p><ul><li>我们在看一个例子</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestOderRelaxed2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::atomic&lt;<span class="type">int</span>&gt; a&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v3, v4;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;a]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i += <span class="number">2</span>) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            a.store(i, std::memory_order_relaxed);</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([&amp;a]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i += <span class="number">2</span>)</span></span></span><br><span class="line"><span class="params"><span class="function">            a.store(i, std::memory_order_relaxed);</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t3</span><span class="params">([&amp;v3, &amp;a]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span></span></span><br><span class="line"><span class="params"><span class="function">            v<span class="number">3.</span>push_back(a.load(std::memory_order_relaxed));</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t4</span><span class="params">([&amp;v4, &amp;a]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span></span></span><br><span class="line"><span class="params"><span class="function">            v<span class="number">4.</span>push_back(a.load(std::memory_order_relaxed));</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">3.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">4.</span><span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : v3) &#123;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : v4) &#123;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可能的输出</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span></span><br><span class="line"><span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span></span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line"><span class="number">0</span> <span class="number">8</span> <span class="number">8</span> <span class="number">8</span> <span class="number">8</span> <span class="number">8</span> <span class="number">8</span> <span class="number">8</span> <span class="number">8</span> <span class="number">8</span></span><br><span class="line"><span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span></span><br></pre></td></tr></table></figure><ul><li><p>由此可见，std::memory_order_relaxed对于多个线程它是乱序执行的，因为多个线程仅操作了a变量，通过memory_order_relaxed的方式仅能保证对a的操作是原子的(同一时刻仅有一个线程写a的值，但是可能多个线程读取a的值)。</p></li><li><p>但是多个线程之间操作不具备同步关系，也就是线程t1将a改为7，那么线程t3不知道a改动的最新值为7，它读到a的值为1。只是要过一阵子可能会读到7或者a变为7之后又改动的其他值。</p></li><li><p>但是t3,t4两个线程读取a的次序是一致的，比如t3和t4都读取了7和9，t3读到7在9之前，那么t4也读取到7在9之前。</p></li><li><p>因为我们memory_order_relaxed保证了多线程对同一个变量的原子操作的安全性，只是可见性会有延迟罢了。</p></li></ul><h3 id="先行"><a href="#先行" class="headerlink" title="先行"></a>先行</h3><ul><li>Happens-before 是一个非常重要的概念. 如前文我们提及：</li><li>如果操作 a “happens-before” 操作 b, 则操作 a 的结果对于操作 b 可见. happens-before 的关系可以建立在用一个线程的两个操作之间, 也可以建立在不同的线程的两个操作之间。</li></ul><h4 id="顺序先行"><a href="#顺序先行" class="headerlink" title="顺序先行"></a>顺序先行</h4><ul><li>单线程情况下前面的语句先执行，后面的语句后执行。操作a先于操作b，那么操作b可以看到操作a的结果。我们称操作a顺序先行于操作b。也就是”a sequenced-before b”。</li></ul><p>这种情况下”a happens before b</p><ul><li>sequencde-before”具备传递性，比如操作 a “sequenced-before” 操作 b, 且操作 b “sequenced-before” 操作 m, 则操作 a “sequenced-before” 操作 m.</li></ul><p><img src="../assets/并发编程/image-6.png" alt="示例图片" style="zoom:100%;" /></p><h4 id="线程间先行"><a href="#线程间先行" class="headerlink" title="线程间先行"></a>线程间先行</h4><ul><li><p>线程间先行又叫做”inter-thread-happens-before”，这是多线程情况的”happens-before”.</p></li><li><p>我们前面提到的”synchronizes-with” 可以构成 “happens-before”。</p></li><li><p>如果线程 1 中的操作 a “synchronizes-with” 线程 2 中的操作 b, 则操作 a “inter-thread happens-before” 操作 b.</p></li></ul><p><img src="../assets/并发编程/image-7.png" alt="示例图片" style="zoom:100%;" /></p><ul><li><p>此外 synchronizes-with 还可以 “后接” 一个 sequenced-before 关系组合成 inter-thread happens-before 的关系:</p></li><li><p>比如操作 a “synchronizes-with” 操作 b, 且操作 b “sequenced-before” 操作 m, 则操作 a “inter-thread happens-before” 操作 m.</p></li></ul><p><img src="../assets/并发编程/image-8.png" alt="示例图片" style="zoom:100%;" /></p><ul><li>那同样的道理， Inter-thread happens-before 关系则可以 “前接” 一个 sequenced-before 关系以延伸它的范围; 而且 inter-thread happens-before 关系具有传递性:</li></ul><ol><li>如果操作 a “sequenced-before” 操作 k, 且操作 k “inter-thread happens-before” 操作 b, 则操作 a “inter-thread happens-before” 操作 b.</li></ol><p><img src="../assets/并发编程/image-9.png" alt="示例图片" style="zoom:100%;" /></p><ol><li>如果操作 a “inter-thread happens-before” 操作 k, 且操作 k “inter-thread happens-before” 操作 b, 则操作 a “inter-thread happens-before” 操作 b.</li></ol><p><img src="../assets/并发编程/image-10.png" alt="示例图片" style="zoom:100%;" /></p><h3 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h3><ul><li><p>依赖关系有 carries dependency 和 dependency-ordered before.</p></li><li><p>单线程情况下a “sequenced-before” b, 且 b 依赖 a 的数据, 则 a “carries a dependency into” b. 称作 a 将依赖关系带给 b, 也理解为b依赖于a。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestDependency</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1 处</span></span><br><span class="line">    std::string str = <span class="string">&quot;hello world!&quot;</span>;</span><br><span class="line">    <span class="comment">// 2 处</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 3 处</span></span><br><span class="line">    std::cout &lt;&lt; str[i] &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>函数TestDependency内部打印str[i]的值。3处代码需要依赖1处和2处两个变量的值，所以达成依赖关系。</p></li><li><p>我们看单线程情况下按顺序执行1，2，3处代码，1 “sequenced-before” 3，且3 依赖 1的数据，则 1 “carries a dependency into” 3</p></li><li><p>同样的道理 2 “sequenced-before” 3, 且3依赖2 的数据，则2 “carries a dependency into” 3.</p></li></ul><p>“carries a dependency into” 也被归为”happens-before”。</p><p><img src="../assets/并发编程/image-11.png" alt="示例图片" style="zoom:100%;" /></p><ul><li><strong><em>多线程情况下</em></strong></li><li>线程1执行操作A(比如对i自增)，线程2执行操作B(比如根据i访问字符串下表的元素), 如果线程1先于线程2执行，且操作A的结果对操作B可见，我们将这种叫做<br>A “dependency-ordered before” B. 有人会说这不是前面说到的A “synchronizes with “ B吗？你可以这么理解。就当作他们达到的效果是一致的，只不过A “dependency-ordered before” B 更细化一点，表述了一种依赖，比如操作A仅仅对i增加，而没有对字符串修改。而操作B需要通过i访问字符串数据。那操作B实际上是依赖于A的。</li></ul><h3 id="Happens-before不代表指令执行顺序"><a href="#Happens-before不代表指令执行顺序" class="headerlink" title="Happens-before不代表指令执行顺序"></a>Happens-before不代表指令执行顺序</h3><ul><li><strong>Happens-before不代表指令实际执行顺序，C++编译器可以对不相关的指令任意编排达到优化效果，Happens-before仅是C++语义层面的描述，表示 a “Happens-before” b仅能说明a操作的结果对b操作可见。</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>  <span class="title">Add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//1 处</span></span><br><span class="line">    a++; </span><br><span class="line">    <span class="comment">// 2 处</span></span><br><span class="line">    b++;</span><br><span class="line">    <span class="comment">// 3 处</span></span><br><span class="line">    <span class="keyword">return</span>  a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>单线程执行上述代码，操作1一定是happens-before 操作2 的(a “sequenced-before” b)，就是我们理解的 a++ 先于 b++。</p></li><li><p>但是计算机的指令可能不是这样，一条C++语句对于多条计算机指令。</p></li><li><p>有可能是先将b值放入寄存器eax做加1，再将a的值放入寄存器edx做加1，然后再将eax寄存器的值写回a，将edx写回b。</p></li><li><p>因为对于计算机来说1处操作和2处操作的顺序对于3处来说并无影响。只要3处返回a+b之前能保证a和b的值是增加过的即可。</p></li><li><p>那我们语义上的”Happens-before”有意义吗？ 是有意义的，因为如果 a “sequenced-before” b, 那么无论指令如何编排，最终写入内存的顺序一定是a先于b。</p></li><li><p>只不过C++编译器不断优化尽可能不造成指令编排和语义理解的差异，上面C++的代码转换为汇编指令如下</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line"><span class="number">00</span>A1C8F5  mov         dword ptr [a],<span class="number">0</span>  </span><br><span class="line"><span class="number">00</span>A1C8FC  mov         dword ptr [b],<span class="number">0</span>  </span><br><span class="line">    <span class="comment">//1 处</span></span><br><span class="line">    a++; </span><br><span class="line"><span class="number">00</span>A1C903  mov         eax,dword ptr [a]  </span><br><span class="line"><span class="number">00</span>A1C906  add         eax,<span class="number">1</span>  </span><br><span class="line"><span class="number">00</span>A1C909  mov         dword ptr [a],eax  </span><br><span class="line">    <span class="comment">// 2 处</span></span><br><span class="line">    b++;</span><br><span class="line"><span class="number">00</span>A1C90C  mov         eax,dword ptr [b]  </span><br><span class="line"><span class="number">00</span>A1C90F  add         eax,<span class="number">1</span>  </span><br><span class="line"><span class="number">00</span>A1C912  mov         dword ptr [b],eax  </span><br><span class="line">    <span class="keyword">return</span>  a + b;</span><br><span class="line"><span class="number">00</span>A1C915  mov         eax,dword ptr [a]  </span><br><span class="line"><span class="number">00</span>A1C918  add         eax,dword ptr [b]</span><br></pre></td></tr></table></figure><h3 id="脑图"><a href="#脑图" class="headerlink" title="脑图"></a>脑图</h3><ul><li>我们将”happens-before” 的几种情况做成脑图，方便理解</li></ul><p><img src="../assets/并发编程/image-12.png" alt="示例图片" style="zoom:100%;" /></p><ul><li>我们画一个框将”happens-before” 的几种情况框起来</li></ul><p><img src="../assets/并发编程/image-13.png" alt="示例图片" style="zoom:100%;" /></p><h2 id="用内存顺序实现内存模型"><a href="#用内存顺序实现内存模型" class="headerlink" title="用内存顺序实现内存模型"></a>用内存顺序实现内存模型</h2><h3 id="memory-order-seq-cst"><a href="#memory-order-seq-cst" class="headerlink" title="memory_order_seq_cst"></a>memory_order_seq_cst</h3><ul><li>memory_order_seq_cst代表全局一致性顺序，可以用于 store, load 和 read-modify-write 操作, 实现 sequencial consistent 的顺序模型. 在这个模型下, 所有线程看到的所有操作都有一个一致的顺序, 即使这些操作可能针对不同的变量, 运行在不同的线程.</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_x_then_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    x.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_seq_cst);  <span class="comment">// 1</span></span><br><span class="line">    y.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_seq_cst);  <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_y_then_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!y.<span class="built_in">load</span>(std::memory_order_seq_cst)) &#123; <span class="comment">// 3</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;y load false&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x.<span class="built_in">load</span>(std::memory_order_seq_cst)) &#123; <span class="comment">//4</span></span><br><span class="line">        ++z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestOrderSeqCst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(write_x_then_y)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(read_y_then_x)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    <span class="built_in">assert</span>(z.<span class="built_in">load</span>() != <span class="number">0</span>); <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>上面的代码x和y采用的是memory_order_seq_cst, 所以当线程t2执行到3处并退出循环时我们可以断定y为true，因为是全局一致性顺序，所以线程t1已经执行完2处将y设置为true，那么线程t1也一定执行完1处代码并对t2可见，所以当t2执行至4处时x为true，那么会执行z++保证z不为零，从而不会触发断言。</p></li><li><p><strong>实现 sequencial consistent 模型有一定的开销</strong>. 现代 CPU 通常有多核, 每个核心还有自己的缓存. <strong>为了做到全局顺序一致, 每次写入操作都必须同步给其他核心</strong>. 为了减少性能开销, 如果不需要全局顺序一致, 我们应该考虑使用更加宽松的顺序模型.</p></li><li><p><strong>为了保持全局一致性，当CPU执行写操作的时候不仅会给别的cpu发送写失效，还会发送不让读的指令，这样就保住了全局一致性</strong></p></li></ul><h3 id="memory-order-relaxed"><a href="#memory-order-relaxed" class="headerlink" title="memory_order_relaxed"></a>memory_order_relaxed</h3><ul><li><p>memory_order_relaxed 可以用于 store, load 和 read-modify-write 操作, 实现 relaxed 的顺序模型.<br>前文我们介绍过这种模型下, 只能保证操作的原子性和修改顺序 (modification order) 一致性, 无法实现 synchronizes-with 的关系。</p></li><li><p>详见上一段笔记</p></li></ul><h3 id="Acquire-Release"><a href="#Acquire-Release" class="headerlink" title="Acquire-Release"></a>Acquire-Release</h3><ul><li><p>在 acquire-release 模型中, 会使用 memory_order_acquire, memory_order_release 和 memory_order_acq_rel 这三种内存顺序. 它们的用法具体是这样的:</p><ol><li>对原子变量的 load 可以使用 memory_order_acquire 内存顺序. 这称为 acquire 操作</li><li>对原子变量的 store 可以使用 memory_order_release 内存顺序. 这称为 release 操作.(发布操作)</li><li>read-modify-write 操作即读 (load) 又写 (store), 它可以使用 memory_order_acquire, memory_order_release 和 memory_order_acq_rel:<ol><li>如果使用 memory_order_acquire, 则作为 acquire 操作;</li><li>如果使用 memory_order_release, 则作为 release 操作;</li><li>如果使用 memory_order_acq_rel, 则同时为两者.</li></ol></li></ol></li><li><p>Acquire-release 可以实现 synchronizes-with 的关系. 如果一个 acquire 操作在同一个原子变量上读取到了一个 release 操作写入的值, 则这个 release 操作 “synchronizes-with” 这个 acquire 操作.（就是说对于一个原子变量，如果store relase先发生，则会保证 load acuire读取到的是操作后的值）</p></li><li>不要想太复杂，release给变量store时加上了一个标记，另一个线程acquire读到该变量时看到该标记就知道要先进行同步，就是同步更新了各自缓冲区的数据（比如线程1告诉线程2我的x更新了，线程2刷新缓冲区），保证数据的一致性，而不是说加上了release标记的就必须得先执行。</li><li>我们可以通过Acquire-release 修正 TestOrderRelaxed函数以达到同步的效果</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestReleaseAcquire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::atomic&lt;<span class="type">bool</span>&gt; rx, ry;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        rx.store(<span class="literal">true</span>, std::memory_order_relaxed); <span class="comment">// 1</span></span></span></span><br><span class="line"><span class="params"><span class="function">        ry.store(<span class="literal">true</span>, std::memory_order_release); <span class="comment">// 2</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span> (!ry.load(std::memory_order_acquire)); <span class="comment">//3</span></span></span></span><br><span class="line"><span class="params"><span class="function">        assert(rx.load(std::memory_order_relaxed)); <span class="comment">//4</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>上面的例子中我们看到ry.store使用的是std::memory_order_release, ry.load使用的是std::memory_order_relaxed.</p></li><li><p>对于ry.store(true, std::memory_order_release);，它确保在存储操作之前的所有操作都发生在存储操作之前，并且不会被重排序到存储操作之后。对于ry.load(std::memory_order_acquire);，它确保在加载操作之后的所有操作都发生在加载操作之后，并且不会被重排序到加载操作之前。”，然后又问了synchronizes with相关的：“具体来说，如果一个原子操作A与另一个原子操作B具有“synchronizes-with”关系，那么：</p><ol><li>所有在A之前的操作都在B之前发生。</li><li>所有在B之后的操作都在A之后发生。</li></ol></li><li><p>可以断定4 不会触发断言。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestReleaseAcquire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::atomic&lt;<span class="type">bool</span>&gt; rx, ry;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        ry.store(<span class="literal">true</span>, std::memory_order_release); <span class="comment">// 1</span></span></span></span><br><span class="line"><span class="params"><span class="function">        rx.store(<span class="literal">true</span>, std::memory_order_relaxed); <span class="comment">// 2</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span> (!ry.load(std::memory_order_acquire)); <span class="comment">//3</span></span></span></span><br><span class="line"><span class="params"><span class="function">        assert(rx.load(std::memory_order_relaxed)); <span class="comment">//4</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>这就又可能发生断言，因为rx.store(true, std::memory_order_relaxed);在1之后操作不会保证同步性</p></li><li><p>我们从cpu结构图理解这一情景</p></li></ul><p><img src="../assets/并发编程/image-14.png" alt="示例图片" style="zoom:100%;" /></p><ul><li><p>到此大家一定要记住仅 Acquire-release能配合达到 synchronizes-with效果，再就是memory_order_seq_cst可以保证全局顺序唯一，其他情况的内存顺序都能保证顺序，使用时需注意。</p></li><li><p>Acquire-release 的开销比 sequencial consistent 小. 在 x86 架构下, memory_order_acquire 和 memory_order_release 的操作不会产生任何其他的指令, 只会影响编译器的优化: 任何指令都不能重排到 acquire 操作的前面, 且不能重排到 release 操作的后面; 否则会违反 acquire-release 的语义. 因此很多需要实现 synchronizes-with 关系的场景都会使用 acquire-release.</p></li></ul><h3 id="Release-sequences"><a href="#Release-sequences" class="headerlink" title="Release sequences"></a>Release sequences</h3><ul><li><p>我们再考虑一种情况，多个线程对同一个变量release操作，另一个线程对这个变量acquire，那么只有一个线程的release操作和这个acquire线程构成同步关系。</p></li><li><p>以下为危险示例</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ReleasAcquireDanger2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::atomic&lt;<span class="type">int</span>&gt; xd&#123;<span class="number">0</span>&#125;, yd&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    std::atomic&lt;<span class="type">int</span>&gt; zd;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        xd.store(<span class="number">1</span>, std::memory_order_release);  <span class="comment">// (1)</span></span></span></span><br><span class="line"><span class="params"><span class="function">        yd.store(<span class="number">1</span>, std::memory_order_release); <span class="comment">//  (2)</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        yd.store(<span class="number">2</span>, std::memory_order_release);  <span class="comment">// (3)</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t3</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span> (!yd.load(std::memory_order_acquire)); <span class="comment">//（4）</span></span></span></span><br><span class="line"><span class="params"><span class="function">        assert(xd.load(std::memory_order_acquire) == <span class="number">1</span>); <span class="comment">// (5)</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">3.</span><span class="built_in">join</span>();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><ul><li>当3被当作4的同步操作的时候，可能会发生断言(xd != 1)</li><li><p>当2被当作4的同步操作的时候，不会发生断言</p></li><li><p>并不是只有在 acquire 操作读取到 release 操作写入的值时才能构成 synchronizes-with 关系. 为了说这种情况, 我们需要引入 release sequence 这个概念.</p></li><li><p>针对一个原子变量 M 的 release 操作 A 完成后, 接下来 M 上可能还会有一连串的其他操作. 如果这一连串操作是由</p><ol><li>同一线程上的写操作</li><li>任意线程上的 read-modify-write 操作，这两种构成的, 则称这一连串的操作为以 release 操作 A 为首的 release sequence. 这里的写操作和 read-modify-write 操作可以使用任意内存顺序.</li></ol></li><li>如果一个 acquire 操作在同一个原子变量上读到了一个 release 操作写入的值, 或者读到了以这个 release 操作为首的 release sequence 写入的值, 那么这个 release 操作 “synchronizes-with” 这个 acquire 操作.</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ReleaseSequence</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; data;</span><br><span class="line">    std::atomic&lt;<span class="type">int</span>&gt; flag&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        data.push_back(<span class="number">42</span>);  <span class="comment">//(1)</span></span></span></span><br><span class="line"><span class="params"><span class="function">        flag.store(<span class="number">1</span>, std::memory_order_release); <span class="comment">//(2)</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int</span> expected = <span class="number">1</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span> (!flag.compare_exchange_strong(expected, <span class="number">2</span>, std::memory_order_relaxed)) <span class="comment">// (3)</span></span></span></span><br><span class="line"><span class="params"><span class="function">            expected = <span class="number">1</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t3</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span> (flag.load(std::memory_order_acquire) &lt; <span class="number">2</span>); <span class="comment">// (4)</span></span></span></span><br><span class="line"><span class="params"><span class="function">        assert(data.at(<span class="number">0</span>) == <span class="number">42</span>); <span class="comment">// (5)</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">3.</span><span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>我们考虑t3要想退出首先flag要等于2，那么就要等到t2将flag设置为2，而flag设置为2又要等到t1将flag设置为1. 所以我们捋一下顺序 2-&gt;3-&gt;4</p></li><li><p>t1中操作2是release操作，以2为开始，其他线程(t2)的读改写在release操作之后，我们称之为release sequence， t3要读取release sequence写入的值，所以我们称t1的release操作 “synchronizes with “ t3的 acquire 操作。</p></li></ul><h3 id="memory-order-consume"><a href="#memory-order-consume" class="headerlink" title="memory_order_consume"></a>memory_order_consume</h3><ul><li>memory_order_consume 其实是 acquire-release 模型的一部分, 但是它比较特殊, 它涉及到数据间相互依赖的关系. 就是前文我们提及的 carries dependency和 dependency-ordered before.</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p++;   <span class="comment">// (1)</span></span><br><span class="line">i++;   <span class="comment">// (2)</span></span><br><span class="line">p[i]   <span class="comment">// (3)</span></span><br></pre></td></tr></table></figure><ul><li><p>(1) “sequenced-before” (2), (2) “sequenced-before” (3), 而(1)和(2)的值作为(3)的下表运算符[]的操作数。</p></li><li><p>我们可以称(1) “carries a dependency into “ (3), (2) “carries a dependency into “ (3), 但是(1)和(2)不是依赖关系。</p></li><li><p>memory_order_consume 可以用于 load 操作. 使用 memory_order_consume 的 load 称为 consume 操作. 如果一个 consume 操作在同一个原子变量上读到了一个 release 操作写入的值, 或以其为首的 release sequence 写入的值, 则这个 release 操作 “dependency-ordered before” 这个 consume 操作.</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConsumeDependency</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::atomic&lt;std::string*&gt; ptr;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::string* p = <span class="keyword">new</span> std::string(<span class="string">&quot;Hello World&quot;</span>); <span class="comment">// (1)</span></span></span></span><br><span class="line"><span class="params"><span class="function">        data = <span class="number">42</span>; <span class="comment">// (2)</span></span></span></span><br><span class="line"><span class="params"><span class="function">        ptr.store(p, std::memory_order_release); <span class="comment">// (3)</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::string* p2;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span> (!(p2 = ptr.load(std::memory_order_consume))); <span class="comment">// (4)</span></span></span></span><br><span class="line"><span class="params"><span class="function">        assert(*p2 == <span class="string">&quot;Hello World&quot;</span>); <span class="comment">// (5)</span></span></span></span><br><span class="line"><span class="params"><span class="function">        assert(data == <span class="number">42</span>); <span class="comment">// (6)</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>t2执行到(4)处时，需要等到ptr非空才能退出循环，这就依赖t1执行完(3)操作。</li></ul><p>-因此(3) “dependency-ordered before” (4), 根据前文我们介绍了dependency等同于synchronizes ，所以(3) “inter-thread happens-before”. （4）</p><p>-因为(1) “sequenced before” (3), 所以(1) “happens-before “ (4)</p><p>-因为(4) “sequenced before” (5), 所以(1) “happens-before “ (5)</p><p>-所以(5)处断言也不会触发。</p><p>-因为(2) 和(3)不构成先行关系，所以(6)处断言可能触发。</p><ul><li>release只能保证其他线程可见，并不能保证其他线程能够正确读到，正因为如此才引入acquire。 而consumer只能保证相关原子能够读到</li></ul><h3 id="单例模型改良"><a href="#单例模型改良" class="headerlink" title="单例模型改良"></a>单例模型改良</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用智能指针解决释放问题</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleMemoryModel</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">SingleMemoryModel</span>()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">SingleMemoryModel</span>(<span class="type">const</span> SingleMemoryModel&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    SingleMemoryModel&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SingleMemoryModel&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">SingleMemoryModel</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;single auto delete success &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> std::shared_ptr&lt;SingleMemoryModel&gt; <span class="title">GetInst</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 1 处</span></span><br><span class="line">        <span class="keyword">if</span> (_b_init.<span class="built_in">load</span>(std::memory_order_acquire))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> single;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2 处</span></span><br><span class="line">        s_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="comment">// 3 处</span></span><br><span class="line">        <span class="keyword">if</span> (_b_init.<span class="built_in">load</span>(std::memory_order_relaxed))</span><br><span class="line">        &#123;</span><br><span class="line">            s_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">return</span> single;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4处</span></span><br><span class="line">        single = std::<span class="built_in">shared_ptr</span>&lt;SingleMemoryModel&gt;(<span class="keyword">new</span> SingleMemoryModel);</span><br><span class="line">        _b_init.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_release);</span><br><span class="line">        s_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> std::shared_ptr&lt;SingleMemoryModel&gt; single;</span><br><span class="line">    <span class="type">static</span> std::mutex s_mutex;</span><br><span class="line">    <span class="type">static</span> std::atomic&lt;<span class="type">bool</span>&gt; _b_init ;</span><br><span class="line">&#125;;</span><br><span class="line">std::shared_ptr&lt;SingleMemoryModel&gt; SingleMemoryModel::single = <span class="literal">nullptr</span>;</span><br><span class="line">std::mutex SingleMemoryModel::s_mutex;</span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; SingleMemoryModel::_b_init = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><ul><li>锁要求全局一致性,所以在3处可以用relaxed</li></ul><h2 id="用内存顺序和原子变量实现无锁队列"><a href="#用内存顺序和原子变量实现无锁队列" class="headerlink" title="用内存顺序和原子变量实现无锁队列"></a>用内存顺序和原子变量实现无锁队列</h2><h3 id="环形队列"><a href="#环形队列" class="headerlink" title="环形队列"></a>环形队列</h3><ul><li>我们要实现<strong>无锁并发</strong>，经常会用到<strong>一种结构无锁队列</strong>，而<strong>无锁队列</strong>和我们经常使用的队列颇有不同，它采用的是<strong>环状的队列结构</strong>，为什么成环呢？主要有两个好处，一个是成<strong>环的队列大小是固定</strong>的，另外一个我们通过移动<strong>头和尾就能实现数据的插入和取出</strong>。</li></ul><p><img src="../assets/并发编程/image-15.png" alt="示例图片" style="zoom:100%;" /></p><ul><li><p>图1表示队列为空的时候，头节点和尾节点交会在一起，指向同一个扇区。</p></li><li><p>图2表示当我们你插入一个数字1后，队列大小为1，此时tail指针移动到下一个扇区，head指向头部，1被存储在头部了。</p></li><li><p>图3表示当我们将数字1出队后，head指针向后移动一个扇区，此时head和tail指向同一个扇区，表示队列又为空了。那有人会问队列中数字1为什么不清空呢？其实不用清空，因为当我们插入新数据时就可以覆盖掉1这个无效的数据。</p></li></ul><p>比如我们继续3图，连续插入几个数字，将队列填满。</p><ul><li>当tail + 1 == head的时候队列就满了，所以如果你想存储10个数你得开辟11个空间最后一个空间用来判断满</li></ul><h3 id="用锁实现环形队列"><a href="#用锁实现环形队列" class="headerlink" title="用锁实现环形队列"></a>用锁实现环形队列</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">size_t</span> Cap&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CircularQueLk</span> :<span class="keyword">private</span> std::allocator&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CircularQueLk</span>() :_max_size(Cap + <span class="number">1</span>),_data(std::allocator&lt;T&gt;::<span class="built_in">allocate</span>(_max_size)), _head(<span class="number">0</span>), _tail(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">CircularQueLk</span>(<span class="type">const</span> CircularQueLk&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    CircularQueLk&amp; <span class="keyword">operator</span> = (<span class="type">const</span> CircularQueLk&amp;) <span class="keyword">volatile</span> = <span class="keyword">delete</span>;</span><br><span class="line">    CircularQueLk&amp; <span class="keyword">operator</span> = (<span class="type">const</span> CircularQueLk&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    ~<span class="built_in">CircularQueLk</span>() &#123;</span><br><span class="line">        <span class="comment">//循环销毁</span></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt;  <span class="title">lock</span><span class="params">(_mtx)</span></span>;</span><br><span class="line">        <span class="comment">//调用内部元素的析构函数</span></span><br><span class="line">        <span class="keyword">while</span> (_head != _tail) &#123;</span><br><span class="line">            std::allocator&lt;T&gt;::<span class="built_in">destroy</span>(_data + _head);</span><br><span class="line">            _head = (_head<span class="number">+1</span>)%_max_size;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调用回收操作</span></span><br><span class="line">        std::allocator&lt;T&gt;::<span class="built_in">deallocate</span>(_data, _max_size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//先实现一个可变参数列表版本的插入函数最为基准函数</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...Args&gt;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">emplace</span><span class="params">(Args &amp;&amp; ... args)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_mtx)</span></span>;</span><br><span class="line">        <span class="comment">//判断队列是否满了</span></span><br><span class="line">        <span class="keyword">if</span> ((_tail + <span class="number">1</span>) % _max_size == _head) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;circular que full ! &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在尾部位置构造一个T类型的对象，构造参数为args...</span></span><br><span class="line">        std::allocator&lt;T&gt;::<span class="built_in">construct</span>(_data + _tail, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">        <span class="comment">//更新尾部元素位置</span></span><br><span class="line">        _tail = (_tail + <span class="number">1</span>) % _max_size;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//push 实现两个版本，一个接受左值引用，一个接受右值引用</span></span><br><span class="line">    <span class="comment">//接受左值引用版本</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp; val)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;called push const T&amp; version&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">emplace</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//接受右值引用版本，当然也可以接受左值引用，T&amp;&amp;为万能引用</span></span><br><span class="line">    <span class="comment">// 但是因为我们实现了const T&amp;</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(T&amp;&amp; val)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;called push T&amp;&amp; version&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">emplace</span>(std::<span class="built_in">move</span>(val));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//出队函数</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(T&amp; val)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_mtx)</span></span>;</span><br><span class="line">        <span class="comment">//判断头部和尾部指针是否重合，如果重合则队列为空</span></span><br><span class="line">        <span class="keyword">if</span> (_head == _tail) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;circular que empty ! &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//取出头部指针指向的数据</span></span><br><span class="line">        val = std::<span class="built_in">move</span>(_data[_head]);</span><br><span class="line">        <span class="comment">//更新头部指针</span></span><br><span class="line">        _head = (_head + <span class="number">1</span>) % _max_size;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">size_t</span> _max_size;</span><br><span class="line">    T* _data;</span><br><span class="line">    std::mutex _mtx;</span><br><span class="line">    <span class="type">size_t</span> _head = <span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> _tail = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestCircularQue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//最大容量为10</span></span><br><span class="line">    CircularQueLk&lt;MyClass, <span class="number">5</span>&gt; cq_lk;</span><br><span class="line">    <span class="function">MyClass <span class="title">mc1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">MyClass <span class="title">mc2</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    cq_lk.<span class="built_in">push</span>(mc1);</span><br><span class="line">    cq_lk.<span class="built_in">push</span>(std::<span class="built_in">move</span>(mc2));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="function">MyClass <span class="title">mc</span><span class="params">(i)</span></span>;</span><br><span class="line">        <span class="keyword">auto</span> res = cq_lk.<span class="built_in">push</span>(mc);</span><br><span class="line">        <span class="keyword">if</span> (res == <span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cq_lk.<span class="built_in">push</span>(mc2);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        MyClass mc1;</span><br><span class="line">        <span class="keyword">auto</span> res = cq_lk.<span class="built_in">pop</span>(mc1);</span><br><span class="line">        <span class="keyword">if</span> (!res) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;pop success, &quot;</span> &lt;&lt; mc1 &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> res = cq_lk.<span class="built_in">pop</span>(mc1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="无锁队列"><a href="#无锁队列" class="headerlink" title="无锁队列"></a>无锁队列</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> std::atomic&lt;T&gt;::<span class="built_in">compare_exchange_weak</span>(T &amp;expected, T desired);</span><br><span class="line"><span class="type">bool</span> std::atomic&lt;T&gt;::<span class="built_in">compare_exchange_strong</span>(T &amp;expected, T desired);</span><br></pre></td></tr></table></figure><ul><li><strong>compare_exchange_strong</strong>会比较原子变量atomic<T>的值和expected的值是否相等，如果相等则执行交换操作，将atomic<T>的值换为desired并且返回true,否则将expected的值修改为T变量的值，并且返回false.</li><li>其伪代码可以这么理解</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> atomic&lt;T&gt;::<span class="built_in">compare_exchange_strong</span>(T &amp;expected, T desired) &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(m_lock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (m_val == expected)</span><br><span class="line">        <span class="keyword">return</span> m_val = desired, <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> expected = m_val, <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>compare_exchange_weak功能比compare_exchange_strong弱一些，他不能保证atomic<T>的值和expected的值相等时也会做交换，很可能原子变量和预期值相等也会返回false，所以使用要多次循环使用。</li><li>我们们定义一个类CircularQueSeq, 其内容和之前我们定义的类CircularQueLk差不多，只不过将类的成员变量mutex换成atomic类型的原子变量, 我们可以利用自旋锁的思路将锁替换为原子变量循环检测的方式，进而达到锁住互斥逻辑的效果。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">size_t</span> Cap&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CircularQueSeq</span> :<span class="keyword">private</span> std::allocator&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CircularQueSeq</span>() :_max_size(Cap + <span class="number">1</span>), _data(std::allocator&lt;T&gt;::<span class="built_in">allocate</span>(_max_size)), _atomic_using(<span class="literal">false</span>),_head(<span class="number">0</span>), _tail(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">CircularQueSeq</span>(<span class="type">const</span> CircularQueSeq&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    CircularQueSeq&amp; <span class="keyword">operator</span> = (<span class="type">const</span> CircularQueSeq&amp;) <span class="keyword">volatile</span> = <span class="keyword">delete</span>;</span><br><span class="line">    CircularQueSeq&amp; <span class="keyword">operator</span> = (<span class="type">const</span> CircularQueSeq&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    ~<span class="built_in">CircularQueSeq</span>() &#123;</span><br><span class="line">        <span class="comment">//循环销毁</span></span><br><span class="line">        <span class="type">bool</span> use_expected = <span class="literal">false</span>;</span><br><span class="line">        <span class="type">bool</span> use_desired = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            use_expected = <span class="literal">false</span>;</span><br><span class="line">            use_desired = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!_atomic_using.<span class="built_in">compare_exchange_strong</span>(use_expected, use_desired));</span><br><span class="line">        <span class="comment">//调用内部元素的析构函数</span></span><br><span class="line">        <span class="keyword">while</span> (_head != _tail) &#123;</span><br><span class="line">            std::allocator&lt;T&gt;::<span class="built_in">destroy</span>(_data + _head);</span><br><span class="line">            _head = （_head<span class="number">+1</span>）% _max_size;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调用回收操作</span></span><br><span class="line">        std::allocator&lt;T&gt;::<span class="built_in">deallocate</span>(_data, _max_size);</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            use_expected = <span class="literal">true</span>;</span><br><span class="line">            use_desired = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!_atomic_using.<span class="built_in">compare_exchange_strong</span>(use_expected, use_desired));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//先实现一个可变参数列表版本的插入函数最为基准函数</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...Args&gt;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">emplace</span><span class="params">(Args &amp;&amp; ... args)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> use_expected = <span class="literal">false</span>;</span><br><span class="line">        <span class="type">bool</span> use_desired = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            use_expected = <span class="literal">false</span>;</span><br><span class="line">            use_desired = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!_atomic_using.<span class="built_in">compare_exchange_strong</span>(use_expected, use_desired));</span><br><span class="line">        <span class="comment">//判断队列是否满了</span></span><br><span class="line">        <span class="keyword">if</span> ((_tail + <span class="number">1</span>) % _max_size == _head) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;circular que full ! &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">                use_expected = <span class="literal">true</span>;</span><br><span class="line">                use_desired = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!_atomic_using.<span class="built_in">compare_exchange_strong</span>(use_expected, use_desired));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在尾部位置构造一个T类型的对象，构造参数为args...</span></span><br><span class="line">        std::allocator&lt;T&gt;::<span class="built_in">construct</span>(_data + _tail, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">        <span class="comment">//更新尾部元素位置</span></span><br><span class="line">        _tail = (_tail + <span class="number">1</span>) % _max_size;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            use_expected = <span class="literal">true</span>;</span><br><span class="line">            use_desired = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!_atomic_using.<span class="built_in">compare_exchange_strong</span>(use_expected, use_desired));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//push 实现两个版本，一个接受左值引用，一个接受右值引用</span></span><br><span class="line">    <span class="comment">//接受左值引用版本</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp; val)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;called push const T&amp; version&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">emplace</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//接受右值引用版本，当然也可以接受左值引用，T&amp;&amp;为万能引用</span></span><br><span class="line">    <span class="comment">// 但是因为我们实现了const T&amp;</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(T&amp;&amp; val)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;called push T&amp;&amp; version&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">emplace</span>(std::<span class="built_in">move</span>(val));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//出队函数</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(T&amp; val)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> use_expected = <span class="literal">false</span>;</span><br><span class="line">        <span class="type">bool</span> use_desired = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            use_desired = <span class="literal">true</span>;</span><br><span class="line">            use_expected = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!_atomic_using.<span class="built_in">compare_exchange_strong</span>(use_expected, use_desired));</span><br><span class="line">        <span class="comment">//判断头部和尾部指针是否重合，如果重合则队列为空</span></span><br><span class="line">        <span class="keyword">if</span> (_head == _tail) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;circular que empty ! &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">                use_expected = <span class="literal">true</span>;</span><br><span class="line">                use_desired = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!_atomic_using.<span class="built_in">compare_exchange_strong</span>(use_expected, use_desired));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//取出头部指针指向的数据</span></span><br><span class="line">        val = std::<span class="built_in">move</span>(_data[_head]);</span><br><span class="line">        <span class="comment">//更新头部指针</span></span><br><span class="line">        _head = (_head + <span class="number">1</span>) % _max_size;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            use_expected = <span class="literal">true</span>;</span><br><span class="line">            use_desired = <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">while</span> (!_atomic_using.<span class="built_in">compare_exchange_strong</span>(use_expected, use_desired));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">size_t</span> _max_size;</span><br><span class="line">    T* _data;</span><br><span class="line">    std::atomic&lt;<span class="type">bool</span>&gt; _atomic_using;</span><br><span class="line">    <span class="type">size_t</span> _head = <span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> _tail = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>原子变量为false 才能进函数执行逻辑</li><li>多线程情况下也能保证安全是因为原子变量循环检测保证有且只有一个线程修改成功。读取也是这样。</li></ul><h4 id="单一原子变量的弊端"><a href="#单一原子变量的弊端" class="headerlink" title="单一原子变量的弊端"></a>单一原子变量的弊端</h4><ul><li><p>我们考虑上述单一原子变量的弊端</p></li><li><p>多个线程push和pop操作耦合读太高，同一时刻仅有一个线程pop或者push，而且互斥逻辑的精度不够。影响效率。</p></li><li><p>我们需要考虑将pop和push操作解耦，我们采用的是环形队列，将tail和head作为原子变量可以实现精细控制。</p></li><li><p>比如我们做push操作的时候，一个线程更新完tail标签和数据后，其他线程就可以pop或者push了，精细控制的好处就是效率提升。</p></li><li><p>我们定义一个新的类CircularQueLight，类的基本数据结构和CircularQueSeq差不多。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">size_t</span> Cap&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CircularQueLight</span>: <span class="keyword">private</span> std::allocator&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CircularQueLight</span>():_max_size(Cap + <span class="number">1</span>),</span><br><span class="line">    _data(std::allocator&lt;T&gt;::<span class="built_in">allocate</span>(_max_size))</span><br><span class="line">    , _head(<span class="number">0</span>), _tail(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">CircularQueLight</span>(<span class="type">const</span> CircularQueLight&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    CircularQueLight&amp; <span class="keyword">operator</span> = (<span class="type">const</span> CircularQueLight&amp;) <span class="keyword">volatile</span> = <span class="keyword">delete</span>;</span><br><span class="line">    CircularQueLight&amp; <span class="keyword">operator</span> = (<span class="type">const</span> CircularQueLight&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(T&amp; val)</span> </span>&#123;</span><br><span class="line">            <span class="type">size_t</span> h;</span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">                h = _head.<span class="built_in">load</span>();  <span class="comment">//1 处</span></span><br><span class="line">                <span class="comment">//判断头部和尾部指针是否重合，如果重合则队列为空</span></span><br><span class="line">                <span class="keyword">if</span>(h == _tail.<span class="built_in">load</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                val = _data[h]; <span class="comment">// 2处</span></span><br><span class="line">            &#125; <span class="keyword">while</span> (!_head.<span class="built_in">compare_exchange_strong</span>(h, </span><br><span class="line">                (h<span class="number">+1</span>)% _max_size)); <span class="comment">//3 处</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">size_t</span> _max_size;</span><br><span class="line">    T* _data;</span><br><span class="line">    std::atomic&lt;<span class="type">size_t</span>&gt;  _head;</span><br><span class="line">    std::atomic&lt;<span class="type">size_t</span>&gt; _tail;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>在pop逻辑里我们在1处load获取头部head的值，在2处采用了复制的方式将头部元素取出赋值给val，而不是通过std::move，因为多个线程同时pop最后只有一个线程成功执行3处代码退出，而失败的则需要继续循环，从更新后的head处pop元素。所以不能用std::move，否则会破坏原有的队列数据。</p></li><li><p>接下来看看push的逻辑</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(T&amp; val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">size_t</span> t;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            t = _tail.<span class="built_in">load</span>(); <span class="comment">//1</span></span><br><span class="line">            <span class="comment">//判断队列是否满</span></span><br><span class="line">            <span class="keyword">if</span>( (t<span class="number">+1</span>)%_max_size == _head.<span class="built_in">load</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            _data[t] = val; <span class="comment">//2</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (!_tail.<span class="built_in">compare_exchange_strong</span>(t,</span><br><span class="line">            (t + <span class="number">1</span>) % _max_size)); <span class="comment">//3</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><p>这样会存在危险，push函数的逻辑乍一看和pop一样，但是我们会发现多线程push的情况存在线程安全问题。</p></li><li><p>比如我们线程1 push(1) 而线程2 push(2). 很有可能的顺序是</p></li><li><p>1.1 -&gt; 1.2 -&gt; 2.1 -&gt; 2.2 -&gt; 1.3</p></li><li><p>这样我们看到的效果就是_data[t]被存储为2了，而实际情况应该是被存储为1，因为线程1的原子变量生效，而线程2的原子变量不满足需继续循环。所以_data[t]必须修改为1.</p></li><li><p>那我们改进一下push的函数</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(T&amp; val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">size_t</span> t;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            t = _tail.<span class="built_in">load</span>();  <span class="comment">//1</span></span><br><span class="line">            <span class="comment">//判断队列是否满</span></span><br><span class="line">            <span class="keyword">if</span>( (t<span class="number">+1</span>)%_max_size == _head.<span class="built_in">load</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!_tail.<span class="built_in">compare_exchange_strong</span>(t,</span><br><span class="line">            (t + <span class="number">1</span>) % _max_size));  <span class="comment">//3</span></span><br><span class="line">        _data[t] = val; <span class="comment">//2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>这样可能还会有安全问题，因为你可能一个线程执行到2处，还没来得及更新，另一个线程就开始执行pop操作了，会使得pop出一个未更新的值</li><li>为了解决这个问题，我们可以增加另一个原子变量<strong>_tail_update</strong>来标记尾部数据是否修改完成，如果尾部数据没有修改完成，此时其他线程pop时获取的数据就是不安全的，所以pop要返回false。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp; val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">size_t</span> t;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            t = _tail.<span class="built_in">load</span>();  <span class="comment">//1</span></span><br><span class="line">            <span class="comment">//判断队列是否满</span></span><br><span class="line">            <span class="keyword">if</span>( (t<span class="number">+1</span>)%_max_size == _head.<span class="built_in">load</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!_tail.<span class="built_in">compare_exchange_strong</span>(t,</span><br><span class="line">            (t + <span class="number">1</span>) % _max_size));  <span class="comment">//3</span></span><br><span class="line">        _data[t] = val; <span class="comment">//2</span></span><br><span class="line">        <span class="type">size_t</span> tailup;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            tailup = t;</span><br><span class="line">        &#125; <span class="keyword">while</span> (_tail_update.<span class="built_in">compare_exchange_strong</span>(tailup, </span><br><span class="line">            (tailup + <span class="number">1</span>) % _max_size));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(T&amp; val)</span> </span>&#123;</span><br><span class="line">        <span class="type">size_t</span> h;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            h = _head.<span class="built_in">load</span>();  <span class="comment">//1 处</span></span><br><span class="line">            <span class="comment">//判断头部和尾部指针是否重合，如果重合则队列为空</span></span><br><span class="line">            <span class="keyword">if</span>(h == _tail.<span class="built_in">load</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断如果此时要读取的数据和tail_update是否一致，如果一致说明尾部数据未更新完</span></span><br><span class="line">            <span class="keyword">if</span>(h == _tail_update.<span class="built_in">load</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            val = _data[h]; <span class="comment">// 2处</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (!_head.<span class="built_in">compare_exchange_strong</span>(h, </span><br><span class="line">            (h<span class="number">+1</span>)% _max_size)); <span class="comment">//3 处</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><p>pop版本也是，先判断队列是否为空，再判断h是否和_tail_update的值相等，如果相等说明有写数据的没更新完，直接返回false或者循环等待也行，为了方便我们直接返回false即可。</p></li><li><p>因为我们知道原子操作默认采用的是memory_order_seq_cst内存顺序，性能上不是最优的，我们可以用acquire和release的内存顺序实现同步的效果。</p></li><li>**这样的改动就相当于使用了3个指针，一个指针指向头，一个指向尾，另一个为修改数据后的下一个位置，（也就是说在这个指针之前的位置都是修改好的，这个指针指向的位置是正在被修改）如果一个线程想要读取一个未被修改的值，会被卡住</li></ul><h4 id="优化性能"><a href="#优化性能" class="headerlink" title="优化性能"></a>优化性能</h4><ul><li>我们用acquire和release模型优化上述代码，实现同步。</li><li><p>最简单的方式就是将load的地方变为memory_order_relaxed，compare_exchange_strong的地方变为memory_order_release</p></li><li><p>我们先看pop操作</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(T&amp; val)</span> </span>&#123;</span><br><span class="line">      <span class="type">size_t</span> h;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">          h = _head.<span class="built_in">load</span>(std::memory_order_relaxed);  <span class="comment">//1 处</span></span><br><span class="line">          <span class="comment">//判断头部和尾部指针是否重合，如果重合则队列为空</span></span><br><span class="line">          <span class="keyword">if</span> (h == _tail.<span class="built_in">load</span>(std::memory_order_acquire)) <span class="comment">//2处</span></span><br><span class="line">          &#123;</span><br><span class="line">              std::cout &lt;&lt; <span class="string">&quot;circular que empty ! &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//判断如果此时要读取的数据和tail_update是否一致，如果一致说明尾部数据未更新完</span></span><br><span class="line">          <span class="keyword">if</span> (h == _tail_update.<span class="built_in">load</span>(std::memory_order_acquire)) <span class="comment">//3处</span></span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          val = _data[h]; <span class="comment">// 2处</span></span><br><span class="line">      &#125; <span class="keyword">while</span> (!_head.<span class="built_in">compare_exchange_strong</span>(h,</span><br><span class="line">          (h + <span class="number">1</span>) % _max_size, std::memory_order_release, std::memory_order_relaxed)); <span class="comment">//4 处</span></span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;pop data success, data is &quot;</span> &lt;&lt; val &lt;&lt; std::endl;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li><p>1 处为memory_order_relaxed是因为即使多个线程pop，每个线程获取的head可能不及时，这个没关系，因为我们有4处的while来重试。</p></li><li><p>2 compare_exchange_strong操作，在期望的条件匹配时采用memory_order_release, 期望的条件不匹配时memory_order_relaxed可以提升效率，毕竟还是要重试的。</p></li><li><p>再看push操作</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">size_t</span> t;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        t = _tail.<span class="built_in">load</span>(std::memory_order_relaxed);  <span class="comment">//5</span></span><br><span class="line">        <span class="comment">//判断队列是否满</span></span><br><span class="line">        <span class="keyword">if</span> ((t + <span class="number">1</span>) % _max_size == _head.<span class="built_in">load</span>(std::memory_order_acquire))</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;circular que full ! &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!_tail.<span class="built_in">compare_exchange_strong</span>(t,</span><br><span class="line">        (t + <span class="number">1</span>) % _max_size, std::memory_order_release, std::memory_order_relaxed));  <span class="comment">//6</span></span><br><span class="line">    _data[t] = val; </span><br><span class="line">    <span class="type">size_t</span> tailup;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        tailup = t;</span><br><span class="line">    &#125; <span class="keyword">while</span> (_tail_update.<span class="built_in">compare_exchange_strong</span>(tailup,</span><br><span class="line">        (tailup + <span class="number">1</span>) % _max_size, std::memory_order_release, std::memory_order_relaxed)); <span class="comment">//7</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;called push data success &quot;</span> &lt;&lt; val &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>两个线程协同工作，一个线程先push，另一个线程后pop，那么对于tail部分和_tail_update，我们要保证push的结果_data[t] = val;先于pop的结果val = _data[h];</p></li><li><p>所以push线程中对于_tail_update的compare_exchange_strong操作采用memory_order_release方式。</p></li><li><p>pop线程对于_tail_update的load操作采用memory_order_acquire。</p></li><li><p>如果一个线程先pop，另一个线程先push，那么对于head部分，我们要保证pop的结果val = _data[h];先于pop的结果_data[t] = val;。</p></li></ul><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><ul><li><p>优势</p></li><li><p>无锁高并发. 虽然存在循环重试, 但是这只会在相同操作并发的时候出现. push 不会因为与 pop 并发而重试, 反之亦然.</p></li><li><p>缺陷</p></li><li><p>这样队列只应该存储标量, 如果存储类对象时，多个push线程只有一个线程push成功，而拷贝复制的开销很大，其他线程会循环重试，每次重试都会有开销。</p></li></ul><h2 id="利用栅栏实现同步模型"><a href="#利用栅栏实现同步模型" class="headerlink" title="利用栅栏实现同步模型"></a>利用栅栏实现同步模型</h2><h3 id="线程可见顺序"><a href="#线程可见顺序" class="headerlink" title="线程可见顺序"></a>线程可见顺序</h3><ul><li><p>我们提到过除了memory_order_seq_cst顺序，其他的顺序都不能保证原子变量修改的值在其他多线程中看到的顺序是一致的。</p></li><li><p>但是可以通过同步机制保证一个线程对原子变量的修改对另一个原子变量可见。通过“Syncronizes With” 的方式达到先行的效果。</p></li><li><p>但是我们说的先行是指 “A Syncronizes With B ”， 如果A 的结果被B读取，则A 先行于B。</p></li><li><p>有时候我们线程1对A的store操作采用release内存序，而线程2对B的load采用acquire内存序，并不能保证A 一定比 B先执行。因为两个线程并行执行无法确定先后顺序，我们指的先行不过是说如果B读取了A操作的结果，则称A先行于B</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; x, y;</span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; z;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_x</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_release); <span class="comment">//1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_y</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    y.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_release); <span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_x_then_y</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!x.<span class="built_in">load</span>(std::memory_order_acquire));</span><br><span class="line">    <span class="keyword">if</span> (y.<span class="built_in">load</span>(std::memory_order_acquire))   <span class="comment">//3</span></span><br><span class="line">        ++z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_y_then_x</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!y.<span class="built_in">load</span>(std::memory_order_acquire));</span><br><span class="line">    <span class="keyword">if</span> (x.<span class="built_in">load</span>(std::memory_order_acquire))   <span class="comment">//4</span></span><br><span class="line">        ++z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>我们写一个函数测试，函数TestAR中初始化x和y为false， 启动4个线程a,b,c,d，分别执行write_x, write_y, read_x_then_y, read_y_then_x.</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestAR</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x = <span class="literal">false</span>;</span><br><span class="line">    y = <span class="literal">false</span>;</span><br><span class="line">    z = <span class="number">0</span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">a</span><span class="params">(write_x)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">b</span><span class="params">(write_y)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">c</span><span class="params">(read_x_then_y)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">d</span><span class="params">(read_y_then_x)</span></span>;</span><br><span class="line">    a.<span class="built_in">join</span>();</span><br><span class="line">    b.<span class="built_in">join</span>();</span><br><span class="line">    c.<span class="built_in">join</span>();</span><br><span class="line">    d.<span class="built_in">join</span>();</span><br><span class="line">    <span class="built_in">assert</span>(z.<span class="built_in">load</span>() != <span class="number">0</span>); <span class="comment">//5</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;z value is &quot;</span> &lt;&lt; z.<span class="built_in">load</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>有的读者可能会觉5处的断言不会被触发，他们认为c和d肯定会有一个线程对z执行++操作。他们的思路是这样的。 1 如果c线程执行read_x_then_y没有对z执行加加操作，那么说明c线程读取的x值为true, y值为false。 2 之后d线程读取时，如果保证执行到4处说明y为true，等d线程执行4处代码时x必然为true。 3 他们的理解是如果x先被store为true，y后被store为true，c线程看到y为false时x已经为true了，那么d线程y为true时x也早就为true了，所以z一定会执行加加操作。</p></li><li><p>上述理解是不正确的，我们提到过即便是releas和acquire顺序也不能保证多个线程看到的一个变量的值是一致的，更不能保证看到的多个变量的值是一致的。</p></li><li><p>变量x和y的载入操作3和4有可能都读取false值（与宽松次序的情况一样），因此有可能令断言触发错误。变量x和y分别由不同线程写出，所以两个释放操作都不会影响到对方线程。</p></li><li><p>看下图</p></li></ul><p><img src="../assets/并发编程/image-17.png" alt="示例图片" style="zoom:100%;" /></p><ul><li><p>无论x和y的store顺序谁先谁后，线程c和线程d读取的x和y顺序都不一定一致。</p></li><li><p>从CPU的角度我们可以这么理解</p></li></ul><p><img src="../assets/并发编程/image-18.png" alt="示例图片" style="zoom:100%;" /></p><ul><li><p>在一个4核CPU结构的主机上，a,b,c,d分别运行在不同的CPU内核上。</p></li><li><p>a执行x.store(true)先被线程c读取，而此时线程b对y的store还没有被c读取到新的值，所以此时c读取的x为true，y为false。</p></li><li><p>同样的道理，d可以读取b修改y的最新值，但是没来的及读取x的最新值，那么读取到y为true，x为false。</p></li><li><p>即使我们采用release和acquire方式也不能保证全局顺序一致。如果一个线程对变量执行release内存序的store操作，另一个线程不一定会马上读取到。这个大家要理解。</p></li></ul><h2 id="栅栏"><a href="#栅栏" class="headerlink" title="栅栏"></a>栅栏</h2><ul><li><p>有时候我们可以通过栅栏保证指令编排顺序。</p></li><li><p>看下面一段代码</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; x,y;</span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; z;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_x_then_y</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x.<span class="built_in">store</span>(<span class="literal">true</span>,std::memory_order_relaxed); <span class="comment">// 1</span></span><br><span class="line">    y.<span class="built_in">store</span>(<span class="literal">true</span>,std::memory_order_relaxed);   <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_y_then_x</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!y.<span class="built_in">load</span>(std::memory_order_relaxed));  <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">if</span>(x.<span class="built_in">load</span>(std::memory_order_relaxed))  <span class="comment">// 4</span></span><br><span class="line">        ++z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="literal">false</span>;</span><br><span class="line">    y=<span class="literal">false</span>;</span><br><span class="line">    z=<span class="number">0</span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">a</span><span class="params">(write_x_then_y)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">b</span><span class="params">(read_y_then_x)</span></span>;</span><br><span class="line">    a.<span class="built_in">join</span>();</span><br><span class="line">    b.<span class="built_in">join</span>();</span><br><span class="line">    <span class="built_in">assert</span>(z.<span class="built_in">load</span>()!=<span class="number">0</span>);  <span class="comment">//5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>上面的代码我们都采用的是memory_order_relaxed, 所以无法保证a线程将x,y修改后b线程看到的也是先修改x，再修改y的值。b线程可能先看到y被修改为true，x后被修改为true，那么b线程执行到4处时x可能为false导致z不会加加，5处断言会被触发。</p></li><li><p>那我们之前做法可以解决这个问题</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_x_then_y3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_relaxed); <span class="comment">// 1</span></span><br><span class="line">    y.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_release);   <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_y_then_x3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!y.<span class="built_in">load</span>(std::memory_order_acquire));  <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">if</span> (x.<span class="built_in">load</span>(std::memory_order_relaxed))  <span class="comment">// 4</span></span><br><span class="line">        ++z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>可以通过std::memory_order_release和std::memory_order_acquire形成同步关系。</p></li><li><p>线程a执行write_x_then_y3，线程b执行read_y_then_x3，如果线程b执行到4处，说明y已经被线程a设置为true。</p></li><li><p>线程a执行到2，也必然执行了1，因为是memory_order_release的内存顺序，所以线程a能2操作之前的指令在2之前被写入内存。</p></li><li><p>同样的道理，线程b在3处执行的是memory_order_acquire的内存顺序，所以能保证4不会先于3写入内存，这样我们能知道1一定先行于4.</p></li><li><p>进而推断出z会加加，所以不会触发assert(z.load() != 0);的断言。</p></li><li><p>其实我们可以通过栅栏机制保证指令的写入顺序。栅栏的机制和memory_order_release类似。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_x_then_y_fence</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_relaxed);  <span class="comment">//1</span></span><br><span class="line">    std::<span class="built_in">atomic_thread_fence</span>(std::memory_order_release);  <span class="comment">//2</span></span><br><span class="line">    y.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_relaxed);  <span class="comment">//3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_y_then_x_fence</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!y.<span class="built_in">load</span>(std::memory_order_relaxed));  <span class="comment">//4</span></span><br><span class="line">    std::<span class="built_in">atomic_thread_fence</span>(std::memory_order_acquire); <span class="comment">//5</span></span><br><span class="line">    <span class="keyword">if</span> (x.<span class="built_in">load</span>(std::memory_order_relaxed))  <span class="comment">//6</span></span><br><span class="line">        ++z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestFence</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x = <span class="literal">false</span>;</span><br><span class="line">    y = <span class="literal">false</span>;</span><br><span class="line">    z = <span class="number">0</span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">a</span><span class="params">(write_x_then_y_fence)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">b</span><span class="params">(read_y_then_x_fence)</span></span>;</span><br><span class="line">    a.<span class="built_in">join</span>();</span><br><span class="line">    b.<span class="built_in">join</span>();</span><br><span class="line">    <span class="built_in">assert</span>(z.<span class="built_in">load</span>() != <span class="number">0</span>);   <span class="comment">//7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>处的断言也不会触发。我们可以分析一下，</p></li><li><p>线程a运行write_x_then_y_fence，线程b运行read_y_then_x_fence.</p></li><li><p>当线程b执行到5处时说明4已经结束，此时线程a看到y为true，那么线程a必然已经执行完3.</p></li><li><p>尽管4和3我们采用的是std::memory_order_relaxed顺序，但是通过逻辑关系保证了3的结果同步给4，进而”3 happens-before 4”</p></li><li><p>因为我们采用了栅栏std::atomic_fence所以，5处能保证6不会先于5写入内存，(memory_order_acquire保证其后的指令不会先于其写入内存)</p></li><li><p>2处能保证1处的指令先于2写入内存，进而”1 happens-before 6”, 1的结果会同步给 6</p></li><li><p>所以”atomic_thread_fence”其实和”release-acquire”相似，都是保证memory_order_release之前的指令不会排到其后，memory_order_acquire之后的指令不会排到其之前。</p></li></ul><h2 id="基于锁是新鲜线程安全队列与栈"><a href="#基于锁是新鲜线程安全队列与栈" class="headerlink" title="基于锁是新鲜线程安全队列与栈"></a>基于锁是新鲜线程安全队列与栈</h2><h3 id="线程安全的栈"><a href="#线程安全的栈" class="headerlink" title="线程安全的栈"></a>线程安全的栈</h3><ul><li>实现一个线程安全的栈，我们能想到的是基于锁控制push和pop操作，比如下面的逻辑</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">empty_stack</span> : std::exception</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">what</span><span class="params">()</span> <span class="type">const</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadsafe_stack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::stack&lt;T&gt; data;</span><br><span class="line">    <span class="keyword">mutable</span> std::mutex m;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">threadsafe_stack</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">threadsafe_stack</span>(<span class="type">const</span> threadsafe_stack&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(other.m)</span></span>;</span><br><span class="line">        data = other.data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    threadsafe_stack&amp; <span class="keyword">operator</span>=(<span class="type">const</span> threadsafe_stack&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        data.<span class="built_in">push</span>(std::<span class="built_in">move</span>(new_value));    <span class="comment">// ⇽-- - 1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (data.<span class="built_in">empty</span>()) <span class="keyword">throw</span> <span class="built_in">empty_stack</span>();  <span class="comment">//  ⇽-- - 2</span></span><br><span class="line">            <span class="function">std::shared_ptr&lt;T&gt; <span class="type">const</span> <span class="title">res</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">                std::make_shared&lt;T&gt;(std::move(data.top())))</span></span>;   <span class="comment">// ⇽-- - 3</span></span><br><span class="line">            data.<span class="built_in">pop</span>();   <span class="comment">// ⇽-- - 4</span></span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(T&amp; value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (data.<span class="built_in">empty</span>()) <span class="keyword">throw</span> <span class="built_in">empty_stack</span>();</span><br><span class="line">        value = std::<span class="built_in">move</span>(data.<span class="built_in">top</span>());   <span class="comment">// ⇽-- - 5</span></span><br><span class="line">            data.<span class="built_in">pop</span>();   <span class="comment">// ⇽-- - 6</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> data.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>我们实现了push操作和pop操作</p></li><li><p>push操作里加锁，然后将数据通过std::move的方式移动放入stack中。我们思考如果1处因为机器内存不足push导致异常，此种情况并不会对栈已有的数据产生危险。<br>但是vector容器大家要考虑，因为vector存在内存不足时将数据拷贝转移到新空间的过程。那么对于vector这种动态扩容的容器该如何保证容器内数据在移动过程中出现了异常仍能不丢失呢？</p></li><li><p>我想到的一个方式就是管理vector的capacity，每次push的时候要判断一下vector的size和capacity是否相等，如果相等则手动扩容并将数据转移到新的vector，再释放旧有的vector。</p></li><li><p>但是同样会存在一个问题就是会造成内存溢出，因为vector的capacity会随着数据增加而增加，当vector中没有数据的时候capacity仍然很大。这种方式也可以通过swap的方式将当前大容量的vector和一个空的vector做交换，快速清空内存。这些操作和思路需结合实际开发情况而定。</p></li><li><p>pop提供了两个版本，一个是返回智能指针一个是返回bool类型，这两种我们分析，比如3处和4处也很可能因为内存不足导致构造智能指针失败，或者5处赋值失败，这种情况下抛出异常并不会影响栈内数据，因为程序没走到4和6处就抛出异常了。</p></li><li><p>pop函数内部判断栈是否空，如果为空则抛出异常，这种情况我们不能接受，异常是用来处理和预判突发情况的，对于一个栈为空这种常见现象，仅需根据返回之后判断为空再做尝试或放弃出栈即可。</p></li><li><p>为了解决栈为空就抛出异常的问题，我们可以做如下优化</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>  T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadsafe_stack_waitable</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::stack&lt;T&gt; data;</span><br><span class="line">    <span class="keyword">mutable</span> std::mutex m;</span><br><span class="line">    std::condition_variable cv;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">threadsafe_stack_waitable</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">threadsafe_stack_waitable</span>(<span class="type">const</span> threadsafe_stack_waitable&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(other.m)</span></span>;</span><br><span class="line">        data = other.data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    threadsafe_stack_waitable&amp; <span class="keyword">operator</span>=(<span class="type">const</span> threadsafe_stack_waitable&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        data.<span class="built_in">push</span>(std::<span class="built_in">move</span>(new_value));    <span class="comment">// ⇽-- - 1</span></span><br><span class="line">        cv.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">wait_and_pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]()   </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(data.<span class="built_in">empty</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;); <span class="comment">//  ⇽-- - 2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function">std::shared_ptr&lt;T&gt; <span class="type">const</span> <span class="title">res</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            std::make_shared&lt;T&gt;(std::move(data.top())))</span></span>;   <span class="comment">// ⇽-- - 3</span></span><br><span class="line">        data.<span class="built_in">pop</span>();   <span class="comment">// ⇽-- - 4</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wait_and_pop</span><span class="params">(T&amp; value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]()</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (data.<span class="built_in">empty</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        value = std::<span class="built_in">move</span>(data.<span class="built_in">top</span>());   <span class="comment">// ⇽-- - 5</span></span><br><span class="line">        data.<span class="built_in">pop</span>();   <span class="comment">// ⇽-- - 6</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> data.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">try_pop</span><span class="params">(T&amp; value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(data.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        value = std::<span class="built_in">move</span>(data.<span class="built_in">top</span>());</span><br><span class="line">        data.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">try_pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(data.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;T&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::shared_ptr&lt;T&gt; <span class="title">res</span><span class="params">(std::make_shared&lt;T&gt;(std::move(data.top())))</span></span>;</span><br><span class="line">        data.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>我们将pop优化为四个版本，四个版本又可以分为两个大类，两个大类分别为try_pop版本和wait_and_pop版本。</p></li><li><p>try_pop版本不阻塞等待队列有数据才返回，而是直接返回，try_pop又有两个版本，分别返回bool值和指针值。如果队列为空返回false或者空指针。</p></li><li><p>wait_and_pop版本阻塞等待队列有数据才返回，同样有两个版本，分别返回bool值和指针值。</p></li><li><p>但是上面的代码我们分析，假设此时栈为空，有一个线程A从队列中消费数据，调用wait_and_pop挂起, 此时另一个线程B向栈中放入数据调用push操作，notify一个线程消费队列中的数据。</p></li><li><p>此时A从wait_and_pop唤醒，但是在执行3或者5处时，因为内存不足引发了异常，我们之前分析过，即使引发异常也不会影响到栈内数据，所以对于栈的数据来说是安全的，但是线程A异常后，其他线程无法从队列中消费数据，除非线程B再执行一次push。因为我们采用的是notify_one的方式，所以仅有一个线程被激活，如果被激活的线程异常了，就不能保证该数据被其他线程消费了，解决这个问题，可以采用几个方案。</p><ol><li>wai_and_pop失败的线程修复后再次取一次数据。</li><li>将notify_one改为notify_all，这样能保证通知所有线程。但是notify_all将导致所有线程竞争，并不可取。</li><li>我们可以通过栈存储智能指针的方式进行，因为智能指针在赋值的时候不会引发异常。</li></ol></li><li><p>稍后我们提供的线程安全队列的版本使用的就是第三种优化。</p></li></ul><h3 id="线程安全队列"><a href="#线程安全队列" class="headerlink" title="线程安全队列"></a>线程安全队列</h3><ul><li>队列和栈最大的不同就是队列为先入先出，有了线程安全的栈的开发思路，我们很快实现一个支持线程安全的队列</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadsafe_queue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mutable</span> std::mutex mut;</span><br><span class="line">    std::queue&lt;T&gt; data_queue;</span><br><span class="line">    std::condition_variable data_cond;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">threadsafe_queue</span>()</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">        data_queue.<span class="built_in">push</span>(std::<span class="built_in">move</span>(new_value));</span><br><span class="line">        data_cond.<span class="built_in">notify_one</span>();    <span class="comment">//⇽-- - ①</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wait_and_pop</span><span class="params">(T&amp; value)</span>    <span class="comment">//⇽-- - ②</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">        data_cond.<span class="built_in">wait</span>(lk, [<span class="keyword">this</span>] &#123;<span class="keyword">return</span> !data_queue.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line">        value = std::<span class="built_in">move</span>(data_queue.<span class="built_in">front</span>());</span><br><span class="line">        data_queue.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">wait_and_pop</span><span class="params">()</span>   <span class="comment">// ⇽-- - ③</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">        data_cond.<span class="built_in">wait</span>(lk, [<span class="keyword">this</span>] &#123;<span class="keyword">return</span> !data_queue.<span class="built_in">empty</span>(); &#125;);   <span class="comment">// ⇽-- - ④</span></span><br><span class="line">        <span class="function">std::shared_ptr&lt;T&gt; <span class="title">res</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            std::make_shared&lt;T&gt;(std::move(data_queue.front())))</span></span>;</span><br><span class="line">        data_queue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">try_pop</span><span class="params">(T&amp; value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (data_queue.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        value = std::<span class="built_in">move</span>(data_queue.<span class="built_in">front</span>());</span><br><span class="line">        data_queue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">try_pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (data_queue.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;T&gt;();    <span class="comment">//⇽-- - ⑤</span></span><br><span class="line">        <span class="function">std::shared_ptr&lt;T&gt; <span class="title">res</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            std::make_shared&lt;T&gt;(std::move(data_queue.front())))</span></span>;</span><br><span class="line">        data_queue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> data_queue.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>关于异常情况的分析和栈一样，上面的队列版本不存在异常导致数据丢失的问题。但是同样面临线程执行wait_and_pop时如果出现了异常，导致数据被滞留在队列中，其他线程也无法被唤醒的情况。</p></li><li><p>为了解决这种情况，我们前文提到了采用智能指针的方式，重新实现一下线程安全队列</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadsafe_queue_ptr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> std::mutex mut;</span><br><span class="line">    std::queue&lt;std::shared_ptr&lt;T&gt;&gt; data_queue;</span><br><span class="line">    std::condition_variable data_cond;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">threadsafe_queue_ptr</span>()</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wait_and_pop</span><span class="params">(T&amp; value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">        data_cond.<span class="built_in">wait</span>(lk, [<span class="keyword">this</span>] &#123;<span class="keyword">return</span> !data_queue.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line">        value = std::<span class="built_in">move</span>(*data_queue.<span class="built_in">front</span>());    <span class="comment">//⇽-- - 1</span></span><br><span class="line">            data_queue.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">try_pop</span><span class="params">(T&amp; value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (data_queue.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        value = std::<span class="built_in">move</span>(*data_queue.<span class="built_in">front</span>());   <span class="comment">// ⇽-- - 2</span></span><br><span class="line">            data_queue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">wait_and_pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">        data_cond.<span class="built_in">wait</span>(lk, [<span class="keyword">this</span>] &#123;<span class="keyword">return</span> !data_queue.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line">        std::shared_ptr&lt;T&gt; res = data_queue.<span class="built_in">front</span>();   <span class="comment">// ⇽-- - 3</span></span><br><span class="line">            data_queue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">try_pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (data_queue.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;T&gt;();</span><br><span class="line">        std::shared_ptr&lt;T&gt; res = data_queue.<span class="built_in">front</span>();   <span class="comment">// ⇽-- - 4</span></span><br><span class="line">            data_queue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::shared_ptr&lt;T&gt; <span class="title">data</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            std::make_shared&lt;T&gt;(std::move(new_value)))</span></span>;   <span class="comment">// ⇽-- - 5</span></span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">        data_queue.<span class="built_in">push</span>(data);</span><br><span class="line">        data_cond.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> data_queue.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>在5处，我们push数据时需要先构造智能指针，如果构造的过程失败了也就不会push到队列中，不会污染队列中的数据。</p></li><li><p>2，3处和4，5处我们仅仅时将智能指针取出来赋值给一个新的智能指针并返回。关于智能指针的赋值不会引发异常这一点在C++并发编程中提及，这一点我觉得有些存疑，我觉得书中表述的意思应该是指针在64位机器占用8个字节，所有智能指针共享引用计数所以在复制时仅为8字节开销，降低了内存消耗。</p></li><li><p>所以推荐大家存储数据放入容器中时尽量用智能指针，这样能保证复制和移动过程中开销较小，也可以实现一定意义的数据共享。</p></li><li><p>但是我们分析上面的代码，队列push和pop时采用的是一个mutex，导致push和pop等操作串行化，我们要考虑的是优化锁的精度，提高并发，那有什么办法吗？</p></li><li><p>我们分析，队列和栈最本质的区别是队列是首尾操作。我们可以考虑将push和pop操作分化为分别对尾和对首部的操作。对首和尾分别用不同的互斥量管理就可以实现真正意义的并发了。</p></li><li><p>我们引入虚位节点的概念，表示一个空的节点，没有数据，是一个无效的节点，初始情况下，队列为空，head和tail节点都指向这个虚位节点。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadsafe_queue_ht</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;T&gt; data;</span><br><span class="line">        std::unique_ptr&lt;node&gt; next;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::mutex head_mutex;</span><br><span class="line">    std::unique_ptr&lt;node&gt; head;</span><br><span class="line">    std::mutex tail_mutex;</span><br><span class="line">    node* tail;</span><br><span class="line">    std::condition_variable data_cond;</span><br><span class="line"></span><br><span class="line">    <span class="function">node* <span class="title">get_tail</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">tail_lock</span><span class="params">(tail_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> tail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;node&gt; <span class="title">pop_head</span><span class="params">()</span>   </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::unique_ptr&lt;node&gt; old_head = std::<span class="built_in">move</span>(head);</span><br><span class="line">        head = std::<span class="built_in">move</span>(old_head-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> old_head;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">wait_for_data</span><span class="params">()</span>   </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">head_lock</span><span class="params">(head_mutex)</span></span>;</span><br><span class="line">        data_cond.<span class="built_in">wait</span>(head_lock,[&amp;] &#123;<span class="keyword">return</span> head.<span class="built_in">get</span>() != <span class="built_in">get_tail</span>(); &#125;); <span class="comment">//5</span></span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">move</span>(head_lock);   </span><br><span class="line">    &#125;</span><br><span class="line">        <span class="function">std::unique_ptr&lt;node&gt; <span class="title">wait_pop_head</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">head_lock</span><span class="params">(wait_for_data())</span></span>;   </span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">pop_head</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">std::unique_ptr&lt;node&gt; <span class="title">wait_pop_head</span><span class="params">(T&amp; value)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">head_lock</span><span class="params">(wait_for_data())</span></span>;  </span><br><span class="line">                value = std::<span class="built_in">move</span>(*head-&gt;data);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">pop_head</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function">std::unique_ptr&lt;node&gt; <span class="title">try_pop_head</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">head_lock</span><span class="params">(head_mutex)</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (head.<span class="built_in">get</span>() == <span class="built_in">get_tail</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> std::<span class="built_in">unique_ptr</span>&lt;node&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">pop_head</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">std::unique_ptr&lt;node&gt; <span class="title">try_pop_head</span><span class="params">(T&amp; value)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">head_lock</span><span class="params">(head_mutex)</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (head.<span class="built_in">get</span>() == <span class="built_in">get_tail</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> std::<span class="built_in">unique_ptr</span>&lt;node&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            value = std::<span class="built_in">move</span>(*head-&gt;data);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">pop_head</span>();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">threadsafe_queue_ht</span>() :  <span class="comment">// ⇽-- - 1</span></span><br><span class="line">        <span class="built_in">head</span>(<span class="keyword">new</span> node), <span class="built_in">tail</span>(head.<span class="built_in">get</span>())</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">threadsafe_queue_ht</span>(<span class="type">const</span> threadsafe_queue_ht&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    threadsafe_queue_ht&amp; <span class="keyword">operator</span>=(<span class="type">const</span> threadsafe_queue_ht&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">wait_and_pop</span><span class="params">()</span> <span class="comment">//  &lt;------3</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::unique_ptr&lt;node&gt; <span class="type">const</span> old_head = <span class="built_in">wait_pop_head</span>();</span><br><span class="line">        <span class="keyword">return</span> old_head-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wait_and_pop</span><span class="params">(T&amp; value)</span>  <span class="comment">//  &lt;------4</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::unique_ptr&lt;node&gt; <span class="type">const</span> old_head = <span class="built_in">wait_pop_head</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">try_pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::unique_ptr&lt;node&gt; old_head = <span class="built_in">try_pop_head</span>();</span><br><span class="line">        <span class="keyword">return</span> old_head ? old_head-&gt;data : std::<span class="built_in">shared_ptr</span>&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">try_pop</span><span class="params">(T&amp; value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::unique_ptr&lt;node&gt; <span class="type">const</span> old_head = <span class="built_in">try_pop_head</span>(value);</span><br><span class="line">        <span class="keyword">return</span> old_head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">head_lock</span><span class="params">(head_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> (head.<span class="built_in">get</span>() == <span class="built_in">get_tail</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T new_value)</span>  <span class="comment">//&lt;------2</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::shared_ptr&lt;T&gt; <span class="title">new_data</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            std::make_shared&lt;T&gt;(std::move(new_value)))</span></span>;</span><br><span class="line">        <span class="function">std::unique_ptr&lt;node&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> node)</span></span>;</span><br><span class="line">        node* <span class="type">const</span> new_tail = p.<span class="built_in">get</span>();</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">tail_lock</span><span class="params">(tail_mutex)</span></span>;</span><br><span class="line">        tail-&gt;data = new_data;</span><br><span class="line">        tail-&gt;next = std::<span class="built_in">move</span>(p);</span><br><span class="line">        tail = new_tail;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>node为节点类型，包含data和next两个成员。 data为智能指针类型存储T类型的数据。next为指向下一个节点的智能指针，以此形成链表。</p></li><li><p>上述代码我们的head是一个node类型的智能指针。而tail为node类型的普通指针，读者也可以用智能指针。</p></li><li><p>在1处构造函数那里，我们将head和tail初始指向的位置设置为虚位节点。</p></li><li><p>在2 处我们push数据的时候先构造T类型的智能指针存储数据new_data，然后我们构造了一个新的智能指针p, p取出裸指针就是新的虚位节点new_tail，我们将new_data赋值给现在的尾节点，并且让尾节点的next指针指向p, 然后将tail更新为我们新的虚位节点。</p></li><li><p>3，4处都是wait_and_pop的不同版本，内部调用了wait_pop_head，wait_pop_head内部先调用wait_for_data判断队列是否为空，这里判断是否为空主要是判断head是否指向虚位节点。如果不为空则返回unique_lock，我们显示的调用了move操作，返回unique_lock仍保留对互斥量的锁住状态。</p></li><li><p>回到wait_pop_head中，接下来执行pop_head将数据pop出来。</p></li><li><p>值得注意的是get_tail()返回tail节点，那么我们思考如果此时有多个线程push数据，tail节点已经变化了，我们此时在5处的判断可能是基于push之前的tail信息，但是不影响逻辑，因为如果head和tail相等则线程挂起，等待通知，如果不等则继续执行，push操作只会将tail向后移动不会导致逻辑问题。</p></li><li><p>pop_head中我们将head节点移动给一个old_head变量，然后将old_head的next节点更新为新的head。这里我觉得可以简化写为head=head-&gt;next.</p></li></ul><h2 id="实现线程安全的查找表"><a href="#实现线程安全的查找表" class="headerlink" title="实现线程安全的查找表"></a>实现线程安全的查找表</h2><h3 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h3><p>散列表（Hash table，也叫哈希表），是根据键（Key）而直接访问在存储器存储位置的数据结构。 也就是说，它通过计算出一个键值的函数，将所需查询的数据映射到表中一个位置来让人访问，这加快了查找速度。 这个映射函数称做散列函数，存放记录的数组称做散列表。</p><h3 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h3><ul><li><p>我们要实现上述逻辑，可以考虑将11，12，13等hash值放入一个vector中。多线程根据key计算得出hash值的过程并不需要加锁，可以实现并行计算。</p></li><li><p>但是对于链表的增删改查需要加锁。</p></li><li><p>所以我们考虑将链表封装为一个类bucket_type,支持数据的增删改查。</p></li><li><p>我们将整体的查找表封装为threadsafe_lookup_table类，实现散列规则和调度bucket_type类。</p></li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><ul><li>我们先实现内部的bucket_type类. 为了threadsafe_lookup_table可以访问他，所以将threadsafe_lookup_table设置为其友元类</li><li>接下来我们设计threadsafe_lookup_table类。我们用一个vector存储上面的bucket_type类型。 因为我们要计算hash值，key可能是多种类型string, int等，所以我们采用std的hash算法作为散列函数即可.</li><li><p>get_bucket函数不需要加锁，各个线程可以并行计算哈希值，取出key对应的桶。如果多线程调用同一个bucket的增删改查，就通过bucket内部的互斥解决线程安全问题。 接下来我们完善threadsafe_lookup_table的对外接口</p></li><li><p>查找表头文件</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;shared_mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value, <span class="keyword">typename</span> Hash = std::hash&lt;Key&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> threadsafe_lockup_table &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">class</span> bucket_type &#123;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> threadsafe_lockup_table;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;Key, Value&gt; bucket_value;</span><br><span class="line"><span class="keyword">typedef</span> std::list&lt;bucket_value&gt; bucket_data;</span><br><span class="line"><span class="comment">// 在模板中指定类型的时候要加typename</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> bucket_data::iterator bucket_iterator;</span><br><span class="line">bucket_data data;</span><br><span class="line"><span class="keyword">mutable</span> std::shared_mutex mutex;</span><br><span class="line"></span><br><span class="line"><span class="function">bucket_iterator <span class="title">find_entry_for</span><span class="params">(<span class="type">const</span> Key&amp; key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">find_if</span>(data.<span class="built_in">begin</span>(), data.<span class="built_in">end</span>(), [&amp;](<span class="type">const</span> bucket_value&amp; item) &#123;</span><br><span class="line"><span class="keyword">return</span> item.first == key;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//查找key值，找到返回对应的value，没有找到返回提供的默认值</span></span><br><span class="line"><span class="function">Value <span class="title">value_for</span><span class="params">(<span class="type">const</span> Key&amp; key, <span class="type">const</span> Value&amp; default_value)</span> </span>&#123;</span><br><span class="line"><span class="function">std::shared_lock&lt;std::shared_mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line">bucket_iterator <span class="type">const</span> found_entry = <span class="built_in">find_entry_for</span>(key);</span><br><span class="line"><span class="keyword">return</span> (found_entry == data.<span class="built_in">end</span>()) ? default_value: found_entry-&gt;second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加key和value，找到更新，没找到就添加</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_or_update_mapping</span><span class="params">(<span class="type">const</span> Key&amp; key, <span class="type">const</span> Value&amp; value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> found_entry = <span class="built_in">find_entry_for</span>(key);</span><br><span class="line"><span class="keyword">if</span> (found_entry == data.<span class="built_in">end</span>()) &#123;</span><br><span class="line">data.<span class="built_in">push_back</span>(<span class="built_in">bucket_value</span>(key, value));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">found_entry-&gt;second = value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除对应的key</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove_mapping</span><span class="params">(Key <span class="type">const</span>&amp; key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">std::unique_lock&lt;std::shared_mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line">bucket_iterator <span class="type">const</span> found_entry = <span class="built_in">find_entry_for</span>(key);</span><br><span class="line"><span class="keyword">if</span> (found_entry != data.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">data.<span class="built_in">erase</span>(found_entry);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">//用vector存储桶类型</span></span><br><span class="line">std::vector&lt;std::unique_ptr&lt;bucket_type&gt;&gt; buckets;</span><br><span class="line"><span class="comment">//hash&lt;Key&gt; 哈希表 用来根据key生成哈希值</span></span><br><span class="line">Hash hasher;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//根据key生成数字，并对桶的大小取余得到下标，根据下标返回对应的桶智能指针</span></span><br><span class="line"><span class="function">bucket_type&amp; <span class="title">get_bucket</span><span class="params">(Key <span class="type">const</span>&amp; key)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::<span class="type">size_t</span> <span class="type">const</span> bucket_index = <span class="built_in">hasher</span>(key) % buckets.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">return</span> *buckets[bucket_index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">threadsafe_lockup_table</span>(<span class="type">unsigned</span> num_buckets = <span class="number">19</span>, Hash <span class="type">const</span>&amp; hasher_ = <span class="built_in">Hash</span>()) :</span><br><span class="line"><span class="built_in">buckets</span>(num_buckets), <span class="built_in">hasher</span>(hasher_)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; num_buckets; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//让智能指针转绑定</span></span><br><span class="line">buckets[i].<span class="built_in">reset</span>(<span class="keyword">new</span> bucket_type);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">threadsafe_lockup_table</span>(threadsafe_lockup_table <span class="type">const</span>&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">threadsafe_lockup_table&amp; <span class="keyword">operator</span>=(threadsafe_lockup_table <span class="type">const</span>&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Value() 就是用构造函数构造一个默认值，这是查找算法</span></span><br><span class="line"><span class="function">Value <span class="title">value_for</span><span class="params">(Key <span class="type">const</span>&amp; key,Value <span class="type">const</span>&amp; default_value = Value())</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">get_bucket</span>(key).<span class="built_in">value_for</span>(key, default_value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_or_update_mapping</span><span class="params">(Key <span class="type">const</span>&amp; key, Value <span class="type">const</span>&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">get_bucket</span>(key).<span class="built_in">add_or_update_mapping</span>(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove_mapping</span><span class="params">(Key <span class="type">const</span>&amp; key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">get_bucket</span>(key).<span class="built_in">remove_mapping</span>(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::map&lt;Key, Value&gt; <span class="title">get_map</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//对所有的桶都加锁</span></span><br><span class="line">std::vector&lt;std::unique_lock&lt;std::shared_mutex&gt;&gt; locks;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; buckets.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">locks.<span class="built_in">push_back</span>(std::<span class="built_in">unique_lock</span>&lt;std::shared_mutex&gt;(buckets[i]-&gt;mutex));</span><br><span class="line">&#125;</span><br><span class="line">std::map&lt;Key, Value&gt; res;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; buckets.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//需用typename告诉编译器bucket_type::bucket_iterator是一个类型，以后再实例化</span></span><br><span class="line"><span class="comment">//当然此处可简写成auto it = buckets[i]-&gt;data.begin();</span></span><br><span class="line"><span class="keyword">typename</span> bucket_type::bucket_iterator it = buckets[i]-&gt;data.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">for</span> (; it != buckets[i]-&gt;data.<span class="built_in">end</span>(); ++it)</span><br><span class="line">&#123;</span><br><span class="line">res.<span class="built_in">insert</span>(*it);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>自定义类型</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> i):_data(i)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span> &lt;&lt; (std::ostream&amp; os, <span class="type">const</span> MyClass&amp; mc)&#123;</span><br><span class="line">        os &lt;&lt; mc._data;</span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>测试函数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyClass.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ThreadSafeLockupTable.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestThreadSafeHash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; removeSet;</span><br><span class="line">    threadsafe_lockup_table&lt;<span class="type">int</span>, std::shared_ptr&lt;MyClass&gt;&gt; table;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span></span></span><br><span class="line"><span class="params"><span class="function">        &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">auto</span> class_ptr = std::make_shared&lt;MyClass&gt;(i);</span></span></span><br><span class="line"><span class="params"><span class="function">            table.add_or_update_mapping(i, class_ptr);</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; )</span></span></span><br><span class="line"><span class="params"><span class="function">        &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">auto</span> find_res = table.value_for(i, <span class="literal">nullptr</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">if</span> (find_res)</span></span></span><br><span class="line"><span class="params"><span class="function">            &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                table.remove_mapping(i);</span></span></span><br><span class="line"><span class="params"><span class="function">                removeSet.insert(i);</span></span></span><br><span class="line"><span class="params"><span class="function">                i++;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">            std::this_thread::sleep_for(std::chrono::milliseconds(<span class="number">10</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t3</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">100</span>; i &lt; <span class="number">200</span>; i++)</span></span></span><br><span class="line"><span class="params"><span class="function">        &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">auto</span> class_ptr = std::make_shared&lt;MyClass&gt;(i);</span></span></span><br><span class="line"><span class="params"><span class="function">            table.add_or_update_mapping(i, class_ptr);</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">3.</span><span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : removeSet)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;remove data is &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> copy_map = table.<span class="built_in">get_map</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : copy_map)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;copy data is &quot;</span> &lt;&lt; *(i.second) &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">TestThreadSafeHash</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现线程安全链表"><a href="#实现线程安全链表" class="headerlink" title="实现线程安全链表"></a>实现线程安全链表</h2><ul><li><p>如果做一个支持多线程并发访问的链表，我们首先想到的是用一个互斥量控制整个链表，达到多线程访问时串行的效果。但是这么做精度不够，需要分化互斥量的功能。我们想到的一个办法就是每个节点都维护一个互斥量，这样能保证多个线程操作不同节点时加不同的锁，减少耦合性。</p></li><li><p>另外我们将head独立为一个虚节点，所谓虚节点就是不存储数据，只做头部标记。我们每次从头部插入只需要修将新的节点的next指针指向原来head的next指向的节点，再将head的next指针指向新的节点</p></li></ul><h2 id="线程间切分任务的方法"><a href="#线程间切分任务的方法" class="headerlink" title="线程间切分任务的方法"></a>线程间切分任务的方法</h2><h3 id="按数量切分"><a href="#按数量切分" class="headerlink" title="按数量切分"></a>按数量切分</h3><ul><li>对于大量处理的数据，可以按照任务数量区分，简单来说如果我们要处理n个任务，总计有m个线程，那么我们可以简单的规划每个线程处理n/m个任务。</li></ul><h2 id="线程池原理和实现"><a href="#线程池原理和实现" class="headerlink" title="线程池原理和实现"></a>线程池原理和实现</h2>]]></content>
    
    
    <summary type="html">本文介绍了C++并发编程的相关知识</summary>
    
    
    
    <category term="C++" scheme="https://pigcanstudy.github.io/categories/C/"/>
    
    
    <category term="C++" scheme="https://pigcanstudy.github.io/tags/C/"/>
    
    <category term="并发编程" scheme="https://pigcanstudy.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>C++面试笔记</title>
    <link href="https://pigcanstudy.github.io/posts/2f7ff9a3.html"/>
    <id>https://pigcanstudy.github.io/posts/2f7ff9a3.html</id>
    <published>2024-07-18T02:49:00.000Z</published>
    <updated>2024-07-18T02:50:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li><a href="#目录">目录</a><ul><li><a href="#new-delete-free-malloc-的区别">new delete free malloc 的区别</a><ul><li><a href="#衍生问题">衍生问题</a><ul><li><a href="#malloc是怎么分配空间的">malloc是怎么分配空间的</a></li><li><a href="#malloc分配的虚拟内存还是物理内存">malloc分配的虚拟内存还是物理内存</a></li><li><a href="#malloc分配后是否立即得到物理内存">malloc分配后是否立即得到物理内存</a></li><li><a href="#freep是怎么得到p这个空间有多大的">free(p)是怎么得到p这个空间有多大的</a></li><li><a href="#free释放内存后内存还在吗">free释放内存后，内存还在吗</a></li><li><a href="#为什么不直接全用mmp来分配而需要分情况使用brk呢">为什么不直接全用mmp()来分配，而需要分情况使用brk()呢</a></li><li><a href="#new的执行过程">new的执行过程</a></li><li><a href="#delete的执行过程">delete的执行过程</a></li></ul></li></ul></li><li><a href="#虚函数表与虚函数表指针的创建时机">虚函数表与虚函数表指针的创建时机</a><ul><li><a href="#虚函数表指针创建的时机">虚函数表指针创建的时机</a></li><li><a href="#虚函数表和虚函数表指针的关系">虚函数表和虚函数表指针的关系</a></li><li><a href="#衍生问题-1">衍生问题</a><ul><li><a href="#多态的内容">多态的内容</a></li><li><a href="#c内存模型">c++内存模型</a></li><li><a href="#程序变为可执行文件的过程">程序变为可执行文件的过程</a></li><li><a href="#静态库与动态库的区别">静态库与动态库的区别</a></li><li><a href="#elf文件模型">ELF文件模型</a></li></ul></li></ul></li><li><a href="#c什么时候生成默认拷贝构造函数">C++什么时候生成默认拷贝构造函数</a><ul><li><a href="#什么时候触发默认拷贝构造函数">什么时候触发默认拷贝构造函数</a></li><li><a href="#什么时候生成默认拷贝构造函数">什么时候生成默认拷贝构造函数</a></li><li><a href="#衍生问题-2">衍生问题</a><ul><li><a href="#函数返回值的细节">函数返回值的细节</a></li></ul></li></ul></li><li><a href="#面向对象的三大特征以及特性">面向对象的三大特征以及特性</a><ul><li><a href="#衍生问题-3">衍生问题</a><ul><li><a href="#继承相关知识">继承相关知识</a><ul><li><a href="#什么是纯虚函数什么是抽象类">什么是纯虚函数？什么是抽象类？</a></li><li><a href="#接口继承与实现继承">接口继承与实现继承</a></li><li><a href="#那接口继承相比于实现继承有什么好处吗">那接口继承相比于实现继承有什么好处吗</a></li><li><a href="#纯接口继承与接口类">纯接口继承与接口类</a></li><li><a href="#继承的时候不要覆盖非虚函数">继承的时候不要覆盖非虚函数</a></li><li><a href="#组合">组合</a></li><li><a href="#什么是菱形继承">什么是菱形继承</a></li></ul></li></ul></li></ul></li><li><a href="#线程池相关知识">线程池相关知识</a><ul><li><a href="#什么线程池">什么线程池</a></li><li><a href="#为什么要用线程池">为什么要用线程池</a></li><li><a href="#怎么用线程池">怎么用线程池</a></li></ul></li><li><a href="#进程和线程的区别">进程和线程的区别</a><ul><li><a href="#衍生问题-4">衍生问题</a><ul><li><a href="#进程切换与线程切换的区别">进程切换与线程切换的区别</a></li></ul></li></ul></li><li><a href="#描述系统调用整个流程">描述系统调用整个流程</a><ul><li><a href="#衍生问题-5">衍生问题</a><ul><li><a href="#系统调用是否会引起线程进程切换">系统调用是否会引起线程/进程切换</a></li><li><a href="#用户态切换内核态切换堆栈具体是啥">用户态切换内核态(切换堆栈)具体是啥？</a></li><li><a href="#task_struct的组成部分">task_struct的组成部分</a></li></ul></li></ul></li><li><a href="#页面置换算法有哪些">页面置换算法有哪些</a></li><li><a href="#tcp和udp的区别">tcp和udp的区别</a><ul><li><a href="#衍生问题-6">衍生问题</a><ul><li><a href="#tcp的mss和ip的mtu分别是什么">TCP的MSS和IP的MTU分别是什么？</a></li><li><a href="#既然再ip层就会分片为什么还要再tcp那进行分段mss">既然再IP层就会分片，为什么还要再TCP那进行分段，MSS</a></li><li><a href="#tcp是如何保证可靠性的">TCP是如何保证可靠性的？</a></li><li><a href="#为什么需要三次握手">为什么需要三次握手</a></li><li><a href="#为什么需要四次挥手">为什么需要四次挥手</a></li><li><a href="#为什么在四次挥手的时候需要等待2个msl时间">为什么在四次挥手的时候需要等待2个MSL时间</a></li><li><a href="#什么是syn攻击">什么是SYN攻击？</a></li><li><a href="#如何唯一确定一个tcp连接呢">如何唯一确定一个TCP连接呢？</a></li></ul></li></ul></li><li><a href="#水平触发与边缘触发的区别">水平触发与边缘触发的区别</a></li><li><a href="#什么是半打开半关闭状态">什么是半打开半关闭状态</a><ul><li><a href="#如何处理半打开状态">如何处理半打开状态</a></li></ul></li><li><a href="#写文件时进程宕机数据会丢失吗">写文件时进程宕机，数据会丢失吗？</a><ul><li><a href="#文件相关知识">文件相关知识</a></li><li><a href="#什么使用直接文件io什么时候使用缓存文件io">什么使用直接文件IO，什么时候使用缓存文件IO</a></li></ul></li><li><a href="#左值引用和右值引用区别">左值引用和右值引用区别</a><ul><li><a href="#衍生问题-7">衍生问题</a><ul><li><a href="#什么是左值什么是右值">什么是左值，什么是右值</a></li><li><a href="#右值引用的移动语义是什么意思">右值引用的移动语义是什么意思？</a></li><li><a href="#什么是完美转发">什么是完美转发</a><ul><li><a href="#那什么是万能引用呢">那什么是万能引用呢？</a></li></ul></li></ul></li></ul></li><li><a href="#智能指针种类以及使用场景">智能指针种类以及使用场景</a></li><li><a href="#什么设计模式它解决的是什么问题">什么设计模式，它解决的是什么问题</a><ul><li><a href="#相关知识">相关知识</a><ul><li><a href="#设计模式一共有哪几大类设计模式的六大原则是什么">设计模式一共有哪几大类，设计模式的六大原则是什么</a></li><li><a href="#单例模式">单例模式</a><ul><li><a href="#什么是单例它可以在哪些地方用到了">什么是单例，它可以在哪些地方用到了</a></li><li><a href="#单例的优缺点">单例的优缺点</a></li><li><a href="#单例创建方式">单例创建方式</a><ul><li><a href="#饿汉式">饿汉式</a></li><li><a href="#懒汉式">懒汉式</a></li><li><a href="#静态内部方式">静态内部方式</a></li></ul></li><li><a href="#如何选择单例模式的创建方式">如何选择单例模式的创建方式</a></li></ul></li><li><a href="#工厂模式">工厂模式</a><ul><li><a href="#简单工厂模式">简单工厂模式</a><ul><li><a href="#简单工厂模式的优缺点">简单工厂模式的优缺点</a></li></ul></li><li><a href="#工厂方法模式">工厂方法模式</a><ul><li><a href="#工厂方法模式的优缺点">工厂方法模式的优缺点</a></li></ul></li><li><a href="#抽象工厂模式">抽象工厂模式</a><ul><li><a href="#抽象工厂模式的优缺点">抽象工厂模式的优缺点</a></li></ul></li><li><a href="#抽象工厂模式和工厂方法模式的区别">抽象工厂模式和工厂方法模式的区别</a></li></ul></li><li><a href="#策略模式">策略模式</a><ul><li><a href="#应用案例">应用案例</a></li></ul></li><li><a href="#观察者模式">观察者模式</a><ul><li><a href="#解决了什么问题">解决了什么问题</a></li><li><a href="#例子">例子</a></li><li><a href="#代码结构">代码结构</a></li><li><a href="#如果扩展代码">如果扩展代码</a></li><li><a href="#应用的案例">应用的案例</a></li><li><a href="#优缺点">优缺点</a></li></ul></li><li><a href="#责任链模式">责任链模式</a><ul><li><a href="#解决了什么问题-1">解决了什么问题</a></li><li><a href="#例子-1">例子</a></li><li><a href="#代码结构-1">代码结构</a></li><li><a href="#代码扩展">代码扩展</a></li><li><a href="#应用案例-1">应用案例</a></li></ul></li><li><a href="#装饰器模式">装饰器模式</a><ul><li><a href="#优缺点-1">优缺点</a></li><li><a href="#代码">代码</a></li><li><a href="#代码扩展-1">代码扩展</a></li></ul></li></ul></li></ul></li><li><a href="#b树与b树与二叉搜索树">B树与B+树与二叉搜索树</a></li><li><a href="#语法基础">语法基础</a><ul><li><a href="#野指针-悬空指针-空指针">野指针 悬空指针 空指针</a></li><li><a href="#union的相关知识">union的相关知识</a></li><li><a href="#指针相关知识">指针相关知识</a></li><li><a href="#c-内存对齐机制">C++ 内存对齐机制</a></li><li><a href="#stdstring">std::string</a></li><li><a href="#const-int--ptr-int--const-ptr的区别是什么">const int * ptr, int * const ptr的区别是什么？</a></li><li><a href="#什么是stdref">什么是std::ref？</a><ul><li><a href="#stdref-和不同引用的区别">std::ref 和不同引用的区别</a></li><li><a href="#总结">总结</a></li></ul></li><li><a href="#decltype-stddeclval-stddecay_t-分别是什么">decltype, std::declval, std::decay_t 分别是什么？</a><ul><li><a href="#decltype">decltype</a></li><li><a href="#stddeclval">std::declval</a></li><li><a href="#stddecay_t">std::decay_t</a></li></ul></li><li><a href="#const-与-constexpr">const 与 constexpr</a></li><li><a href="#noexcept">noexcept</a></li><li><a href="#用户自定义字面量">用户自定义字面量</a></li><li><a href="#mutable-volatile">mutable volatile</a></li><li><a href="#explicit">explicit</a></li><li><a href="#stdinvoke">std::invoke</a><ul><li><a href="#invoke-和function-的区别">invoke 和function 的区别</a></li></ul></li><li><a href="#stl容器里emplace_back和push_back的区别emplace_back是不是能完美替代push_back">stl容器里emplace_back和push_back的区别，emplace_back是不是能完美替代push_back</a></li><li><a href="#如果使用stdmovet来构造一个对象但是该类没有显式提供移动构造函数那么它是使用的式默认移动构造函数已经定义的拷贝构造">如果使用std::move(t)来构造一个对象，但是该类没有显式提供移动构造函数，那么它是使用的式默认移动构造函数已经定义的拷贝构造</a></li><li><a href="#在模板中使用-typedef的时候的注意事项">在模板中使用 typedef的时候的注意事项</a></li></ul></li></ul></li></ul><h2 id="new-delete-free-malloc-的区别"><a href="#new-delete-free-malloc-的区别" class="headerlink" title="new delete free malloc 的区别"></a>new delete free malloc 的区别</h2><ul><li>背景：前两者是C++里的操作符，后两者是C语言的库函数</li><li><strong>new</strong>在分配内存的时候是自动计算分配内存的大小，而<strong>malloc</strong>需要程序员手动指定</li><li><strong>new</strong>是在free store(自由存储区)分配，<strong>malloc</strong>是在堆区分配，由于<strong>new</strong>的底层实现用到了<strong>malloc</strong>所以free store默认也是堆区</li><li><strong>new</strong>分配失败会抛出异常，<strong>malloc</strong>分配失败会返回NULL</li><li><strong>new</strong>返回的指向对象类型的指针，<strong>malloc</strong>返回的是<strong>void*/</strong>，需要强制类型转换成对应类型</li><li><strong>new</strong>分配完内存后会执行析构函数, <strong>malloc</strong>分配内存后则不会</li></ul><h3 id="衍生问题"><a href="#衍生问题" class="headerlink" title="衍生问题"></a>衍生问题</h3><h4 id="malloc是怎么分配空间的"><a href="#malloc是怎么分配空间的" class="headerlink" title="malloc是怎么分配空间的"></a>malloc是怎么分配空间的</h4><ul><li>malloc在分配内存的时候会有一个阈值，这个值为128k，当分配内存小于128K的时候进行brk()调用申请内存，此内存在堆区，大于的时候会通过mmp()点用进行分配内存（分配在文件映射段也就是再堆区与栈区直接那个段），此内存会在销毁的时候释放，而小于128K的时候，在被销毁的时候会被先放到内存池中</li></ul><h4 id="malloc分配的虚拟内存还是物理内存"><a href="#malloc分配的虚拟内存还是物理内存" class="headerlink" title="malloc分配的虚拟内存还是物理内存"></a>malloc分配的虚拟内存还是物理内存</h4><ul><li>malloc分配的内存是虚拟内存。</li></ul><h4 id="malloc分配后是否立即得到物理内存"><a href="#malloc分配后是否立即得到物理内存" class="headerlink" title="malloc分配后是否立即得到物理内存"></a>malloc分配后是否立即得到物理内存</h4><ul><li>不是的，他是在访问已分配的虚拟地址空间的时候，操作系统通过查找页表，发现虚拟内存对应的页没有在物理内存中，就会触发缺页中断，然后操作系统会建立虚拟内存和物理内存之间的映射关系，这样之后才会得到物理内存</li></ul><h4 id="free-p-是怎么得到p这个空间有多大的"><a href="#free-p-是怎么得到p这个空间有多大的" class="headerlink" title="free(p)是怎么得到p这个空间有多大的"></a>free(p)是怎么得到p这个空间有多大的</h4><ul><li>在malloc分配内存的时候，会首先分配16个字节放在前面，这16个字节会存储有关内存的相关信息，其中就包括内存块大小，所以在执行free的时候只需要向前移16字节就能知道空间有多大了</li></ul><h4 id="free释放内存后，内存还在吗"><a href="#free释放内存后，内存还在吗" class="headerlink" title="free释放内存后，内存还在吗"></a>free释放内存后，内存还在吗</h4><ul><li>分情况，如果内存是通过brk()调用得到存放在堆区，释放内存后会被存储在内存池中，而如果通过mmp()调用得到的内存，则会被操作系统释放</li></ul><h4 id="为什么不直接全用mmp-来分配，而需要分情况使用brk-呢"><a href="#为什么不直接全用mmp-来分配，而需要分情况使用brk-呢" class="headerlink" title="为什么不直接全用mmp()来分配，而需要分情况使用brk()呢"></a>为什么不直接全用mmp()来分配，而需要分情况使用brk()呢</h4><ul><li>因为mmp()调用的时候每次都需要进行系统调用，而进行系统调用需要从用户态变为内核态再变回用户态需要大量时间。另外，因为 mmap 分配的内存每次释放的时候，都会归还给操作系统，于是每次 mmap 分配的虚拟地址都是缺页状态的，然后在第一次访问该虚拟地址的时候，就会触发缺页中断。也就是说，频繁通过 mmap 分配的内存话，不仅每次都会发生运行态的切换，还会发生缺页中断（在第一次访问虚拟地址后），这样会导致 CPU 消耗较大。</li><li>而使用brk()就能改进这两个问题，由于堆空间是连续的，所以直接预分配更大的内存来作为内存池，当内存释放的时候，就缓存在内存池中。这样就可以在内存池中，取出对应内存块，而且可能虚拟地址与物理地址映射关系还存在这样不仅减少了系统调用的次数，也减少了缺页中断的次数，这将大大降低CPU的消耗</li></ul><h4 id="new的执行过程"><a href="#new的执行过程" class="headerlink" title="new的执行过程"></a>new的执行过程</h4><ol><li>先执行operator new</li><li>寻找合适的内存空间</li><li>执行构造函数</li></ol><h4 id="delete的执行过程"><a href="#delete的执行过程" class="headerlink" title="delete的执行过程"></a>delete的执行过程</h4><ol><li>先调用析构函数</li><li>执行operator delete</li><li>销毁空间</li></ol><h2 id="虚函数表与虚函数表指针的创建时机"><a href="#虚函数表与虚函数表指针的创建时机" class="headerlink" title="虚函数表与虚函数表指针的创建时机"></a>虚函数表与虚函数表指针的创建时机</h2><ul><li>背景：是用来实现多态的</li><li>什么时候生成的? 是在编译器编译的时候，遇到virtual关键词的时候生成的</li><li>存放在哪里？ 可执行文件（存在磁盘）， 运行的时候（在内存），在磁盘里是存储在.rodata中，在内存中是存储在代码区</li><li><img src="../assets/面试笔记/image-1.png" alt="示例图片" style="zoom:100%;" /></li></ul><h3 id="虚函数表指针创建的时机"><a href="#虚函数表指针创建的时机" class="headerlink" title="虚函数表指针创建的时机"></a>虚函数表指针创建的时机</h3><ul><li>类对象构造的时候，会把类的虚函数表地址赋给 vptr</li><li>如果类没有构造函数，编译器会生成默认的构造函数（类的前八个字节就是虚函数表指针所在位置(vptr)）</li><li>继承的情况下，虚函数表指针赋值过程？<ol><li>调用基类构造函数，把A的虚函数表的地址赋给 vptr</li><li>调用子类构造函数，把B子类的虚函数表的地址赋给 vptr</li></ol></li></ul><h3 id="虚函数表和虚函数表指针的关系"><a href="#虚函数表和虚函数表指针的关系" class="headerlink" title="虚函数表和虚函数表指针的关系"></a>虚函数表和虚函数表指针的关系</h3><ul><li><p>一个类只对应一个虚函数表，这个类创造的每一个对象对应的是虚函数表指针（在堆里），<strong>通常来说虚函数表指针是不一样的</strong>（涉及<strong>浅拷贝与深拷贝</strong>），<strong><em>需要显示写出拷贝构造函数和重载赋值运算符</em></strong>，虚函数表指针是指向的是虚函数表位置，大概如图所示:(vptr 在32位机上4字节，64位机上8字节)<br><img src="../assets/面试笔记/image-6.png" alt="示例图片" style="zoom:100%;" /><br>解释这张图就是 虚函数表指针指向虚函数表（在.rodata中）的某个位置，这个位置是一个函数的地址，指向代码区里的函数</p></li><li><p>对于每个对象来说，其都有一个虚函数表指针指向这个类的虚函数表，而虚函数表是与类绑定的，因此对于每个对象的虚函数表指针来说其指向的位置是相同的，即每个指针中存的地址是一样的。那么析构后仅是将对应的vptr置为nullptr，应该不会影响其他对象的vptr.</p></li></ul><h3 id="衍生问题-1"><a href="#衍生问题-1" class="headerlink" title="衍生问题"></a>衍生问题</h3><h4 id="多态的内容"><a href="#多态的内容" class="headerlink" title="多态的内容"></a>多态的内容</h4><ul><li>首先多态分为静态多态(编译时多态)与动态多态（运行时多态）</li><li><strong>静态多态</strong>：在系统编译期间就可以确定程序将要执行哪个函数，比如 函数重载，通过类成员函数符指定的运算<br>函数重载条件：1.同一个作用域，2.同一个函数名，3.函数参数类型不同或者个数不同或者顺序不同<br><strong>注意</strong>：如果只有函数的返回值不同，就不算函数重载<br><img src="image.png" alt="alt text"></li><li><strong>动态多态</strong>：是利用虚函数实现运行时的多态，即在系统编译的时候并不知道程序将要调用哪一个函数，只有在运行到这里的时候才能确定接下来会跳转到哪一个函数，动态多态是在虚函数的基础上实现的，而实现的条件有：<br>(1) 在类中声明为虚函数<br>(2) 函数的函数名，返回值，函数参数个数，参数类型，全都与基类的所声明的虚函数相同（否则是函数重载的条件）<br>(3) 将子类对象的指针（或以引用形式）赋值给父类对象的指针（或引用），再用该指向父类对象的指针（或引用）调用虚函数<br>如此，便可以实现动态多态，程序会按照实际对象类型来选择要实行的函数具体时哪一个。</li></ul><h4 id="c-内存模型"><a href="#c-内存模型" class="headerlink" title="c++内存模型"></a>c++内存模型</h4><ol><li><strong>栈区</strong>：用于实现函数调用。由编译器自动分配释放，存放函数的参数值和局部变量等（向下增长），每个线程都有自己的栈区，栈区的内存是线程私有的，不同线程之间的栈区不共享</li><li><strong>堆区</strong>：用于存放于存放动态分配的变量。由程序员动态分配和释放，使用new和delete操作符（向上增长）<br> <strong>堆区碎片</strong>：随着时间的推移，动态内存的频繁分配和释放可能导致堆区出现碎片。堆区碎片是指堆中剩余的不连续、无法利用的小块内存。虽然这不会直接影响程序的正确性，但在某些情况下，可能会降低内存的利用率<br> <strong>线程共享</strong>：堆区内存可以在线程之间共享，多个线程可以访问和使用堆区的相同内存。这使得堆区在多线程编程中非常有用，但也需要注意同步和避免竞争条件</li><li><strong>全局/静态代码区</strong>：存放全局变量，和静态变量，在程序结束是自动释放<ul><li>分为Bss Semgent：存放未初始化的全局与静态变量(.bss)，不占用实际的磁盘空间,只在编译时预留内存空间</li><li>Data Semgent：存放初始化的全局与静态变量(.data)</li></ul></li><li><strong>代码区（Text Semgent）</strong>:通常也被称为文本区或只读区。存放程序的二进制代码（ELF）文件和常量，代码段是只读的，可以被多个进程共享<ul><li>.text</li><li>.rodata，里面存放只读数据，其中虚函数表就在其中</li></ul></li></ol><p><img src="../assets/面试笔记/image-2.png" alt="示例图片" style="zoom:100%;" /><br><img src="../assets/面试笔记/image-3.png" alt="示例图片" style="zoom:100%;" /></p><h4 id="程序变为可执行文件的过程"><a href="#程序变为可执行文件的过程" class="headerlink" title="程序变为可执行文件的过程"></a>程序变为可执行文件的过程</h4><p><img src="../assets/面试笔记/image-5.png" alt="示例图片" style="zoom:100%;" /></p><ul><li><strong>预处理阶段</strong>：预处理器（cpp）根据以#开头的命令修改原始的C程序，得到的通常是以.i文件扩展名为结尾的文件，也就是说，在这个阶段主要进行的是<strong>文本替换，宏展开，删除注释</strong>这类简单工作<br><strong>对应的命令</strong>：Linux&gt; gcc -E hello.c hello.i</li><li><strong>编译阶段</strong>：编译器将文本文件hello.i翻译成hello.s（用汇编语言程序翻译）<br><strong>对应的命令</strong>：Linux&gt; gcc -S hello.c hello.s</li><li><strong>汇编阶段</strong>：将.s文件翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标程序的格式，并将结果保存在目标文件.o中(把汇编语言翻译成机器语言的过程)。也就是编译原理学的东西(<strong>词法分析，语法分析，语义检查和中间代码生成，代码优化，目标代码生成</strong>，用来发现语法错误)<br><strong>对应的命令</strong>：Linux&gt; gcc -c hello.c hello.o</li><li><strong>连接阶段</strong>：此时hello程序调用了printf函数。 printf函数存在于一个名为printf.o的单独的预编译目标文件中。 链接器（ld）就负责处理把这个文件并入到hello.o程序中，结果得到hello文件，一个可执行文件。最后可执行文件加载到储存器后由系统负责执行<br><strong>对应的命令</strong>：Linux&gt; gcc hello.cpp<br><strong><em>注意:</em></strong> gcc -o 这里的-o并不是对应连接阶段，而是用于指定要生成的结果文件，后面跟的就是结果文件名字。<strong>链接器的作用</strong>就是以一组可重定位目标文件作为输入，生成可加载和运行的可执行目标文件</li></ul><h4 id="静态库与动态库的区别"><a href="#静态库与动态库的区别" class="headerlink" title="静态库与动态库的区别"></a>静态库与动态库的区别</h4><ul><li>函数库一般分为<strong>静态库</strong>和<strong>动态库</strong>两种。<strong>静态库</strong>是指编译链接时，<strong><em>把库文件的代码全部加入到可执行文件中，因此生成的文件比较大，但在运行时也就不再需要库文件了。其后缀名一般为.a</em></strong>。<strong>动态库</strong>与之相反，在编译链接时并没有把库文件的代码加入到可执行文件中，而是在程序执行时由<strong>运行时链接文件加载库</strong>，这样可以<strong>节省系统的开销</strong>。<strong>动态库一般后缀名为.so</strong>，<strong>gcc在编译时默认使用动态库</strong>。</li></ul><h4 id="ELF文件模型"><a href="#ELF文件模型" class="headerlink" title="ELF文件模型"></a>ELF文件模型</h4><p><img src="../assets/面试笔记/image-4.png" alt="示例图片" style="zoom:100%;" /></p><h2 id="C-什么时候生成默认拷贝构造函数"><a href="#C-什么时候生成默认拷贝构造函数" class="headerlink" title="C++什么时候生成默认拷贝构造函数"></a>C++什么时候生成默认拷贝构造函数</h2><ul><li>背景：如果不提供，就是浅拷贝(位拷贝)，危害(堆上的资源，文件句柄socket)</li></ul><h3 id="什么时候触发默认拷贝构造函数"><a href="#什么时候触发默认拷贝构造函数" class="headerlink" title="什么时候触发默认拷贝构造函数"></a>什么时候触发默认拷贝构造函数</h3><ol><li>赋值的时候</li><li>函数传参，其中参数为类对象</li><li>函数返回值</li></ol><h3 id="什么时候生成默认拷贝构造函数"><a href="#什么时候生成默认拷贝构造函数" class="headerlink" title="什么时候生成默认拷贝构造函数"></a>什么时候生成默认拷贝构造函数</h3><ul><li>类成员变量也是一个类，该成员类有默认拷贝构造函数</li><li>类继承自一个基类，该基类有默认拷贝构造函数</li><li>类成员中有一个或者多个虚函数，如果没有拷贝构造函数</li><li>基类有虚函数，子类没有</li></ul><h3 id="衍生问题-2"><a href="#衍生问题-2" class="headerlink" title="衍生问题"></a>衍生问题</h3><h4 id="函数返回值的细节"><a href="#函数返回值的细节" class="headerlink" title="函数返回值的细节"></a>函数返回值的细节</h4><ul><li>对于以下这种情况：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">A <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A a = <span class="built_in">func</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在以上情况不考虑编译器优化的时候，会有一次构造函数，一次析构函数（前两者由于作用域），一次拷贝构造函数（由于返回值）</li><li>而如果去掉优化，并且时C++11版本后，会有以下三种情况<ol><li>看类有没有移动构造</li><li>看类有没有拷贝构造</li><li>报错</li></ol></li></ul><h2 id="面向对象的三大特征以及特性"><a href="#面向对象的三大特征以及特性" class="headerlink" title="面向对象的三大特征以及特性"></a>面向对象的三大特征以及特性</h2><ul><li>封装:<ol><li>目的：隐藏实现细节，实现模块化（public，protect，private）</li><li>特性：访问权限，属性，方法</li></ol></li><li>继承:<ol><li>目的：无需修改原有类的情况下通过继承实现对功能的扩展（只能继承public以及protected，因为private 访问不到，虽然它也会在子类中）</li><li>特性：权限继承，基类在子类中最高权限</li><li>怎么破除继承：1.使用友元 2.使用using 这样可以让派生类能够使用基类的私有成员</li></ol></li><li>多态: 有静态多态与动态多态 在上面有阐述</li></ul><h3 id="衍生问题-3"><a href="#衍生问题-3" class="headerlink" title="衍生问题"></a>衍生问题</h3><h4 id="继承相关知识"><a href="#继承相关知识" class="headerlink" title="继承相关知识"></a>继承相关知识</h4><h5 id="什么是纯虚函数？什么是抽象类？"><a href="#什么是纯虚函数？什么是抽象类？" class="headerlink" title="什么是纯虚函数？什么是抽象类？"></a>什么是纯虚函数？什么是抽象类？</h5><ul><li><p>一个函数如果虚函数并且有等于0就为虚函数，此处0填充在虚表中，这会导致纯虚函数的虚表为0项，即无法创建虚表，无法实例化<br><img src="../assets/面试笔记/image-13.png" alt="示例图片" style="zoom:100%;" /></p></li><li><p>一个类只要存在至少一个纯虚函数就是抽象类</p></li></ul><h5 id="接口继承与实现继承"><a href="#接口继承与实现继承" class="headerlink" title="接口继承与实现继承"></a>接口继承与实现继承</h5><ul><li>接口继承就是一个类继承一个抽象类，并且这个子类必须重写父类这个抽象类的纯虚函数，并且要确保接口继承是一个”is-a”关系，也就是public继承，并且这个接口对于子类来说是有意义的，例如企鹅是鸟类但不能飞，所以鸟这个类就不能有飞行这个纯虚函数（接口）</li><li>实现继承就是派生类以protected或private继承一个基类时，派生类没有继承到基类的接口，而是继承到了基类的实现。实现继承就意味着派生类与基类不是”is-a”关系,而只是复用其实现或功能。</li><li>对于虚函数而言是继承接口与默认实现，对于非虚函数而言是继承的接口与强制实现</li><li><img src="../assets/面试笔记/image-14.png" alt="示例图片" style="zoom:100%;" /></li></ul><h5 id="那接口继承相比于实现继承有什么好处吗"><a href="#那接口继承相比于实现继承有什么好处吗" class="headerlink" title="那接口继承相比于实现继承有什么好处吗"></a>那接口继承相比于实现继承有什么好处吗</h5><ul><li>对于某些情况就可以避免危险，例如飞机的飞行模式实现，使用接口继承就比实现继承更安全</li><li>如图：<img src="../assets/面试笔记/image-15.png" alt="示例图片" style="zoom:100%;" /></li><li>使用纯虚函数加提供protected下的默认实现函数来代替虚函数继承</li></ul><h5 id="纯接口继承与接口类"><a href="#纯接口继承与接口类" class="headerlink" title="纯接口继承与接口类"></a>纯接口继承与接口类</h5><ul><li>纯接口继承是指基类只提供接口，不提供定义，即严格代码规范下，基类的所有函数都是纯虚函数，不提供具体实现，派生类需要对所有方法进行自定义，这样的类型称为纯接口类。纯接口继承完全分离了接口与实现，依赖更少，如下例所示：<img src="../assets/面试笔记/image-16.png" alt="示例图片" style="zoom:100%;" /></li><li>这样的接口类有以下三个特点：一，<strong>没有非静态成员变量</strong>；二，<strong>所有成员都是public成员</strong>；三，<strong>所有成员都是纯虚函数，析构函数除外</strong>，因此在上例Interface类中存在一个有定义的虚的析构函数。纯接口继承的<strong>优点</strong>是最小化调用处的依赖，且接口与实现完全分离，这样在只有实现发生变化时，调用处不会受到任何影响。而它的<strong>缺点</strong>是不利于代码复用，如果多个派生类都要实现相差不多的方法F()，就需要重复编写多遍F()的代码。</li></ul><h5 id="继承的时候不要覆盖非虚函数"><a href="#继承的时候不要覆盖非虚函数" class="headerlink" title="继承的时候不要覆盖非虚函数"></a>继承的时候不要覆盖非虚函数</h5><ul><li>因为这样就破坏了”is-a”关系,如果子类也编写了一个与基类同名的非虚函数，这种关系叫做覆盖而不是重写，是子类函数覆盖了基类函数，当我们直接通过派生类对象调用F()与通过基类指针调用F()，会产生不一样的行为！如图：<img src="../assets/面试笔记/image-17.png" alt="示例图片" style="zoom:100%;" /></li></ul><h5 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h5><ul><li>将std::string变成Password的一个成员，而不是Password的基类，这样仍能使用std::string的各种功能，且不需要增加一种继承关系。这种方法被称为“组合”，它是比继承更灵活的复用方法。一般在可以用组合达到目的时，要尽量避免使用实现继承</li></ul><h5 id="什么是菱形继承"><a href="#什么是菱形继承" class="headerlink" title="什么是菱形继承"></a>什么是菱形继承</h5><ul><li>InputFile和OutputFile同时继承于File类，而下一层IOFile类同时继承InputFile和OutputFile，即继承了两次File，这就是菱形继承<img src="../assets/面试笔记/image-18.png" alt="示例图片" style="zoom:100%;" /></li><li>使用虚继承来解决菱形继承问题</li></ul><h2 id="线程池相关知识"><a href="#线程池相关知识" class="headerlink" title="线程池相关知识"></a>线程池相关知识</h2><h3 id="什么线程池"><a href="#什么线程池" class="headerlink" title="什么线程池"></a>什么线程池</h3><ul><li>线程池是一个高效管理线程的技术，它是预先创建好一组线程，并用这些预先创建好的线程来处理工作任务，这些线程可以在需要的时候被动态地分配和重用，而不是为每一个任务创建一个新线程，这可以大大减少创建和销毁线程的开销</li><li>线程池由三个部分组成：<ol><li>任务队列：用于存放需要执行的任务</li><li>线程池管理器：负责管理线程池的创建，销毁和线程的分配回收等，会根据需要动态调整线程数量</li><li>工作线程：线程池中实际执行任务的线程，它们从任务队列中取出任务并执行</li></ol></li></ul><h3 id="为什么要用线程池"><a href="#为什么要用线程池" class="headerlink" title="为什么要用线程池"></a>为什么要用线程池</h3><ol><li>可以降低资源消耗：可以减少创建和销毁线程的开销</li><li>提高性能：对于一个任务而言不需要等待线程的创建就能被执行</li><li>避免过度资源竞争：线程池可以限制同时执行的线程数量，避免过度竞争，提高稳定性</li><li>控制并发度：可以根据资源与负载情况动态调整线程数量</li><li>简化了线程管理的难度</li></ol><p>可能会出现任务队列溢出：执行完一个任务的速度远小于进入任务队列的速度</p><h3 id="怎么用线程池"><a href="#怎么用线程池" class="headerlink" title="怎么用线程池"></a>怎么用线程池</h3><h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><ul><li>本质区别：进程是资源分配的基本单位，线程是CPU调度的基本单位</li><li>并发性：进程切换效率低，线程切换效率高</li><li>内存：进程有独立的虚拟地址空间，线程没有独立虚拟地址空间，是共享同一个进程，但是线程会分配独立的栈区，PC，本地存储等</li><li>所属关系：一个线程只能属于一个进程，一个进程可以拥有多个线程</li><li>健壮性：进程的健壮性高，因为进程切换在多进程的时候不会因为一个进程的宕机而影响整体，但是线程宕机就会影响同一进程下的其它线程</li></ul><h3 id="衍生问题-4"><a href="#衍生问题-4" class="headerlink" title="衍生问题"></a>衍生问题</h3><h4 id="进程切换与线程切换的区别"><a href="#进程切换与线程切换的区别" class="headerlink" title="进程切换与线程切换的区别"></a>进程切换与线程切换的区别</h4><ul><li>进程在进行上下文切换的时候，要保留现场的运行环境（CPU的寄存器，程序计数器，用户空间的信息，内核空间pcb），进程切换在多进程的时候不会因为一个进程的宕机而影响整体</li><li>线程的切换，如果线程是在不同进程里的，和进程是一样的，如果是在同一个进程里就可以少保留一些信息（CPU寄存器，程序计数器），效率就高了，但是线程需要加锁。</li></ul><h2 id="描述系统调用整个流程"><a href="#描述系统调用整个流程" class="headerlink" title="描述系统调用整个流程"></a>描述系统调用整个流程</h2><ul><li>宏观视角：应用程序想要访问内核里的资源，应用程序通过函数库调用函数库中的系统调用，将用户态转变为内核态，调用完后再切换回用户态</li><li>微观视角：想要实现系统调用，离不开中断，当程序想要获取内核数据的时候，会触发<strong>中断</strong>，操作系统会把<strong>系统调用号</strong>放在<strong>寄存器（eax)</strong>中，并且会有一个<strong>中断号（比如 int 0x80）</strong>，接下来操作系统会<strong>切换堆栈</strong>，也就是从<strong>用户态切换为内核态</strong>，在内核态中通过<strong>中断号</strong>在<strong>中断向量表</strong>中找到对应的<strong>中断处理程序（比如system_call）</strong>，然后通过寄存器eax中的<strong>系统调用号</strong>在<strong>系统调用表</strong>中，找到对应的<strong>处理程序(比如syscall_read)</strong>，执行相应操作，之后通过<strong>iret中断</strong>返回对应值，并切换回用户态</li></ul><h3 id="衍生问题-5"><a href="#衍生问题-5" class="headerlink" title="衍生问题"></a>衍生问题</h3><h4 id="系统调用是否会引起线程-进程切换"><a href="#系统调用是否会引起线程-进程切换" class="headerlink" title="系统调用是否会引起线程/进程切换"></a>系统调用是否会引起线程/进程切换</h4><ul><li>不一定，如果我们使用阻塞的IO且IO未就绪，就会将线程或进程切换；运行态 -&gt; 阻塞态，如果使用的是非阻塞IO就不会引起进/线程切换</li></ul><h4 id="用户态切换内核态-切换堆栈-具体是啥？"><a href="#用户态切换内核态-切换堆栈-具体是啥？" class="headerlink" title="用户态切换内核态(切换堆栈)具体是啥？"></a>用户态切换内核态(切换堆栈)具体是啥？</h4><ul><li>首先会切换中断上下文，也就是先保存用户态的上下文，之后会将CPU上的用户态指令切换成内核态的指令</li></ul><h4 id="task-struct的组成部分"><a href="#task-struct的组成部分" class="headerlink" title="task_struct的组成部分"></a>task_struct的组成部分</h4><ol><li>标识符：与进程相关的唯一标识符，用来区别正在执行的进程和其他进程。</li><li>状态：描述进程的状态，因为进程有挂起，阻塞，运行等好几个状态，所以都有个标识符来记录进程的执行状态。</li><li>优先级：如果有好几个进程正在执行，就涉及到进程被执行的先后顺序的问题，这和进程优先级这个标识符有关。</li><li>程序计数器：程序中即将被执行的下一条指令的地址。</li><li>内存指针：程序代码和进程相关数据的指针。</li><li>上下文数据：进程执行时处理器的寄存器中的数据。</li><li>I/O状态信息：包括显示的I/O请求，分配给进程的I/O设备和被进程使用的文件列表等。</li><li>记账信息：包括处理器的时间总和，记账号等等。</li></ol><h2 id="页面置换算法有哪些"><a href="#页面置换算法有哪些" class="headerlink" title="页面置换算法有哪些"></a>页面置换算法有哪些</h2><ul><li>产生页面置换原因：缺页中断-&gt; 内存已满 -&gt; 将某些页面置换到磁盘中</li><li>加载一个页面，如果产生缺页中断的全过程：<img src="../assets/面试笔记/image-8.png" alt="示例图片" style="zoom:100%;" /></li></ul><ol><li>最佳页面置换算法（置换未来最长时间不访问的页面）</li><li>先进先出置换算法(FIFO) （选择在内存驻留时间最长的页面）</li><li>最近最久未使用置换算法 （选择最长时间没有被访问的页面）</li><li>时钟页面置换算法/最近未用算法  (环形列表实现)</li><li>改进版的时钟页面置换算法</li></ol><h2 id="tcp和udp的区别"><a href="#tcp和udp的区别" class="headerlink" title="tcp和udp的区别"></a>tcp和udp的区别</h2><p>  <img src="../assets/面试笔记/image-11.png" alt="示例图片" style="zoom:100%;" /></p><ul><li>相同点：都是传输层的协议，目的都是为了给上层提供服务</li><li>是否面向链接：tcp是面向链接，udp是面向无链接， 面向链接可以告诉我们：他建立链接需要三次握手，释放链接需要四次挥手，它是一个端对端的链接，他是一个全双工链接（双方可以互相发送数据），面向无连接：无需三次握手与四次挥手，可以一对一，一对多，多对一，多对多</li><li>数据传输方式：tcp是基于字节流，UDP是基于报文，对于TCP来说，完整的用户消息可能会被分成多个tcp报文进行传输，对于接收端而言，需要处理粘包（对于一个完整数据与一个不属于这个数据的数据链接在一起的问题）问题，而对于UDP，每次收发都是完整数据</li><li>是否可靠：TCP是可靠的，UDP是不可靠的，不可靠的意思就是，不保证消息交付的完整性，也不保证交付顺序，不进行拥塞控制，不进行流量控制（没有接收缓冲区）</li><li>传输效率：tcp效率低，udp效率高，tcp由于需要实现可靠传输，以及发送相同数据时，tcp所允许的大小比UDP小，因为tcp头是20字节，UDP头只有8字节</li><li>应用场景：TCP 主要是对于要求数据完整，效率不需要很高的场景（文件传输），UDP则是数据允许丢失，同时实时性要求高的的场景（网络直播，）</li></ul><p><img src="../assets/面试笔记/image-12.png" alt="示例图片" style="zoom:100%;" /></p><h3 id="衍生问题-6"><a href="#衍生问题-6" class="headerlink" title="衍生问题"></a>衍生问题</h3><h4 id="TCP的MSS和IP的MTU分别是什么？"><a href="#TCP的MSS和IP的MTU分别是什么？" class="headerlink" title="TCP的MSS和IP的MTU分别是什么？"></a>TCP的MSS和IP的MTU分别是什么？</h4><ul><li>首先MTU为时网络层的最大传输单元，以太网最大的数据帧是1518字节，这样刨去帧头14字节和帧尾CRC校验部分4字节，那么剩下承载上层IP报文的地方最大就只有1500字节，这个值就是以太网的默认MTU值。当传输的数据的字节数超过这个数据就得分片，<img src="../assets/面试笔记/image-9.png" alt="示例图片" style="zoom:100%;" /></li><li>MSS通常是MTU - IP头 - TCP头得到的数据，也就是1500 - 20 - 20 = 1460；<img src="../assets/面试笔记/image-10.png" alt="示例图片" style="zoom:100%;" />，MSS的值通常需要两端的协商，得到具体值，TCP是传输层，IP在网络层，数据从传输层到网络层就要进行封装，IP头,TCP头就是封装</li></ul><h4 id="既然再IP层就会分片，为什么还要再TCP那进行分段，MSS"><a href="#既然再IP层就会分片，为什么还要再TCP那进行分段，MSS" class="headerlink" title="既然再IP层就会分片，为什么还要再TCP那进行分段，MSS"></a>既然再IP层就会分片，为什么还要再TCP那进行分段，MSS</h4><ul><li>当数据大于这个（MSS）最大报文段长度的时候，要进行分段，这个值是建立连接的时候双方协商的，当双方每次发数据的时候都会协商一次，如果在TCP不分段传给IP的时候，一旦ip中的一个MTU发生丢包，就得重新传一大片数据，而如果采用了MSS分段，丢包的时候只需要重传丢的那一小块MSS就行，这样是为了效率，为了避免IP进行分片（加入TCP头 与 IP头）</li></ul><h4 id="TCP是如何保证可靠性的？"><a href="#TCP是如何保证可靠性的？" class="headerlink" title="TCP是如何保证可靠性的？"></a>TCP是如何保证可靠性的？</h4><ul><li>重传机制：解决的是数据丢失问题，是通过序列号和确认应答机制来实现的，<ol><li>超时重传：也就是会有一个超时定时器，当设定来回的时间之内没有收到ACK，就会重传数据，就是超时后重传</li><li>快速重传：就是在超时之前收到三个相同的数据包确认，直接重传丢失的数据，<img src="../assets/面试笔记/image-19.png" alt="示例图片" style="zoom:100%;" /></li></ol></li><li>滑动窗口：（是一种机制，为下面两个服务）<ol><li>可以连续发送多个字节数据，而不需要返回每个字节数据的确认</li><li>窗口：在没有应答的情况下发送方可以发送多少数据</li><li>滑动：收到确认包之后在移动窗口，例如连续发了300字节数据其中第201到300数据丢失了，下次发送的时候窗口左边界会移动到201，并根据对方（接收方）发来的窗口大小来调整大小（即发送方的滑动窗口由接收方决定）</li></ol></li><li>流量控制：<ol><li>通过接收方的处理能力来限制发送方的发送量，即解决接收方接收缓冲区满而丢失数据的问题</li><li>怎么控制？ 先收缩窗口，再缩小缓冲区，当窗口收缩为0的时候，发送方由于不能发送数据，会发送一个1字节的探测报文，来探测接收方滑动窗口大小是否改变</li></ol></li><li>拥塞控制：<ol><li>解决的是网络不好的时候，接收方继续发送大量数据而导致数据时延或丢失的问题</li><li>怎么控制？首先接收方会有一个cwnd（拥塞窗口），接收方接收缓冲区会有一个接收窗口，发送方还一个ssthresh值（慢启动阀值），一开始发送方从1开始执行慢开始算法(拥塞窗口以指数增长)，当到达设定的慢启动阀值的时候就开始进行拥塞避免算法(cwnd慢慢 + 1)，如果此时遇到了超时重传，就会使得阀值减少一半，然后cwnd变为1从新开始慢启动，如果遇到的是快重传，就会执行快恢复（阀值减半，但cwnd不会下降为1而是会变为从阀值开始执行拥塞避免）如图<img src="../assets/面试笔记/image-20.png" alt="示例图片" style="zoom:100%;" />，2<em>N=v</em>RTT，探测到拥塞说明管道的容量为当前窗口C，而C=2<em>N，因此N=(1/2)</em>C!</li></ol></li></ul><h4 id="为什么需要三次握手"><a href="#为什么需要三次握手" class="headerlink" title="为什么需要三次握手"></a>为什么需要三次握手</h4><ul><li>为什么最后要发送ack呢，因为如果主动连接端有一次SYN连接请求超时了，也就是在网络上滞留了，主动连接方会超时重传，当这个重传的被接受了，并且建立了链接，并正确释放连接后，滞留的连接请求到达了服务端，服务端发送确认请求，并且进入established阶段，但是由于客户端时closed，不会给予响应，就会导致服务端一直处于连接状态</li></ul><h4 id="为什么需要四次挥手"><a href="#为什么需要四次挥手" class="headerlink" title="为什么需要四次挥手"></a>为什么需要四次挥手</h4><ul><li>因为服务端可以继续发送未发完的数据，使用三次挥手可能导致数据不完整</li></ul><h4 id="为什么在四次挥手的时候需要等待2个MSL时间"><a href="#为什么在四次挥手的时候需要等待2个MSL时间" class="headerlink" title="为什么在四次挥手的时候需要等待2个MSL时间"></a>为什么在四次挥手的时候需要等待2个MSL时间</h4><ul><li><strong>保证A发送的最后一个ACK报文段能够到达B</strong>。这个ACK报文段有可能丢失，B收不到这个确认报文，就会超时重传连接释放报文段，然后A可以在2MSL时间内收到这个重传的连接释放报文段，接着A重传一次确认，重新启动2MSL计时器，最后A和B都进入到CLOSED状态，若A在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到B重传的连接释放报文段，所以不会再发送一次确认报文段，B就无法正常进入到CLOSED状态。</li><li><strong>防止已失效的连接请求报文段出现在本连接中</strong>。A在发送完最后一个ACK报文段后，再经过2MSL，就可以使这个连接所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现旧的连接请求报文段。</li></ul><h4 id="什么是SYN攻击？"><a href="#什么是SYN攻击？" class="headerlink" title="什么是SYN攻击？"></a>什么是SYN攻击？</h4><ul><li>我们都知道 TCP 连接建立是需要三次握手,假设攻击者短时间伪造不同 IP 地址的 SYN 报文,服务端每接收到 一个 SYN 报文,就进入 SYN_RCVD 状态,但服务端发送出去的 ACK + SYN 报文,无法得到未知 IP 主机的ACK 应答,久而久之就会占满服务端的 SYN 接收队列(未连接队列),使得服务器不能为正常用户服务。</li></ul><h4 id="如何唯一确定一个TCP连接呢？"><a href="#如何唯一确定一个TCP连接呢？" class="headerlink" title="如何唯一确定一个TCP连接呢？"></a>如何唯一确定一个TCP连接呢？</h4><ul><li>TCP 四元组可以唯一的确定一个连接,四元组包括如下: 源地址 源端口 目的地址 目的端口。</li><li>源地址和目的地址的字段(32位)是在 IP 头部中,作用是通过 IP 协议发送报文给对方主机。</li><li>源端口和目的端口的字段(16位)是在 TCP 头部中,作用是告诉 TCP 协议应该把报文发给哪个进程。</li></ul><h2 id="水平触发与边缘触发的区别"><a href="#水平触发与边缘触发的区别" class="headerlink" title="水平触发与边缘触发的区别"></a>水平触发与边缘触发的区别</h2><ul><li>水平触发：<ol><li>读事件：只要有数据可读（接受缓冲区还有数据），就继续触发读事件</li><li>写事件：当发送缓冲区没有满的时候，也就是还能继续写入数据的时候，会继续触发写事件</li></ol></li><li><p>边缘触发：</p><ol><li>读事件：只有新数据到达缓冲区的时候才会再次出发读事件</li><li>写事件：只有当发送缓冲区从满变为了不满时，才会触发写事件</li></ol></li><li><p>由于水平触发时会一直调用读或写事件，所以得关闭EPOLLOUT，如果发送的数据很多会频繁关闭，所以一般来说边缘触发的效率要比水平触发要高</p></li></ul><h2 id="什么是半打开半关闭状态"><a href="#什么是半打开半关闭状态" class="headerlink" title="什么是半打开半关闭状态"></a>什么是半打开半关闭状态</h2><ul><li>当连接双方两端，一端断开了连接，而另一端没有发觉，继续发送数据，保留连接状态，服务端一方未能及时检测到对端已经关闭,会一直占用资源直至超时。</li><li>半打开套接字会占用文件句柄和内存,影响系统的性能。因此,半打开套接字需要特别注意,应尽快检测并关闭。</li></ul><h3 id="如何处理半打开状态"><a href="#如何处理半打开状态" class="headerlink" title="如何处理半打开状态"></a>如何处理半打开状态</h3><ul><li>采用超时重连机制或心跳包机制，定期检查连接状态，检出异常就关闭套接字</li><li>添加空闲超时机制，在一段时间内未收到数据就关闭套接字</li><li>在应用层做好异常处理</li><li>使用TCP keep-alive选项，对端DOWN后,TCP层会自动关闭连接。</li></ul><h2 id="写文件时进程宕机，数据会丢失吗？"><a href="#写文件时进程宕机，数据会丢失吗？" class="headerlink" title="写文件时进程宕机，数据会丢失吗？"></a>写文件时进程宕机，数据会丢失吗？</h2><ul><li>背景：<ol><li>文件的写是在stdIO库中</li><li>stdIO有缓冲区：可以setbuf自定义，作用是减少系统调用</li><li>page cache：的<strong>作用</strong>是为了减少磁盘IO的词是，是为了提供速度，因为从内存到磁盘需要花费大量时间，在中间引入page cache后可以异步向磁盘载入数据，<strong>缺点</strong>：用户层无法优化page cache的策略，这也是为什么数据库要维护page管理</li><li>两种磁盘IO的方式：<ul><li>缓存文件IO: 是用户态的缓冲区里的数据先经过page cache，再写入磁盘</li><li>直接文件IO：是直接从用户态的缓存区到磁盘<br><strong>分两种情况</strong></li></ul></li></ol></li><li>写文件如果没有调用fflush(write)宕机后会丢失数据</li><li>写文件如果调用过fflush,也就是把数据写入了page cache，进程宕机不会丢失，但是os崩了就会</li><li>假设进程宕机了，系统也关闭了，如果没调用write会丢失，调用了write但是用的是缓存文件IO也会丢失，用直接文件IO不会丢失</li></ul><h3 id="文件相关知识"><a href="#文件相关知识" class="headerlink" title="文件相关知识"></a>文件相关知识</h3><ul><li>用户态会有一个缓冲区，在内核态会有一个高速缓存区（page cache），还有磁盘，一共有四个接口，fflush（本质调用的是write）是把用户态缓冲区内容写入page cache，fsync（指定一个fd），fdatasync，sync（把所有文件全部载入磁盘） 是把page cache写入磁盘中<br>如图：<img src="../assets/面试笔记/image-21.png" alt="示例图片" style="zoom:100%;" /></li></ul><h3 id="什么使用直接文件IO，什么时候使用缓存文件IO"><a href="#什么使用直接文件IO，什么时候使用缓存文件IO" class="headerlink" title="什么使用直接文件IO，什么时候使用缓存文件IO"></a>什么使用直接文件IO，什么时候使用缓存文件IO</h3><ul><li>大数据使用直接文件IO，因为大数据使用缓存文件IO，会把page cache全部占据了并从page cache中淘汰一些数据，如果将来这些数据被频繁读取，需要从磁盘重新读，会大大减低效率</li><li>小数据使用缓存文件IO</li></ul><h2 id="左值引用和右值引用区别"><a href="#左值引用和右值引用区别" class="headerlink" title="左值引用和右值引用区别"></a>左值引用和右值引用区别</h2><ul><li>一个是针对左值，一个是引用右值，const左值引用，可以引用右值，但是不能修改（右值引用就是解决不能修改这个问题），右值引用也可通过std::move（将左值转换为右值）来引用左值，声明出来的左值引用和右值引用都是左值</li><li>功能差异：<ol><li>左值引用是为了避免对象拷贝，常用在函数传参和函数返回值（A&amp; b = func()）中</li><li>右值引用是为了实现移动语义move 和 完美转发</li></ol></li><li>右值引用的移动语义是为了在对象赋值时避免资源的重新分配，移动构造以及移动赋值构造，stl应用，std::unique_ptr，function等</li></ul><h3 id="衍生问题-7"><a href="#衍生问题-7" class="headerlink" title="衍生问题"></a>衍生问题</h3><h4 id="什么是左值，什么是右值"><a href="#什么是左值，什么是右值" class="headerlink" title="什么是左值，什么是右值"></a>什么是左值，什么是右值</h4><ul><li>左值：可以放在等号左边，可以取地址，并且是具备名字的，比如（变量，返回左值引用的函数调用，<strong>前置</strong>自增自减，赋值运算符，解引用）</li><li>右值：只能在等号右边，不可以取地址，没有具备名字<ol><li>纯右值：常量（字面值），返回非引用类型的函数调用，<strong>后置</strong>自增自减，逻辑表达式，算数表达式，比较表达式</li><li>将亡值：是C++11新引入的值类型，与移动语义息息相关，移动构造和移动赋值构造处理的就是将亡值，并进行资源转移，之后将调用析构函数</li></ol></li></ul><h4 id="右值引用的移动语义是什么意思？"><a href="#右值引用的移动语义是什么意思？" class="headerlink" title="右值引用的移动语义是什么意思？"></a>右值引用的移动语义是什么意思？</h4><ul><li>就是用来处理将亡值这个右值，用于函数返回值时可以减少一次拷贝构造函数，因为它是将将亡值里的资源直接”移动”到被赋值的上面</li><li>移动构造函数：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">A</span>(A&amp;&amp; a)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;p = a.p;</span><br><span class="line">    a.p = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">b</span><span class="params">(std::move(a))</span></span>;</span><br></pre></td></tr></table></figure><h4 id="什么是完美转发"><a href="#什么是完美转发" class="headerlink" title="什么是完美转发"></a>什么是完美转发</h4><ul><li>完美转发的意思就是函数模板可以将自己的参数完美的转发给内部调用的其他函数</li><li>完美是指不仅能准确的转发参数的值，还能准确的转发参数的左右值属性,因为右值它经过一系列处理后会变为左值</li><li>我的理解是想要实现完美转发就离不开<strong>万能引用</strong> + <strong>引用折叠</strong> + <strong>std::forward函数</strong></li><li><strong>forward函数</strong>：<img src="af62188138a1eff94ced25b66cfb9df8.png" alt="alt text">，它定义于move.h中</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">forward&lt;<span class="type">int</span>&gt;(a);<span class="comment">// 这个与foward&lt;int &amp;&amp;&gt;(a)结果一样，无论a是左值还是右值都转换为右值引用</span></span><br><span class="line">forward&lt;<span class="type">int</span> &amp;&gt;(a);<span class="comment">// 无论a是左值还是右值都转换为左值引用</span></span><br><span class="line">forward&lt;<span class="keyword">decltype</span>(t)&gt;(t);<span class="comment">//根据实际类型和实际左右值进行转发</span></span><br></pre></td></tr></table></figure><ul><li><p>右值转发：forward(param) —&gt; int&amp;&amp; 或 forward<int&&>(param) —&gt; int&amp;&amp;</p></li><li><p>左值转发：forward<int&>(param) —&gt; int&amp;</p></li><li><p>如果要转发其自身的类型，使用： <strong>forward<decltype(param)>(param)</strong></p></li></ul><h5 id="那什么是万能引用呢？"><a href="#那什么是万能引用呢？" class="headerlink" title="那什么是万能引用呢？"></a>那什么是万能引用呢？</h5><ul><li>它既能接收左值又能接收右值</li><li>基于参数模板的， T &amp;&amp;，他会有以下几种情况：<ol><li>T &amp;&amp;碰到右值int &amp;&amp;， T匹配成int；</li><li>T &amp;&amp; 遇到左值 int ，也能匹配，T此时是int &amp;。</li><li>T &amp;&amp; 碰到左值const int，T匹配为 const int &amp;。</li><li>T &amp;&amp;碰到左值const int <em>（指针类型), T匹配为const int</em>&amp; (下略）</li><li>T &amp;&amp;碰到左值const int <em>const（指针类型), T匹配为const int</em>const &amp; （下略）</li></ol></li><li>其中就用到了<strong>引用折叠</strong> int &amp; &amp;&amp; 这种情况 会被折叠为 int &amp;</li></ul><h2 id="智能指针种类以及使用场景"><a href="#智能指针种类以及使用场景" class="headerlink" title="智能指针种类以及使用场景"></a>智能指针种类以及使用场景</h2><ul><li>指针管理的困境：<ol><li>资源释放了，但是指针没置空，野指针，指针悬挂</li><li>没有释放资源导致内存泄漏</li><li>多个指针指向一个资源，导致重复释放一个资源</li></ol></li><li><p>使用RAII思想：它通过在对象的构造函数中获取资源，在对象的析构函数中释放资源，从而确保资源的正确获取和释放，利用生命周期来正确释放资源<br>一共三种智能指针：</p></li><li><p>shared_ptr:</p><ol><li>解决的是多个指针指向一个资源的问题，共享所有权</li><li>原理：内部维护了一个引用计数，这个数字就是指向这个资源的指针数量，只有数为0才能通过析构函数释放资源，因为不同shared_ptr指针需要共享相同的内存对象，因此引用计数的存储是在堆上的</li><li>使用场景：通常用于一些资源创建昂贵比较耗时的场景， 比如涉及到文件读写、网络连接、数据库连接等。当需要共享资源的所有权时，例如，一个资源需要被多个对象共享，但是不知道哪个对象会最后释放它，这时候就可以使用std::shared_ptr<T></li></ol></li><li>weak_ptr:<ol><li>是一个弱引用，指向的是<strong>shared_ptr所指的对象</strong>，而不影响所指对象的生命周期（不会改变引用计数）</li><li>weak_ptr不能解引用，所以如果要访问所指对象，就得强制转换为shared_ptr，lock()函数就实现了该功能，成功返回共享对象的shared_ptr,失败返回空的shared_ptr</li><li>使用场景：<ol><li>可用于<strong>实现缓存</strong>，因为当weak_ptr所知对象被销毁是，weak_ptr会自动释放，不会成为野指针<img src="../assets/面试笔记/image-23.png" alt="示例图片" style="zoom:100%;" />，为什么不直接用shared_ptr，因为用这个之后引用计数永远不会为0</li><li><strong>避免循环引用问题</strong>，两个对象的shared_ptr互相指向对方，导致形成一个环，互相依赖，从而导致内存泄漏，解决办法就是将其中一个shared_ptr改为weak_ptr</li><li><strong>用于实现单例模式</strong>，<img src="../assets/面试笔记/image-24.png" alt="示例图片" style="zoom:100%;" />，优点是避免循环应用：避免了内存泄漏。访问控制：可以访问对象，但是不会延长对象的生命周期。可以在单例对象不被使用时，自动释放对象。</li></ol></li></ol></li><li><p>unique_ptr:</p><ol><li>独享所有权，一个资源只能有一个指针指向它，使用移动语义实现</li><li><p>原理：</p><ol><li><p>禁用了拷贝构造和赋值构造</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>(<span class="type">const</span> unique_ptr&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">unique_ptr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> unique_ptr&amp;) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure></li><li><p>std::move() 可以将一个unique_ptr转移给另一个unique_ptr或者shared_ptr。转移后，原来的unique_ptr将不再拥有对内存的控制权，将变为空指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; p1 = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">0</span>);</span><br><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; p2 = std::<span class="built_in">move</span>(p1); </span><br></pre></td></tr></table></figure></li></ol></li></ol></li></ul><h2 id="什么设计模式，它解决的是什么问题"><a href="#什么设计模式，它解决的是什么问题" class="headerlink" title="什么设计模式，它解决的是什么问题"></a>什么设计模式，它解决的是什么问题</h2><ul><li>设计模式是指在软件开发中，通过前人验证的，用于解决特定环境下，一种通用的，可重用的解决方案</li><li>解决的是如何做到修改少量代码，就可以适应需求的变化，前提是（既有稳定点，又有变化点），就好比一个整洁的房间，好动的猫，怎么保证房间的整洁</li></ul><h3 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h3><h4 id="设计模式一共有哪几大类，设计模式的六大原则是什么"><a href="#设计模式一共有哪几大类，设计模式的六大原则是什么" class="headerlink" title="设计模式一共有哪几大类，设计模式的六大原则是什么"></a>设计模式一共有哪几大类，设计模式的六大原则是什么</h4><ul><li>有三大类， 创建型模式（工厂模式，抽象工厂模式，单例模式，建造者模式，原型模式），结构型模式（适配器模式，代理模式，外观模式），行为型模式（策略模式，观察者模式，责任链模式）</li><li>六大原则：<ol><li>开放封闭原则：<ol><li>原则思想：尽量通过扩展软件实体来解决需求变化，而不是通过修改已有的代码</li><li>描述：一个软件产品在生命周期内，都会发生变化，既然变化是一个既定的事实，我们就应该在设计的时候尽量适应这些变化，以提高项目的稳定性和灵活性。</li></ol></li><li>里氏代换原则：<ol><li>原则思想：使用的基类可以在任何地方使用继承的子类，完美替换基类</li><li>大概意思是：子类可以扩展父类的功能，但不能改变父类原有的功能。子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法，子类中可以增加自己特有的方法</li></ol></li><li>依赖倒转原则：<ol><li>核心思想是面向接口编程，它要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，依赖抽象而不依赖具体</li></ol></li><li>接口隔离原则：<ol><li>这个原则的大概意思是使用多个隔离的接口，也就是各个接口之间的联系要尽可能小，即要降低接口之间的耦合度</li><li>类间的依赖接力在最基础的接口，尽量不要使用用户选择不用的接口</li></ol></li><li>迪米特法则（最少知道原则）：<ol><li>原则思想：一个软件实体应当尽可能少的与其他实体发生相互作用，简称类之间的解耦</li><li>大概意思就是一个模块修改而尽量少的影响其他模块，也就是要高内聚，低耦合</li></ol></li><li>单一职责原则：<ol><li>一个方法只负责一件事件</li><li>优点：降低类和类的耦合，提高可读性，增加可维护性和可拓展性，降低可变性的风险</li></ol></li></ol></li></ul><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><h5 id="什么是单例，它可以在哪些地方用到了"><a href="#什么是单例，它可以在哪些地方用到了" class="headerlink" title="什么是单例，它可以在哪些地方用到了"></a>什么是单例，它可以在哪些地方用到了</h5><ul><li>保证一个类只有一个实例，并且提供一个访问该全局的访问点</li><li>windows的任务管理器，windows的回收站，网站的计数器，多线程的线程池设计等等</li></ul><h5 id="单例的优缺点"><a href="#单例的优缺点" class="headerlink" title="单例的优缺点"></a>单例的优缺点</h5><ul><li>优点：保证所有的对象都只会访问一个实例，避免对共享资源的多重占用，一个系统只存在一个对象，因此可以节约系统资源，所以如果需要频繁创建和销毁的对象时单例模式可以提高系统的性能</li><li>缺点：单例类不好扩展，不适用于变化的对象</li></ul><h5 id="单例创建方式"><a href="#单例创建方式" class="headerlink" title="单例创建方式"></a>单例创建方式</h5><h6 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h6><ul><li>类初始化的时候，会加载该对象，调用效率高，线程安全</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//饿汉式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有的构造函数，防止外部调用构造函数创建实例</span></span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将拷贝构造函数和赋值运算符重载声明为私有，防止拷贝创建实例</span></span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;);</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态成员变量，用于存储唯一的实例</span></span><br><span class="line">    <span class="type">static</span> Singleton* instance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取单例实例的静态方法</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他成员方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">someMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Some method of Singleton class&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化静态成员变量，当类有静态成员变量，其是在类的定义外部进行初始化</span></span><br><span class="line">Singleton* Singleton::instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取单例实例</span></span><br><span class="line">    Singleton* singleton = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用单例实例的方法</span></span><br><span class="line">    singleton-&gt;<span class="built_in">someMethod</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h6><ul><li>类初始化时，不会初始化该对象，而是在真正需要使用的时候才会创建该对象</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有的静态成员变量，用于存储唯一的实例</span></span><br><span class="line">    <span class="type">static</span> Singleton* instance;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 私有的构造函数，防止外部调用构造函数创建实例</span></span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Singleton instance created.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将拷贝构造函数和赋值运算符重载声明为私有，防止拷贝创建实例</span></span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;);</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取单例实例的静态方法</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用局部静态变量确保线程安全地创建单例实例</span></span><br><span class="line">        <span class="type">static</span> std::mutex mtx;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他成员方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">someMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Some method of Singleton class&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化静态成员变量</span></span><br><span class="line">Singleton* Singleton::instance = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取单例实例</span></span><br><span class="line">    Singleton* singleton1 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">    Singleton* singleton2 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否是同一个实例</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Are singleton1 and singleton2 the same instance? &quot;</span> &lt;&lt; (singleton1 == singleton2 ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用单例实例的方法</span></span><br><span class="line">    singleton1-&gt;<span class="built_in">someMethod</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="静态内部方式"><a href="#静态内部方式" class="headerlink" title="静态内部方式"></a>静态内部方式</h6><ul><li>结合了懒汉式和饿汉式各自的优点，真正需要对象的时候才会加载，加载类是线程安全的。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有的构造函数，防止外部调用构造函数创建实例</span></span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Singleton instance created.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将拷贝构造函数和赋值运算符重载声明为私有，防止拷贝创建实例</span></span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取单例实例的静态方法</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton&amp; <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 局部静态变量，确保在程序运行过程中只创建一次实例</span></span><br><span class="line">        <span class="type">static</span> Singleton instance;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他成员方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">someMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Some method of Singleton class&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取单例实例</span></span><br><span class="line">    Singleton&amp; singleton1 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">    Singleton&amp; singleton2 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否是同一个实例</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Are singleton1 and singleton2 the same instance? &quot;</span> &lt;&lt; (&amp;singleton1 == &amp;singleton2 ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用单例实例的方法</span></span><br><span class="line">    singleton<span class="number">1.</span><span class="built_in">someMethod</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong><em>注意</em></strong>：这种方式 在C++11之前是不安全的，得加互斥锁，但是在C++11之后是安全的</p><h5 id="如何选择单例模式的创建方式"><a href="#如何选择单例模式的创建方式" class="headerlink" title="如何选择单例模式的创建方式"></a>如何选择单例模式的创建方式</h5><ul><li>如果不需要延迟加载单例，就用饿汉式</li><li>如果需要用延迟加载机制，可以用静态内部类或者懒汉式</li></ul><h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><ul><li>定义一个创建对象的接口，让子类决定实例化哪个类，而对象的创建统一交由工厂去生产，有良好的封装性，既做到了解耦，也保证了最少知识原则。</li><li>工厂模式总共分为三类，简单工厂模式，工厂方法模式，抽象工厂模式</li></ul><h5 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h5><ul><li>特点是需要在工厂类中做判断，从而创造相应产品，当需要增加产品种类的时候，不能够扩展，而只能修改源码，不满足开发封闭原则</li><li>举例：有一家生产处理器核的厂家，它只有一个工厂，能够生产两种型号的处理器核。客户需要什么样的处理器核，一定要显示地告诉生产工厂。下面给出一种实现方案：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//程序实例（简单工厂模式）</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">CTYPE</span> &#123;COREA, COREB&#125;;     </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleCore</span>    </span><br><span class="line">&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;  </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="comment">//单核A    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleCoreA</span>: <span class="keyword">public</span> SingleCore    </span><br><span class="line">&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;SingleCore A&quot;</span>&lt;&lt;endl; &#125;    </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="comment">//单核B    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleCoreB</span>: <span class="keyword">public</span> SingleCore    </span><br><span class="line">&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;SingleCore B&quot;</span>&lt;&lt;endl; &#125;    </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="comment">//唯一的工厂，可以生产两种型号的处理器核，在内部判断    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span>    </span><br><span class="line">&#123;    </span><br><span class="line"><span class="keyword">public</span>:     </span><br><span class="line">    <span class="function">SingleCore* <span class="title">CreateSingleCore</span><span class="params">(<span class="keyword">enum</span> CTYPE ctype)</span>    </span></span><br><span class="line"><span class="function">    </span>&#123;    </span><br><span class="line">        <span class="keyword">if</span>(ctype == COREA) <span class="comment">//工厂内部判断    </span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SingleCoreA</span>(); <span class="comment">//生产核A    </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ctype == COREB)    </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SingleCoreB</span>(); <span class="comment">//生产核B    </span></span><br><span class="line">        <span class="keyword">else</span>    </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;    </span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>大概如图所示：</li><li><img src="../assets/面试笔记/image-26.png" alt="示例图片" style="zoom:100%;" /></li></ul><h6 id="简单工厂模式的优缺点"><a href="#简单工厂模式的优缺点" class="headerlink" title="简单工厂模式的优缺点"></a>简单工厂模式的优缺点</h6><ul><li>优点：可以根据需求，动态生成使用者所需的类对象，而使用者不用去知道怎么创建对象，者使得模块各司其职，降低了系统耦合性</li><li>缺点:违反了开放封闭原则</li></ul><h5 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h5><ul><li><p>所谓工厂方法模式（又称多态性工厂模式），是指核心的工厂类不再负责所有的产品的创建，而是将具体创建的工作交给子类去做。该核心类成为一个抽象工厂角色，仅负责给出具体工厂子类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节</p></li><li><p>举例：这家生产处理器核的产家赚了不少钱，于是决定再开设一个工厂专门用来生产B型号的单核，而原来的工厂专门用来生产A型号的单核。这时，客户要做的是找好工厂，比如要A型号的核，就找A工厂要；否则找B工厂要，不再需要告诉工厂具体要什么型号的处理器核了。下面给出一个实现方案：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//程序实例（工厂方法模式）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleCore</span>    </span><br><span class="line">&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;  </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="comment">//单核A    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleCoreA</span>: <span class="keyword">public</span> SingleCore    </span><br><span class="line">&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;SingleCore A&quot;</span>&lt;&lt;endl; &#125;    </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="comment">//单核B    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleCoreB</span>: <span class="keyword">public</span> SingleCore    </span><br><span class="line">&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;SingleCore B&quot;</span>&lt;&lt;endl; &#125;    </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span>    </span><br><span class="line">&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> SingleCore* <span class="title">CreateSingleCore</span><span class="params">()</span> </span>= <span class="number">0</span>;  </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="comment">//生产A核的工厂    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FactoryA</span>: <span class="keyword">public</span> Factory    </span><br><span class="line">&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function">SingleCoreA* <span class="title">CreateSingleCore</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> SingleCoreA; &#125;    </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="comment">//生产B核的工厂    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FactoryB</span>: <span class="keyword">public</span> Factory    </span><br><span class="line">&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function">SingleCoreB* <span class="title">CreateSingleCore</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> SingleCoreB; &#125;    </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="../assets/面试笔记/image-27.png" alt="示例图片" style="zoom:100%;" /></p><h6 id="工厂方法模式的优缺点"><a href="#工厂方法模式的优缺点" class="headerlink" title="工厂方法模式的优缺点"></a>工厂方法模式的优缺点</h6><ul><li>优点：扩展性好，符合了开放封闭原则，新增的时候只需要扩展子类就行</li><li>缺点：如果需要很多工厂，就要继承出很多子类</li></ul><h5 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h5><ul><li>举例：这家公司的技术不断进步，不仅可以生产单核处理器，也能生产多核处理器。现在简单工厂模式和工厂方法模式都鞭长莫及。抽象工厂模式登场了。它的定义为提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。具体这样应用，这家公司还是开设两个工厂，一个专门用来生产A型号的单核多核处理器，而另一个工厂专门用来生产B型号的单核多核处理器，下面给出实现的代码：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//程序实例（抽象工厂模式）</span></span><br><span class="line"><span class="comment">//单核    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleCore</span>     </span><br><span class="line">&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;  </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleCoreA</span>: <span class="keyword">public</span> SingleCore      </span><br><span class="line">&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;Single Core A&quot;</span>&lt;&lt;endl; &#125;    </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleCoreB</span> :<span class="keyword">public</span> SingleCore    </span><br><span class="line">&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;Single Core B&quot;</span>&lt;&lt;endl; &#125;    </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="comment">//多核    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MultiCore</span>      </span><br><span class="line">&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;  </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MultiCoreA</span> : <span class="keyword">public</span> MultiCore      </span><br><span class="line">&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;Multi Core A&quot;</span>&lt;&lt;endl; &#125;    </span><br><span class="line">    </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MultiCoreB</span> : <span class="keyword">public</span> MultiCore      </span><br><span class="line">&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;Multi Core B&quot;</span>&lt;&lt;endl; &#125;    </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="comment">//工厂    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CoreFactory</span>      </span><br><span class="line">&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> SingleCore* <span class="title">CreateSingleCore</span><span class="params">()</span> </span>= <span class="number">0</span>;  </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> MultiCore* <span class="title">CreateMultiCore</span><span class="params">()</span> </span>= <span class="number">0</span>;  </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="comment">//工厂A，专门用来生产A型号的处理器    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FactoryA</span> :<span class="keyword">public</span> CoreFactory    </span><br><span class="line">&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function">SingleCore* <span class="title">CreateSingleCore</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SingleCoreA</span>(); &#125;    </span><br><span class="line">    <span class="function">MultiCore* <span class="title">CreateMultiCore</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">MultiCoreA</span>(); &#125;    </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="comment">//工厂B，专门用来生产B型号的处理器    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FactoryB</span> : <span class="keyword">public</span> CoreFactory    </span><br><span class="line">&#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function">SingleCore* <span class="title">CreateSingleCore</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SingleCoreB</span>(); &#125;    </span><br><span class="line">    <span class="function">MultiCore* <span class="title">CreateMultiCore</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">MultiCoreB</span>(); &#125;    </span><br><span class="line">&#125;;   </span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="../assets/面试笔记/image-28.png" alt="示例图片" style="zoom:100%;" /></p><h6 id="抽象工厂模式的优缺点"><a href="#抽象工厂模式的优缺点" class="headerlink" title="抽象工厂模式的优缺点"></a>抽象工厂模式的优缺点</h6><ul><li><p>优点： 工厂抽象类创建了多个类型的产品，当有需求时，可以创建相关产品子类和子工厂类来获取。</p></li><li><p>缺点： 扩展新种类产品时困难。抽象工厂模式需要我们在工厂抽象类中提前确定了可能需要的产品种类，以满足不同型号的多种产品的需求。但是如果我们需要的产品种类并没有在工厂抽象类中提前确定，那我们就需要去修改工厂抽象类了，而一旦修改了工厂抽象类，那么所有的工厂子类也需要修改，这样显然扩展不方便。</p></li></ul><h5 id="抽象工厂模式和工厂方法模式的区别"><a href="#抽象工厂模式和工厂方法模式的区别" class="headerlink" title="抽象工厂模式和工厂方法模式的区别"></a>抽象工厂模式和工厂方法模式的区别</h5><ul><li>传统的工厂方法模式，一般只能有一个纯虚函数，他的子类实现这个纯虚函数，一个只能创造一种产品，且每个产品都是同一种</li><li>抽象工厂模式，必须有多个纯虚函数，他的子类必须实现这些纯虚函数，并创建一系列相关的对象，即一个工厂可以创造多个有相同性质又有不同的产品</li></ul><h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h4><ul><li>定义：策略模式是定义了一系列算法，把它们一个个封装起来，并且使它们可互相替换，该模式使得算法可以独立于使用它的客户端变化而变化</li><li><p>例如：一个商城有多种打折方式，有国庆打折方式，劳动节打折方式，春节打折方式，又例如一个会员，有初级会员，中级会员，高级会员</p></li><li><p>如果不采用策略模式，在一个商城类中，既要有国庆打折方式，劳动节打折方式，春节打折方式，当一个打折方式变化后，这个商城类整体就要变化</p></li><li>如果采用设计模式，国庆打折方式抽象出来成为一个类劳动节打折方式和春节打折方式付也抽象出来成为类，这样就会有一个商城类和 一个国庆打折方式类，一个劳动节打折方式类，一个春节打折方式类，在商城类只需要一个指针，指向对应的打折方式就行</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ProStategy</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">CalcPro</span> <span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">gqStategy</span>: <span class="keyword">public</span> ProStategy&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">CalcPro</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;国庆打折&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ldjStategy</span>: <span class="keyword">public</span> ProStategy&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">CalcPro</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;劳动节打折&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">cjqStategy</span>: <span class="keyword">public</span> ProStategy&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">CalcPro</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;春节打折&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Promotion</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Promotion</span>(ProStategy * sss = <span class="literal">nullptr</span>) : <span class="built_in">s</span>(sss)&#123;&#125;</span><br><span class="line">    ~<span class="built_in">Promotion</span>()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Chose</span><span class="params">(ProStategy *sss)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sss != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        s = sss;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ProStategy *s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="../assets/面试笔记/image-29.png" alt="示例图片" style="zoom:100%;" /></p><p>其中左位使用前，右为使用后</p><h5 id="应用案例"><a href="#应用案例" class="headerlink" title="应用案例"></a>应用案例</h5><ul><li>日志容错恢复机制：通常情况下，日志记录在数据库中，但是如果发生了异常，数据库暂时连接不上的情况，就会先将日志记录在文件中，之后在合适的时机再写回数据库，这就可以采用策略模式，把日志记录在数据库和记录在文件中当作两种记录日志的策略，在运行其动态选择（断网了选择记入在文件，连接的上就计入在数据库中）</li></ul><h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><ul><li>定义：指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。这种模式有时又称作发布-订阅模式、模型-视图模式，它是对象行为型模式。</li></ul><h5 id="解决了什么问题"><a href="#解决了什么问题" class="headerlink" title="解决了什么问题"></a>解决了什么问题</h5><ul><li>稳定点：一对多的依赖关系，一变化多跟着变化</li><li>变化点：多增加或者多减少，不能影响依赖关系，也不能影响一的</li></ul><h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><ul><li>气象站发布气象资料给数据中心，数据中心经过处理，将气象信息更新到两个不同的显示终端(a和b)</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 观察者接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">const</span> std::string&amp; weatherData)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 气象站，作为被观察者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WeatherStation</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;Observer*&gt; observers;</span><br><span class="line">    std::string weatherData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单例实现</span></span><br><span class="line">    <span class="built_in">WeatherStation</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取单例实例</span></span><br><span class="line">    <span class="function"><span class="type">static</span> WeatherStation&amp; <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> WeatherStation instance;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册观察者</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">registerObserver</span><span class="params">(Observer* observer)</span> </span>&#123;</span><br><span class="line">        observers.<span class="built_in">push_back</span>(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发布气象资料并通知观察者</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">publishWeatherData</span><span class="params">(<span class="type">const</span> std::string&amp; data)</span> </span>&#123;</span><br><span class="line">        weatherData = data;</span><br><span class="line">        <span class="built_in">notifyObservers</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知所有观察者</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">notifyObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer* observer : observers) &#123;</span><br><span class="line">            observer-&gt;<span class="built_in">update</span>(weatherData);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示终端A，观察者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DisplayTerminalA</span> : <span class="keyword">public</span> Observer &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">const</span> std::string&amp; weatherData)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Display Terminal A: Weather data updated - &quot;</span> &lt;&lt; weatherData &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示终端B，观察者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DisplayTerminalB</span> : <span class="keyword">public</span> Observer &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">const</span> std::string&amp; weatherData)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Display Terminal B: Weather data updated - &quot;</span> &lt;&lt; weatherData &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取气象站单例实例</span></span><br><span class="line">    WeatherStation&amp; weatherStation = WeatherStation::<span class="built_in">getInstance</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建显示终端A和B</span></span><br><span class="line">    DisplayTerminalA displayA;</span><br><span class="line">    DisplayTerminalB displayB;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册观察者</span></span><br><span class="line">    weatherStation.<span class="built_in">registerObserver</span>(&amp;displayA);</span><br><span class="line">    weatherStation.<span class="built_in">registerObserver</span>(&amp;displayB);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟气象站发布气象资料</span></span><br><span class="line">    weatherStation.<span class="built_in">publishWeatherData</span>(<span class="string">&quot;Temperature: 25°C, Humidity: 50%&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>博客订阅的例子，当博主发表新文章的时候，即博主状态发生了改变，那些订阅的读者就会收到通知，然后进行相应的动作，比如去看文章，或者收藏起来</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//观察者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span>  </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Observer</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Observer</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Update</span><span class="params">()</span> </span>&#123;&#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//博客</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Blog</span>  </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Blog</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Blog</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Attach</span><span class="params">(Observer *observer)</span> </span>&#123; m_observers.<span class="built_in">push_back</span>(observer); &#125;     <span class="comment">//添加观察者</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Remove</span><span class="params">(Observer *observer)</span> </span>&#123; m_observers.<span class="built_in">remove</span>(observer); &#125;        <span class="comment">//移除观察者</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Notify</span><span class="params">()</span> <span class="comment">//通知观察者</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        list&lt;Observer*&gt;::iterator iter = m_observers.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">for</span>(; iter != m_observers.<span class="built_in">end</span>(); iter++)</span><br><span class="line">            (*iter)-&gt;<span class="built_in">Update</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SetStatus</span><span class="params">(string s)</span> </span>&#123; m_status = s; &#125; <span class="comment">//设置状态</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> string <span class="title">GetStatus</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_status; &#125;    <span class="comment">//获得状态</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    list&lt;Observer* &gt; m_observers; <span class="comment">//观察者链表</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    string m_status; <span class="comment">//状态</span></span><br><span class="line">&#125;;</span><br><span class="line">    以上是观察者和博客的基类，定义了通用接口。博客类主要完成观察者的添加、移除、通知操作，设置和获得状态仅仅是一个默认实现。下面给出它们相应的子类实现。</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体博客类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BlogCSDN</span> : <span class="keyword">public</span> Blog</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_name; <span class="comment">//博主名称</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BlogCSDN</span>(string name): <span class="built_in">m_name</span>(name) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">BlogCSDN</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetStatus</span><span class="params">(string s)</span> </span>&#123; m_status = <span class="string">&quot;CSDN通知 : &quot;</span> + m_name + s; &#125; <span class="comment">//具体设置状态信息</span></span><br><span class="line">    <span class="function">string <span class="title">GetStatus</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_status; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//具体观察者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ObserverBlog</span> : <span class="keyword">public</span> Observer   </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_name;  <span class="comment">//观察者名称</span></span><br><span class="line">    Blog *m_blog;   <span class="comment">//观察的博客，当然以链表形式更好，就可以观察多个博客</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="built_in">ObserverBlog</span>(string name,Blog *blog): <span class="built_in">m_name</span>(name), <span class="built_in">m_blog</span>(blog) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">ObserverBlog</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Update</span><span class="params">()</span>  <span class="comment">//获得更新状态</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        string status = m_blog-&gt;<span class="built_in">GetStatus</span>();</span><br><span class="line">        cout&lt;&lt;m_name&lt;&lt;<span class="string">&quot;-------&quot;</span>&lt;&lt;status&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//测试案例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Blog *blog = <span class="keyword">new</span> <span class="built_in">BlogCSDN</span>(<span class="string">&quot;wuzhekai1985&quot;</span>);</span><br><span class="line">    Observer *observer1 = <span class="keyword">new</span> <span class="built_in">ObserverBlog</span>(<span class="string">&quot;tutupig&quot;</span>, blog);</span><br><span class="line">    blog-&gt;<span class="built_in">Attach</span>(observer1);</span><br><span class="line">    blog-&gt;<span class="built_in">SetStatus</span>(<span class="string">&quot;发表设计模式C++实现（15）——观察者模式&quot;</span>);</span><br><span class="line">    blog-&gt;<span class="built_in">Notify</span>();</span><br><span class="line">    <span class="keyword">delete</span> blog; <span class="keyword">delete</span> observer1;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h5><ul><li>观察者接口（抽象类）</li><li>实现不同的观察者</li><li>目标对象接口（一个单例，用容器接收不同的观察者）</li><li>往容器添加与删除接口</li><li>推送变化</li></ul><h5 id="如果扩展代码"><a href="#如果扩展代码" class="headerlink" title="如果扩展代码"></a>如果扩展代码</h5><ul><li>新增一个观察者，继承自观察者接口，实现观察者的变化逻辑，进容器</li><li>减少就是使用出容器</li></ul><h5 id="应用的案例"><a href="#应用的案例" class="headerlink" title="应用的案例"></a>应用的案例</h5><ul><li>游戏业务开发场景：一个用户有许多的特性，比如装备系统，vip系统，人物面板系统，当一个系统改变，其他系统也跟着改变</li></ul><h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><ul><li>优点<ol><li>降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。符合依赖倒置原则。</li><li>目标与观察者之间建立了一套触发机制。</li></ol></li><li>缺点<ol><li>目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。</li><li>当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。</li></ol></li></ul><h4 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h4><ul><li>定义：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递请求，直到有一个对象处理它为止</li><li>人话：客户发出一个请求，会有很多对象可以处理这个请求，并且不同对象的处理逻辑是不一样的，对于客户而言，不关心是谁处理的，只是希望处理流程可以灵活多变，处理请求的对象需要方便修改处理请求的方式或者能被替换，以适应业务功能的变化</li></ul><h5 id="解决了什么问题-1"><a href="#解决了什么问题-1" class="headerlink" title="解决了什么问题"></a>解决了什么问题</h5><ul><li>稳定点： 处理流程，请求按照链条传递，需要链表和请求处理的接口，要可打断（结束继续遍历）</li><li>变化点：处理节点的个数，处理顺序，处理逻辑，其中处理逻辑又分为处理方式和处理条件</li></ul><h5 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h5><ul><li>背景：请假流程，3天内需要主程序批准，30天内需要项目经理批准，30天以上需要老板批准</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 工厂模式加责任链模式</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 请假请求类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LeaveRequest</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> days;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LeaveRequest</span>(<span class="type">int</span> days) : <span class="built_in">days</span>(days) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getDays</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> days; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理请假请求的抽象处理者类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LeaveHandler</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    LeaveHandler* nextHandler;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LeaveHandler</span>() : <span class="built_in">nextHandler</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setNextHandler</span><span class="params">(LeaveHandler* handler)</span> </span>&#123;</span><br><span class="line">        nextHandler = handler;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">handleRequest</span><span class="params">(<span class="type">const</span> LeaveRequest&amp; request)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主程序处理者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Supervisor</span> : <span class="keyword">public</span> LeaveHandler &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleRequest</span><span class="params">(<span class="type">const</span> LeaveRequest&amp; request)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request.<span class="built_in">getDays</span>() &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Main program approved the leave request.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nextHandler != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            nextHandler-&gt;<span class="built_in">handleRequest</span>(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 项目经理处理者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProjectManager</span> : <span class="keyword">public</span> LeaveHandler &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleRequest</span><span class="params">(<span class="type">const</span> LeaveRequest&amp; request)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request.<span class="built_in">getDays</span>() &gt; <span class="number">3</span> &amp;&amp; request.<span class="built_in">getDays</span>() &lt;= <span class="number">30</span>) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Project manager approved the leave request.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nextHandler != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            nextHandler-&gt;<span class="built_in">handleRequest</span>(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 老板处理者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Boss</span> : <span class="keyword">public</span> LeaveHandler &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleRequest</span><span class="params">(<span class="type">const</span> LeaveRequest&amp; request)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request.<span class="built_in">getDays</span>() &gt; <span class="number">30</span>) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Boss approved the leave request.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;No one can approve the leave request.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 责任链工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LeaveHandlerFactory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> LeaveHandler* <span class="title">createLeaveHandlerChain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Supervisor* supervisor = <span class="keyword">new</span> <span class="built_in">Supervisor</span>();</span><br><span class="line">        ProjectManager* projectManager = <span class="keyword">new</span> <span class="built_in">ProjectManager</span>();</span><br><span class="line">        Boss* boss = <span class="keyword">new</span> <span class="built_in">Boss</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置责任链关系</span></span><br><span class="line">        supervisor-&gt;<span class="built_in">setNextHandler</span>(projectManager);</span><br><span class="line">        projectManager-&gt;<span class="built_in">setNextHandler</span>(boss);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> supervisor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建责任链</span></span><br><span class="line">    LeaveHandler* handlerChain = LeaveHandlerFactory::<span class="built_in">createLeaveHandlerChain</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发起请假请求</span></span><br><span class="line">    <span class="function">LeaveRequest <span class="title">request1</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">LeaveRequest <span class="title">request2</span><span class="params">(<span class="number">15</span>)</span></span>;</span><br><span class="line">    <span class="function">LeaveRequest <span class="title">request3</span><span class="params">(<span class="number">40</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理请假请求</span></span><br><span class="line">    handlerChain-&gt;<span class="built_in">handleRequest</span>(request1);</span><br><span class="line">    handlerChain-&gt;<span class="built_in">handleRequest</span>(request2);</span><br><span class="line">    handlerChain-&gt;<span class="built_in">handleRequest</span>(request3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">delete</span> handlerChain;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="代码结构-1"><a href="#代码结构-1" class="headerlink" title="代码结构"></a>代码结构</h5><ul><li>从单个节点出发：<ol><li>抽象一个处理对象接口</li><li>处理对象继承自该接口<ol><li>实现处理请求功能</li><li>实现链条关系</li><li>实现功能传递</li></ol></li></ol></li><li>实现一个构造链表关系的静态接口（工厂）</li></ul><h5 id="代码扩展"><a href="#代码扩展" class="headerlink" title="代码扩展"></a>代码扩展</h5><ul><li>如果我要扩展出一个新的处理逻辑，只需新增一个类，继承自处理请假接口，并在工厂中加入链表</li><li>例如我要加一个董事长</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 董事长处理者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Chairman</span> : <span class="keyword">public</span> LeaveHandler &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleRequest</span><span class="params">(<span class="type">const</span> LeaveRequest&amp; request)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request.<span class="built_in">getDays</span>() &gt; <span class="number">180</span>) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Chairman approved the leave request.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nextHandler != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            nextHandler-&gt;<span class="built_in">handleRequest</span>(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 责任链工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LeaveHandlerFactory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> LeaveHandler* <span class="title">createLeaveHandlerChain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Supervisor* supervisor = <span class="keyword">new</span> <span class="built_in">Supervisor</span>();</span><br><span class="line">        ProjectManager* projectManager = <span class="keyword">new</span> <span class="built_in">ProjectManager</span>();</span><br><span class="line">        Boss* boss = <span class="keyword">new</span> <span class="built_in">Boss</span>();</span><br><span class="line">        Chairman* chairman = <span class="keyword">new</span> <span class="built_in">Chairman</span>(); <span class="comment">// 新增董事长处理者</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置责任链关系</span></span><br><span class="line">        supervisor-&gt;<span class="built_in">setNextHandler</span>(projectManager);</span><br><span class="line">        projectManager-&gt;<span class="built_in">setNextHandler</span>(boss);</span><br><span class="line">        boss-&gt;<span class="built_in">setNextHandler</span>(chairman); <span class="comment">// 将董事长处理者添加到责任链中</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> supervisor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="应用案例-1"><a href="#应用案例-1" class="headerlink" title="应用案例"></a>应用案例</h5><ul><li>nginx 就是用了责任链模式，http请求就是要经过11个阶段一个一个处理</li></ul><h4 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h4><ul><li>定义：指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式。</li><li>结构及实现：通常情况下，扩展一个类的功能会使用继承方式来实现。但继承具有静态特征，耦合度高，并且随着扩展功能的增多，子类会很膨胀。如果使用组合关系来创建一个包装对象（即装饰对象）来包裹真实对象，并在保持真实对象的类结构不变的前提下，为其提供额外的功能，这就是装饰模式的目标。下面来分析其基本结构和实现方法。</li></ul><h5 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h5><ul><li><p>优点：</p><ol><li>装饰器是继承的有力补充，比继承灵活，在不改变原有对象的情况下，动态扩展功能，即插即用</li><li>通过使用不用装饰类及这些装饰类的排列组合，可以实现不同效果；</li><li>装饰器模式完全遵守开闭原则</li></ol></li><li><p>缺点：装饰模式会增加许多子类，过度使用会增加程序得复杂性。</p></li></ul><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 咖啡接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">cost</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基础咖啡类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleCoffee</span> : <span class="keyword">public</span> Coffee &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">cost</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0</span>; <span class="comment">// 基础咖啡价格为1元</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 咖啡装饰器类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CoffeeDecorator</span> : <span class="keyword">public</span> Coffee &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Coffee* coffee;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CoffeeDecorator</span>(Coffee* coffee) : <span class="built_in">coffee</span>(coffee) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">cost</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> coffee-&gt;<span class="built_in">cost</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 牛奶装饰器类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Milk</span> : <span class="keyword">public</span> CoffeeDecorator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Milk</span>(Coffee* coffee) : <span class="built_in">CoffeeDecorator</span>(coffee) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">cost</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> coffee-&gt;<span class="built_in">cost</span>() + <span class="number">0.5</span>; <span class="comment">// 牛奶价格为0.5元</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 糖装饰器类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sugar</span> : <span class="keyword">public</span> CoffeeDecorator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Sugar</span>(Coffee* coffee) : <span class="built_in">CoffeeDecorator</span>(coffee) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">cost</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> coffee-&gt;<span class="built_in">cost</span>() + <span class="number">0.2</span>; <span class="comment">// 糖价格为0.2元</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个简单的咖啡</span></span><br><span class="line">    Coffee* coffee = <span class="keyword">new</span> <span class="built_in">SimpleCoffee</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加牛奶和糖</span></span><br><span class="line">    coffee = <span class="keyword">new</span> <span class="built_in">Milk</span>(coffee);</span><br><span class="line">    coffee = <span class="keyword">new</span> <span class="built_in">Sugar</span>(coffee);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算总价格</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Total cost: &quot;</span> &lt;&lt; coffee-&gt;<span class="built_in">cost</span>() &lt;&lt; <span class="string">&quot;元&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> coffee; <span class="comment">// 释放内存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>往咖啡里加配料 就可以使用装饰者模式，我们可以动态地为咖啡添加各种配料，而不需要修改咖啡类的代码，这使得代码更加可维护和可扩展。</li></ul><h5 id="代码扩展-1"><a href="#代码扩展-1" class="headerlink" title="代码扩展"></a>代码扩展</h5><ul><li>新增一个类继承自coffee装饰器类，实现具体功能</li></ul><h2 id="B树与B-树与二叉搜索树"><a href="#B树与B-树与二叉搜索树" class="headerlink" title="B树与B+树与二叉搜索树"></a>B树与B+树与二叉搜索树</h2><ul><li>什么是二叉搜索树？二叉搜索树是一种使用了二分的思想，将小于根节点的数值放在左子树，大于根节点的放在右子树，这样便于查找数据，但是也有局限性，当根节点为最小值或者最大值的时候会退化成O(N)的复杂度</li><li>什么是B树？是为了解决二叉搜索树效率不稳定的弊端，它已经不属于二叉树，而是一种多叉树，运用的也是二分思想，允许一个节点有多个索引，并且每个索引都有一个指针以及对应的数据，但由于没多一层高度，就会多一次操作，在数据库里要频繁IO，所以效率也不是特别高</li><li>什么是B+树？B+树是B树的改良版，它只允许叶子节点有数据，并且每个叶子节点通过链表连接。其中一个节点的子节点包含根节点所表示的索引，这个索引的是半闭半开的。B+树比B树的层级更少，查找效率更稳定和快。</li></ul><h2 id="语法基础"><a href="#语法基础" class="headerlink" title="语法基础"></a>语法基础</h2><h3 id="野指针-悬空指针-空指针"><a href="#野指针-悬空指针-空指针" class="headerlink" title="野指针 悬空指针 空指针"></a>野指针 悬空指针 空指针</h3><ul><li>野指针是<strong>没有被初始化过</strong>的指针，指向的位置是不可知的（随机的、不正确的、没有明确限制的）</li><li>悬空指针：指针最初指向的内存已经被释放了的一种指针。（例子：返回局部变量的地址）</li><li>空指针：指针的值为0，不指向任何有效数据</li></ul><h3 id="union的相关知识"><a href="#union的相关知识" class="headerlink" title="union的相关知识"></a>union的相关知识</h3><ul><li>union 是一个共用体，union 里面的属性是共享同一个内存，所以当我们sizeof(union),输出的大小是union里面内存最高的</li></ul><h3 id="指针相关知识"><a href="#指针相关知识" class="headerlink" title="指针相关知识"></a>指针相关知识</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> p[][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>&#125;, &#123;<span class="number">5</span>, <span class="number">6</span>&#125;&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *((<span class="type">int</span>*) p + <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">- 输出是<span class="number">4</span> 因为先把p转换为p[<span class="number">0</span>][<span class="number">0</span>],之后三个位置为p[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">- </span><br></pre></td></tr></table></figure><h3 id="C-内存对齐机制"><a href="#C-内存对齐机制" class="headerlink" title="C++ 内存对齐机制"></a>C++ 内存对齐机制</h3><ul><li>C++内存对齐机制：内存对齐的时候 看的是结构体里面最大的字节，如果最大为8 则对齐的时候是8的倍数，如果最大为4，最对齐是4的倍数</li></ul><h3 id="std-string"><a href="#std-string" class="headerlink" title="std::string"></a>std::string</h3><ul><li>std::string 在初始化时给多少就会有多少字节，在后续扩展的时候，是以原来的两倍扩展，std::string 内部是用char* 实现的，所以当sizeof它的时候是4</li></ul><h3 id="const-int-ptr-int-const-ptr的区别是什么？"><a href="#const-int-ptr-int-const-ptr的区别是什么？" class="headerlink" title="const int  ptr, int  const ptr的区别是什么？"></a>const int <em> ptr, int </em> const ptr的区别是什么？</h3><ul><li>const int <em>ptr 表示的是 ptr所指向的内容是常量，是不可变的，int </em>const ptr； 则表示其ptr指针的指向是不能改变的</li></ul><h3 id="什么是std-ref？"><a href="#什么是std-ref？" class="headerlink" title="什么是std::ref？"></a>什么是std::ref？</h3><ul><li><p>std::ref的作用是将一个值包装为reference_Wrapper，这个对象在bind 和 thread时会被识别为引用，这样就解决了bind与thread 无法传递引用的问题（因为原本会被拷贝为右值）</p></li><li><p>大致可以这么理解：在底层 ref函数会把 一个值的地址和类型封装成reference_wrapper，当我们调用的时候触发了仿函数()，取得了该地址下的值</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> _CONSTEXPR20 <span class="keyword">operator</span> _Ty&amp;() <span class="type">const</span> <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> *_Ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">_NODISCARD _CONSTEXPR20 _Ty&amp; <span class="title">get</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *_Ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="std-ref-和不同引用的区别"><a href="#std-ref-和不同引用的区别" class="headerlink" title="std::ref 和不同引用的区别"></a>std::ref 和不同引用的区别</h4><ul><li>std::ref只是尝试模拟引用传递，并不能真正变成引用，在非模板情况下，std::ref根本没法实现引用传递，只有模板自动推导类型或类型隐式转换时，std::ref能用包装类型reference_wrapper来代替原本会被识别的值类型，而reference_wrapper能隐式转换为被引用的值的引用类型。</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>我来给总结下，首先我们讲解了std::ref的一些用法，然后我们讲解std::ref是通过std::reference_wrapper实现，然后我们借助了cppreference上的实现来给大家剖析了他本质就是存放了对象的地址(类似指针的用法😁)，还讲解了noexcept等语法，最后我们讲解了下std::bind为什么要使用到reference_wrapper。</li><li>std::bind使用的是参数的拷贝而不是引用，当可调用对象期待入参为引用时，必须显示利用std::ref来进行引用绑定。</li><li>多线程std::thread的可调用对象期望入参为引用时，也必须显式通过std::ref来绑定引用进行传参。</li></ul><h3 id="decltype-std-declval-std-decay-t-分别是什么？"><a href="#decltype-std-declval-std-decay-t-分别是什么？" class="headerlink" title="decltype, std::declval, std::decay_t 分别是什么？"></a>decltype, std::declval, std::decay_t 分别是什么？</h3><h4 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h4><ul><li><strong>decltype</strong>是一个关键字，用于从一个表达式中推导出其类型。它通常与表达式一起使用，以便在编译时确定表达式的类型</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">decltype</span>(x) y = <span class="number">10</span>; 推到为<span class="type">int</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="std-declval"><a href="#std-declval" class="headerlink" title="std::declval"></a>std::declval</h4><ul><li><strong>std::declval</strong>是一个函数模板，它能返回类型 T 的右值引用，其实是一个伪实例，不会产生任何临时对象，也不会因为表达式很复杂而发生真实的计算。因为不会真正的进行构造，所以可以实现在元编程时伪构造一个没有定义默认构造函数类，还可以避开纯虚基类不能实例化的问题，<strong>说白了它就是假装创建个对象(实际没创造)用于推导类型。</strong></li></ul><h4 id="std-decay-t"><a href="#std-decay-t" class="headerlink" title="std::decay_t"></a>std::decay_t</h4><ul><li><p><strong>std::decay_t</strong>用于获取一个类型的衰变类型（decay type）。衰变类型是指将一个类型转换为最基本形式的类型，通常是将引用和顶层 const 限定符去除，并将数组类型转换为指针类型。<strong>说白了就是一个类型转换为最基本形式的类型</strong></p></li><li><p>如果类型是数组类型，则将其转换为指向数组首元素的指针类型。</p></li><li>如果类型是函数类型，则将其转换为指向函数的指针类型。</li><li>如果类型是引用类型，则将其转换为对应的非引用类型。</li><li>如果类型是顶层 const 限定符类型，则将其转换为对应的非 const 类型</li></ul><h3 id="const-与-constexpr"><a href="#const-与-constexpr" class="headerlink" title="const 与 constexpr"></a>const 与 constexpr</h3><ul><li><p>constexpr 关键字的功能是使指定的常量表达式获得在程序编译阶段计算出结果的能力，而不必等到程序运行阶段。C++ 11 标准中，constexpr 可用于修饰普通变量、函数（包括模板函数）以及类的构造函数。<br>注意，获得在编译阶段计算出结果的能力，并不代表 constexpr 修饰的表达式一定会在程序编译阶段被执行，具体的计算时机还是编译器说了算。</p></li><li><p>const与constexpr，这两个都是编译期就能知道确切值，在C++11后const建议用来表示只读，constexpr来表示常量，constexpr修饰的是常量表达式，它可以修饰模板函数，可以修饰函数(除了typedef，using static_assert断言)，只有一个返回值且必须是常量表达式，函数必须先声明，可以修饰构造函数</p></li></ul><h3 id="noexcept"><a href="#noexcept" class="headerlink" title="noexcept"></a>noexcept</h3><ul><li>noexcept 是一个说明符同时也是一个操作符</li><li>noexcept 作为说明符放在函数名后面，表明次函数不会抛出异常，等同于noexcept(true)</li><li>noexcept 作为操作符时，可以用来判断一个函数是否会抛出异常，用法为 noexcept(funcName)</li><li>当使用 noexcept 标记函数时，我们需要自己保证函数不会抛出异常，这样可以生成更高效的代码，他会减少编译器对于抛出异常后对象的默认虚构</li><li>如果标记了 noexcept函数还是抛出了异常，那么程序会直接调用 std::abort() 终止程序，try…catch都没用</li><li>C++17后noexcept成为了一种类型的一部分</li></ul><p>使用 noecept之前的汇编代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">entrance</span>():</span><br><span class="line">        push    rbp</span><br><span class="line">        mov     rbp, rsp</span><br><span class="line">        push    rbx</span><br><span class="line">        sub     rsp, <span class="number">24</span></span><br><span class="line">        <span class="function">call    <span class="title">inner</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        lea     rax, [rbp-17]</span></span><br><span class="line"><span class="function">        mov     rdi, rax</span></span><br><span class="line"><span class="function">        call    Obj::~<span class="title">Obj</span><span class="params">()</span> [complete object destructor]</span></span><br><span class="line"><span class="function">        jmp     .L4</span></span><br><span class="line"><span class="function">        mov     rbx, rax</span></span><br><span class="line"><span class="function">        lea     rax, [rbp-17]</span></span><br><span class="line"><span class="function">        mov     rdi, rax</span></span><br><span class="line"><span class="function">        call    Obj::~<span class="title">Obj</span><span class="params">()</span> [complete object destructor]</span></span><br><span class="line"><span class="function">        mov     rax, rbx</span></span><br><span class="line"><span class="function">        mov     rdi, rax</span></span><br><span class="line"><span class="function">        call    _Unwind_Resume</span></span><br><span class="line"><span class="function">.L4:</span></span><br><span class="line"><span class="function">        mov     rbx, QWORD PTR [rbp<span class="number">-8</span>]</span></span><br><span class="line"><span class="function">        leave</span></span><br><span class="line"><span class="function">        ret</span></span><br></pre></td></tr></table></figure><p>使用 noecept之后的汇编代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">entrance</span>():</span><br><span class="line">        push    rbp</span><br><span class="line">        mov     rbp, rsp</span><br><span class="line">        sub     rsp, <span class="number">16</span></span><br><span class="line">        <span class="function">call    <span class="title">inner</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        lea     rax, [rbp-1]</span></span><br><span class="line"><span class="function">        mov     rdi, rax</span></span><br><span class="line"><span class="function">        call    Obj::~<span class="title">Obj</span><span class="params">()</span> [complete object destructor]</span></span><br><span class="line"><span class="function">        leave</span></span><br><span class="line"><span class="function">        ret</span></span><br></pre></td></tr></table></figure><ul><li>总而言之就是优化了个析构函数</li></ul><h3 id="用户自定义字面量"><a href="#用户自定义字面量" class="headerlink" title="用户自定义字面量"></a>用户自定义字面量</h3><ul><li>其中用户自定义后缀尽可能使用“_”下划线作为开头，否则很可能会与C++原生的表示方式冲突，如2L其实是long long 2</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="keyword">operator</span> <span class="string">&quot;&quot;</span> _S(<span class="type">double</span> num)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (num + <span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="keyword">auto</span> res = <span class="number">2.6</span>_S;    <span class="comment">//res = int(2.6 + 0.5) = 3</span></span><br></pre></td></tr></table></figure><ul><li>然而用户定义字面量也不是随意定义的，有如下规则限制：</li></ul><p>1、字面量只可以使用四种基本类型：整型、浮点型、字符、字符串<br>2、若字面量为整型，参数只能为unsigned long long、const char<em>，且当unsigned long long无法容纳该字面量时，会将其转换为字符串，以’\0’结束，并调用const char </em>参数版本的字面量函数<br>3、若字面量为浮点型，参数只能为unsigned double 和const char <em>，当unsigned double过长时，也会调用const char </em>版本<br>4、若字面量为字符型，参数只能为一个char<br>5、若字面量为字符串，参数只能为const char* (注意是与，传入两个参数)size_t，即长度已知的字符串作为参数<br>6、operator “” [用户定义字面量后缀]，注意中间必须有空格</p><h3 id="mutable-volatile"><a href="#mutable-volatile" class="headerlink" title="mutable volatile"></a>mutable volatile</h3><ul><li>mutable 就是使得被mutable修饰的const成员可以被修改(const_cast也可以实现去const)</li><li>volatile 表示<strong>直接存取原始内存地址</strong>，就是编译器优化的时候为了提高效率，会把一个变量读取到一个寄存器中，如果在本线程里值没有发生改变，就会直接从寄存器里取出上一次的值，如果在别的线程里被改变，编译器是识别不出来的，所以就会使用一个与实际不一样的值，这是很致命的。</li></ul><h3 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h3><ul><li><strong>explicit</strong> 是禁用隐式转换</li></ul><h3 id="std-invoke"><a href="#std-invoke" class="headerlink" title="std::invoke"></a>std::invoke</h3><ul><li>std::invoke 是 C++17标准库中引入的一个函数模板，它的引入就是为了解决这个问题，它提供了一种统一的调用语法，无论是调用普通函数、函数指针、类成员函数指针、仿函数、std::function、类成员还是lambda表达式，都可以使用相同的方式进行调用。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">member_function</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Member function called with argument: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">free_function</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Free function called with argument: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Foo foo;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用成员函数</span></span><br><span class="line">    std::<span class="built_in">invoke</span>(&amp;Foo::member_function, foo, <span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用自由函数</span></span><br><span class="line">    std::<span class="built_in">invoke</span>(free_function, <span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>invoke 只是调用可调用函数 而不是封装</li></ul><h4 id="invoke-和function-的区别"><a href="#invoke-和function-的区别" class="headerlink" title="invoke 和function 的区别"></a>invoke 和function 的区别</h4><p>std::invoke 与 std::function 是 C++ 标准库中不同的概念，它们有不同的作用和用途：</p><ul><li><p>std::invoke：</p><p>是一个模板函数，用于调用可调用对象（函数指针、成员函数指针、仿函数等）。<br>它是一个通用的工具函数，用于在运行时动态调用不同类型的可调用对象。<br>不会持有可调用对象，只是调用它并返回结果。<br>在使用时需要指定要调用的可调用对象的类型，例如成员函数指针需要使用 &amp;ClassName::member_function 的形式。</p></li><li><p>std::function：</p><p>是一个模板类，用于封装可调用对象，使其表现得像一个函数。<br>它可以持有任何可调用对象，包括函数指针、成员函数指针、函数对象、Lambda 表达式等。<br>提供了一种统一的接口来处理不同类型的可调用对象。<br>可以在运行时动态改变持有的可调用对象。<br>总的来说，std::invoke 用于调用可调用对象，而 std::function 用于封装和管理可调用对象。它们的主要区别在于功能和使用方式。</p></li></ul><h3 id="stl容器里emplace-back和push-back的区别，emplace-back是不是能完美替代push-back"><a href="#stl容器里emplace-back和push-back的区别，emplace-back是不是能完美替代push-back" class="headerlink" title="stl容器里emplace_back和push_back的区别，emplace_back是不是能完美替代push_back"></a>stl容器里emplace_back和push_back的区别，emplace_back是不是能完美替代push_back</h3><ul><li>当加入一个已经存在的值的时候两个是一样的</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddItem</span><span class="params">(<span class="type">const</span> Item&amp; item)</span></span>&#123;</span><br><span class="line">vector&lt;Item&gt; vec1;</span><br><span class="line">vec<span class="number">1.</span><span class="built_in">push_back</span>(item); <span class="comment">//Item(const Item &amp;)</span></span><br><span class="line"></span><br><span class="line">vector&lt;Item&gt; vec2;</span><br><span class="line">vec<span class="number">2.</span><span class="built_in">emplace_back</span>(item);<span class="comment">//Item(const Item &amp;)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>当移动一个已经存在的对象的时候也是一样的</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Item <span class="title">item1</span><span class="params">(<span class="number">1</span>, <span class="string">&quot;car1&quot;</span>)</span></span>;</span><br><span class="line">vector&lt;Item&gt; vec1, vec2;</span><br><span class="line">vec<span class="number">1.</span><span class="built_in">push_back</span>(std::<span class="built_in">move</span>(item1));<span class="comment">// Item(Item &amp;&amp;)</span></span><br><span class="line"></span><br><span class="line"><span class="function">Item <span class="title">item2</span><span class="params">(<span class="number">2</span>, <span class="string">&quot;car2&quot;</span>)</span></span>;</span><br><span class="line">vec<span class="number">2.</span><span class="built_in">emplace_back</span>(std::<span class="built_in">move</span>(item2));<span class="comment">// Item(Item &amp;&amp;)</span></span><br></pre></td></tr></table></figure><ul><li>当创建并加入的时候也是一样的</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Item <span class="title">item1</span><span class="params">(<span class="number">1</span>, <span class="string">&quot;car1&quot;</span>)</span></span>;          <span class="comment">// Item(int , string)</span></span><br><span class="line">vector&lt;Item&gt; vec1, vec2;        <span class="comment">// Item(Item &amp;&amp;)</span></span><br><span class="line">vec<span class="number">1.</span><span class="built_in">push_back</span>(<span class="built_in">Item</span>(<span class="number">1</span>, <span class="string">&quot;car1&quot;</span>));<span class="comment">// ~Item()</span></span><br><span class="line"></span><br><span class="line">                                    <span class="comment">// Item(int , string)</span></span><br><span class="line"><span class="function">Item <span class="title">item2</span><span class="params">(<span class="number">2</span>, <span class="string">&quot;car2&quot;</span>)</span></span>;              <span class="comment">// Item(Item &amp;&amp;)</span></span><br><span class="line">vec<span class="number">2.</span><span class="built_in">emplace_back</span>(<span class="built_in">Item</span>(<span class="number">1</span>, <span class="string">&quot;car1&quot;</span>)); <span class="comment">// ~Item()</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>直接构造一个匿名对象的时候 emplace_back效率更高，因为它是直接在vector容器的尾部执行构造函数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">                            <span class="comment">// Item(int , string)</span></span><br><span class="line">vector&lt;Item&gt; vec1, vec2;    <span class="comment">// Item(Item &amp;&amp;)</span></span><br><span class="line">vec<span class="number">1.</span><span class="built_in">push_back</span>(&#123;<span class="number">1</span>, <span class="string">&quot;car1&quot;</span>&#125;);<span class="comment">// ~Item()</span></span><br><span class="line"></span><br><span class="line">vec<span class="number">2.</span><span class="built_in">emplace_back</span>(<span class="number">1</span>, <span class="string">&quot;car1&quot;</span>);<span class="comment">// Item(int, string)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="../assets/面试笔记/image-30.png" alt="示例图片" style="zoom:100%;" /></p><ul><li>这样笔误可能会让你找不出错误</li></ul><h3 id="如果使用std-move-t-来构造一个对象，但是该类没有显式提供移动构造函数，那么它是使用的式默认移动构造函数已经定义的拷贝构造"><a href="#如果使用std-move-t-来构造一个对象，但是该类没有显式提供移动构造函数，那么它是使用的式默认移动构造函数已经定义的拷贝构造" class="headerlink" title="如果使用std::move(t)来构造一个对象，但是该类没有显式提供移动构造函数，那么它是使用的式默认移动构造函数已经定义的拷贝构造"></a>如果使用std::move(t)来构造一个对象，但是该类没有显式提供移动构造函数，那么它是使用的式默认移动构造函数已经定义的拷贝构造</h3><ul><li>他会调用已经定义的拷贝构造，而不是默认的移动构造</li></ul><h3 id="在模板中使用-typedef的时候的注意事项"><a href="#在模板中使用-typedef的时候的注意事项" class="headerlink" title="在模板中使用 typedef的时候的注意事项"></a>在模板中使用 typedef的时候的注意事项</h3><ul><li>typedef typename：</li></ul><p>在模板中，typename 关键字用于指示其后的标识符是一个类型名字（type name）而不是变量名或者其他东西。这在模板的实例化过程中是非常重要的，因为编译器需要知道该标识符代表的是类型还是变量等。<br>通常情况下，当模板中使用了<strong>依赖于模板参数</strong>的类型名字时，需要在前面加上 typename 关键字，以告诉编译器这是一个类型。</p><ul><li>typedef：</li></ul><p>typedef 关键字用于给一个类型定义一个别名，可以为已有的类型或者复杂的类型表达式定义一个简单的别名。<br>在模板中，typedef 用于给类型起一个别名，可以方便后续使用，但没有 typename 关键字那样特别用于模板的语法。<br>综上所述，typedef typename 用于模板中，指示其后的标识符是一个类型名字；而 typedef 则用于给类型定义别名，无论在模板中还是非模板中都可以使用。</p><ul><li><p>什么叫做<strong>依赖于模板参数呢？</strong></p></li><li><p><strong>就是你定义的时候用到了模板嵌套类或者是你上一次typedef的的别名，如下</strong></p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;Key, Value&gt; bucket_value;</span><br><span class="line"><span class="keyword">typedef</span> std::list&lt;bucket_value&gt; bucket_data;</span><br><span class="line"><span class="comment">// 在模板中指定类型的时候要加typename</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> bucket_data::iterator bucket_iterator;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>typedef typename bucket_data::iterator bucket_iterator;：在这里，bucket_iterator 是由 bucket_data 类型的迭代器类型决定的，而 bucket_data 是依赖于模板参数的，因此需要加上 typename。</p></li><li><p>又如下：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value, <span class="keyword">typename</span> Hash = std::hash&lt;Key&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> threadsafe_lockup_table &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">class</span> bucket_type &#123;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">typename</span> bucket_type::bucket_iterator it = buckets[i]-&gt;data.<span class="built_in">begin</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>这用到了嵌套类 所以得用typename</li></ul>]]></content>
    
    
    <summary type="html">本文介绍了C++面试笔记的相关知识</summary>
    
    
    
    <category term="C++" scheme="https://pigcanstudy.github.io/categories/C/"/>
    
    
    <category term="C++" scheme="https://pigcanstudy.github.io/tags/C/"/>
    
    <category term="面试笔记" scheme="https://pigcanstudy.github.io/tags/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>网络编程教程</title>
    <link href="https://pigcanstudy.github.io/posts/95787e92.html"/>
    <id>https://pigcanstudy.github.io/posts/95787e92.html</id>
    <published>2024-07-16T15:48:00.000Z</published>
    <updated>2024-07-16T15:49:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li><a href="#目录">目录</a><ul><li><a href="#第一部分">第一部分</a><ul><li><a href="#静态库与动态库的建立">静态库与动态库的建立</a><ul><li><a href="#静态库的建立和使用">静态库的建立和使用</a></li><li><a href="#动态库的建立和使用">动态库的建立和使用</a></li></ul></li><li><a href="#makefile">makefile</a><ul><li><a href="#为什么要引入make这个工具">为什么要引入make这个工具</a></li><li><a href="#makefile的使用与细节">makefile的使用与细节</a></li></ul></li><li><a href="#main函数的参数">main函数的参数</a><ul><li><a href="#argc">argc</a></li><li><a href="#argv">argv</a></li><li><a href="#envp">envp</a></li></ul></li><li><a href="#gdb调试程序">gdb调试程序</a><ul><li><a href="#gdb的常用命令">gdb的常用命令</a></li><li><a href="#用gdb调试core文件">用gdb调试core文件</a></li><li><a href="#用gdb调试一个正在运行的程序">用gdb调试一个正在运行的程序</a></li></ul></li><li><a href="#linux的时间操作">linux的时间操作</a><ul><li><a href="#time_t-别名">time_t 别名</a></li><li><a href="#time库函数">time()库函数</a></li><li><a href="#tm结构体timeval">tm结构体(timeval)</a></li><li><a href="#localtime库函数">localtime()库函数</a></li><li><a href="#mktime函数">mktime()函数</a></li><li><a href="#gettimeofday函数">gettimeofday()函数</a></li><li><a href="#程序的睡眠">程序的睡眠</a></li></ul></li><li><a href="#linux-获取目录操作">linux 获取目录操作</a><ul><li><a href="#几个简单的目录操作函数">几个简单的目录操作函数</a><ul><li><a href="#获取当前工作目录">获取当前工作目录</a></li><li><a href="#切换工作目录">切换工作目录</a></li><li><a href="#创建目录">创建目录</a></li><li><a href="#删除目录">删除目录</a></li></ul></li><li><a href="#获取目录中文件的列表">获取目录中文件的列表</a><ul><li><a href="#包含头文件">包含头文件</a></li><li><a href="#相关的库函数">相关的库函数</a></li></ul></li></ul></li><li><a href="#linux-的系统错误">linux 的系统错误</a><ul><li><a href="#sterror库函数">sterror()库函数</a></li><li><a href="#perror库函数">perror()库函数</a></li><li><a href="#注意事项">注意事项</a></li></ul></li><li><a href="#目录和文件的更多操作">目录和文件的更多操作</a><ul><li><a href="#access库函数">access()库函数</a></li><li><a href="#stat结构体">stat结构体</a></li><li><a href="#stat库函数">stat()库函数</a></li><li><a href="#utime库函数">utime()库函数</a></li><li><a href="#rename库函数">rename()库函数</a></li><li><a href="#remove库函数">remove()库函数</a></li></ul></li><li><a href="#linux的信号">Linux的信号</a><ul><li><a href="#信号的基本概念">信号的基本概念</a><ul><li><a href="#kill-与-killall-的区别">kill 与 killall 的区别</a></li></ul></li><li><a href="#信号的类型">信号的类型</a></li><li><a href="#信号的处理">信号的处理</a></li><li><a href="#信号有什么用">信号有什么用</a></li><li><a href="#发送信号">发送信号</a></li></ul></li><li><a href="#进程终止">进程终止</a><ul><li><a href="#进程终止方式">进程终止方式</a></li><li><a href="#进程终止状态">进程终止状态</a></li><li><a href="#资源释放的问题">资源释放的问题</a></li><li><a href="#进程的终止函数">进程的终止函数</a></li></ul></li><li><a href="#调用可执行程序">调用可执行程序</a><ul><li><a href="#system库函数">system()库函数</a><ul><li><a href="#功能">功能</a></li><li><a href="#返回值">返回值</a></li></ul></li><li><a href="#exec函数族">exec函数族</a><ul><li><a href="#execl函数">execl()函数</a></li><li><a href="#execv函数">execv()函数</a></li></ul></li></ul></li><li><a href="#创建进程">创建进程</a><ul><li><a href="#linux的012号进程">Linux的0，1，2号进程</a></li><li><a href="#进程标识">进程标识</a></li><li><a href="#fork函数">fork()函数</a></li><li><a href="#fork的两种用法">fork()的两种用法</a></li><li><a href="#共享文件">共享文件</a></li><li><a href="#vfork">vfork()</a></li></ul></li><li><a href="#僵尸进程">僵尸进程</a><ul><li><a href="#僵尸进程的产生">僵尸进程的产生</a></li><li><a href="#僵尸进程地避免">僵尸进程地避免</a></li></ul></li><li><a href="#多进程与信号">多进程与信号</a></li><li><a href="#共享内存">共享内存</a><ul><li><a href="#shmget函数">shmget()函数</a></li><li><a href="#shmat函数">shmat()函数</a></li><li><a href="#shmdt函数">shmdt()函数</a></li><li><a href="#shmctl函数">shmctl()函数</a></li></ul></li><li><a href="#循环队列">循环队列</a><ul><li><a href="#原理">原理</a></li></ul></li><li><a href="#信号量">信号量</a></li><li><a href="#pthread-线程库">pthread 线程库</a></li></ul></li><li><a href="#第二部分">第二部分</a><ul><li><a href="#第一个网络通信程序户端">第一个网络通信程序户端</a></li><li><a href="#基于linux的文件操作">基于linux的文件操作</a><ul><li><a href="#文件描述符的分配规则">文件描述符的分配规则</a></li></ul></li><li><a href="#socket函数详解">socket函数详解</a><ul><li><a href="#创建socket">创建socket</a><ul><li><a href="#函数的声明">函数的声明</a></li><li><a href="#type-表示数据的传输类型">type 表示数据的传输类型</a></li><li><a href="#protocol协议">protocol协议</a></li><li><a href="#两种创建方式">两种创建方式</a></li></ul></li><li><a href="#主机字节序和网络字节序">主机字节序和网络字节序</a><ul><li><a href="#大端序和小端序">大端序和小端序</a></li><li><a href="#网络字节序">网络字节序</a></li><li><a href="#ip地址和通讯端口">IP地址和通讯端口</a></li><li><a href="#如何处理大小端序">如何处理大小端序</a></li></ul></li><li><a href="#万恶的结构体">万恶的结构体</a><ul><li><a href="#sockaddr结构体">sockaddr结构体</a></li><li><a href="#sockaddr_in结构体">sockaddr_in结构体</a><ul><li><a href="#细说此结构体内部的细节">细说此结构体内部的细节</a></li><li><a href="#使用gethostbyname函数">使用gethostbyname()函数</a></li><li><a href="#字符串ip与大端序ip的转换">字符串IP与大端序IP的转换</a></li></ul></li></ul></li></ul></li><li><a href="#未封装的客户端代码">未封装的客户端代码</a></li><li><a href="#未封装的服务端代码">未封装的服务端代码</a></li><li><a href="#封装的客户端代码">封装的客户端代码</a></li><li><a href="#封装socket的服务端">封装socket的服务端</a></li><li><a href="#多进程的服务端代码">多进程的服务端代码</a><ul><li><a href="#void--是什么">void * 是什么？</a></li></ul></li><li><a href="#文件传输">文件传输</a><ul><li><a href="#服务端代码">服务端代码</a></li><li><a href="#客户端代码">客户端代码</a></li></ul></li><li><a href="#三次握手四次挥手">三次握手，四次挥手</a><ul><li><a href="#三次握手">三次握手</a><ul><li><a href="#细节">细节</a></li></ul></li><li><a href="#四次挥手">四次挥手</a><ul><li><a href="#细节-1">细节</a></li><li><a href="#解决上述问题办法">解决上述问题办法</a></li></ul></li></ul></li><li><a href="#tcp缓存">TCP缓存</a><ul><li><a href="#查看缓冲区的大小">查看缓冲区的大小</a></li><li><a href="#nagle-算法">Nagle 算法</a></li></ul></li><li><a href="#io多路复用--select模型">IO多路复用 -select模型</a><ul><li><a href="#什么是io多路复用">什么是IO多路复用</a></li><li><a href="#网络通讯-读事件">网络通讯-读事件</a></li><li><a href="#网络通讯-写事件">网络通讯-写事件</a></li><li><a href="#select-的原理">select 的原理</a></li><li><a href="#select-函数的使用">select 函数的使用</a><ul><li><a href="#select函数的声明">select函数的声明</a><ul><li><a href="#fd_set的本质如图所示">fd_set的本质如图所示</a></li><li><a href="#selec服务吨端代码">selec服务吨端代码</a></li></ul></li></ul></li><li><a href="#select模型的细节">select模型的细节</a><ul><li><a href="#select模型-写事件">select模型-写事件</a></li><li><a href="#select-模型-水平触发">select 模型 水平触发</a></li><li><a href="#select-模型性能">select 模型性能</a></li><li><a href="#存在的问题">存在的问题</a></li></ul></li></ul></li><li><a href="#poll模型">POLL模型</a><ul><li><a href="#pollfd-结构体">pollfd 结构体</a></li><li><a href="#poll可要求socket数">poll可要求socket数</a></li><li><a href="#pollfd结构体数组初始化的细节">pollfd结构体数组初始化的细节</a></li><li><a href="#poll的事件常用">poll的事件常用</a><ul><li><a href="#读事件pollin-写事件pollout">读事件：POLLIN， 写事件：POLLOUT</a></li></ul></li><li><a href="#pollfd结构体的使用方法有两种">pollfd结构体的使用方法有两种</a><ul><li><a href="#填在与请求的socket符号编码一样的位置">填在与请求的socket符号编码一样的位置</a></li><li><a href="#填在结构体数组最前面">填在结构体数组最前面</a></li><li><a href="#两者的区别">两者的区别</a></li></ul></li><li><a href="#poll模型存在的问题">poll模型存在的问题</a></li><li><a href="#poll相对于select的区别">poll相对于select的区别</a></li></ul></li><li><a href="#epoll模型">epoll模型</a><ul><li><a href="#epoll_create函数">epoll_create()函数</a></li><li><a href="#epoll_ctl函数">epoll_ctl()函数</a></li><li><a href="#epoll_wait函数">epoll_wait函数</a></li><li><a href="#epoll的相关结构体">epoll的相关结构体</a><ul><li><a href="#epoll_event">epoll_event</a></li><li><a href="#epoll服务端代码">epoll服务端代码</a></li></ul></li></ul></li><li><a href="#阻塞io-与-非阻塞io">阻塞I/O 与 非阻塞I/O</a><ul><li><a href="#阻塞与非阻塞io的应用场景">阻塞与非阻塞IO的应用场景</a></li><li><a href="#非阻塞io-connect函数">非阻塞IO-connect()函数</a></li><li><a href="#非阻塞io-accept函数">非阻塞IO accept()函数</a></li><li><a href="#非阻塞io-recv">非阻塞IO recv</a></li><li><a href="#非阻塞io-send">非阻塞IO send()</a></li></ul></li><li><a href="#水平触发与边缘触发">水平触发与边缘触发</a><ul><li><a href="#水平触发含义">水平触发含义</a></li><li><a href="#边缘触发的含义">边缘触发的含义</a></li></ul></li></ul></li></ul></li></ul><h2 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h2><h3 id="静态库与动态库的建立"><a href="#静态库与动态库的建立" class="headerlink" title="静态库与动态库的建立"></a>静态库与动态库的建立</h3><h4 id="静态库的建立和使用"><a href="#静态库的建立和使用" class="headerlink" title="静态库的建立和使用"></a>静态库的建立和使用</h4><ul><li><p><strong>建立</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -c -o libpublic.a <span class="keyword">public</span>.cpp</span><br></pre></td></tr></table></figure></li></ul><p>其中libpublic.a表示静态库，public.cpp表示需要建立静态库的代码</p><ul><li><p><strong>使用</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -o demo01 demo<span class="number">01.</span>cpp -L/home/pigcanstudy/tools -lpublic</span><br></pre></td></tr></table></figure></li></ul><p>其中-L表示静态库所在目录，-l表示静态库的库名<br><img src="../assets/网络编程/image.png" alt="示例图片" style="zoom:100%;" /></p><h4 id="动态库的建立和使用"><a href="#动态库的建立和使用" class="headerlink" title="动态库的建立和使用"></a>动态库的建立和使用</h4><ul><li><p><strong>建立</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -fPIC -shared -o lib库名.so 源代码文件</span><br><span class="line">g++ -fPIC -shared -o libpublic.so <span class="keyword">public</span>.cpp</span><br></pre></td></tr></table></figure></li><li><p><strong>使用</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ 选项 源代码文件 -l库名 -L库文件所在目录名</span><br><span class="line">g++ -o demo01 demo<span class="number">01.</span>cpp -L/home/pigcanstudy/tools -lpublic</span><br></pre></td></tr></table></figure><p><strong>需要注意的是如果使用了动态库需要提前设置LD_LIBRARY_PATH</strong><br><img src="../assets/网络编程/image-1.png" alt="示例图片" style="zoom:50%;" /> 用来查看路线有啥<br><img src="../assets/网络编程/image-2.png" alt="示例图片" style="zoom:50%;" /> 用来设置路径，后面加的是动态库的地址</p></li></ul><h3 id="makefile"><a href="#makefile" class="headerlink" title="makefile"></a>makefile</h3><h4 id="为什么要引入make这个工具"><a href="#为什么要引入make这个工具" class="headerlink" title="为什么要引入make这个工具"></a>为什么要引入make这个工具</h4><ul><li>静态库与动态库在建立的时候很麻烦，如果有很多项目文件选哟建立库，就可以使用make工具，使用.sh脚本工具也能实现，即建立一个.sh的脚本，里面加入你要建立库的语句，如图所示：<br><img src="../assets/网络编程/image-3.png" alt="示例图片" style="zoom:50%;" /><br>可以用 sh命令来执行</li></ul><h4 id="makefile的使用与细节"><a href="#makefile的使用与细节" class="headerlink" title="makefile的使用与细节"></a>makefile的使用与细节</h4><ul><li><p>使用makefile的时候需要注意的事项<br>注意在所有g++ rm cp 前面得需要TAB键分割，然后再换行使用\的时候\后面不要乱加空格<br>否则会报如下错误：<br><img src="../assets/网络编程/image-4.png" alt="示例图片" style="zoom:50%;" /><br> <strong><em>makefile的基本语法 如下图所示：</em></strong><br><img src="../assets/网络编程/image-5.png" alt="示例图片" style="zoom:50%;" /></p><ol><li>执行make 会生成两个库文件</li><li>执行make clean 会执行删除两个库文件<br>执行make 时出现如下所示：<br><img src="image-6.png" alt="表示"><br>表示不需要重新编译all中的库文件</li><li>make采用的是<strong>增量编译</strong>（也就是只需要重新编译需要重新编译的文件，原本编译好的文件无需继续编译，这就是其与脚本比较更好的原因）</li><li><strong><em>注意</em></strong> 当你改变了hpp或者cpp的时候，一定要重新make以下库文件，否则会很痛苦，会报错 因为用了之前的为改变的hpp与cpp</li><li><p>以上makefile的基本语法这么写建立在main文件长成这样的时候：<br><img src="../assets/网络编程/image-7.png" alt="示例图片" style="zoom:50%;" /><br>这种头文件定义方式是不符合规范的，一旦头文件的路径发生改变，所有源代码都得修改，所以得换一种实现方式：</p><ol><li>首先改成如下所示：<br><img src="../assets/网络编程/image-8.png" alt="示例图片" style="zoom:50%;" /></li><li><p>然后需要执行如下指令：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -o demo01 demo<span class="number">01.</span>cpp -L/home/pigcanstudy/test1/tools -lpublic -L/home/pigcanstudy/test1/api -lmyapi -I/home/pigcanstudy/test1/tools -I/home/pigcanstudy/test1/api/test1/api -lmyapi -I/home/pigcanstudy/test1/tools -I/home/pigcanstudy/test1/api</span><br></pre></td></tr></table></figure></li><li><p>执行文件<br><img src="../assets/网络编程/image-9.png" alt="示例图片" style="zoom:50%;" /></p></li><li><strong><em>为了不让每次执行都需要打那么的编译指令。可以使用makefile来代替之：如图所示：</em></strong><br><img src="../assets/网络编程/image-10.png" alt="示例图片" style="zoom:50%;" /></li><li>之后执行make就行了加./demo就能执行了</li><li><strong><em>项目很大，有很多需要编译的东西怎么办？</em></strong><br><strong>答案是</strong>使用变量来表示 如图<br><img src="../assets/网络编程/image-11.png" alt="示例图片" style="zoom:50%;" /></li></ol></li></ol></li></ul><h3 id="main函数的参数"><a href="#main函数的参数" class="headerlink" title="main函数的参数"></a>main函数的参数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[], <span class="type">char</span> *envp[])</span></span></span><br></pre></td></tr></table></figure><h4 id="argc"><a href="#argc" class="headerlink" title="argc"></a>argc</h4><p>存放了程序参数的个数，包括程序本身</p><h4 id="argv"><a href="#argv" class="headerlink" title="argv"></a>argv</h4><p>字符串数组,存放了每个参数的值，包括程序本身</p><h4 id="envp"><a href="#envp" class="headerlink" title="envp"></a>envp</h4><p>字符串数组，存放了环境变量，数组最后一个元素为空<br>这参数常用于判断一个人是否能进入程序（如表白程序）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//int setenv(const char* name, const char* value, int overwrite)&#123;</span></span><br><span class="line">        <span class="comment">// name 环境变量名</span></span><br><span class="line">        <span class="comment">// value 环境变量值</span></span><br><span class="line">        <span class="comment">//overwrite 0 如果环境不存在增加新的环境变量，存在不替换其值</span></span><br><span class="line">        <span class="comment">//overwrite 非0 存在就替换其值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//只对本进程有效</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[],<span class="type">char</span>* envp[])</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;一共有&quot;</span> &lt;&lt; argc &lt;&lt; <span class="string">&quot;个参数\n&quot;</span>;</span><br><span class="line">    <span class="comment">// 显示全部的参数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; argc; i ++)&#123;</span><br><span class="line">        std:: cout &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;个参数: &quot;</span> &lt;&lt; argv[i] &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">setenv</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;HELLO&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">getenv</span>(<span class="string">&quot;hello&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">/*for(int i = 0; envp[i]!=0; i ++)&#123;</span></span><br><span class="line"><span class="comment">        std::cout &lt;&lt; envp[i] &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="gdb调试程序"><a href="#gdb调试程序" class="headerlink" title="gdb调试程序"></a>gdb调试程序</h3><p>如果需要程序可调试，编译时需要加-g选项，并且，不能使用-O的优化选项</p><h4 id="gdb的常用命令"><a href="#gdb的常用命令" class="headerlink" title="gdb的常用命令"></a>gdb的常用命令</h4><p><img src="../assets/网络编程/image-12.png" alt="示例图片" style="zoom:50%;" /></p><p><img src="../assets/网络编程/image-13.png" alt="示例图片" style="zoom:50%;" /></p><p><img src="../assets/网络编程/image-14.png" alt="示例图片" style="zoom:50%;" /></p><h4 id="用gdb调试core文件"><a href="#用gdb调试core文件" class="headerlink" title="用gdb调试core文件"></a>用gdb调试core文件</h4><p><img src="../assets/网络编程/image-15.png" alt="示例图片" style="zoom:50%;" /></p><p><img src="../assets/网络编程/image-16.png" alt="示例图片" style="zoom:50%;" /></p><p>ulimit 的参数 ：<img src="../assets/网络编程/image-17.png" alt="示例图片" style="zoom:50%;" /><br>要修改哪个参数 就 - 啥</p><ul><li><p><strong>gdb排查死锁的方法</strong></p><p>1 . 先使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ --std=c+<span class="number">+11</span> -g -O0 dead_lock.cpp -o dead_lock</span><br></pre></td></tr></table></figure><ol><li>发生死锁后 程序会卡住，一般会有一个看门狗程序，对卡住的程序发送kill信号，这时候被杀死的信号会产生core文件</li><li><p><strong>然后执行以下命令来分析core文件</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb -c ./core<span class="number">-49237</span> ./dead_lock</span><br></pre></td></tr></table></figure><p>并用bt命令查看调用栈<br><img src="image-120.png" alt="alt text"></p></li><li>在gdb调试下使用 <strong>info threads</strong>，查看当前有多少线程<br><img src="image-121.png" alt="alt text"></li><li>使用<strong>thread 加对应编号</strong>以及 <strong>bt</strong> 查看线程在干啥<br><img src="image-122.png" alt="alt text"></li><li>使用<strong>f 加对应编号</strong> 来查看对应调用栈干了什么<br> <img src="image-123.png" alt="alt text"></li><li>使用 <strong>p 加你要查看的变量</strong>查看其参数<br> <img src="image-124.png" alt="alt text"><br> owner 不为0就表示他被谁占有着，使用 <strong>info threads</strong> 能看线程的对应线程号</li></ol></li></ul><h4 id="用gdb调试一个正在运行的程序"><a href="#用gdb调试一个正在运行的程序" class="headerlink" title="用gdb调试一个正在运行的程序"></a>用gdb调试一个正在运行的程序</h4><ul><li>首先需要知道运行程序的进程编号是什么？<br>使用 ps -ef |grep demo</li><li>然后使用 gdb demo -p 进程编号</li><li>正在运行的程序被调试了会自动停下来</li></ul><h3 id="linux的时间操作"><a href="#linux的时间操作" class="headerlink" title="linux的时间操作"></a>linux的时间操作</h3><ul><li>C++11提供了操作时间的chrono库</li><li>但这个库屏蔽了很多细节 所以我们为了更好使用它，得了解他的底层</li></ul><h4 id="time-t-别名"><a href="#time-t-别名" class="headerlink" title="time_t 别名"></a>time_t 别名</h4><ul><li>这是一个时间类型，他是一个long类型的别名，在<time.h>文件中定义，表示从1970.1.1到现在的秒数</li><li>推荐使用 time_t定义它<br>可用这个 简化书写 typedef long time_t。</li></ul><h4 id="time-库函数"><a href="#time-库函数" class="headerlink" title="time()库函数"></a>time()库函数</h4><ul><li><p>获取操作系统的当前时间<br><img src="../assets/网络编程/image-18.png" alt="示例图片" style="zoom:50%;" /><br>上述两种用法是一样的，都可以用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  include &lt;iostream&gt;</span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">long</span> <span class="type">time_t</span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">long</span> t = <span class="built_in">time</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="type">long</span> tt;</span><br><span class="line">  <span class="built_in">time</span>(&amp;tt);</span><br><span class="line">  std::cout &lt;&lt; t &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; tt &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="tm结构体-timeval"><a href="#tm结构体-timeval" class="headerlink" title="tm结构体(timeval)"></a>tm结构体(timeval)</h4><p><img src="../assets/网络编程/image-19.png" alt="示例图片" style="zoom:50%;" /></p><h4 id="localtime-库函数"><a href="#localtime-库函数" class="headerlink" title="localtime()库函数"></a>localtime()库函数</h4><ul><li>这个函数的作用是把time_t表示的时间转变为tm结构体表示的时间</li><li>localtime()函数不是线程安全的,localtime_r()是线程安全的</li><li>函数声明 <img src="../assets/网络编程/image-20.png" alt="示例图片" style="zoom:50%;" /></li></ul><h4 id="mktime-函数"><a href="#mktime-函数" class="headerlink" title="mktime()函数"></a>mktime()函数</h4><p>与localtime()功能相反<br><img src="../assets/网络编程/image-21.png" alt="示例图片" style="zoom:50%;" /></p><ul><li>这个函数主要用于时间的运算，这样更方便运算</li></ul><p><img src="../assets/网络编程/image-22.png" alt="示例图片" style="zoom:50%;" /></p><h4 id="gettimeofday-函数"><a href="#gettimeofday-函数" class="headerlink" title="gettimeofday()函数"></a>gettimeofday()函数</h4><ul><li>用于获取从1970.1.1到现在的秒和当前秒中已逝去的微秒数，可以用于程序的计时</li><li>函数声明：<img src="../assets/网络编程/image-23.png" alt="示例图片" style="zoom:50%;" /></li></ul><h4 id="程序的睡眠"><a href="#程序的睡眠" class="headerlink" title="程序的睡眠"></a>程序的睡眠</h4><ul><li>把程序挂起一段时间 sleep()函数<br>与usleep()函数</li><li>前者单位是秒 后者是微秒</li><li>包含在头文件<unistd.h>中<br><img src="../assets/网络编程/image-24.png" alt="示例图片" style="zoom:50%;" /></li></ul><h3 id="linux-获取目录操作"><a href="#linux-获取目录操作" class="headerlink" title="linux 获取目录操作"></a>linux 获取目录操作</h3><h4 id="几个简单的目录操作函数"><a href="#几个简单的目录操作函数" class="headerlink" title="几个简单的目录操作函数"></a>几个简单的目录操作函数</h4><h5 id="获取当前工作目录"><a href="#获取当前工作目录" class="headerlink" title="获取当前工作目录"></a>获取当前工作目录</h5><p>  <img src="../assets/网络编程/image-25.png" alt="示例图片" style="zoom:50%;" /></p><ul><li><p>即 getcwd()函数，这个函数的作用是获取当前的工作目录，需要提前指定好容量</p></li><li><p>get_current_dir_name(void) 这个函数 功能也是获取当前的工作目录,但是它是 动态分配内存，其内部是使用malloc()函数 所以需要手动free()它</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> path1[<span class="number">256</span>];</span><br><span class="line">    <span class="built_in">getcwd</span>(path1, <span class="number">256</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;path1 = &quot;</span> &lt;&lt; path1 &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">char</span>* path2 = <span class="built_in">get_current_dir_name</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;path2= &quot;</span> &lt;&lt; path2 &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">free</span>(path2);<span class="comment">//注意释放内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="切换工作目录"><a href="#切换工作目录" class="headerlink" title="切换工作目录"></a>切换工作目录</h5><p><img src="../assets/网络编程/image-26.png" alt="示例图片" style="zoom:50%;" /></p><h5 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h5><p><img src="../assets/网络编程/image-27.png" alt="示例图片" style="zoom:50%;" /><br>其中有两个参数 一个是目录名 一个是访问权限 <strong><em>注意：权限是八进制数不要省略前置的0 也就是说 0755</em></strong></p><ul><li><strong>如果上级目录不存在会失败</strong></li></ul><h5 id="删除目录"><a href="#删除目录" class="headerlink" title="删除目录"></a>删除目录</h5><p><img src="../assets/网络编程/image-28.png" alt="示例图片" style="zoom:50%;" /></p><h4 id="获取目录中文件的列表"><a href="#获取目录中文件的列表" class="headerlink" title="获取目录中文件的列表"></a>获取目录中文件的列表</h4><ul><li>在处理文件之前必须先知道目录列表</li></ul><h5 id="包含头文件"><a href="#包含头文件" class="headerlink" title="包含头文件"></a>包含头文件</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br></pre></td></tr></table></figure><h5 id="相关的库函数"><a href="#相关的库函数" class="headerlink" title="相关的库函数"></a>相关的库函数</h5><p><img src="../assets/网络编程/image-29.png" alt="示例图片" style="zoom:50%;" /></p><ul><li>目录指针 DIR ，声明方式DIR* 指针名字</li><li>readdir()，返回结构体 dirent的地址，存放了本次读取到的内容</li><li>结构体定义如下：<img src="../assets/网络编程/image-30.png" alt="示例图片" style="zoom:50%;" /></li><li>重点关注d_type和d_name成员，其中文件类型有多种取值，最重要的是8和4，8表示常规文件，4表示目录</li><li><p>示例代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span> <span class="comment">// 目录操作的头文件</span></span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(argc != <span class="number">2</span>)&#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;Using ./mulu1 目录名\n&quot;</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  DIR* dir;</span><br><span class="line">  <span class="keyword">if</span>((dir = <span class="built_in">opendir</span>(argv[<span class="number">1</span>])) == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 打开失败</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">dirent</span> *stdinfo = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>((stdinfo = <span class="built_in">readdir</span>(dir)) == <span class="literal">nullptr</span>) <span class="keyword">break</span>;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;文件名: &quot;</span> &lt;&lt; stdinfo-&gt;d_name &lt;&lt; <span class="string">&quot;, 文件类型= &quot;</span> &lt;&lt; (<span class="type">int</span>)stdinfo-&gt;d_type &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="linux-的系统错误"><a href="#linux-的系统错误" class="headerlink" title="linux 的系统错误"></a>linux 的系统错误</h3><ul><li>在C++程序中，如果调用了库函数，如果失败了会在全局变量<strong>errno</strong>中存放调用过程产生错误代码的原因，所以我们可以用<strong>errno</strong>变量来查找原因</li><li>头文件：<error.h></li><li>需要配合sterror()和perror()两个函数库，来获取详细信息</li></ul><h4 id="sterror-库函数"><a href="#sterror-库函数" class="headerlink" title="sterror()库函数"></a>sterror()库函数</h4><ul><li>其是声明在<string.h>中</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">strerror</span><span class="params">(<span class="type">int</span> errnum)</span></span>; <span class="comment">//非线程安全</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">strerror_r</span><span class="params">(<span class="type">int</span> errnum, <span class="type">char</span>*buf, <span class="type">size_t</span> buflen)</span></span>; <span class="comment">//线程安全</span></span><br></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cerrno&gt;</span> <span class="comment">//errno全局变量的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span> <span class="comment">// mkdir函数所在头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ir = <span class="built_in">mkdir</span>(<span class="string">&quot;/home/pigcanstudy/test1/123&quot;</span>, <span class="number">0755</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ir= &quot;</span> &lt;&lt; ir &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; errno &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="perror-库函数"><a href="#perror-库函数" class="headerlink" title="perror()库函数"></a>perror()库函数</h4><ul><li>在<stdio.h> 中，用于在控制台显示最近一次系统错误的详细信息</li></ul><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol><li><strong><em>并不是所有库函数调用失败都会在errno中存储，以man 手册为主(不属于系统调用的函数不会设置errno)</em></strong></li><li><strong><em>errno不能作为调用库函数的失败标志 因为errno 在调用成功后 不会改变值，也就是说不会主动置为0（0表示成功）</em></strong></li></ol><h3 id="目录和文件的更多操作"><a href="#目录和文件的更多操作" class="headerlink" title="目录和文件的更多操作"></a>目录和文件的更多操作</h3><h4 id="access-库函数"><a href="#access-库函数" class="headerlink" title="access()库函数"></a>access()库函数</h4><ul><li>此函数用于判断当前用户对目录或文件的存储权限是否满足</li><li>包含在头文件<unistd.h>中<br><img src="../assets/网络编程/image-31.png" alt="示例图片" style="zoom:50%;" /><br>四种权限<br><img src="../assets/网络编程/image-32.png" alt="示例图片" style="zoom:50%;" /></li><li>返回值 当pathname满足mode权限返回0，不满足返回-1，errno 被设置</li><li>在实际开发中 access()函数主要用于判断目录或文件是否存在<br>示例代码：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(argc != <span class="number">2</span>)&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Using ./access 文件或目录名\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">access</span>(argv[<span class="number">1</span>],F_OK) != <span class="number">0</span>)&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;文件或目录&quot;</span> &lt;&lt; argv[<span class="number">1</span>] &lt;&lt; <span class="string">&quot;不存在\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;文件或目录&quot;</span> &lt;&lt; argv[<span class="number">1</span>] &lt;&lt; <span class="string">&quot;存在\n&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="stat结构体"><a href="#stat结构体" class="headerlink" title="stat结构体"></a>stat结构体</h4><ul><li>stat 结构体用于存放目录或文件的详细信息，如下：<img src="../assets/网络编程/image-33.png" alt="示例图片" style="zoom:50%;" /></li><li><strong><em>重点关注st_mode,st_size和st_mtime成员</em></strong>, st_mtime是一个整数表示的时间，需要程序员自己写代码转换格式<br><img src="../assets/网络编程/image-34.png" alt="示例图片" style="zoom:50%;" /></li></ul><h4 id="stat-库函数"><a href="#stat-库函数" class="headerlink" title="stat()库函数"></a>stat()库函数</h4><p><img src="../assets/网络编程/image-35.png" alt="示例图片" style="zoom:50%;" /></p><h4 id="utime-库函数"><a href="#utime-库函数" class="headerlink" title="utime()库函数"></a>utime()库函数</h4><ul><li><p>用于修改目录或文件的时间<br><img src="../assets/网络编程/image-36.png" alt="示例图片" style="zoom:50%;" /></p></li><li><p>结构体 utimbuf<br><img src="../assets/网络编程/image-37.png" alt="示例图片" style="zoom:50%;" /></p></li></ul><h4 id="rename-库函数"><a href="#rename-库函数" class="headerlink" title="rename()库函数"></a>rename()库函数</h4><p><img src="../assets/网络编程/image-38.png" alt="示例图片" style="zoom:50%;" /></p><h4 id="remove-库函数"><a href="#remove-库函数" class="headerlink" title="remove()库函数"></a>remove()库函数</h4><p><img src="../assets/网络编程/image-39.png" alt="示例图片" style="zoom:50%;" /></p><h3 id="Linux的信号"><a href="#Linux的信号" class="headerlink" title="Linux的信号"></a>Linux的信号</h3><h4 id="信号的基本概念"><a href="#信号的基本概念" class="headerlink" title="信号的基本概念"></a>信号的基本概念</h4><ul><li>信号是软件中断，是进程之间相互传递消息的一种方法，用于通知进程发生了事件，但是，不能给进程传递任何数据</li><li>在shell中使用kill 和 killall 命令发送信号</li></ul><h5 id="kill-与-killall-的区别"><a href="#kill-与-killall-的区别" class="headerlink" title="kill 与 killall 的区别"></a>kill 与 killall 的区别</h5><p><img src="../assets/网络编程/image-40.png" alt="示例图片" style="zoom:50%;" /></p><h4 id="信号的类型"><a href="#信号的类型" class="headerlink" title="信号的类型"></a>信号的类型</h4><p><img src="../assets/网络编程/image-44.png" alt="示例图片" style="zoom:50%;" /></p><ul><li><p><strong><em>重要的类型</em></strong></p><ol><li><p>SIGINT 2 A 键盘中断</p></li><li><p>SIGKILL 9 AEF 采用kill -9 进程编号强制杀死程序</p></li><li>SIGALRM 14 A 由闹钟alarm()函数发出的信号</li><li>SIGTERM 15 A 采用 kill 进程编号 或 killall 程序名来通知程序</li><li>SIGCHLD 17 B 子进程结束信号</li><li>SIGSEGV 11 CEF 无效的内存引用（数组越界，操作空指针和野指针）</li></ol></li></ul><p><strong><em>其中字母表示默认缺省的类型</em></strong><br><img src="../assets/网络编程/image-41.png" alt="示例图片" style="zoom:50%;" /></p><h4 id="信号的处理"><a href="#信号的处理" class="headerlink" title="信号的处理"></a>信号的处理</h4><ol><li>大部分默认操作是终止进程</li><li>设置信号处理函数（signal() 函数）</li><li>忽略某个信号<br><img src="../assets/网络编程/image-43.png" alt="示例图片" style="zoom:50%;" /></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> signum)</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;收到了信号: &quot;</span> &lt;&lt; signum &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">int</span> sig)</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;收到了闹钟信号,完成了定时任务\n&quot;</span>;</span><br><span class="line">    <span class="built_in">alarm</span>(<span class="number">5</span>); <span class="comment">//此函数不能少否则只会响应一次</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">signal</span>(<span class="number">1</span>,func);</span><br><span class="line">    <span class="built_in">signal</span>(<span class="number">15</span>,func);</span><br><span class="line">    <span class="built_in">signal</span>(SIGINT, SIG_IGN); <span class="comment">// 忽略2的信号</span></span><br><span class="line">    <span class="built_in">signal</span>(<span class="number">9</span>, func);<span class="comment">//此代码无效，因为9不可被捕获</span></span><br><span class="line">    <span class="built_in">signal</span>(<span class="number">9</span>, SIG_IGN);<span class="comment">//此代码无效，因为9不可被忽略</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">alarm</span>(<span class="number">5</span>);<span class="comment">//闹钟（定时器），5秒后向进程发送14的信号</span></span><br><span class="line">    <span class="built_in">signal</span>(<span class="number">14</span>, func1);<span class="comment">//设置定时任务函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;执行了一次任务。\n&quot;</span>;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>SIG_DEF: 恢复参数signum 所指信号的处理方法为默认值</li><li>自定义的信号比如func</li><li>SIG_IGN: 忽略参数signum所指的信号</li></ul><h4 id="信号有什么用"><a href="#信号有什么用" class="headerlink" title="信号有什么用"></a>信号有什么用</h4><ol><li>可以在杀死进程的时候进行善后工作，比如释放内存啥的</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EXIT</span><span class="params">(<span class="type">int</span> sig)</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;收到了信号：&quot;</span> &lt;&lt; sig &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;正在释放资源，程序将退出....&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">//以下是释放资源</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;程序退出&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">signal</span>(<span class="number">2</span>, EXIT);</span><br><span class="line">    <span class="built_in">signal</span>(<span class="number">15</span>, EXIT);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>向程序发送0信号，可以检测程序是否存活<br><img src="../assets/网络编程/image-45.png" alt="示例图片" style="zoom:50%;" /></li></ol><h4 id="发送信号"><a href="#发送信号" class="headerlink" title="发送信号"></a>发送信号</h4><p>可以使用kill（）函数向其他进程发送信号</p><ol><li>函数声明 int kill(pid_t pid, int sig);<ol><li>sig表示是啥信号</li><li>pid 表示指定的进程号</li></ol></li><li>pid的几种情况<ol><li>pid&gt;0 将信号传给进程号为pid的进程</li><li>pid=0 将信号传递给和目前进程相同进程组的所有进程常用于父进程给子进程发送信号，注意，发送信号者也会收到自己发出的信号</li><li>pid=-1 将信号广播发送给系统内所有进程，例如系统关机时，会向所有的登录窗口广播关机信息</li></ol></li></ol><h3 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h3><h4 id="进程终止方式"><a href="#进程终止方式" class="headerlink" title="进程终止方式"></a>进程终止方式</h4><ul><li>有8种方式可以终止进程</li><li>其中五种为正常终止<ol><li>main()函数用return 返回</li><li>用exit()退出</li><li>调用_exit()或_Exit()函数</li><li>最后一个线程从启动例程(线程主函数)用return返回</li><li>在最后一个线程中调用pthread_exit()返回</li></ol></li><li>异常终止有三个方式<ol><li>调用abort() 函数</li><li>接收到一个信号</li><li>最后一个线程对取消请求做出响应</li></ol></li></ul><h4 id="进程终止状态"><a href="#进程终止状态" class="headerlink" title="进程终止状态"></a>进程终止状态</h4><ol><li>默认终止状态为0</li><li>查看进程终止状态为 echo $?</li><li>3个正常终止函数的参数就是状态<br><img src="../assets/网络编程/image-46.png" alt="示例图片" style="zoom:100%;" /></li><li>异常终止 状态为非0</li></ol><h4 id="资源释放的问题"><a href="#资源释放的问题" class="headerlink" title="资源释放的问题"></a>资源释放的问题</h4><ul><li>return 在哪个函数中返回就会清理哪个局部对象的析构函数，在main中还会调用全局对象的析构</li><li><strong><em>exit()不会调用局部对象的析构，会调用全局对象析构</em></strong></li><li>exit()会执行清理工作，在退出 而_exit(),_Exit()会直接退出，不执行清理工作</li></ul><h4 id="进程的终止函数"><a href="#进程的终止函数" class="headerlink" title="进程的终止函数"></a>进程的终止函数</h4><ul><li>atexit()函数登记终止函数最多32个，这些函数由exit()自动调用<ol><li>int atexit(void(*function)(void));</li><li>exit()调用终止函数顺序与登记时相反</li><li>可以干些进程终止前的收尾工作</li></ol></li></ul><h3 id="调用可执行程序"><a href="#调用可执行程序" class="headerlink" title="调用可执行程序"></a>调用可执行程序</h3><h4 id="system-库函数"><a href="#system-库函数" class="headerlink" title="system()库函数"></a>system()库函数</h4><h5 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h5><p>调用可执行程序，把需要执行的程序和参数用一个字符串传给system()就好了<br>头文件可用 man system()来查看</p><h5 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">system</span>(<span class="string">&quot;/bin/ls -l /tmp&quot;</span>);<span class="comment">//注意使用全路径，因为可以避免环境变量问题</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ret=&quot;</span> &lt;&lt; ret &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;system&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="../assets/网络编程/image-47.png" alt="示例图片" style="zoom:100%;" /></p><h4 id="exec函数族"><a href="#exec函数族" class="headerlink" title="exec函数族"></a>exec函数族</h4><p>exec函数族提供了另一种在进程中调用程序(二进制文件或shell脚本)的方法</p><p><img src="../assets/网络编程/image-48.png" alt="示例图片" style="zoom:100%;" /></p><p>其中重要的已经加粗</p><h5 id="execl-函数"><a href="#execl-函数" class="headerlink" title="execl()函数"></a>execl()函数</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">execl</span>(<span class="string">&quot;/bin/ls&quot;</span>, <span class="string">&quot;/bin/ls&quot;</span>, <span class="string">&quot;-lt&quot;</span>, <span class="string">&quot;/tmp&quot;</span>, <span class="number">0</span>);<span class="comment">//最后一个0不能省略，因为他表示可变参数结束，第一个与第二个填需要执行的函数，后面是可变参数填需要执行函数的参数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ret=&quot;</span> &lt;&lt; ret &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;execl&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>注意事项:<img src="../assets/网络编程/image-49.png" alt="示例图片" style="zoom:100%;" /><ol><li>其中第二点尤为重要，新进程的进程编号与原进程相同，但是，新进程取代了原进程的代码段，数据段，和堆栈<br>举例：</li></ol></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="comment">// 新进程的进程编号与原进程编号相同，但是，新进程取代了原进程的代码段，数据段和堆栈</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;demo 本进程的编号是: &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">execl</span>(<span class="string">&quot;/home/pigcanstudy/test1/demo01&quot;</span>,<span class="string">&quot;/home/pigcanstudy/test1/demo01&quot;</span>,<span class="number">0</span>);<span class="comment">//最后一个0不能省略，因为他表示可变参数结束，第一个与第二个填需要执行的函数，后面是可变参数填需要执行函数的参数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ret=&quot;</span> &lt;&lt; ret &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;execl&quot;</span>);</span><br><span class="line">    <span class="comment">/*int res = system(&quot;/home/pigcanstudy/test1.demo01&quot;);</span></span><br><span class="line"><span class="comment">    std::cout &lt;&lt; &quot;res=&quot; &lt;&lt; res &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">    perror(&quot;system&quot;);*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="../assets/网络编程/image-50.png" alt="示例图片" style="zoom:100%;" /></p><h5 id="execv-函数"><a href="#execv-函数" class="headerlink" title="execv()函数"></a>execv()函数</h5><p><img src="../assets/网络编程/image-52.png" alt="示例图片" style="zoom:100%;" /><br>注意 char* 必不可少否则会报错</p><h3 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h3><h4 id="Linux的0，1，2号进程"><a href="#Linux的0，1，2号进程" class="headerlink" title="Linux的0，1，2号进程"></a>Linux的0，1，2号进程</h4><p><img src="../assets/网络编程/image-53.png" alt="示例图片" style="zoom:100%;" /></p><ul><li>注意他是一个树形结构</li></ul><h4 id="进程标识"><a href="#进程标识" class="headerlink" title="进程标识"></a>进程标识</h4><p><img src="../assets/网络编程/image-54.png" alt="示例图片" style="zoom:100%;" /></p><h4 id="fork-函数"><a href="#fork-函数" class="headerlink" title="fork()函数"></a>fork()函数</h4><p>用来创建一个子进程<br><img src="../assets/网络编程/image-55.png" alt="示例图片" style="zoom:100%;" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> bh = <span class="number">8</span>;</span><br><span class="line">    std::string message=<span class="string">&quot;我是一只小猪&quot;</span>;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="type">pid_t</span> pid1 = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;fu&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; pid &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;zi&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; pid &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pid1 &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;fu&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; pid1 &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;zi&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; pid1 &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="fork-的两种用法"><a href="#fork-的两种用法" class="headerlink" title="fork()的两种用法"></a>fork()的两种用法</h4><p><img src="../assets/网络编程/image-56.png" alt="示例图片" style="zoom:100%;" /></p><ul><li>第一种为上述Cpp</li><li>第二种示例为下：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fork() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//父进程执行这一段代码</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;父进程运行中...\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 子进程执行这一段代码</span></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;子进程开始执行任务....\n&quot;</span>;</span><br><span class="line">        <span class="built_in">execl</span>(<span class="string">&quot;/home/pigcanstudy/test1/demo01&quot;</span>, <span class="string">&quot;/home/pigcanstudy/test1/demo01&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;子进程执行任务结束，退出\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>补充 <strong><em>shell的原理是在bash这个进程下创建子进程来执行你写的操作</em></strong></li></ul><h4 id="共享文件"><a href="#共享文件" class="headerlink" title="共享文件"></a>共享文件</h4><p><img src="../assets/网络编程/image-58.png" alt="示例图片" style="zoom:100%;" /><br>对这句话的解释就是父子进程中，如果父进程先执行完文件写操作，子进程会接着父进程的文件指针的下一个来写，也就是说不会覆盖文件的内容，而是接在后面</p><p><img src="../assets/网络编程/image-59.png" alt="示例图片" style="zoom:100%;" /><br><strong><em>需要采用进程同步</em></strong></p><h4 id="vfork"><a href="#vfork" class="headerlink" title="vfork()"></a>vfork()</h4><p><img src="../assets/网络编程/image-60.png" alt="示例图片" style="zoom:100%;" /></p><h3 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h3><h4 id="僵尸进程的产生"><a href="#僵尸进程的产生" class="headerlink" title="僵尸进程的产生"></a>僵尸进程的产生</h4><p><img src="../assets/网络编程/image-63.png" alt="示例图片" style="zoom:100%;" /></p><ul><li><p>对于第一句话的解释<br>  代码：<br>  <img src="../assets/网络编程/image-62.png" alt="示例图片" style="zoom:100%;" /><br>  结果：<br>  <img src="../assets/网络编程/image-61.png" alt="示例图片" style="zoom:100%;" /></p><p>  将一个可执行程序放在后台运行有两种方法：</p><ol><li>直接执行 ./demo &amp;</li><li>在程序的代码中 加入一行if(fork() &gt; 0) return 0;</li></ol><ul><li><p>对于第二句话解释</p><p>代码：<br><img src="../assets/网络编程/image-64.png" alt="示例图片" style="zoom:100%;" /></p><p>结果：<br><img src="../assets/网络编程/image-65.png" alt="示例图片" style="zoom:100%;" /></p><p>当一个进程终止时，它的状态信息仍然被保留在系统中，直到其父进程调用wait或waitpid等系统调用来获取其终止状态信息。如果父进程没有及时调用这些系统调用来获取终止状态信息，那么这个已经终止的子进程就会成为一个僵尸进程（Zombie Process）。</p><p><img src="../assets/网络编程/image-66.png" alt="示例图片" style="zoom:100%;" /></p></li></ul></li></ul><h4 id="僵尸进程地避免"><a href="#僵尸进程地避免" class="headerlink" title="僵尸进程地避免"></a>僵尸进程地避免</h4><ol><li>子进程退出的时候，内核会给父进程发出SIGCHLD信号，如果父进程调用了signal(SIGCHLD,SIG_IGN)来通知内核，内核就会把这个子进程的数据结构释放，但是父进程得不到子进程被释放的信息</li><li>使用wait或waitpid 如图：<br><img src="../assets/网络编程/image-67.png" alt="示例图片" style="zoom:100%;" /></li></ol><p><img src="../assets/网络编程/image-68.png" alt="示例图片" style="zoom:100%;" /></p><ol><li>如果父进程很忙，可以捕获SIFCHLD信号，在信号处理函数中调用wait（）/waitpid（）</li></ol><p><img src="../assets/网络编程/image-69.png" alt="示例图片" style="zoom:100%;" /></p><h3 id="多进程与信号"><a href="#多进程与信号" class="headerlink" title="多进程与信号"></a>多进程与信号</h3><ul><li>在多进程的服务程序中，如果子进程收到退出信号，子进程自行退出，如果父进程收到退出信号，应该先向所有子进程发送退出信号，再自己退出</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FatherEXIT</span><span class="params">(<span class="type">int</span> sig)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChildEXIT</span><span class="params">(<span class="type">int</span> sig)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 忽视全部的信号，不希望被打扰</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">65</span>; i ++) <span class="built_in">signal</span>(i, SIG_IGN);</span><br><span class="line">    <span class="comment">//设置信号，在shell状态下，可用kill 进程号 或者 Cirl + c 正常终止这些进程</span></span><br><span class="line">    <span class="comment">// 但请不要用 kill -9 + 进程号 强行终止</span></span><br><span class="line">    <span class="built_in">signal</span>(SIGTERM, FatherEXIT); <span class="comment">//15信号,这行的代码意思是自己规定一个信号处理函数</span></span><br><span class="line">    <span class="built_in">signal</span>(SIGINT, FatherEXIT);<span class="comment">// 2信号</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fork() &gt; <span class="number">0</span>)&#123; <span class="comment">//父进程流程</span></span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123; <span class="comment">//子进程流程</span></span><br><span class="line">            <span class="built_in">signal</span>(SIGTERM, ChildEXIT);<span class="comment">//规定一个子进程退出信号</span></span><br><span class="line">            <span class="built_in">signal</span>(SIGINT, SIG_IGN);<span class="comment">//子进程不需要捕获SIGINT信号</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;子进程&quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; <span class="string">&quot;正在运行中。\n&quot;</span>;</span><br><span class="line">                <span class="built_in">sleep</span>(<span class="number">3</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FatherEXIT</span><span class="params">(<span class="type">int</span> sig)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 以下代码是为了防止信号处理函数在执行的过程中被信号再次中断</span></span><br><span class="line">    <span class="built_in">signal</span>(SIGTERM, SIG_IGN);</span><br><span class="line">    <span class="built_in">signal</span>(SIGINT, SIG_IGN);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;父进程&quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; <span class="string">&quot;正在退出, sig=&quot;</span> &lt;&lt; sig &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">kill</span>(<span class="number">0</span>,SIGTERM);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;子进程&quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; <span class="string">&quot;正在释放父进程的资源以及全局资源&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 这里些释放资源的代码</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChildEXIT</span><span class="params">(<span class="type">int</span> sig)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 以下代码是为了防止信号处理函数在执行的过程中被信号再次中断</span></span><br><span class="line">    <span class="built_in">signal</span>(SIGTERM, SIG_IGN);</span><br><span class="line">    <span class="built_in">signal</span>(SIGINT, SIG_IGN);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;子进程&quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; <span class="string">&quot;正在退出, sig=&quot;</span> &lt;&lt; sig &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;子进程&quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; <span class="string">&quot;正在释放子进程的资源&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 这里些释放资源的代码</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p><img src="../assets/网络编程/image-70.png" alt="示例图片" style="zoom:100%;" /></p><p><img src="../assets/网络编程/image-71.png" alt="示例图片" style="zoom:100%;" /></p><h4 id="shmget-函数"><a href="#shmget-函数" class="headerlink" title="shmget()函数"></a>shmget()函数</h4><p><img src="../assets/网络编程/image-72.png" alt="示例图片" style="zoom:100%;" /></p><ul><li><p>补充说明：shmget()函数，如果共享内存不存在就创建它，如果有就返回他的IP</p></li><li><p><strong><em>ipcs -m</em></strong> 用来查看共享字段<br><img src="../assets/网络编程/image-73.png" alt="示例图片" style="zoom:100%;" /></p></li><li><strong><em>ipcrm -m + shimd</em></strong> 用来删除共享内存<br><img src="../assets/网络编程/image-74.png" alt="示例图片" style="zoom:100%;" /></li></ul><h4 id="shmat-函数"><a href="#shmat-函数" class="headerlink" title="shmat()函数"></a>shmat()函数</h4><p><img src="../assets/网络编程/image-75.png" alt="示例图片" style="zoom:100%;" /></p><h4 id="shmdt-函数"><a href="#shmdt-函数" class="headerlink" title="shmdt()函数"></a>shmdt()函数</h4><p><img src="../assets/网络编程/image-76.png" alt="示例图片" style="zoom:100%;" /></p><h4 id="shmctl-函数"><a href="#shmctl-函数" class="headerlink" title="shmctl()函数"></a>shmctl()函数</h4><p><img src="../assets/网络编程/image-77.png" alt="示例图片" style="zoom:100%;" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> no;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">51</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="comment">// 第一步创建共享内存</span></span><br><span class="line">    <span class="type">int</span> shmid = <span class="built_in">shmget</span>(<span class="number">0x5005</span>, <span class="built_in">sizeof</span>(node), <span class="number">0640</span>|IPC_CREAT);</span><br><span class="line">    <span class="keyword">if</span>(shmid == <span class="number">-1</span>)&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;shgmget(0x5005) failed.\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;shmid=&quot;</span> &lt;&lt; shmid &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">//第二步：把共享内存连接到当前进程的地址空间</span></span><br><span class="line">    node *ptr = (node *)<span class="built_in">shmat</span>(shmid,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ptr == (<span class="type">void</span> *)<span class="number">-1</span>)&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;shmat() failed\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第三步：使用共享内存，对共享内存进行读/写操作</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;原值：no=&quot;</span> &lt;&lt; ptr-&gt;no &lt;&lt; <span class="string">&quot;,name=&quot;</span> &lt;&lt; ptr-&gt;name &lt;&lt; std::endl;</span><br><span class="line">    ptr-&gt;no = <span class="built_in">atoi</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">strcpy</span>(ptr-&gt;name, argv[<span class="number">2</span>]);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;新值：no=&quot;</span> &lt;&lt; ptr-&gt;no &lt;&lt; <span class="string">&quot;,name=&quot;</span> &lt;&lt; ptr-&gt;name &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 第四步把共享内存从当前进程中分离</span></span><br><span class="line">    <span class="built_in">shmdt</span>(ptr);</span><br><span class="line">    <span class="comment">//第五步：删除共享进程</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">shmctl</span>(shmid, IPC_RMID,<span class="number">0</span>) == <span class="number">-1</span>)&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;shmctl failed\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><em>注意分配共享内存的时候不能分配堆区，所以在数据结构中的stl那些都不能分配</em></strong></li></ul><h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p><img src="../assets/网络编程/image-78.png" alt="示例图片" style="zoom:100%;" /></p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p><img src="../assets/网络编程/image-79.png" alt="示例图片" style="zoom:100%;" /></p><p>细节：用来动态使用<br><a href="https://www.bilibili.com/video/BV11Z4y157RY/?p=22&amp;spm_id_from=pageDriver&amp;vd_source=772b61fb408cdf9169f726ab21790987">https://www.bilibili.com/video/BV11Z4y157RY/?p=22&amp;spm_id_from=pageDriver&amp;vd_source=772b61fb408cdf9169f726ab21790987</a></p><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p><img src="../assets/网络编程/image-80.png" alt="示例图片" style="zoom:100%;" /></p><ul><li>p操作wait 将信号量的值减一，如果信号量的值为0，将阻塞等待，知道信号量大于0</li><li>V操作post 将信号量的值加1 任何时候都不会阻塞</li></ul><p><a href="https://www.bilibili.com/video/BV11Z4y157RY/?p=23&amp;spm_id_from=pageDriver&amp;vd_source=772b61fb408cdf9169f726ab21790987">https://www.bilibili.com/video/BV11Z4y157RY/?p=23&amp;spm_id_from=pageDriver&amp;vd_source=772b61fb408cdf9169f726ab21790987</a></p><h3 id="pthread-线程库"><a href="#pthread-线程库" class="headerlink" title="pthread 线程库"></a>pthread 线程库</h3><p><img src="../assets/网络编程/image-81.png" alt="示例图片" style="zoom:100%;" /></p><h2 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h2><h3 id="第一个网络通信程序户端"><a href="#第一个网络通信程序户端" class="headerlink" title="第一个网络通信程序户端"></a>第一个网络通信程序户端</h3><h3 id="基于linux的文件操作"><a href="#基于linux的文件操作" class="headerlink" title="基于linux的文件操作"></a>基于linux的文件操作</h3><h4 id="文件描述符的分配规则"><a href="#文件描述符的分配规则" class="headerlink" title="文件描述符的分配规则"></a>文件描述符的分配规则</h4><p><img src="../assets/网络编程/image-82.png" alt="示例图片" style="zoom:100%;" /></p><ul><li><p>其分配规则是找到最小的，没有被占用的文件描述符，也就是说如果我们把0，1，2三个描述符关掉后，再打开文件，分配的就是0，如果都不关则分配3，关掉0，对应就不能输入，其他亦然</p></li><li><p>在Linux系统中，文件与socket没有区别，socket也会分配文件描述符给他</p></li></ul><p><img src="../assets/网络编程/image-83.png" alt="示例图片" style="zoom:100%;" /></p><ul><li><strong><em>linux底层的read系统调用和write系统调用，也能用在socket中</em></strong></li></ul><h3 id="socket函数详解"><a href="#socket函数详解" class="headerlink" title="socket函数详解"></a>socket函数详解</h3><h4 id="创建socket"><a href="#创建socket" class="headerlink" title="创建socket"></a>创建socket</h4><h5 id="函数的声明"><a href="#函数的声明" class="headerlink" title="函数的声明"></a>函数的声明</h5><p><img src="../assets/网络编程/image-84.png" alt="示例图片" style="zoom:100%;" /></p><ul><li>其中 <strong><em>domain</em></strong> 参数用来指定协议家族：<br><img src="../assets/网络编程/image-86.png" alt="示例图片" style="zoom:100%;" /><br><strong>重要参数</strong> <strong><em>IP_INET</em></strong></li></ul><h5 id="type-表示数据的传输类型"><a href="#type-表示数据的传输类型" class="headerlink" title="type 表示数据的传输类型"></a>type 表示数据的传输类型</h5><p><img src="../assets/网络编程/image-87.png" alt="示例图片" style="zoom:100%;" /></p><h5 id="protocol协议"><a href="#protocol协议" class="headerlink" title="protocol协议"></a>protocol协议</h5><p><img src="../assets/网络编程/image-88.png" alt="示例图片" style="zoom:100%;" /></p><h5 id="两种创建方式"><a href="#两种创建方式" class="headerlink" title="两种创建方式"></a>两种创建方式</h5><p><img src="../assets/网络编程/image-89.png" alt="示例图片" style="zoom:100%;" /></p><p><strong><em>几乎全部的网络编程函数失败时都会返回-1，并且errno被设置，单个进程中创建的socket数量受系统的openfile限制（ulimit -a）</em></strong></p><h4 id="主机字节序和网络字节序"><a href="#主机字节序和网络字节序" class="headerlink" title="主机字节序和网络字节序"></a>主机字节序和网络字节序</h4><h5 id="大端序和小端序"><a href="#大端序和小端序" class="headerlink" title="大端序和小端序"></a>大端序和小端序</h5><ul><li>大端序：低位字节存放在高位，高位字节存放在低位</li><li><p>小端序：地位字节存放在地位，高位字节存放在高位</p></li><li><p>举例：<img src="../assets/网络编程/image-90.png" alt="示例图片" style="zoom:100%;" /></p></li><li><p>问题：<br><img src="../assets/网络编程/image-98.png" alt="示例图片" style="zoom:100%;" /></p></li></ul><h5 id="网络字节序"><a href="#网络字节序" class="headerlink" title="网络字节序"></a>网络字节序</h5><ul><li>为了解决主机字节序不同的问题，引入了网络字节序（是一种大端序）<br><img src="../assets/网络编程/image-91.png" alt="示例图片" style="zoom:100%;" /><ol><li>其中 h 表示host（主机）</li><li>to 转换</li><li>n network 网络</li><li>s short 二字节 16位整数</li><li>l long 四字节 32位整数</li></ol></li></ul><h5 id="IP地址和通讯端口"><a href="#IP地址和通讯端口" class="headerlink" title="IP地址和通讯端口"></a>IP地址和通讯端口</h5><p><img src="../assets/网络编程/image-92.png" alt="示例图片" style="zoom:100%;" /></p><h5 id="如何处理大小端序"><a href="#如何处理大小端序" class="headerlink" title="如何处理大小端序"></a>如何处理大小端序</h5><ul><li>数据收发的时候有自动转换，只有向sockaddr_in 结构体成员变量填充数据的时候才需要考虑字节序问题</li></ul><h4 id="万恶的结构体"><a href="#万恶的结构体" class="headerlink" title="万恶的结构体"></a>万恶的结构体</h4><p><img src="../assets/网络编程/image-93.png" alt="示例图片" style="zoom:100%;" /></p><h5 id="sockaddr结构体"><a href="#sockaddr结构体" class="headerlink" title="sockaddr结构体"></a>sockaddr结构体</h5><ul><li>用来存放协议族，端口和地址信息，客户端和connect()函数和bind（）函数需要这个结构体</li></ul><p><img src="../assets/网络编程/image-94.png" alt="示例图片" style="zoom:100%;" /></p><h5 id="sockaddr-in结构体"><a href="#sockaddr-in结构体" class="headerlink" title="sockaddr_in结构体"></a>sockaddr_in结构体</h5><p>sockaddr结构体是为了统一接口函数，操作起来不方便，所以加了这个等价的结构体</p><p><img src="../assets/网络编程/image-95.png" alt="示例图片" style="zoom:100%;" /><br>也就是说 后者的结构体是为了方便操作而设计的</p><ul><li><strong><em>在程序中我们操作的是sockaddr_in结构体，在调用函数的时候我们调用的soockaddr结构体</em></strong></li></ul><h6 id="细说此结构体内部的细节"><a href="#细说此结构体内部的细节" class="headerlink" title="细说此结构体内部的细节"></a>细说此结构体内部的细节</h6><ul><li>首先由于它的大小与sockaddr相同所以可以强制转换为sockaddr<br><img src="../assets/网络编程/image-96.png" alt="示例图片" style="zoom:100%;" /></li></ul><p><strong><em>但操作ip地址成员的时候 我们该怎么办？</em></strong></p><h6 id="使用gethostbyname-函数"><a href="#使用gethostbyname-函数" class="headerlink" title="使用gethostbyname()函数"></a>使用gethostbyname()函数</h6><ul><li>函数声明以及其返回结构体的内容如下：<br><img src="../assets/网络编程/image-97.png" alt="示例图片" style="zoom:100%;" /></li></ul><p>举例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此段代码就是使用gethostbuname函数的例子</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">hostent</span>* h;</span><br><span class="line">    <span class="keyword">if</span>((h = <span class="built_in">gethostbyname</span>(argv[<span class="number">1</span>])) == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;gethostbyname failed.\n&quot;</span>;</span><br><span class="line">        <span class="built_in">close</span>(sockfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;servaddr.sin_addr, h-&gt;h_addr,h-&gt;h_length);</span><br></pre></td></tr></table></figure><h6 id="字符串IP与大端序IP的转换"><a href="#字符串IP与大端序IP的转换" class="headerlink" title="字符串IP与大端序IP的转换"></a>字符串IP与大端序IP的转换</h6><ul><li>C语言提供了一个库函数，用于字符串格式的IP和大端序IP的互相转换，用于网络通信的服务端程序中</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">in_addr_t</span>; <span class="comment">//32位大端序的IP的值</span></span><br><span class="line"><span class="comment">// 把字符串格式的IP（192.168.168.1）转换为大端序IP，转换后IP赋值给sockaddr_in.int_addr.s_addr</span></span><br><span class="line"><span class="function"><span class="type">in_addr_t</span> <span class="title">inet_addr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* cp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把字符串格式IP转换为大端序IP，将转换后IP填充给sockaddr_in.int_addr.s_addr</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">inet_ation</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* cp, <span class="keyword">struct</span> in_addr* inp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把大端序IP转换为字符串格式的IP，用于在服务器端程序中解析客户端的IP的值</span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">inet_ntoa</span><span class="params">(<span class="keyword">struct</span> in_addr in)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>在客户端程序中使用此方法就只能指定ip地址而不能指定域名或者主机号，而用gethostbyname 方法就行</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">servaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);<span class="comment">//表示操作系统里的所有IP都能通信</span></span><br><span class="line"><span class="comment">//servaddr.sin_addr.s_addr = inet_addr(&quot;192.168.168.1&quot;); // 指定服务端用于通讯的IP</span></span><br></pre></td></tr></table></figure><h3 id="未封装的客户端代码"><a href="#未封装的客户端代码" class="headerlink" title="未封装的客户端代码"></a>未封装的客户端代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span><span class="comment">//sockaddr_in需要</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span><span class="comment">//hostent需要</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">3</span>)&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Using:./client 服务端IP地址 服务端的端口\n Example：./client 192.168.168.1 5005\n\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第一步建立socket</span></span><br><span class="line">    <span class="type">int</span> sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);<span class="comment">//  分别指定IPV4协议族，面向有链接的，如果是 0 的话，你不必自己指定协议，而由服务提供者为你选择合适的协议类型（或者写tcp协议对应编号）</span></span><br><span class="line">    std::cout &lt;&lt; sockfd &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">if</span>(sockfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二步向服务器发送链接请求</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> servaddr;<span class="comment">//用于存放协议，IP地址和端口的结构体</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="built_in">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET; <span class="comment">// 协议族</span></span><br><span class="line">    servaddr.sin_port = <span class="built_in">htons</span>(<span class="built_in">atoi</span>(argv[<span class="number">2</span>])); <span class="comment">// 指定服务端的通信端口</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">hostent</span>* h;</span><br><span class="line">    <span class="keyword">if</span>((h = <span class="built_in">gethostbyname</span>(argv[<span class="number">1</span>])) == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;gethostbyname failed.\n&quot;</span>;</span><br><span class="line">        <span class="built_in">close</span>(sockfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;servaddr.sin_addr, h-&gt;h_addr,h-&gt;h_length);<span class="comment">//指定服务端的通讯IP</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">connect</span>(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;servaddr, <span class="built_in">sizeof</span>(servaddr)) == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(sockfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第三步 与服务端通信，发送一个请求报文后等待服务端的回复，收到下一个回复后，再发下一个请求报文</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++)&#123;</span><br><span class="line">        <span class="type">int</span> iret;</span><br><span class="line">        <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">        <span class="built_in">sprintf</span>(buffer, <span class="string">&quot;这是第%d个智鞭，编号%03d。&quot;</span>, i + <span class="number">1</span>, i + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(iret = <span class="built_in">send</span>(sockfd,buffer,<span class="built_in">sizeof</span>(buffer), <span class="number">0</span>) &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;发送&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;发送&quot;</span> &lt;&lt; buffer &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">        <span class="comment">// 接收服务端的回应报文，如果没有回应报文，recv（）函数将阻塞等待。</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">recv</span>(sockfd, buffer, <span class="built_in">sizeof</span>(buffer), <span class="number">0</span>) &lt;= <span class="number">0</span>)&#123;<span class="comment">//接收函数存入buffer</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;iret=&quot;</span> &lt;&lt; iret &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;接收&quot;</span> &lt;&lt; buffer &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第四步 关闭socket</span></span><br><span class="line">    <span class="built_in">close</span>(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="未封装的服务端代码"><a href="#未封装的服务端代码" class="headerlink" title="未封装的服务端代码"></a>未封装的服务端代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span><span class="comment">//sockaddr_in需要</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span><span class="comment">//hostent需要</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>)&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Using:./server 通讯端口\n Example：./server 5005\n\n&quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;注意：运行服务端的程序Linux系统的防火墙必须要开通5005端口\n&quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;如果是云服务器，还有开通云平台的访问策略&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第一步建立服务端的socket</span></span><br><span class="line">    <span class="type">int</span> listenfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(listenfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二部用bind绑定ip地址和端口到socket上</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> servaddr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="built_in">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;<span class="comment">//固定填AF_INET</span></span><br><span class="line">    servaddr.sin_port = <span class="built_in">htons</span>(<span class="built_in">atoi</span>(argv[<span class="number">1</span>]));</span><br><span class="line">    servaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);<span class="comment">//表示操作系统里的所有IP都能通信</span></span><br><span class="line">    <span class="comment">//servaddr.sin_addr.s_addr = inet_addr(&quot;192.168.168.1&quot;); // 指定服务端用于通讯的IP</span></span><br><span class="line">    <span class="comment">//绑定服务器的IP和端口</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">bind</span>(listenfd,(sockaddr *)&amp;servaddr, <span class="built_in">sizeof</span>(servaddr)) == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(listenfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第三步打开socket监听状态</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">listen</span>(listenfd,<span class="number">5</span>) == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(listenfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第四步：受理客户端的链接请求，如果没有客户端练上来，accept（）将阻塞等待</span></span><br><span class="line">    <span class="comment">//accept后面两个参数一个是地址信息，一个是地址结构体大小，两个都填0表示不关心地址信息</span></span><br><span class="line">    <span class="type">int</span> clientfd = <span class="built_in">accept</span>(listenfd, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(clientfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(listenfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;客户端已连接&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第五步：接收客户端发来的信息，并发送回应报文</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="type">int</span> iret;</span><br><span class="line">        <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">        <span class="comment">//接收客户端的请求，没有哦请求就阻塞recv()等待</span></span><br><span class="line">        <span class="comment">//如果客户端已断开连接，recv函数将返回0</span></span><br><span class="line">        <span class="keyword">if</span>((iret = <span class="built_in">recv</span>(clientfd, buffer, <span class="built_in">sizeof</span>(buffer), <span class="number">0</span>)) &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">           std::cout &lt;&lt; <span class="string">&quot;iret= &quot;</span> &lt;&lt; iret &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;接收&quot;</span> &lt;&lt; buffer &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">strcpy</span>(buffer, <span class="string">&quot;ok&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>((iret = <span class="built_in">send</span>(clientfd, buffer, <span class="built_in">sizeof</span>(buffer), <span class="number">0</span>) &lt;= <span class="number">0</span>))&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;send&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;发送：&quot;</span> &lt;&lt; buffer &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭socket 释放资源</span></span><br><span class="line">    <span class="built_in">close</span>(listenfd);</span><br><span class="line">    <span class="built_in">close</span>(clientfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="封装的客户端代码"><a href="#封装的客户端代码" class="headerlink" title="封装的客户端代码"></a>封装的客户端代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span><span class="comment">//sockaddr_in需要</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span><span class="comment">//hostent需要</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ctcpclient</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_clientfd; <span class="comment">// 客户端的socket，-1表示未连接或连接已断开，&gt;=0 表示有效的socket</span></span><br><span class="line">    std::string m_ip; <span class="comment">// 服务器的IP/域名</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> m_port; <span class="comment">// 通讯端口</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//向服务端发起连接请求，成功返回true，失败false</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">connect</span><span class="params">(<span class="type">const</span> std::string&amp; in_ip, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">short</span> in_port)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 建立套接字</span></span><br><span class="line">        m_clientfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(m_clientfd == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 向服务端发送连接请求</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> servaddr;</span><br><span class="line">        m_ip = in_ip;</span><br><span class="line">        m_port = in_port;</span><br><span class="line">        servaddr.sin_family = AF_INET;</span><br><span class="line">        servaddr.sin_port = <span class="built_in">htons</span>(m_port);</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">hostent</span>* h;</span><br><span class="line">        <span class="keyword">if</span>((h = <span class="built_in">gethostbyname</span>(m_ip.<span class="built_in">c_str</span>())) == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="built_in">close</span>();</span><br><span class="line">            m_clientfd = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;servaddr.sin_addr, h-&gt;h_addr, h-&gt;h_length);</span><br><span class="line">        <span class="comment">// 以下错误常犯，注意当你想使用全局函数或者全局同名变量的时候 要在前面+::</span></span><br><span class="line">        <span class="keyword">if</span>(::<span class="built_in">connect</span>(m_clientfd, (<span class="keyword">struct</span> sockaddr *) &amp;servaddr, <span class="built_in">sizeof</span>(servaddr)) == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">close</span>();</span><br><span class="line">            m_clientfd = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为什么不用const char * 因为const char * 无法支持string,而下列可以支持从const char *</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">send</span><span class="params">(<span class="type">const</span> std::string&amp; buffer)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_clientfd == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//一定不要忘了::</span></span><br><span class="line">        <span class="keyword">if</span>(::<span class="built_in">send</span>(m_clientfd, buffer.<span class="built_in">data</span>(), buffer.<span class="built_in">size</span>(), <span class="number">0</span>) &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收服务端的报文，成功返回true，失败返回false</span></span><br><span class="line">    <span class="comment">//buffer存放接收到的报文内容，maxlen本次接收报文的长度</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">recv</span><span class="params">(std::string&amp; buffer,<span class="type">const</span> <span class="type">size_t</span> maxlen)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果直接操作string对象的内存，必须保证1）不能越界，2）操作后手动设置数据大小</span></span><br><span class="line">        buffer.<span class="built_in">clear</span>();</span><br><span class="line">        buffer.<span class="built_in">resize</span>(maxlen);</span><br><span class="line">        <span class="type">int</span> readn=::<span class="built_in">recv</span>(m_clientfd, &amp;buffer[<span class="number">0</span>], buffer.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//-1表示失败，0表示断开连接，成功放回数据大小</span></span><br><span class="line">        <span class="keyword">if</span>(readn &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            buffer.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        buffer.<span class="built_in">resize</span>(readn); <span class="comment">//重置buffer的实际大小</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_clientfd == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ::<span class="built_in">close</span>(m_clientfd);</span><br><span class="line">        m_clientfd = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ctcpclient</span>():<span class="built_in">m_clientfd</span>(<span class="number">-1</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">ctcpclient</span>()&#123;<span class="built_in">close</span>();&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">3</span>)&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Using:./client 服务端IP地址 服务端的端口\n Example：./client 192.168.168.1 5005\n\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ctcpclient tcpclient;</span><br><span class="line">    <span class="keyword">if</span>(!tcpclient.<span class="built_in">connect</span>(argv[<span class="number">1</span>], <span class="built_in">atoi</span>(argv[<span class="number">2</span>])))&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第三步 与服务端通信，发送一个请求报文后等待服务端的回复，收到下一个回复后，再发下一个请求报文</span></span><br><span class="line">    std::string buffer;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++)&#123;</span><br><span class="line">        buffer = <span class="string">&quot;这是第&quot;</span> + std::<span class="built_in">to_string</span>(i + <span class="number">1</span>) + <span class="string">&quot;个小智鞭, 编号&quot;</span> + std::<span class="built_in">to_string</span>(i + <span class="number">1</span>) + <span class="string">&quot;。&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!tcpclient.<span class="built_in">send</span>(buffer))&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;发送&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;发送:&quot;</span> &lt;&lt; buffer &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 接收服务端的回应报文，如果没有回应报文，recv（）函数将阻塞等待。</span></span><br><span class="line">        <span class="keyword">if</span>(!tcpclient.<span class="built_in">recv</span>(buffer, <span class="number">1024</span>))&#123;<span class="comment">//接收函数存入buffer</span></span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;recv&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;接收:&quot;</span> &lt;&lt; buffer &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第四步 关闭socket</span></span><br><span class="line">    tcpclient.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="封装socket的服务端"><a href="#封装socket的服务端" class="headerlink" title="封装socket的服务端"></a>封装socket的服务端</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span><span class="comment">//sockaddr_in需要</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span><span class="comment">//hostent需要</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// accept的过程理解为受理客户端的链接(从已连接的客户端中取出一个客户端)，一个服务端可以和很多客户端通信</span></span><br><span class="line"><span class="comment">//如果没有已连接的客户端，accept将阻塞</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ctcpserver</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_listenfd; <span class="comment">//监听的socket，-1表示未初始化</span></span><br><span class="line">    <span class="type">int</span> m_clientfd; <span class="comment">//客户端练上来的socket，-1表示未初始化</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> m_port;<span class="comment">//服务器用于通信的端口</span></span><br><span class="line">    std::string m_clientip; <span class="comment">//客户端的IP</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ctcpserver</span>():<span class="built_in">m_clientfd</span>(<span class="number">-1</span>), <span class="built_in">m_listenfd</span>(<span class="number">-1</span>)&#123;&#125;</span><br><span class="line">    <span class="comment">//创建监听socket,并初始化它</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">initserver</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">short</span> in_port)</span></span>&#123;</span><br><span class="line">        <span class="comment">//第一步创建socket</span></span><br><span class="line">        <span class="keyword">if</span>((m_listenfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>)) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 第二部 将ip地址和端口绑在socket上</span></span><br><span class="line">        m_port = in_port;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> servaddr;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="built_in">sizeof</span>(servaddr));</span><br><span class="line">        servaddr.sin_family = AF_INET;</span><br><span class="line">        servaddr.sin_port = <span class="built_in">htons</span>(m_port);</span><br><span class="line">        servaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">bind</span>(m_listenfd, (<span class="type">const</span> sockaddr *)&amp;servaddr, <span class="built_in">sizeof</span>(servaddr)) == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">close</span>(m_listenfd);</span><br><span class="line">            m_listenfd = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第三步打开监听状态</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">listen</span>(m_listenfd, <span class="number">5</span>) == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">close</span>(m_listenfd);</span><br><span class="line">            m_listenfd = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">accept</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> caddr; <span class="comment">// 客户端的地址信息</span></span><br><span class="line">        <span class="type">socklen_t</span> addrlen = <span class="built_in">sizeof</span>(caddr); <span class="comment">// 上面的大小</span></span><br><span class="line">        <span class="comment">//accept,三个参数第一个为监听socket的fd值，第二个为ip地址的地址，第三个为ip地址大小的地址</span></span><br><span class="line">        <span class="keyword">if</span>((m_clientfd = ::<span class="built_in">accept</span>(m_listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;caddr, &amp;addrlen)) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        m_clientip = <span class="built_in">inet_ntoa</span>(caddr.sin_addr); <span class="comment">//把客户端的地址从大端序转换成字符串</span></span><br><span class="line">        <span class="keyword">return</span> truei;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> std::string &amp; <span class="title">clientip</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_clientip;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">send</span><span class="params">(<span class="type">const</span> std::string&amp; buffer)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_clientfd == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>((::<span class="built_in">send</span>(m_clientfd, buffer.<span class="built_in">data</span>(), buffer.<span class="built_in">size</span>(), <span class="number">0</span>)) &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">recv</span><span class="params">(std::string &amp;buffer, <span class="type">const</span> <span class="type">size_t</span> maxlen)</span></span>&#123;</span><br><span class="line">        buffer.<span class="built_in">clear</span>();  <span class="comment">//清空内存</span></span><br><span class="line">        buffer.<span class="built_in">resize</span>(maxlen); <span class="comment">//设置容器大小为maxlen</span></span><br><span class="line">        <span class="type">int</span> readn = ::<span class="built_in">recv</span>(m_clientfd, &amp;buffer[<span class="number">0</span>], buffer.<span class="built_in">size</span>(), <span class="number">0</span>); <span class="comment">//直接操作buffer的内存</span></span><br><span class="line">        <span class="keyword">if</span>(readn &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            buffer.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        buffer.<span class="built_in">resize</span>(readn);<span class="comment">//重置大小</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 以下要分开两个成员函数 不能写在一个函数里面</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">closelisten</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_listenfd == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        ::<span class="built_in">close</span>(m_listenfd);</span><br><span class="line">        m_listenfd = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">closeclient</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_clientfd == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        ::<span class="built_in">close</span>(m_clientfd);</span><br><span class="line">        m_clientfd = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭socket资源</span></span><br><span class="line">    ~<span class="built_in">ctcpserver</span>()&#123;</span><br><span class="line">        <span class="built_in">closelisten</span>();</span><br><span class="line">        <span class="built_in">closeclient</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>)&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Using:./server 通讯端口\n Example：./server 5005\n\n&quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;注意：运行服务端的程序Linux系统的防火墙必须要开通5005端口\n&quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;如果是云服务器，还有开通云平台的访问策略&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ctcpserver tcpserver;</span><br><span class="line">    <span class="keyword">if</span>(!tcpserver.<span class="built_in">initserver</span>(<span class="built_in">atoi</span>(argv[<span class="number">1</span>])))&#123;<span class="comment">// 初始化服务端用于监听的socket</span></span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;initserver&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//第四步：受理客户端的链接请求，如果没有客户端练上来，accept（）将阻塞等待</span></span><br><span class="line">    <span class="keyword">if</span>(!tcpserver.<span class="built_in">accept</span>())&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;客户端已连接( &quot;</span> &lt;&lt; tcpserver.<span class="built_in">clientip</span>() &lt;&lt; <span class="string">&quot;)。\n&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第五步：接收客户端发来的信息，并发送回应报文</span></span><br><span class="line">    std::string buffer;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//接收客户端的请求，没有哦请求就阻塞recv()等待</span></span><br><span class="line">        <span class="comment">//如果客户端已断开连接，recv函数将返回0</span></span><br><span class="line">        <span class="keyword">if</span>(!tcpserver.<span class="built_in">recv</span>(buffer, <span class="number">1024</span>))&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;recv&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;接收&quot;</span> &lt;&lt; buffer &lt;&lt; std::endl;</span><br><span class="line">        </span><br><span class="line">        buffer = <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!tcpserver.<span class="built_in">send</span>(buffer))&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;send&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;发送：&quot;</span> &lt;&lt; buffer &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多进程的服务端代码"><a href="#多进程的服务端代码" class="headerlink" title="多进程的服务端代码"></a>多进程的服务端代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    程序名:server2.cpp 是用来演示多进程的socket服务端</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span><span class="comment">//sockaddr_in需要</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span><span class="comment">//hostent需要</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FatherEXIT</span><span class="params">(<span class="type">int</span> sig)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChildEXIT</span><span class="params">(<span class="type">int</span> sig)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// accept的过程理解为受理客户端的链接(从已连接的客户端中取出一个客户端)，一个服务端可以和很多客户端通信</span></span><br><span class="line"><span class="comment">//如果没有已连接的客户端，accept将阻塞</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ctcpserver</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_listenfd; <span class="comment">//监听的socket，-1表示未初始化</span></span><br><span class="line">    <span class="type">int</span> m_clientfd; <span class="comment">//客户端练上来的socket，-1表示未初始化</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> m_port;<span class="comment">//服务器用于通信的端口</span></span><br><span class="line">    std::string m_clientip; <span class="comment">//客户端的IP</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ctcpserver</span>():<span class="built_in">m_clientfd</span>(<span class="number">-1</span>), <span class="built_in">m_listenfd</span>(<span class="number">-1</span>)&#123;&#125;</span><br><span class="line">    <span class="comment">//创建监听socket,并初始化它</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">initserver</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">short</span> in_port)</span></span>&#123;</span><br><span class="line">        <span class="comment">//第一步创建socket</span></span><br><span class="line">        <span class="keyword">if</span>((m_listenfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>)) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 第二部 将ip地址和端口绑在socket上</span></span><br><span class="line">        m_port = in_port;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> servaddr;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="built_in">sizeof</span>(servaddr));</span><br><span class="line">        servaddr.sin_family = AF_INET;</span><br><span class="line">        servaddr.sin_port = <span class="built_in">htons</span>(m_port);</span><br><span class="line">        servaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">bind</span>(m_listenfd, (<span class="type">const</span> sockaddr *)&amp;servaddr, <span class="built_in">sizeof</span>(servaddr)) == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">close</span>(m_listenfd);</span><br><span class="line">            m_listenfd = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第三步打开监听状态</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">listen</span>(m_listenfd, <span class="number">5</span>) == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">close</span>(m_listenfd);</span><br><span class="line">            m_listenfd = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">accept</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> caddr; <span class="comment">// 客户端的地址信息</span></span><br><span class="line">        <span class="type">socklen_t</span> addrlen = <span class="built_in">sizeof</span>(caddr); <span class="comment">// 上面的大小</span></span><br><span class="line">        <span class="comment">//accept,三个参数第一个为监听socket的fd值，第二个为ip地址的地址，第三个为ip地址大小的地址</span></span><br><span class="line">        <span class="keyword">if</span>((m_clientfd = ::<span class="built_in">accept</span>(m_listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;caddr, &amp;addrlen)) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        m_clientip = <span class="built_in">inet_ntoa</span>(caddr.sin_addr); <span class="comment">//把客户端的地址从大端序转换成字符串</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> std::string &amp; <span class="title">clientip</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_clientip;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">send</span><span class="params">(<span class="type">const</span> std::string&amp; buffer)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_clientfd == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>((::<span class="built_in">send</span>(m_clientfd, buffer.<span class="built_in">data</span>(), buffer.<span class="built_in">size</span>(), <span class="number">0</span>)) &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">recv</span><span class="params">(std::string &amp;buffer, <span class="type">const</span> <span class="type">size_t</span> maxlen)</span></span>&#123;</span><br><span class="line">        buffer.<span class="built_in">clear</span>();  <span class="comment">//清空内存</span></span><br><span class="line">        buffer.<span class="built_in">resize</span>(maxlen); <span class="comment">//设置容器大小为maxlen</span></span><br><span class="line">        <span class="type">int</span> readn = ::<span class="built_in">recv</span>(m_clientfd, &amp;buffer[<span class="number">0</span>], buffer.<span class="built_in">size</span>(), <span class="number">0</span>); <span class="comment">//直接操作buffer的内存</span></span><br><span class="line">        <span class="keyword">if</span>(readn &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            buffer.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        buffer.<span class="built_in">resize</span>(readn);<span class="comment">//重置大小</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 以下要分开两个成员函数 不能写在一个函数里面</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">closelisten</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_listenfd == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        ::<span class="built_in">close</span>(m_listenfd);</span><br><span class="line">        m_listenfd = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">closeclient</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_clientfd == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        ::<span class="built_in">close</span>(m_clientfd);</span><br><span class="line">        m_clientfd = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭socket资源</span></span><br><span class="line">    ~<span class="built_in">ctcpserver</span>()&#123;</span><br><span class="line">        <span class="built_in">closelisten</span>();</span><br><span class="line">        <span class="built_in">closeclient</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ctcpserver tcpserver;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>)&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Using:./server 通讯端口\n Example：./server 5005\n\n&quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;注意：运行服务端的程序Linux系统的防火墙必须要开通5005端口\n&quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;如果是云服务器，还有开通云平台的访问策略&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 忽视全部的信号，不希望被打扰，顺便解决了僵尸进程的问题</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">65</span>; i ++) <span class="built_in">signal</span>(i, SIG_IGN);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置信号，在shell状态下，可用kill 进程号 或者 Cirl + c 正常终止这些进程</span></span><br><span class="line">    <span class="comment">// 但请不要用 kill -9 + 进程号 强行终止</span></span><br><span class="line">    <span class="built_in">signal</span>(SIGTERM, FatherEXIT); <span class="comment">//15信号,这行的代码意思是自己规定一个信号处理函数</span></span><br><span class="line">    <span class="built_in">signal</span>(SIGINT, FatherEXIT);<span class="comment">// 2信号</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!tcpserver.<span class="built_in">initserver</span>(<span class="built_in">atoi</span>(argv[<span class="number">1</span>])))&#123;<span class="comment">// 初始化服务端用于监听的socket</span></span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;initserver&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第四步：受理客户端的链接请求，如果没有客户端练上来，accept（）将阻塞等待</span></span><br><span class="line">        <span class="keyword">if</span>(!tcpserver.<span class="built_in">accept</span>())&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> pid = fork();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//系统资源不足时</span></span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 父进程返回到循环开始的位置，继续受理客户端的链接</span></span><br><span class="line">        <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//父进程不需要客户端连接socket</span></span><br><span class="line">            <span class="comment">//tcpserver.closeclient();</span></span><br><span class="line">            <span class="keyword">continue</span>; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 子进程负责与客户端进行通讯</span></span><br><span class="line">        <span class="comment">// 子进程不需要监听窗口</span></span><br><span class="line">       <span class="comment">// tcpserver.closelisten();</span></span><br><span class="line">        <span class="built_in">signal</span>(SIGTERM, ChildEXIT);<span class="comment">//规定一个子进程退出信号</span></span><br><span class="line">        <span class="built_in">signal</span>(SIGINT, SIG_IGN);<span class="comment">//子进程不需要捕获SIGINT信号</span></span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;客户端已连接( &quot;</span> &lt;&lt; tcpserver.<span class="built_in">clientip</span>() &lt;&lt; <span class="string">&quot;)。\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第五步：接收客户端发来的信息，并发送回应报文</span></span><br><span class="line">        std::string buffer;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//接收客户端的请求，没有哦请求就阻塞recv()等待</span></span><br><span class="line">            <span class="comment">//如果客户端已断开连接，recv函数将返回0</span></span><br><span class="line">            <span class="keyword">if</span>(!tcpserver.<span class="built_in">recv</span>(buffer, <span class="number">1024</span>))&#123;</span><br><span class="line">                <span class="built_in">perror</span>(<span class="string">&quot;recv&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;接收&quot;</span> &lt;&lt; buffer &lt;&lt; std::endl;</span><br><span class="line">            buffer = <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span>(!tcpserver.<span class="built_in">send</span>(buffer))&#123;</span><br><span class="line">                <span class="built_in">perror</span>(<span class="string">&quot;send&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;发送：&quot;</span> &lt;&lt; buffer &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FatherEXIT</span><span class="params">(<span class="type">int</span> sig)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 以下代码是为了防止信号处理函数在执行的过程中被信号再次中断</span></span><br><span class="line">    <span class="built_in">signal</span>(SIGTERM, SIG_IGN);</span><br><span class="line">    <span class="built_in">signal</span>(SIGINT, SIG_IGN);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;父进程&quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; <span class="string">&quot;正在退出, sig=&quot;</span> &lt;&lt; sig &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">kill</span>(<span class="number">0</span>,SIGTERM);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;子进程&quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; <span class="string">&quot;正在释放父进程的资源以及全局资源&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 这里些释放资源的代码</span></span><br><span class="line">    tcpserver.<span class="built_in">closelisten</span>(); <span class="comment">// 关闭监听socket</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChildEXIT</span><span class="params">(<span class="type">int</span> sig)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 以下代码是为了防止信号处理函数在执行的过程中被信号再次中断</span></span><br><span class="line">    <span class="built_in">signal</span>(SIGTERM, SIG_IGN);</span><br><span class="line">    <span class="built_in">signal</span>(SIGINT, SIG_IGN);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;子进程&quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; <span class="string">&quot;正在退出, sig=&quot;</span> &lt;&lt; sig &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;子进程&quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; <span class="string">&quot;正在释放子进程的资源&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 这里些释放资源的代码</span></span><br><span class="line">    tcpserver.<span class="built_in">closeclient</span>(); <span class="comment">// 关闭客户端连接socket</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意一定要释放资源，在子进程中关闭监听socket，在父进程中关闭 客户端连接socket，杀死进程时一定要释放资源</li></ul><h4 id="void-是什么？"><a href="#void-是什么？" class="headerlink" title="void * 是什么？"></a>void * 是什么？</h4><ul><li>void * 是一个跳跃力(+1 后跨越的幅度)未定的指针<br>这就是它的神奇之处了，我们可以自己控制在需要的时候将它实现为需要的类型。这样的好处是：编程时候节约代码，实现泛型编程。</li><li>void <em>是一种指针类型，常用在函数参数、函数返回值中需要兼容不同指针类型的地方。我们可以将别的类型的指针无需强制类型转换的赋值给void</em>类型。也可以将void *强制类型转换成任何别的指针类型，至于强转的类型是否合理，就需要我们程序员自己控制了。</li></ul><h3 id="文件传输"><a href="#文件传输" class="headerlink" title="文件传输"></a>文件传输</h3><h4 id="服务端代码"><a href="#服务端代码" class="headerlink" title="服务端代码"></a>服务端代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    程序名:server3.cpp 是用来演示文件传输的多进程的socket服务端</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span><span class="comment">//sockaddr_in需要</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span><span class="comment">//hostent需要</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FatherEXIT</span><span class="params">(<span class="type">int</span> sig)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChildEXIT</span><span class="params">(<span class="type">int</span> sig)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// accept的过程理解为受理客户端的链接(从已连接的客户端中取出一个客户端)，一个服务端可以和很多客户端通信</span></span><br><span class="line"><span class="comment">//如果没有已连接的客户端，accept将阻塞</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ctcpserver</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_listenfd; <span class="comment">//监听的socket，-1表示未初始化</span></span><br><span class="line">    <span class="type">int</span> m_clientfd; <span class="comment">//客户端练上来的socket，-1表示未初始化</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> m_port;<span class="comment">//服务器用于通信的端口</span></span><br><span class="line">    std::string m_clientip; <span class="comment">//客户端的IP</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ctcpserver</span>():<span class="built_in">m_clientfd</span>(<span class="number">-1</span>), <span class="built_in">m_listenfd</span>(<span class="number">-1</span>)&#123;&#125;</span><br><span class="line">    <span class="comment">//创建监听socket,并初始化它</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">initserver</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">short</span> in_port)</span></span>&#123;</span><br><span class="line">        <span class="comment">//第一步创建socket</span></span><br><span class="line">        <span class="keyword">if</span>((m_listenfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>)) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 第二部 将ip地址和端口绑在socket上</span></span><br><span class="line">        m_port = in_port;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> servaddr;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="built_in">sizeof</span>(servaddr));</span><br><span class="line">        servaddr.sin_family = AF_INET;</span><br><span class="line">        servaddr.sin_port = <span class="built_in">htons</span>(m_port);</span><br><span class="line">        servaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">bind</span>(m_listenfd, (<span class="type">const</span> sockaddr *)&amp;servaddr, <span class="built_in">sizeof</span>(servaddr)) == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">close</span>(m_listenfd);</span><br><span class="line">            m_listenfd = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第三步打开监听状态</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">listen</span>(m_listenfd, <span class="number">5</span>) == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">close</span>(m_listenfd);</span><br><span class="line">            m_listenfd = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">accept</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> caddr; <span class="comment">// 客户端的地址信息</span></span><br><span class="line">        <span class="type">socklen_t</span> addrlen = <span class="built_in">sizeof</span>(caddr); <span class="comment">// 上面的大小</span></span><br><span class="line">        <span class="comment">//accept,三个参数第一个为监听socket的fd值，第二个为ip地址的地址，第三个为ip地址大小的地址</span></span><br><span class="line">        <span class="keyword">if</span>((m_clientfd = ::<span class="built_in">accept</span>(m_listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;caddr, &amp;addrlen)) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        m_clientip = <span class="built_in">inet_ntoa</span>(caddr.sin_addr); <span class="comment">//把客户端的地址从大端序转换成字符串</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> std::string &amp; <span class="title">clientip</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_clientip;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送报文</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">send</span><span class="params">(<span class="type">const</span> std::string&amp; buffer)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_clientfd == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>((::<span class="built_in">send</span>(m_clientfd, buffer.<span class="built_in">data</span>(), buffer.<span class="built_in">size</span>(), <span class="number">0</span>)) &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//接受报文</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">recv</span><span class="params">(std::string &amp;buffer, <span class="type">const</span> <span class="type">size_t</span> maxlen)</span></span>&#123;</span><br><span class="line">        buffer.<span class="built_in">clear</span>();  <span class="comment">//清空内存</span></span><br><span class="line">        buffer.<span class="built_in">resize</span>(maxlen); <span class="comment">//设置容器大小为maxlen</span></span><br><span class="line">        <span class="type">int</span> readn = ::<span class="built_in">recv</span>(m_clientfd, &amp;buffer[<span class="number">0</span>], buffer.<span class="built_in">size</span>(), <span class="number">0</span>); <span class="comment">//直接操作buffer的内存</span></span><br><span class="line">        <span class="keyword">if</span>(readn &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            buffer.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        buffer.<span class="built_in">resize</span>(readn);<span class="comment">//重置大小</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收文件名称和大小</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">recv</span><span class="params">(<span class="type">void</span> *buffer, <span class="type">const</span> <span class="type">size_t</span> maxlen)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(::<span class="built_in">recv</span>(m_clientfd, buffer, maxlen, <span class="number">0</span>) &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收文件内容</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">recvfile</span><span class="params">(<span class="type">const</span> std::string &amp;filename, <span class="type">const</span> <span class="type">size_t</span> filesize)</span></span>&#123;</span><br><span class="line">        std::ofstream fout;</span><br><span class="line">        fout.<span class="built_in">open</span>(filename, std::ios::out);</span><br><span class="line">        <span class="keyword">if</span>(!fout.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;打开文件&quot;</span> &lt;&lt; filename &lt;&lt; <span class="string">&quot;失败。\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> totalbytes = <span class="number">0</span>; <span class="comment">//已经接受的文件总字节数</span></span><br><span class="line">        <span class="type">int</span> onread = <span class="number">0</span>; <span class="comment">//本次打算接受的字节数</span></span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">1000</span>]; <span class="comment">// 接收文件内容的缓冲区</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">// 计算被你应该就收的字节数</span></span><br><span class="line">            <span class="keyword">if</span>(filesize - totalbytes &gt; <span class="number">1000</span>) onread = <span class="number">1000</span>;</span><br><span class="line">            <span class="keyword">else</span> onread = filesize - totalbytes;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//接收文件内容</span></span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">recv</span>(buffer, onread)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 把接收到的内容写入文件</span></span><br><span class="line">            fout.<span class="built_in">write</span>(buffer, onread);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//计算已经接收文件的总字节数，如果文件接受完跳出循环</span></span><br><span class="line">            totalbytes += onread;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(totalbytes == filesize) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 以下要分开两个成员函数 不能写在一个函数里面</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">closelisten</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_listenfd == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        ::<span class="built_in">close</span>(m_listenfd);</span><br><span class="line">        m_listenfd = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">closeclient</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_clientfd == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        ::<span class="built_in">close</span>(m_clientfd);</span><br><span class="line">        m_clientfd = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭socket资源</span></span><br><span class="line">    ~<span class="built_in">ctcpserver</span>()&#123;</span><br><span class="line">        <span class="built_in">closelisten</span>();</span><br><span class="line">        <span class="built_in">closeclient</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ctcpserver tcpserver;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st_fileinfo</span>&#123;</span><br><span class="line">    <span class="type">char</span> filename[<span class="number">256</span>];</span><br><span class="line">    <span class="type">int</span> filesize;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">3</span>)&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Using:./server 通讯端口 文件存放目录\n Example：./server 5005 /tmp\n\n&quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;注意：运行服务端的程序Linux系统的防火墙必须要开通5005端口\n&quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;如果是云服务器，还有开通云平台的访问策略&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 忽视全部的信号，不希望被打扰，顺便解决了僵尸进程的问题</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">65</span>; i ++) <span class="built_in">signal</span>(i, SIG_IGN);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置信号，在shell状态下，可用kill 进程号 或者 Cirl + c 正常终止这些进程</span></span><br><span class="line">    <span class="comment">// 但请不要用 kill -9 + 进程号 强行终止</span></span><br><span class="line">    <span class="built_in">signal</span>(SIGTERM, FatherEXIT); <span class="comment">//15信号,这行的代码意思是自己规定一个信号处理函数</span></span><br><span class="line">    <span class="built_in">signal</span>(SIGINT, FatherEXIT);<span class="comment">// 2信号</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!tcpserver.<span class="built_in">initserver</span>(<span class="built_in">atoi</span>(argv[<span class="number">1</span>])))&#123;<span class="comment">// 初始化服务端用于监听的socket</span></span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;initserver&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第四步：受理客户端的链接请求，如果没有客户端练上来，accept（）将阻塞等待</span></span><br><span class="line">        <span class="keyword">if</span>(!tcpserver.<span class="built_in">accept</span>())&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> pid = fork();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//系统资源不足时</span></span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 父进程返回到循环开始的位置，继续受理客户端的链接</span></span><br><span class="line">        <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//父进程不需要客户端连接socket</span></span><br><span class="line">            <span class="comment">//tcpserver.closeclient();</span></span><br><span class="line">            <span class="keyword">continue</span>; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 子进程负责与客户端进行通讯</span></span><br><span class="line">        <span class="comment">// 子进程不需要监听窗口</span></span><br><span class="line">       <span class="comment">// tcpserver.closelisten();</span></span><br><span class="line">        <span class="built_in">signal</span>(SIGTERM, ChildEXIT);<span class="comment">//规定一个子进程退出信号</span></span><br><span class="line">        <span class="built_in">signal</span>(SIGINT, SIG_IGN);<span class="comment">//子进程不需要捕获SIGINT信号</span></span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;客户端已连接( &quot;</span> &lt;&lt; tcpserver.<span class="built_in">clientip</span>() &lt;&lt; <span class="string">&quot;)。\n&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//以下是服务端的流程</span></span><br><span class="line">        <span class="comment">//1）接收文件名和文件大小信息</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">st_fileinfo</span> fileinfo;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;fileinfo, <span class="number">0</span>, <span class="built_in">sizeof</span>(fileinfo));</span><br><span class="line">        <span class="comment">// 用结构体文件来接受发来的文件信息</span></span><br><span class="line">        <span class="keyword">if</span>(!tcpserver.<span class="built_in">recv</span>(&amp;fileinfo, <span class="built_in">sizeof</span>(fileinfo)))&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;recv&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;收到文件名 （&quot;</span> &lt;&lt; fileinfo.filename &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; fileinfo.filesize &lt;&lt; std::endl;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">//2）给客户端回复确认报文（表示客户端可以发文件）</span></span><br><span class="line">        <span class="keyword">if</span>(!tcpserver.<span class="built_in">send</span>(<span class="string">&quot;ok&quot;</span>))&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;send&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;发送OK&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3）接收文件内容</span></span><br><span class="line">        <span class="keyword">if</span>(!tcpserver.<span class="built_in">recvfile</span>(std::<span class="built_in">string</span>(argv[<span class="number">2</span>]) + <span class="string">&quot;/&quot;</span> + fileinfo.filename, fileinfo.filesize))&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;接收文件内容失败&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;接收文件内容成功&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">//4）给客户端回复确认报文（表示服务端接收成功）</span></span><br><span class="line">        <span class="keyword">if</span>(!tcpserver.<span class="built_in">send</span>(<span class="string">&quot;ok&quot;</span>))&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;send&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;文件传输完毕\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FatherEXIT</span><span class="params">(<span class="type">int</span> sig)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 以下代码是为了防止信号处理函数在执行的过程中被信号再次中断</span></span><br><span class="line">    <span class="built_in">signal</span>(SIGTERM, SIG_IGN);</span><br><span class="line">    <span class="built_in">signal</span>(SIGINT, SIG_IGN);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;父进程&quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; <span class="string">&quot;正在退出, sig=&quot;</span> &lt;&lt; sig &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">kill</span>(<span class="number">0</span>,SIGTERM);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;子进程&quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; <span class="string">&quot;正在释放父进程的资源以及全局资源&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 这里些释放资源的代码</span></span><br><span class="line">    tcpserver.<span class="built_in">closelisten</span>(); <span class="comment">// 关闭监听socket</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChildEXIT</span><span class="params">(<span class="type">int</span> sig)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 以下代码是为了防止信号处理函数在执行的过程中被信号再次中断</span></span><br><span class="line">    <span class="built_in">signal</span>(SIGTERM, SIG_IGN);</span><br><span class="line">    <span class="built_in">signal</span>(SIGINT, SIG_IGN);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;子进程&quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; <span class="string">&quot;正在退出, sig=&quot;</span> &lt;&lt; sig &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;子进程&quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; <span class="string">&quot;正在释放子进程的资源&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 这里些释放资源的代码</span></span><br><span class="line">    tcpserver.<span class="built_in">closeclient</span>(); <span class="comment">// 关闭客户端连接socket</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="客户端代码"><a href="#客户端代码" class="headerlink" title="客户端代码"></a>客户端代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span><span class="comment">//sockaddr_in需要</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span><span class="comment">//hostent需要</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    用来演示文件传输的客户端</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ctcpclient</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_clientfd; <span class="comment">// 客户端的socket，-1表示未连接或连接已断开，&gt;=0 表示有效的socket</span></span><br><span class="line">    std::string m_ip; <span class="comment">// 服务器的IP/域名</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> m_port; <span class="comment">// 通讯端口</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//向服务端发起连接请求，成功返回true，失败false</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">connect</span><span class="params">(<span class="type">const</span> std::string&amp; in_ip, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">short</span> in_port)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 建立套接字</span></span><br><span class="line">        m_clientfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(m_clientfd == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 向服务端发送连接请求</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> servaddr;</span><br><span class="line">        m_ip = in_ip;</span><br><span class="line">        m_port = in_port;</span><br><span class="line">        servaddr.sin_family = AF_INET;</span><br><span class="line">        servaddr.sin_port = <span class="built_in">htons</span>(m_port);</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">hostent</span>* h;</span><br><span class="line">        <span class="keyword">if</span>((h = <span class="built_in">gethostbyname</span>(m_ip.<span class="built_in">c_str</span>())) == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="built_in">close</span>();</span><br><span class="line">            m_clientfd = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;servaddr.sin_addr, h-&gt;h_addr, h-&gt;h_length);</span><br><span class="line">        <span class="comment">// 以下错误常犯，注意当你想使用全局函数或者全局同名变量的时候 要在前面+::</span></span><br><span class="line">        <span class="keyword">if</span>(::<span class="built_in">connect</span>(m_clientfd, (<span class="keyword">struct</span> sockaddr *) &amp;servaddr, <span class="built_in">sizeof</span>(servaddr)) == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">close</span>();</span><br><span class="line">            m_clientfd = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为什么不用const char * 因为const char * 无法支持string,而下列可以支持从const char *</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">send</span><span class="params">(<span class="type">const</span> std::string&amp; buffer)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_clientfd == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//一定不要忘了::</span></span><br><span class="line">        <span class="keyword">if</span>(::<span class="built_in">send</span>(m_clientfd, buffer.<span class="built_in">data</span>(), buffer.<span class="built_in">size</span>(), <span class="number">0</span>) &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用于发送文件结构体</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">send</span><span class="params">(<span class="type">void</span> *buffer, <span class="type">const</span> <span class="type">size_t</span> maxlen)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_clientfd == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(::<span class="built_in">send</span>(m_clientfd, buffer, maxlen, <span class="number">0</span>) &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">sendfile</span><span class="params">(<span class="type">const</span> std::string &amp;filename, <span class="type">const</span> <span class="type">size_t</span> filesize)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 以二进制形式打开文件</span></span><br><span class="line">        <span class="function">std::ifstream <span class="title">fin</span><span class="params">(filename, std::ios::in)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(fin.<span class="built_in">is_open</span>() == <span class="literal">false</span>)&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;打开文件&quot;</span> &lt;&lt; filename &lt;&lt; <span class="string">&quot;失败.\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> onread = <span class="number">0</span>; <span class="comment">//每次调用fin.read()打算读取的字节数</span></span><br><span class="line">        <span class="type">int</span> totalbytes = <span class="number">0</span>;<span class="comment">// 从文件中已经读取的字节总数</span></span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">1000</span>]; <span class="comment">// 存放读取数据的buffer</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算本次应该读取的字节数，如果剩余超过1000字节，就读1000字节</span></span><br><span class="line">            <span class="keyword">if</span>(filesize - totalbytes &gt; <span class="number">1000</span>) onread = <span class="number">1000</span>;</span><br><span class="line">            <span class="keyword">else</span> onread = filesize - totalbytes;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从文件中读取数据</span></span><br><span class="line">            fin.<span class="built_in">read</span>(buffer, onread);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 把读取到的数据发送给对端</span></span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">send</span>(buffer, onread)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算文件已经读取的字节总个数，如果文件已经读完，跳出循环</span></span><br><span class="line">            totalbytes += onread;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(totalbytes == filesize) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收服务端的报文，成功返回true，失败返回false</span></span><br><span class="line">    <span class="comment">//buffer存放接收到的报文内容，maxlen本次接收报文的长度</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">recv</span><span class="params">(std::string&amp; buffer,<span class="type">const</span> <span class="type">size_t</span> maxlen)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果直接操作string对象的内存，必须保证1）不能越界，2）操作后手动设置数据大小</span></span><br><span class="line">        buffer.<span class="built_in">clear</span>();</span><br><span class="line">        std::cout &lt;&lt; buffer &lt;&lt;  std::endl;</span><br><span class="line">        buffer.<span class="built_in">resize</span>(maxlen);</span><br><span class="line">        <span class="type">int</span> readn=::<span class="built_in">recv</span>(m_clientfd, &amp;buffer[<span class="number">0</span>], buffer.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//-1表示失败，0表示断开连接，成功放回数据大小</span></span><br><span class="line">        <span class="keyword">if</span>(readn &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            buffer.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        buffer.<span class="built_in">resize</span>(readn); <span class="comment">//重置buffer的实际大小</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_clientfd == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ::<span class="built_in">close</span>(m_clientfd);</span><br><span class="line">        m_clientfd = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ctcpclient</span>():<span class="built_in">m_clientfd</span>(<span class="number">-1</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">ctcpclient</span>()&#123;<span class="built_in">close</span>();&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">5</span>)&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Using:./client 服务端IP地址 服务端的端口, 文件名，文件大小\n&quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Example：./client 192.168.168.1 5005 aaa.txt 2424\n\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ctcpclient tcpclient;</span><br><span class="line">    <span class="keyword">if</span>(!tcpclient.<span class="built_in">connect</span>(argv[<span class="number">1</span>], <span class="built_in">atoi</span>(argv[<span class="number">2</span>])))&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下是发送文件的流程</span></span><br><span class="line">    <span class="comment">// 1）把传输的文件名和文件大小告诉服务端</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义文件信息结构体</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">st_fileinfo</span>&#123;</span><br><span class="line">        <span class="type">char</span> filename[<span class="number">256</span>];</span><br><span class="line">        <span class="type">int</span> filesize;</span><br><span class="line">    &#125;fileinfo;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;fileinfo, <span class="number">0</span>, <span class="built_in">sizeof</span>(fileinfo));</span><br><span class="line">    <span class="built_in">strcpy</span>(fileinfo.filename, argv[<span class="number">3</span>]);<span class="comment">//文件名</span></span><br><span class="line">    fileinfo.filesize = <span class="built_in">atoi</span>(argv[<span class="number">4</span>]);<span class="comment">//文件大小</span></span><br><span class="line">    <span class="comment">//把文件信息的结构题发送给服务端</span></span><br><span class="line">    <span class="keyword">if</span>(!tcpclient.<span class="built_in">send</span>(&amp;fileinfo, <span class="built_in">sizeof</span>(fileinfo)))&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;send&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;发送文件信息的结构体&quot;</span> &lt;&lt; fileinfo.filename &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; fileinfo.filesize &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2）等待服务端的确认报文（对文件名和文件的大小的确认）</span></span><br><span class="line">    std::string buffer;</span><br><span class="line">    <span class="keyword">if</span>(!tcpclient.<span class="built_in">recv</span>(buffer, <span class="number">1024</span>))&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;recv&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(buffer != <span class="string">&quot;ok&quot;</span>) std::cout &lt;&lt; <span class="string">&quot;服务端没有回复ok\n&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 3）发送文件内容</span></span><br><span class="line">    <span class="keyword">if</span>(!tcpclient.<span class="built_in">sendfile</span>(fileinfo.filename, fileinfo.filesize))&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;sendfile&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4）等待服务端的确认报文（服务端已接受完文件）</span></span><br><span class="line">    <span class="keyword">if</span>(!tcpclient.<span class="built_in">recv</span>(buffer, <span class="number">2</span>))&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;recv&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(buffer != <span class="string">&quot;ok&quot;</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;发送文件内容失败。\n&quot;</span>; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三次握手，四次挥手"><a href="#三次握手，四次挥手" class="headerlink" title="三次握手，四次挥手"></a>三次握手，四次挥手</h3><ul><li>yum install net-tools -y; 下载工具包</li><li>netstat -na|less 查看套接字状态</li></ul><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p><img src="../assets/网络编程/image-99.png" alt="示例图片" style="zoom:100%;" /></p><p><img src="../assets/网络编程/image-100.png" alt="示例图片" style="zoom:100%;" /></p><h5 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h5><ul><li>客户端也有端口号，对于程序员来说，可以不必关心客户端的端口号，所以系统随机分配（socket 通讯中的地址包括ip和端口号，但是习惯地址仅仅指ip地址）</li><li>服务端的bind函数，普通用户必须是使用1024以上端口，root任意</li><li>listen函数第二个参数+1为已连接队列的大小，一次能接受多少</li><li>SYN_RECV状态的连接也称半连接</li><li>CLOSED是假象状态，实际不存在</li></ul><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p><img src="../assets/网络编程/image-102.png" alt="示例图片" style="zoom:100%;" /></p><p><img src="../assets/网络编程/image-101.png" alt="示例图片" style="zoom:100%;" /></p><h5 id="细节-1"><a href="#细节-1" class="headerlink" title="细节"></a>细节</h5><ul><li>主动断开短端在四次挥手后，socket的状态为 TIME_WAIT状态，将持续2MSL（30s/1min/2min）MSL表示报文在网路中存在的最长时间</li><li>如果客户端主动断开连接，TIME_WAIT状态几乎不会造成危害<ol><li>客户端程序的socket很少</li><li>客户端的窗口是随机分配的，不存在重用问题</li></ol></li><li>如果客户端主动断开，有两方面的危害：1）socket没有立即释放；2）端口后只能在2MSL后才能重用<br>也就是会报这个错误：<br><img src="../assets/网络编程/image-103.png" alt="示例图片" style="zoom:100%;" /></li></ul><h5 id="解决上述问题办法"><a href="#解决上述问题办法" class="headerlink" title="解决上述问题办法"></a>解决上述问题办法</h5><p>在服务端程序中，用setsockopt()函数设置socket的属性(一定要放在bind()前)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TIME_WAIT状态还在，但是仍然可以打开</span></span><br><span class="line"><span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">setsockopt</span>(m_listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt,<span class="built_in">sizeof</span>(opt));</span><br></pre></td></tr></table></figure><h3 id="TCP缓存"><a href="#TCP缓存" class="headerlink" title="TCP缓存"></a>TCP缓存</h3><ul><li>系统为每个socket创建了发送缓冲区和接收缓冲区，应用程序调用send()/write()函数发送数据的时候，内核把数据从应用进程拷贝到sokcet的发送缓存中区中;在调用recv()/read()函数接收数据的时候，内核把数据从socket的接收缓冲区拷贝到应用进程中</li></ul><p><img src="../assets/网络编程/image-104.png" alt="示例图片" style="zoom:100%;" /></p><h4 id="查看缓冲区的大小"><a href="#查看缓冲区的大小" class="headerlink" title="查看缓冲区的大小"></a>查看缓冲区的大小</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> bufsize = <span class="number">0</span>;</span><br><span class="line"><span class="type">socklen_t</span> optlen = <span class="built_in">sizeof</span>(bufsize);</span><br><span class="line"></span><br><span class="line"><span class="built_in">gersockopt</span>(sockfd, SOL_SOCKET, SO_SNDBUF, &amp;bufsize, &amp;optlen);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Send bufsize=&quot;</span> &lt;&lt; buffer &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">getsockopt</span>(sockfd, SOL_SOCKET,SO_RCVBUF,&amp;bufsizem &amp;optlen);</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;recv bufsize =&quot;</span> &lt;&lt; bufsize &lt;&lt; std::endl;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可能遇到的问题：</p><ol><li><p><strong>send（）函数可能会阻塞吗？</strong></p><p> 会，当发送缓冲区满了和服务端接收满了 就会</p></li><li><p><strong>向socket中写入数据后，如果关闭了socket，对端还能接收到数据吗？</strong></p><p> 能，因为这些数据已经存入了对端的接收缓存区中了，即使关闭了socket，之前发送的数据只要还在缓冲区中就能接受</p></li></ol><h4 id="Nagle-算法"><a href="#Nagle-算法" class="headerlink" title="Nagle 算法"></a>Nagle 算法</h4><p><img src="../assets/网络编程/image-105.png" alt="示例图片" style="zoom:100%;" /></p><p><img src="../assets/网络编程/image-106.png" alt="示例图片" style="zoom:100%;" /></p><p><img src="../assets/网络编程/image-107.png" alt="示例图片" style="zoom:100%;" /></p><h3 id="IO多路复用-select模型"><a href="#IO多路复用-select模型" class="headerlink" title="IO多路复用 -select模型"></a>IO多路复用 -select模型</h3><p><img src="../assets/网络编程/image-108.png" alt="示例图片" style="zoom:100%;" /></p><h4 id="什么是IO多路复用"><a href="#什么是IO多路复用" class="headerlink" title="什么是IO多路复用"></a>什么是IO多路复用</h4><ul><li>用一个进/线程处理多个TCP连接，减少系统开销</li><li>三种模型:select(1024), poll(数千)和epoll(百万)</li></ul><p>括号中表示其处理TCP连接的数量</p><h4 id="网络通讯-读事件"><a href="#网络通讯-读事件" class="headerlink" title="网络通讯-读事件"></a>网络通讯-读事件</h4><ul><li>已连接队列中有已经准备好的socket(有新的客户端连上来)</li><li>接收缓存中有数据可以读</li><li>tcp连接已断开（对端关闭了链接）</li></ul><h4 id="网络通讯-写事件"><a href="#网络通讯-写事件" class="headerlink" title="网络通讯-写事件"></a>网络通讯-写事件</h4><ul><li>发送缓冲区没有满，可以写入数据(可以向对端发送报文).</li></ul><h4 id="select-的原理"><a href="#select-的原理" class="headerlink" title="select 的原理"></a>select 的原理</h4><p>select之于服务器server，相当于秘书之于老板，select是由内核提供的。之前没有select时，server要一直accept()阻塞，等待有客户端的连接。</p><p>有了select之后，相当于给各个客户端留电话，谁有事就给秘书打电话，然后秘书告诉老板去调用accept()，创建cfd，和客户端建立连接。</p><p>select自己不会创建出cfd，与客户端连接。</p><p>所以select做的就是监听，lfd。其实请求连接本质是一个读事件，只是读到的数据是连接请求</p><p><img src="../assets/网络编程/image-109.png" alt="示例图片" style="zoom:100%;" /></p><p><img src="image-125.png" alt="alt text"></p><h4 id="select-函数的使用"><a href="#select-函数的使用" class="headerlink" title="select 函数的使用"></a>select 函数的使用</h4><h5 id="select函数的声明"><a href="#select函数的声明" class="headerlink" title="select函数的声明"></a>select函数的声明</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件 </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="comment">//成功返回大于0的数，失败返回-1；这个大于0的数是发生事件的文件描述符数，返回0就是没有哪个文件描述符有事件</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">select</span><span class="params">(<span class="type">int</span> maxfd, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 用于从bitmap中删除socket</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="type">int</span> fd, fd_set *set)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于询问socket 是否存在于bitmap</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set *set)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于将socket 存入bitmap里</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set *set)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于初始化bitmap(都置为0)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *set)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//fd_set是一个集合，fd_set的size值在linux下一般被定义为1024，意思是select管理的文件描述符数量不能大于1024，继而文件描述符取值为0~1023</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//readset、 writeset、exceptset分别对应文件描述符的三种事件，分别是读事件，写事件，异常事件</span></span><br><span class="line"><span class="comment">//timeout是设置的超时时间，防止陷入无限阻塞</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="fd-set的本质如图所示"><a href="#fd-set的本质如图所示" class="headerlink" title="fd_set的本质如图所示"></a>fd_set的本质如图所示</h6><p>是一个bitmap（共1024位）<br><img src="../assets/网络编程/image-110.png" alt="示例图片" style="zoom:100%;" /></p><h6 id="selec服务吨端代码"><a href="#selec服务吨端代码" class="headerlink" title="selec服务吨端代码"></a>selec服务吨端代码</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    此程序用于演示采用select模型实现网络通讯的服务器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化服务器的监听端口</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">initserver</span><span class="params">(<span class="type">int</span> port)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>)&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;usage:./tcpselect port\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化服务端用于监听的socket</span></span><br><span class="line">    <span class="type">int</span> listensock = <span class="built_in">initserver</span>(<span class="built_in">atoi</span>(argv[<span class="number">1</span>]));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;listensock= &quot;</span> &lt;&lt; listensock &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(listensock &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;initserver() failed.\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    fd_set readfds;                 <span class="comment">//需要监视读事件的socket的集合，大小为16字节（1024位）的位图（bitmap）</span></span><br><span class="line">    <span class="built_in">FD_ZERO</span>(&amp;readfds);              <span class="comment">//初始化readfds，把bitmap每位设置为0</span></span><br><span class="line">    <span class="built_in">FD_SET</span>(listensock, &amp;readfds);   <span class="comment">//把服务端用于监控的socket加入readfds</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> maxfd = listensock;         <span class="comment">//readfds中socket的最大值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">timeval</span> timeout;     <span class="comment">//用于表示超时间的结构体</span></span><br><span class="line">        timeout.tv_sec = <span class="number">10</span>;</span><br><span class="line">        timeout.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在select函数中，会修改bitmap 所以要复制一份给tmpfds，在将tmpfds传回给select</span></span><br><span class="line">        fd_set tmpfds = readfds;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//select()等待事件的发生(监视哪些socket发生了事件), 第三个为写事件的bitmap，四个为检测异常事件（可以普通IO）的bitmap</span></span><br><span class="line">        <span class="type">int</span> infds = <span class="built_in">select</span>(maxfd + <span class="number">1</span>, &amp;tmpfds, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, &amp;timeout);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果infds &lt; 0 表示用于表示调用select失败</span></span><br><span class="line">        <span class="keyword">if</span>(infds &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;select() failed&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果infds == 0 表示select（）超时</span></span><br><span class="line">        <span class="keyword">if</span>(infds == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;timeout&quot;</span>);</span><br><span class="line">           <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果infds&gt;0 表示有事件发生，infds存放了已发生事件的个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> eventfd = <span class="number">0</span>; eventfd &lt;= maxfd; eventfd ++)&#123;</span><br><span class="line">            <span class="comment">//如果eventfd在bitmap中标志为0， 表示它没有事件，continue</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">FD_ISSET</span>(eventfd, &amp;tmpfds) == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果发生事件的是listensock，表示已连接队列中有已经准备好的socket(有新的客户端连上来了)</span></span><br><span class="line">            <span class="keyword">if</span>(eventfd == listensock)&#123;</span><br><span class="line">                sockaddr_in client;</span><br><span class="line">                <span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(client);</span><br><span class="line">                <span class="type">int</span> clientsock = <span class="built_in">accept</span>(listensock, (sockaddr *)&amp;client, &amp;len);</span><br><span class="line">                <span class="keyword">if</span>(clientsock &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="built_in">perror</span>(<span class="string">&quot;accept() failed&quot;</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;accept client(socket = %d)pk.\n&quot;</span>, clientsock);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 把bitmap中新连上来的客户端标志位置为1</span></span><br><span class="line">                <span class="built_in">FD_SET</span>(clientsock, &amp;readfds);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//更新maxfd的值,因为如果建立了连接描述符会建立在之前建完后的下一位，不管那个描述符是否被删除</span></span><br><span class="line">                <span class="keyword">if</span>(maxfd &lt; clientsock) maxfd = clientsock;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//如果是客户端连接的socket有事件，表示接收缓存中有数据可以读，或者客户端已断开连接</span></span><br><span class="line">                <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">                <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">recv</span>(eventfd, buffer, <span class="built_in">sizeof</span>(buffer), <span class="number">0</span>) &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//如果客户端的链接已经断开</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client(eventfd = %d) disconnected.\n&quot;</span>, eventfd);</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">close</span>(eventfd);</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">FD_CLR</span>(eventfd, &amp;readfds);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//重新计算maxfd的值，注意只有当eventfd==maxfd时才需要计算</span></span><br><span class="line">                    <span class="keyword">if</span>(eventfd == maxfd)&#123;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> i = maxfd; i &gt; <span class="number">0</span>; i --)&#123; <span class="comment">//从后往前找</span></span><br><span class="line">                            <span class="keyword">if</span>(<span class="built_in">FD_ISSET</span>(i,&amp;readfds))&#123;</span><br><span class="line">                                maxfd = i;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//如果客户端有报文发过来</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;recv(eventfd=%d)%s\n&quot;</span>, eventfd, buffer);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//把接收到的报文内容原封不动的发回去</span></span><br><span class="line">                    <span class="built_in">send</span>(eventfd, buffer, <span class="built_in">strlen</span>(buffer), <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化服务端的监听端口</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">initserver</span><span class="params">(<span class="type">int</span> port)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> sock = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sock &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket() failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> len = <span class="built_in">sizeof</span>(opt);</span><br><span class="line">    <span class="built_in">setsockopt</span>(sock, SOL_SOCKET, SO_REUSEADDR,&amp;opt,len);</span><br><span class="line"></span><br><span class="line">    sockaddr_in servaddr;</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line">    servaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">bind</span>(sock, (sockaddr *)&amp;servaddr, <span class="built_in">sizeof</span>(servaddr)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind() failed&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(sock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">listen</span>(sock, <span class="number">5</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen() failed&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(sock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="select模型的细节"><a href="#select模型的细节" class="headerlink" title="select模型的细节"></a>select模型的细节</h4><h5 id="select模型-写事件"><a href="#select模型-写事件" class="headerlink" title="select模型-写事件"></a>select模型-写事件</h5><ol><li>如果tcp的发送缓冲区没有满，那么, socket连接是可写的</li><li>如果发送数据量太大，或网络带宽不够，发送缓冲区就有填满的可能</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    此程序用于演示采用select模型实现网络通讯的服务器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化服务器的监听端口</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">initserver</span><span class="params">(<span class="type">int</span> port)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>)&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;usage:./tcpselect port\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化服务端用于监听的socket</span></span><br><span class="line">    <span class="type">int</span> listensock = <span class="built_in">initserver</span>(<span class="built_in">atoi</span>(argv[<span class="number">1</span>]));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;listensock= &quot;</span> &lt;&lt; listensock &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(listensock &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;initserver() failed.\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    fd_set readfds;                 <span class="comment">//需要监视读事件的socket的集合，大小为16字节（1024位）的位图（bitmap）</span></span><br><span class="line">    <span class="built_in">FD_ZERO</span>(&amp;readfds);              <span class="comment">//初始化readfds，把bitmap每位设置为0</span></span><br><span class="line">    <span class="built_in">FD_SET</span>(listensock, &amp;readfds);   <span class="comment">//把服务端用于监控的socket加入readfds</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> maxfd = listensock;         <span class="comment">//readfds中socket的最大值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">timeval</span> timeout;     <span class="comment">//用于表示超时间的结构体</span></span><br><span class="line">        timeout.tv_sec = <span class="number">10</span>;</span><br><span class="line">        timeout.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在select函数中，会修改bitmap 所以要复制一份给tmpfds，在将tmpfds传回给select</span></span><br><span class="line">        fd_set tmpfds = readfds;</span><br><span class="line">        fd_set tmpfds1 = readfds;<span class="comment">//用于监视写事件</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//select()等待事件的发生(监视哪些socket发生了事件), 第三个为写事件的bitmap，四个为检测异常事件（可以普通IO）的bitmap</span></span><br><span class="line">        <span class="comment">// 该函数调用后 会修改bitmap，把为准备好的置为0，所以得传入拷贝</span></span><br><span class="line">        <span class="type">int</span> infds = <span class="built_in">select</span>(maxfd + <span class="number">1</span>, &amp;tmpfds, &amp;tmpfds1, <span class="literal">nullptr</span>, &amp;timeout);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果infds &lt; 0 表示用于表示调用select失败</span></span><br><span class="line">        <span class="keyword">if</span>(infds &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;select() failed&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果infds == 0 表示select（）超时</span></span><br><span class="line">        <span class="keyword">if</span>(infds == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;timeout&quot;</span>);</span><br><span class="line">           <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是否有写事件</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> eventfd = <span class="number">0</span>; eventfd &lt;= maxfd; eventfd ++)&#123;</span><br><span class="line">            <span class="comment">//如果eventfd在bitmap中标志为0， 表示它没有事件，continue</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">FD_ISSET</span>(eventfd, &amp;tmpfds) == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;eventfd=%d可以写。\n&quot;</span>, eventfd);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果infds&gt;0 表示有事件发生，infds存放了已发生事件的个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> eventfd = <span class="number">0</span>; eventfd &lt;= maxfd; eventfd ++)&#123;</span><br><span class="line">            <span class="comment">//如果eventfd在bitmap中标志为0， 表示它没有事件，continue</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">FD_ISSET</span>(eventfd, &amp;tmpfds) == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果发生事件的是listensock，表示已连接队列中有已经准备好的socket(有新的客户端连上来了)</span></span><br><span class="line">            <span class="keyword">if</span>(eventfd == listensock)&#123;</span><br><span class="line">                sockaddr_in client;</span><br><span class="line">                <span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(client);</span><br><span class="line">                <span class="comment">// accept 函数调用的时候， 会把客户端的值存储在client 里</span></span><br><span class="line">                <span class="type">int</span> clientsock = <span class="built_in">accept</span>(listensock, (sockaddr *)&amp;client, &amp;len);</span><br><span class="line">                <span class="keyword">if</span>(clientsock &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="built_in">perror</span>(<span class="string">&quot;accept() failed&quot;</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;accept client(socket = %d)pk.\n&quot;</span>, clientsock);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 把bitmap中新连上来的客户端标志位置为1</span></span><br><span class="line">                <span class="built_in">FD_SET</span>(clientsock, &amp;readfds);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//更新maxfd的值,因为如果建立了连接描述符会建立在之前建完后的下一位，不管那个描述符是否被删除</span></span><br><span class="line">                <span class="keyword">if</span>(maxfd &lt; clientsock) maxfd = clientsock;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//如果是客户端连接的socket有事件，表示接收缓存中有数据可以读，或者客户端已断开连接</span></span><br><span class="line">                <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">                <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">recv</span>(eventfd, buffer, <span class="built_in">sizeof</span>(buffer), <span class="number">0</span>) &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//如果客户端的链接已经断开</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client(eventfd = %d) disconnected.\n&quot;</span>, eventfd);</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">close</span>(eventfd);</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">FD_CLR</span>(eventfd, &amp;readfds);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//重新计算maxfd的值，注意只有当eventfd==maxfd时才需要计算</span></span><br><span class="line">                    <span class="keyword">if</span>(eventfd == maxfd)&#123;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> i = maxfd; i &gt; <span class="number">0</span>; i --)&#123; <span class="comment">//从后往前找</span></span><br><span class="line">                            <span class="keyword">if</span>(<span class="built_in">FD_ISSET</span>(i,&amp;readfds))&#123;</span><br><span class="line">                                maxfd = i;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//如果客户端有报文发过来</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;recv(eventfd=%d)%s\n&quot;</span>, eventfd, buffer);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//把接收到的报文内容原封不动的发回去</span></span><br><span class="line">                    <span class="built_in">send</span>(eventfd, buffer, <span class="built_in">strlen</span>(buffer), <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化服务端的监听端口</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">initserver</span><span class="params">(<span class="type">int</span> port)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> sock = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sock &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket() failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> len = <span class="built_in">sizeof</span>(opt);</span><br><span class="line">    <span class="built_in">setsockopt</span>(sock, SOL_SOCKET, SO_REUSEADDR,&amp;opt,len);</span><br><span class="line"></span><br><span class="line">    sockaddr_in servaddr;</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line">    servaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">bind</span>(sock, (sockaddr *)&amp;servaddr, <span class="built_in">sizeof</span>(servaddr)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind() failed&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(sock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">listen</span>(sock, <span class="number">5</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen() failed&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(sock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="select-模型-水平触发"><a href="#select-模型-水平触发" class="headerlink" title="select 模型 水平触发"></a>select 模型 水平触发</h5><ul><li><p>select()监视的socket如果发送了事件就会立即返回(通知应用程序处理事件)，如果发现数据一次性没有处理完，就会再发通知来处理，也就是说原本一次的，用了三次<br><img src="../assets/网络编程/image-111.png" alt="示例图片" style="zoom:100%;" /></p></li><li><p>如果事件没有被处理，再次调用select()的时候会立即再通知(因某种原因休眠了)</p></li></ul><h5 id="select-模型性能"><a href="#select-模型性能" class="headerlink" title="select 模型性能"></a>select 模型性能</h5><ul><li>1s大概能处理十二万个业务请求</li></ul><h5 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h5><ol><li>采用轮询方式扫描bitmap，性能随着socket数量增多而下降</li><li>调用一次就需要拷贝一份bitmap</li><li>bitmap的大小由FD_SETSIZE宏设置，默认是1024个，可以修改但是效率更低</li></ol><h3 id="POLL模型"><a href="#POLL模型" class="headerlink" title="POLL模型"></a>POLL模型</h3><h4 id="pollfd-结构体"><a href="#pollfd-结构体" class="headerlink" title="pollfd 结构体"></a>pollfd 结构体</h4><p>这个结构体有三个成员，第一个为socket，第二个为请求事件，第三个为返回的事件，并且修改的时候只会修改第三个成员。<br><img src="../assets/网络编程/image-112.png" alt="示例图片" style="zoom:100%;" /></p><h4 id="poll可要求socket数"><a href="#poll可要求socket数" class="headerlink" title="poll可要求socket数"></a>poll可要求socket数</h4><p>其不是固定的，可以由程序员自己决定</p><h4 id="pollfd结构体数组初始化的细节"><a href="#pollfd结构体数组初始化的细节" class="headerlink" title="pollfd结构体数组初始化的细节"></a>pollfd结构体数组初始化的细节</h4><p>不能用memset 而得用循环<br><img src="../assets/网络编程/image-113.png" alt="示例图片" style="zoom:100%;" /><br>poll 对socket值为-1的会忽略</p><h4 id="poll的事件常用"><a href="#poll的事件常用" class="headerlink" title="poll的事件常用"></a>poll的事件常用</h4><h5 id="读事件：POLLIN，-写事件：POLLOUT"><a href="#读事件：POLLIN，-写事件：POLLOUT" class="headerlink" title="读事件：POLLIN， 写事件：POLLOUT"></a>读事件：POLLIN， 写事件：POLLOUT</h5><p>如果即想读又想写可以使用|来连接</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//listensock 是用于监听的socket符</span></span><br><span class="line">pollfd fds[<span class="number">2048</span>];</span><br><span class="line">fds[listensock].fd = POLLIN|POLLOUT</span><br></pre></td></tr></table></figure><h4 id="pollfd结构体的使用方法有两种"><a href="#pollfd结构体的使用方法有两种" class="headerlink" title="pollfd结构体的使用方法有两种"></a>pollfd结构体的使用方法有两种</h4><h5 id="填在与请求的socket符号编码一样的位置"><a href="#填在与请求的socket符号编码一样的位置" class="headerlink" title="填在与请求的socket符号编码一样的位置"></a>填在与请求的socket符号编码一样的位置</h5><p><img src="../assets/网络编程/image-114.png" alt="示例图片" style="zoom:100%;" /></p><h5 id="填在结构体数组最前面"><a href="#填在结构体数组最前面" class="headerlink" title="填在结构体数组最前面"></a>填在结构体数组最前面</h5><p>如下图的三行<br><img src="../assets/网络编程/image-115.png" alt="示例图片" style="zoom:100%;" /></p><h5 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a>两者的区别</h5><p>第一个对于编码来说比较方便，第二个对数组利用率更高</p><h4 id="poll模型存在的问题"><a href="#poll模型存在的问题" class="headerlink" title="poll模型存在的问题"></a>poll模型存在的问题</h4><p><img src="../assets/网络编程/image-116.png" alt="示例图片" style="zoom:100%;" /></p><h4 id="poll相对于select的区别"><a href="#poll相对于select的区别" class="headerlink" title="poll相对于select的区别"></a>poll相对于select的区别</h4><ul><li>函数功能实现过程</li></ul><p>（1）应用程序通过poll函数的pollfd结构体将感兴趣的文件描述符和事件类型</p><p>（2）调用poll系统调用，将pollfd类型的结构体数组拷贝给内核空间，内核程序采用轮询方式查找所传入的数组中的就绪文件描述符，将内核处理之后的结果通过revents带回，这里的revents中不但有就绪的文件描述符，也有未就绪的，比select有优势的地方是内核并没有直接在传进的数组中修改状态，而是将传入的数组拷贝一份进行修改并由revents带回，所以下一次调用时不需要重新设置要监听的文件描述符；但是采用轮询方式时间复杂度为O(n)</p><p>（3）应用程序接受到内核返回的pollfd之后，同样采用轮询方式将events与revents遍历查找，时间复杂度为O(n)，找出就绪的文件描述符</p><p>poll相对于select的优势</p><p>poll所能监听的文件描述符数达到系统允许打开的最大文件描述符数，而select由于_FD_SETSIZE的限制只能达到1023个</p><p>poll函数的缺点</p><p>（1）应用程序和内核程序都采用轮询方式查找就绪文件描述符，时间复杂度为O(n)，</p><p>（2）poll仍需要每次调用将文件描述符数组拷贝一份给内核空间</p><p>（3）poll之工作在效率低下的LT模式下，在未处理就绪事件时会一直提醒就绪信息</p><p><img src="image-127.png" alt="alt text"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">用于演示采用poll模型实现网络通讯的服务端</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化服务端的监听端口</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">initserver</span><span class="params">(<span class="type">int</span> port)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage:./tcppoll port\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化服务端用于监听的窗口</span></span><br><span class="line">    <span class="type">int</span> listensock = <span class="built_in">initserver</span>(<span class="built_in">atoi</span>(argv[<span class="number">1</span>]));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;listensock=&quot;</span> &lt;&lt; listensock &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(listensock &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;initserver failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于存放需要监视的socket</span></span><br><span class="line">    pollfd fds[<span class="number">2048</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化数组，把全部socket都设置为-1， poll会忽略-1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2048</span>; i ++)&#123;</span><br><span class="line">        fds[i].fd = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打算让poll监视listensock 读事件</span></span><br><span class="line">    fds[listensock].fd = listensock;</span><br><span class="line">    <span class="comment">//读事件POLLIN 写事件POLLOUT</span></span><br><span class="line">    fds[listensock].events = POLLIN;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> maxfd = listensock; <span class="comment">// 需要监听的实际大小</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="comment">//调用poll等待事件的发生(监听哪些socket发生了事件)</span></span><br><span class="line">        <span class="type">int</span> infds = <span class="built_in">poll</span>(fds, maxfd + <span class="number">1</span>, <span class="number">10000</span>); <span class="comment">// 超时时间10s</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//poll 失败</span></span><br><span class="line">        <span class="keyword">if</span>(infds &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;poll failed&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// poll 超时</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(infds == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;poll timeout&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// poll正常运行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> eventfd = <span class="number">0</span>; eventfd &lt;= maxfd; eventfd ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fds[eventfd].fd &lt; <span class="number">0</span>) <span class="keyword">continue</span>; <span class="comment">//fd 为-1 就忽略</span></span><br><span class="line">            <span class="comment">//没有读时间就continue</span></span><br><span class="line">            <span class="keyword">if</span>(fds[eventfd].events &amp; POLLIN == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//如果发生的事件是listensock 表示已连接队列中已经有准备好的socket(有新的客户端练上来)</span></span><br><span class="line">            <span class="keyword">if</span>(eventfd == listensock)&#123;</span><br><span class="line">                sockaddr_in client;</span><br><span class="line">                <span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(client);</span><br><span class="line">                <span class="type">int</span> clientsock = <span class="built_in">accept</span>(listensock,(sockaddr *) &amp;client, &amp;len);</span><br><span class="line">                <span class="keyword">if</span>(clientsock &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="built_in">perror</span>(<span class="string">&quot;accept(*) failed&quot;</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;accept client(socket = %d)ok.\n&quot;</span>, clientsock);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 修改fds数组中clientsock位置的元素</span></span><br><span class="line">                fds[clientsock].fd = clientsock;</span><br><span class="line">                fds[clientsock].events = POLLIN;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(maxfd &lt; clientsock) maxfd = clientsock; <span class="comment">// 更新maxfd</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 如果是客户端连接的socket有事件目标是有报文发过来或者连接已断开</span></span><br><span class="line"></span><br><span class="line">                <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">                <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">recv</span>(eventfd, buffer, <span class="built_in">sizeof</span>(buffer), <span class="number">0</span>) &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">// 如果客户端的链接已断开</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client(eventfd = %d) disconnected.\n&quot;</span>, eventfd);</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//关闭客户端的socket</span></span><br><span class="line">                    <span class="built_in">close</span>(eventfd);</span><br><span class="line">                    fds[eventfd].fd = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//重新计算maxfd的值，只有当eventfd等于maxfd才开始计算</span></span><br><span class="line">                    <span class="keyword">if</span>(eventfd == maxfd)&#123;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> i = maxfd; i &gt; <span class="number">0</span>; i --)&#123;</span><br><span class="line">                            <span class="keyword">if</span>(fds[i].fd != <span class="number">-1</span>)&#123;</span><br><span class="line">                                maxfd = i;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 如果客户端有报文发过来</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;recv(eventfd = %d).%s\n&quot;</span>, eventfd,buffer);</span><br><span class="line">                    <span class="comment">//把接收到的报文内容原封不动的发回去</span></span><br><span class="line">                    <span class="built_in">send</span>(eventfd, buffer, <span class="built_in">strlen</span>(buffer), <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化服务端的监听端口</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">initserver</span><span class="params">(<span class="type">int</span> port)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sock = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sock &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket() failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// TIME_WAIT状态还在，但是仍然可以打开,用来打开/关闭地址复用功能，1为打开，0为关闭</span></span><br><span class="line">    <span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">setsockopt</span>(sock, SOL_SOCKET, SO_REUSEADDR, &amp;opt,<span class="built_in">sizeof</span>(opt));</span><br><span class="line"></span><br><span class="line">    sockaddr_in servaddr;</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line">    servaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">bind</span>(sock, (sockaddr *) &amp;servaddr, <span class="built_in">sizeof</span>(servaddr)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind() failed&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(sock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">listen</span>(sock, <span class="number">5</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen() failed&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(sock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sock;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="epoll模型"><a href="#epoll模型" class="headerlink" title="epoll模型"></a>epoll模型</h3><ul><li>epoll实例的创造(一个文件描述符)</li></ul><h4 id="epoll-create-函数"><a href="#epoll-create-函数" class="headerlink" title="epoll_create()函数"></a>epoll_create()函数</h4><p>这个函数是用来创造epoll的，参数为一个整数，这个参数在Linux2.6.8之后被忽略，只要填大于0就行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> epollfd = <span class="built_in">epoll_create</span>(<span class="number">1</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="epoll-ctl-函数"><a href="#epoll-ctl-函数" class="headerlink" title="epoll_ctl()函数"></a>epoll_ctl()函数</h4><p>epoll_ctl 函数</p><ul><li>int epoll_ctl(int epfd, int op, int fd, struct - - epoll_event *event);</li><li>功能：epoll 的事件注册函数，它不同于 select() 是在监听事件时告诉内核要监听什么类型的事件，而是在这里先注册要监听的事件类型。</li><li>参数epfd: epoll 专用的文件描述符，epoll_create()的返回值</li><li>参数op: 表示动作，用三个宏来表示：<br>  EPOLL_CTL_ADD：注册新的 fd 到 epfd 中；<br>  EPOLL_CTL_MOD：修改已经注册的fd的监听事件；<br>  EPOLL_CTL_DEL：从 epfd 中删除一个 fd；</li><li>参数fd: 需要监听的文件描述符</li><li>参数event: 告诉内核要监听什么事件，struct epoll_event 结构如:<br>  events可以是以下几个宏的集合：<br>  EPOLLIN ：表示对应的文件描述符可以读（包括对端 SOCKET 正常关闭）；<br>  EPOLLOUT：表示对应的文件描述符可以写；<br>  EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；<br>  EPOLLERR：表示对应的文件描述符发生错误；<br>  EPOLLHUP：表示对应的文件描述符被挂断；<br>  EPOLLET ：将 EPOLL 设为边缘触发(Edge Trigger)模式，这是相对于水平触发(Level Trigger)来说的。<br>  EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个 socket 的话，需要再次把这个 socket 加入到 EPOLL 队列里</li><li>返回值：0表示成功，-1表示失败。</li></ul><h4 id="epoll-wait函数"><a href="#epoll-wait函数" class="headerlink" title="epoll_wait函数"></a>epoll_wait函数</h4><ul><li><strong>int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</strong></li><li><strong>功能</strong>：等待事件的产生，收集在 epoll 监控的事件中已经发送的事件，类似于 select() 调用。</li><li><strong>参数epfd</strong>: epoll 专用的文件描述符，epoll_create()的返回值</li><li><strong>参数events</strong>: 分配好的 epoll_event 结构体数组，epoll 将会把发生的事件赋值到events 数组中（events 不可以是空指针，内核只负责把数据复制到这个 events 数组中，不会去帮助我们在用户态中分配内存）。</li><li><strong>参数maxevents</strong>: maxevents 告之内核这个 events 有多少个 。</li><li><strong>参数timeout</strong>: 超时时间，单位为毫秒，为 -1 时，函数为阻塞。</li><li><strong>返回值</strong>：<br>如果成功，表示返回需要处理的事件数目<br>如果返回0，表示已超时<br>如果返回-1，表示失败</li></ul><h4 id="epoll的相关结构体"><a href="#epoll的相关结构体" class="headerlink" title="epoll的相关结构体"></a>epoll的相关结构体</h4><h5 id="epoll-event"><a href="#epoll-event" class="headerlink" title="epoll_event"></a>epoll_event</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> events; <span class="comment">//事件</span></span><br><span class="line">    <span class="type">epoll_data_t</span> data; <span class="comment">//用户可用数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> <span class="title class_">epoll_data</span>&#123;</span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">uint32_t</span>;</span><br><span class="line">    <span class="type">uint64_t</span>;</span><br><span class="line">&#125;<span class="type">epoll_data_t</span>;</span><br></pre></td></tr></table></figure><p><img src="image-128.png" alt="alt text"></p><p><img src="image-129.png" alt="alt text"></p><ul><li><p>epoll的视频演示在同级目录下</p></li><li><p><strong>epoll为什么快?</strong></p></li><li>事件触发模式 事件到来唤醒fd的等待队列中的进程，回调进程之前的注册的回调函数ep_poll_callback ，这个回调函数实际上就是将红黑树上收到event的epitem插入到它的就绪队列中并唤醒调用epoll_wait进程。不用逐个遍历</li></ul><h5 id="epoll服务端代码"><a href="#epoll服务端代码" class="headerlink" title="epoll服务端代码"></a>epoll服务端代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">用于演示采用epoll模型实现网络通讯的服务端</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/fcbtl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化服务端的监听端口</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">initserver</span><span class="params">(<span class="type">int</span> port)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage:./tcppoll port\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化服务端用于监听的窗口</span></span><br><span class="line">    <span class="type">int</span> listensock = <span class="built_in">initserver</span>(<span class="built_in">atoi</span>(argv[<span class="number">1</span>]));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;listensock=&quot;</span> &lt;&lt; listensock &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(listensock &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;initserver failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建epoll句柄</span></span><br><span class="line">    <span class="type">int</span> epollfd = <span class="built_in">epoll_create</span>(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化数组，把全部socket都设置为-1， poll会忽略-1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2048</span>; i ++)&#123;</span><br><span class="line">        fds[i].fd = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为服务端的listensock准备可读事件</span></span><br><span class="line">    epoll_event ev; <span class="comment">//声明事件的数据结构</span></span><br><span class="line">    ev.data.fd = listensock; <span class="comment">//指定事件的自定义数据，会随着epoll_wait()返回的事件一并返回</span></span><br><span class="line">    ev.events = EPOLLIN; <span class="comment">//打算让epoll监视的listensock的读事件</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_ADD, listensock, &amp;ev); <span class="comment">// 把需要监视的socket加入epollfd中</span></span><br><span class="line">    epoll_event evs[<span class="number">10</span>]; <span class="comment">//存放epoll返回的事件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="comment">//等待监视的socket有事件发生</span></span><br><span class="line">        <span class="type">int</span> infds = <span class="built_in">epoll_wait</span>(epollfd, evs, <span class="number">10</span>, <span class="number">-1</span>); <span class="comment">// 不设置超时时间</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//epoll 失败</span></span><br><span class="line">        <span class="keyword">if</span>(infds &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;poll failed&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// epoll 超时</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(infds == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;poll timeout&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// epoll正常运行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; infds; i ++)&#123; <span class="comment">// 遍历epoll的返回数组evs</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//printf(&quot;socket=%d,events=%d\n&quot;,evs[i].data.fd, evs[i].events);</span></span><br><span class="line">        </span><br><span class="line">            <span class="comment">//如果发生的事件是listensock 表示已连接队列中已经有准备好的socket(有新的客户端练上来)</span></span><br><span class="line">            <span class="keyword">if</span>(evs[i].data.fd == listensock)&#123;</span><br><span class="line">                sockaddr_in client;</span><br><span class="line">                <span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(client);</span><br><span class="line">                <span class="type">int</span> clientsock = <span class="built_in">accept</span>(listensock,(sockaddr *) &amp;client, &amp;len);</span><br><span class="line">                <span class="keyword">if</span>(clientsock &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="built_in">perror</span>(<span class="string">&quot;accept(*) failed&quot;</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;accept client(socket = %d)ok.\n&quot;</span>, clientsock);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 为新客户端准备可读事件，并添加到epoll中</span></span><br><span class="line">                ev.data.fd = clientsock;</span><br><span class="line">                ev.events = EPOLLIN;</span><br><span class="line">                <span class="built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_ADD, clientsock, &amp;ev);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 如果是客户端连接的socket有事件目标是有报文发过来或者连接已断开</span></span><br><span class="line"></span><br><span class="line">                <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">                <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">recv</span>(evs[i].data.fd, buffer, <span class="built_in">sizeof</span>(buffer), <span class="number">0</span>) &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">// 如果客户端的链接已断开</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client(eventfd = %d) disconnected.\n&quot;</span>, evs[i].data.fd);</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//关闭客户端的socket</span></span><br><span class="line">                    <span class="built_in">close</span>(evs[i].data.fd);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 如果客户端有报文发过来</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;recv(eventfd = %d).%s\n&quot;</span>,evs[i].data.fd,buffer);</span><br><span class="line">                    <span class="comment">//把接收到的报文内容原封不动的发回去，如果接收缓冲区满了就会阻塞</span></span><br><span class="line">                    <span class="built_in">send</span>(evs[i].data.fd, buffer, <span class="built_in">strlen</span>(buffer), <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化服务端的监听端口</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">initserver</span><span class="params">(<span class="type">int</span> port)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sock = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sock &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket() failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// TIME_WAIT状态还在，但是仍然可以打开,用来打开/关闭地址复用功能，1为打开，0为关闭</span></span><br><span class="line">    <span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">setsockopt</span>(sock, SOL_SOCKET, SO_REUSEADDR, &amp;opt,<span class="built_in">sizeof</span>(opt));</span><br><span class="line"></span><br><span class="line">    sockaddr_in servaddr;</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line">    servaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">bind</span>(sock, (sockaddr *) &amp;servaddr, <span class="built_in">sizeof</span>(servaddr)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind() failed&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(sock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">listen</span>(sock, <span class="number">5</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen() failed&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(sock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sock;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="阻塞I-O-与-非阻塞I-O"><a href="#阻塞I-O-与-非阻塞I-O" class="headerlink" title="阻塞I/O 与 非阻塞I/O"></a>阻塞I/O 与 非阻塞I/O</h3><ul><li>阻塞: 在进/线程中，发起一个调用时，在调用返回前，进/线程会被阻塞等待，等待中的进/线让出CPU的使用权</li><li>非阻塞: 在进/线程中，发起一个调用时，会立即返回</li><li>会阻塞的四个函数:connect(), accept(), send(), recv()</li></ul><h4 id="阻塞与非阻塞IO的应用场景"><a href="#阻塞与非阻塞IO的应用场景" class="headerlink" title="阻塞与非阻塞IO的应用场景"></a>阻塞与非阻塞IO的应用场景</h4><ul><li>在传统的网络服务端程序中（每连接每线/进程）， 采用阻塞IO</li><li>在IO复用模型中 是采用非阻塞IO，在事件循环中是不能被阻塞的</li></ul><h4 id="非阻塞IO-connect-函数"><a href="#非阻塞IO-connect-函数" class="headerlink" title="非阻塞IO-connect()函数"></a>非阻塞IO-connect()函数</h4><ul><li>对非阻塞的IO调用connect()函数，不管是否能连接成功，connect()都会立即返回失败，errno == EINPROGRESS</li><li>对非阻塞的IO调用connect()函数后，如果socket的状态是可写的，证明连接是成功的，否则是失败的</li></ul><p><strong><em>对于上面两句话的详细解释</em></strong></p><ul><li><p>首先connect()函数是发生在客户端的，当它使用以下方法变为非阻塞模式的时候，不管连接成功与否都会失败</p></li><li><p>以下代码是将此套接字设置为非阻塞状态<br>-</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="type">int</span> fd)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取fd的状态</span></span><br><span class="line">    <span class="keyword">if</span>(flags = <span class="built_in">fcntl</span>(fd, F_GETFL, <span class="number">0</span>) == <span class="number">-1</span>)&#123;</span><br><span class="line">         flags = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">fcntl</span>(fd, F_SETTFL, flags|O_NONBKLOCK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这样的话怎么判断是否连接成功呢？</li><li>需要在连接的地方加入一个判断</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">connect</span>(sockfd, (sockaddr *)&amp;servaddr, <span class="built_in">sizeof</span>(servaddr)) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(errno!=EINPROGRESS)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;connect(%s:%s)failed.\n&quot;</span>, argv[<span class="number">1</span>], argv[<span class="number">2</span>]);</span><br><span class="line">        <span class="built_in">close</span>(sockfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 再看socket是否可写</span></span><br><span class="line">pollfd fds;</span><br><span class="line">fds.fd = sockfd;</span><br><span class="line">fds.events = POLLOUT;</span><br><span class="line"><span class="built_in">poll</span>(&amp;fds, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span>(fds.revents == POLLOUT) <span class="built_in">printf</span>(<span class="string">&quot;connect ok\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;connect failed\n&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="非阻塞IO-accept-函数"><a href="#非阻塞IO-accept-函数" class="headerlink" title="非阻塞IO accept()函数"></a>非阻塞IO accept()函数</h4><ul><li>对非阻塞的IO调用accept(), 如果已连接队列中没有socket， 函数立即返回失败, errno == EAGAIN;</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setnonblocking</span>(listensock);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="非阻塞IO-recv"><a href="#非阻塞IO-recv" class="headerlink" title="非阻塞IO recv"></a>非阻塞IO recv</h4><ul><li>对非阻塞的IO调用recv()，如果没有数据可读(接收缓冲区为空)， 函数立即返回失败， errno == EAGAIN</li></ul><h4 id="非阻塞IO-send"><a href="#非阻塞IO-send" class="headerlink" title="非阻塞IO send()"></a>非阻塞IO send()</h4><ul><li>对非阻塞IO调用send()， 如果socket 不可写(发送缓冲区已满), 函数立即返回失败，errno==EAGAIN</li></ul><h3 id="水平触发与边缘触发"><a href="#水平触发与边缘触发" class="headerlink" title="水平触发与边缘触发"></a>水平触发与边缘触发</h3><ul><li>select 和 poll 采用 <strong><em>水平触发</em></strong></li><li>epoll 既有 <strong><em>水平触发</em></strong> 又有 <strong><em>边缘触发</em></strong>, 默认水平触发</li></ul><h4 id="水平触发含义"><a href="#水平触发含义" class="headerlink" title="水平触发含义"></a>水平触发含义</h4><ul><li>读事件：如果epoll_wait触发了读事件，表示有数据可读，如果程序没有把数据读完，再次调用epoll_wait的时候，将立即再次触发读事件</li><li>写事件: 如果发送缓冲区没有满，表示可以写入数据，此时如果再次调用epoll_wait的时候，将立即再次触发写事件</li></ul><h4 id="边缘触发的含义"><a href="#边缘触发的含义" class="headerlink" title="边缘触发的含义"></a>边缘触发的含义</h4><ul><li>对于读事件：epoll_wait触发读事件后，不管程序有没有处理读事件，epoll_wait不会再触发读事件,只有新数据到达才会触发，也就是说数据从<strong>无到有或者从少到多</strong>的时候，会通知，类似菜鸟驿站</li><li><p>对于写事件：epoll_wait触发读事件后，如果发送缓冲区没满，epoll_wait不会再触发写事件, 只用当发送缓冲区由<strong>满</strong>变成<strong>不满</strong>时，才再次触发写事件</p></li><li><p>如果epoll使用边缘触发一定要设置为非阻塞模式</p></li><li><p>有新客户端连接情况<br><img src="../assets/网络编程/image-117.png" alt="示例图片" style="zoom:100%;" /></p></li><li><p>对于接收发送报文的时候如果使用边缘触发要这么编码，因为这样才能读完</p></li></ul><p><img src="../assets/网络编程/image-118.png" alt="示例图片" style="zoom:100%;" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将epoll设置为边缘触发</span></span><br><span class="line">ev.events = EPOLLOUT|EPOLLET;</span><br></pre></td></tr></table></figure><p><img src="../assets/网络编程/image-119.png" alt="示例图片" style="zoom:100%;" /></p>]]></content>
    
    
    <summary type="html">🥧本文介绍了linux基础的系统编程和基础的Linux网络编程</summary>
    
    
    
    <category term="C++" scheme="https://pigcanstudy.github.io/categories/C/"/>
    
    
    <category term="Linux" scheme="https://pigcanstudy.github.io/tags/Linux/"/>
    
    <category term="网络编程" scheme="https://pigcanstudy.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>
